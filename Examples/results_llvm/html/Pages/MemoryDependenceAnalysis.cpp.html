<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>MemoryDependenceAnalysis.cpp</title>
    <link rel="stylesheet" href="../Style/style.css" />
  </head>
  <body>
    <div class="headerDiv">
      <h1>
        Code Coverage
      </h1>
      <p>
        Source file: /home/nikola/Desktop/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
      </p>
    </div>
    <button class="collapsible" type="button">Open Summary Report</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Summary Report</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line number</th>
    <th class="mainTh">Line</th>
    <th class="mainTh">Number of hits</th>
    <th class="mainTh">Tests that cover line</th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="">//===- MemoryDependenceAnalysis.cpp - Mem Deps Implementation -------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="">// This file implements an analysis that determines, for a given memory</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="">// operation, what preceding memory operations it depends on.  It builds on</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="">// alias analysis information, and tries to provide a lazy, caching interface to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="">// a common kind of alias information query.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="">#include "llvm/Analysis/MemoryDependenceAnalysis.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="">#include "llvm/ADT/DenseMap.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="">#include "llvm/ADT/STLExtras.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="">#include "llvm/ADT/SmallPtrSet.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="">#include "llvm/ADT/SmallVector.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="">#include "llvm/ADT/Statistic.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="">#include "llvm/Analysis/AliasAnalysis.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="">#include "llvm/Analysis/AssumptionCache.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="">#include "llvm/Analysis/MemoryBuiltins.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="">#include "llvm/Analysis/MemoryLocation.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="">#include "llvm/Analysis/PHITransAddr.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="">#include "llvm/Analysis/TargetLibraryInfo.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="">#include "llvm/Analysis/ValueTracking.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="">#include "llvm/IR/BasicBlock.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="">#include "llvm/IR/Dominators.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="">#include "llvm/IR/Function.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="">#include "llvm/IR/InstrTypes.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="">#include "llvm/IR/Instruction.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="">#include "llvm/IR/Instructions.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="">#include "llvm/IR/IntrinsicInst.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="">#include "llvm/IR/LLVMContext.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="">#include "llvm/IR/Metadata.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="">#include "llvm/IR/Module.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="">#include "llvm/IR/PredIteratorCache.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="">#include "llvm/IR/Type.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="">#include "llvm/IR/Use.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="">#include "llvm/IR/Value.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="">#include "llvm/InitializePasses.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="">#include "llvm/Pass.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="">#include "llvm/Support/AtomicOrdering.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="">#include "llvm/Support/Casting.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="">#include "llvm/Support/CommandLine.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="">#include "llvm/Support/Compiler.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="">#include "llvm/Support/Debug.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="">#include <algorithm></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="">#include <cassert></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="">#include <iterator></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="">#include <utility></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="">using namespace llvm;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="">#define DEBUG_TYPE "memdep"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="">STATISTIC(NumCacheNonLocal, "Number of fully cached non-local responses");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="">STATISTIC(NumCacheDirtyNonLocal, "Number of dirty cached non-local responses");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="">STATISTIC(NumUncacheNonLocal, "Number of uncached non-local responses");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="">STATISTIC(NumCacheNonLocalPtr,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="">          "Number of fully cached non-local ptr responses");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="">STATISTIC(NumCacheDirtyNonLocalPtr,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="">          "Number of cached, but dirty, non-local ptr responses");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="">STATISTIC(NumUncacheNonLocalPtr, "Number of uncached non-local ptr responses");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="">STATISTIC(NumCacheCompleteNonLocalPtr,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="">          "Number of block queries that were completely cached");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="">// Limit for the number of instructions to scan in a block.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="">static cl::opt<unsigned> BlockScanLimit(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="">    "memdep-block-scan-limit", cl::Hidden, cl::init(100),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="">    cl::desc("The number of instructions to scan in a block in memory "</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="">             "dependency analysis (default = 100)"));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="">static cl::opt<unsigned></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="">    BlockNumberLimit("memdep-block-number-limit", cl::Hidden, cl::init(200),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="">                     cl::desc("The number of blocks to scan during memory "</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="">                              "dependency analysis (default = 200)"));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="">// Limit on the number of memdep results to process.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="">static const unsigned int NumResultsLimit = 100;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="">/// This is a helper function that removes Val from 'Inst's set in ReverseMap.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="">/// If the set becomes empty, remove Inst's entry.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="">template <typename KeyTy></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="">static void</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="uncoveredLine">RemoveFromReverseMap(DenseMap<Instruction *, SmallPtrSet<KeyTy, 4>> &ReverseMap,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="">                     Instruction *Inst, KeyTy Val) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="">  typename DenseMap<Instruction *, SmallPtrSet<KeyTy, 4>>::iterator InstIt =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="uncoveredLine">      ReverseMap.find(Inst);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="uncoveredLine">  assert(InstIt != ReverseMap.end() && "Reverse map out of sync?");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="uncoveredLine">  bool Found = InstIt->second.erase(Val);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="uncoveredLine">  assert(Found && "Invalid reverse map!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="">  (void)Found;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="uncoveredLine">  if (InstIt->second.empty())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="uncoveredLine">    ReverseMap.erase(InstIt);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="">/// If the given instruction references a specific memory location, fill in Loc</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="">/// with the details, otherwise set Loc.Ptr to null.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="">/// Returns a ModRefInfo value describing the general behavior of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="">/// instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="uncoveredLine">static ModRefInfo GetLocation(const Instruction *Inst, MemoryLocation &Loc,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="">                              const TargetLibraryInfo &TLI) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="uncoveredLine">  if (const LoadInst *LI = dyn_cast<LoadInst>(Inst)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="uncoveredLine">    if (LI->isUnordered()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="uncoveredLine">      Loc = MemoryLocation::get(LI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="uncoveredLine">      return ModRefInfo::Ref;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="uncoveredLine">    if (LI->getOrdering() == AtomicOrdering::Monotonic) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="uncoveredLine">      Loc = MemoryLocation::get(LI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="uncoveredLine">      return ModRefInfo::ModRef;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="uncoveredLine">    Loc = MemoryLocation();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="uncoveredLine">    return ModRefInfo::ModRef;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="uncoveredLine">  if (const StoreInst *SI = dyn_cast<StoreInst>(Inst)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="uncoveredLine">    if (SI->isUnordered()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="uncoveredLine">      Loc = MemoryLocation::get(SI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="uncoveredLine">      return ModRefInfo::Mod;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="uncoveredLine">    if (SI->getOrdering() == AtomicOrdering::Monotonic) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="uncoveredLine">      Loc = MemoryLocation::get(SI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="uncoveredLine">      return ModRefInfo::ModRef;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="uncoveredLine">    Loc = MemoryLocation();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="uncoveredLine">    return ModRefInfo::ModRef;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="uncoveredLine">  if (const VAArgInst *V = dyn_cast<VAArgInst>(Inst)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="uncoveredLine">    Loc = MemoryLocation::get(V);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="uncoveredLine">    return ModRefInfo::ModRef;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="uncoveredLine">  if (const CallBase *CB = dyn_cast<CallBase>(Inst)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="uncoveredLine">    if (Value *FreedOp = getFreedOperand(CB, &TLI)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="">      // calls to free() deallocate the entire structure</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="uncoveredLine">      Loc = MemoryLocation::getAfter(FreedOp);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="uncoveredLine">      return ModRefInfo::Mod;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="uncoveredLine">  if (const IntrinsicInst *II = dyn_cast<IntrinsicInst>(Inst)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="uncoveredLine">    switch (II->getIntrinsicID()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="uncoveredLine">    case Intrinsic::lifetime_start:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="">    case Intrinsic::lifetime_end:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="">    case Intrinsic::invariant_start:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="uncoveredLine">      Loc = MemoryLocation::getForArgument(II, 1, TLI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="">      // These intrinsics don't really modify the memory, but returning Mod</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="">      // will allow them to be handled conservatively.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="uncoveredLine">      return ModRefInfo::Mod;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="uncoveredLine">    case Intrinsic::invariant_end:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="uncoveredLine">      Loc = MemoryLocation::getForArgument(II, 2, TLI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="">      // These intrinsics don't really modify the memory, but returning Mod</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="">      // will allow them to be handled conservatively.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="uncoveredLine">      return ModRefInfo::Mod;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="uncoveredLine">    case Intrinsic::masked_load:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="uncoveredLine">      Loc = MemoryLocation::getForArgument(II, 0, TLI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="uncoveredLine">      return ModRefInfo::Ref;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="uncoveredLine">    case Intrinsic::masked_store:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="uncoveredLine">      Loc = MemoryLocation::getForArgument(II, 1, TLI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="uncoveredLine">      return ModRefInfo::Mod;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="uncoveredLine">    default:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="">  // Otherwise, just do the coarse-grained thing that always works.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="uncoveredLine">  if (Inst->mayWriteToMemory())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="uncoveredLine">    return ModRefInfo::ModRef;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="uncoveredLine">  if (Inst->mayReadFromMemory())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="uncoveredLine">    return ModRefInfo::Ref;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="uncoveredLine">  return ModRefInfo::NoModRef;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="">/// Private helper for finding the local dependencies of a call site.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="uncoveredLine">MemDepResult MemoryDependenceResults::getCallDependencyFrom(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="">    CallBase *Call, bool isReadOnlyCall, BasicBlock::iterator ScanIt,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="">    BasicBlock *BB) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="uncoveredLine">  unsigned Limit = getDefaultBlockScanLimit();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="">  // Walk backwards through the block, looking for dependencies.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="uncoveredLine">  while (ScanIt != BB->begin()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="uncoveredLine">    Instruction *Inst = &*--ScanIt;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="">    // Debug intrinsics don't cause dependences and should not affect Limit</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="uncoveredLine">    if (isa<DbgInfoIntrinsic>(Inst))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="">    // Limit the amount of scanning we do so we don't end up with quadratic</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="">    // running time on extreme testcases.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="uncoveredLine">    --Limit;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="uncoveredLine">    if (!Limit)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="uncoveredLine">      return MemDepResult::getUnknown();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="">    // If this inst is a memory op, get the pointer it accessed</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="uncoveredLine">    MemoryLocation Loc;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="uncoveredLine">    ModRefInfo MR = GetLocation(Inst, Loc, TLI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="uncoveredLine">    if (Loc.Ptr) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="">      // A simple instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="uncoveredLine">      if (isModOrRefSet(AA.getModRefInfo(Call, Loc)))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="uncoveredLine">        return MemDepResult::getClobber(Inst);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="uncoveredLine">    if (auto *CallB = dyn_cast<CallBase>(Inst)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="">      // If these two calls do not interfere, look past it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="uncoveredLine">      if (isNoModRef(AA.getModRefInfo(Call, CallB))) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="">        // If the two calls are the same, return Inst as a Def, so that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="">        // Call can be found redundant and eliminated.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="uncoveredLine">        if (isReadOnlyCall && !isModSet(MR) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="uncoveredLine">            Call->isIdenticalToWhenDefined(CallB))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="uncoveredLine">          return MemDepResult::getDef(Inst);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="">        // Otherwise if the two calls don't interact (e.g. CallB is readnone)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="">        // keep scanning.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="">      } else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="uncoveredLine">        return MemDepResult::getClobber(Inst);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="">    // If we could not obtain a pointer for the instruction and the instruction</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="">    // touches memory then assume that this is a dependency.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="uncoveredLine">    if (isModOrRefSet(MR))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="uncoveredLine">      return MemDepResult::getClobber(Inst);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="">  // No dependence found.  If this is the entry block of the function, it is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="">  // unknown, otherwise it is non-local.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="uncoveredLine">  if (BB != &BB->getParent()->getEntryBlock())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="uncoveredLine">    return MemDepResult::getNonLocal();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="uncoveredLine">  return MemDepResult::getNonFuncLocal();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="uncoveredLine">MemDepResult MemoryDependenceResults::getPointerDependencyFrom(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="">    const MemoryLocation &MemLoc, bool isLoad, BasicBlock::iterator ScanIt,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="">    BasicBlock *BB, Instruction *QueryInst, unsigned *Limit,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="">    BatchAAResults &BatchAA) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="uncoveredLine">  MemDepResult InvariantGroupDependency = MemDepResult::getUnknown();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="uncoveredLine">  if (QueryInst != nullptr) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="uncoveredLine">    if (auto *LI = dyn_cast<LoadInst>(QueryInst)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="uncoveredLine">      InvariantGroupDependency = getInvariantGroupPointerDependency(LI, BB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="uncoveredLine">      if (InvariantGroupDependency.isDef())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="uncoveredLine">        return InvariantGroupDependency;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="uncoveredLine">  MemDepResult SimpleDep = getSimplePointerDependencyFrom(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="">      MemLoc, isLoad, ScanIt, BB, QueryInst, Limit, BatchAA);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="uncoveredLine">  if (SimpleDep.isDef())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="uncoveredLine">    return SimpleDep;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="">  // Non-local invariant group dependency indicates there is non local Def</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="">  // (it only returns nonLocal if it finds nonLocal def), which is better than</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="">  // local clobber and everything else.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="uncoveredLine">  if (InvariantGroupDependency.isNonLocal())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="uncoveredLine">    return InvariantGroupDependency;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="uncoveredLine">  assert(InvariantGroupDependency.isUnknown() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="">         "InvariantGroupDependency should be only unknown at this point");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="uncoveredLine">  return SimpleDep;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="uncoveredLine">MemDepResult MemoryDependenceResults::getPointerDependencyFrom(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="">    const MemoryLocation &MemLoc, bool isLoad, BasicBlock::iterator ScanIt,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="">    BasicBlock *BB, Instruction *QueryInst, unsigned *Limit) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="uncoveredLine">  BatchAAResults BatchAA(AA);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="uncoveredLine">  return getPointerDependencyFrom(MemLoc, isLoad, ScanIt, BB, QueryInst, Limit,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="uncoveredLine">                                  BatchAA);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="">MemDepResult</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="uncoveredLine">MemoryDependenceResults::getInvariantGroupPointerDependency(LoadInst *LI,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="">                                                            BasicBlock *BB) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="uncoveredLine">  if (!LI->hasMetadata(LLVMContext::MD_invariant_group))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="uncoveredLine">    return MemDepResult::getUnknown();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="">  // Take the ptr operand after all casts and geps 0. This way we can search</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="">  // cast graph down only.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="uncoveredLine">  Value *LoadOperand = LI->getPointerOperand()->stripPointerCasts();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="">  // It's is not safe to walk the use list of global value, because function</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="">  // passes aren't allowed to look outside their functions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="">  // FIXME: this could be fixed by filtering instructions from outside</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="">  // of current function.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="uncoveredLine">  if (isa<GlobalValue>(LoadOperand))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="uncoveredLine">    return MemDepResult::getUnknown();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="">  // Queue to process all pointers that are equivalent to load operand.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="uncoveredLine">  SmallVector<const Value *, 8> LoadOperandsQueue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="uncoveredLine">  LoadOperandsQueue.push_back(LoadOperand);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="uncoveredLine">  Instruction *ClosestDependency = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="">  // Order of instructions in uses list is unpredictible. In order to always</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="">  // get the same result, we will look for the closest dominance.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="uncoveredLine">  auto GetClosestDependency = [this](Instruction *Best, Instruction *Other) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="uncoveredLine">    assert(Other && "Must call it with not null instruction");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="uncoveredLine">    if (Best == nullptr || DT.dominates(Best, Other))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="uncoveredLine">      return Other;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="uncoveredLine">    return Best;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="uncoveredLine">  };</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="">  // FIXME: This loop is O(N^2) because dominates can be O(n) and in worst case</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="">  // we will see all the instructions. This should be fixed in MSSA.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="uncoveredLine">  while (!LoadOperandsQueue.empty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="uncoveredLine">    const Value *Ptr = LoadOperandsQueue.pop_back_val();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="uncoveredLine">    assert(Ptr && !isa<GlobalValue>(Ptr) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="">           "Null or GlobalValue should not be inserted");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="uncoveredLine">    for (const Use &Us : Ptr->uses()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="uncoveredLine">      auto *U = dyn_cast<Instruction>(Us.getUser());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="uncoveredLine">      if (!U || U == LI || !DT.dominates(U, LI))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="">      // Bitcast or gep with zeros are using Ptr. Add to queue to check it's</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="">      // users.      U = bitcast Ptr</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="uncoveredLine">      if (isa<BitCastInst>(U)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="uncoveredLine">        LoadOperandsQueue.push_back(U);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="">      // Gep with zeros is equivalent to bitcast.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="">      // FIXME: we are not sure if some bitcast should be canonicalized to gep 0</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="">      // or gep 0 to bitcast because of SROA, so there are 2 forms. When</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="">      // typeless pointers will be ready then both cases will be gone</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="">      // (and this BFS also won't be needed).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="uncoveredLine">      if (auto *GEP = dyn_cast<GetElementPtrInst>(U))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="uncoveredLine">        if (GEP->hasAllZeroIndices()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="uncoveredLine">          LoadOperandsQueue.push_back(U);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="uncoveredLine">          continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="">      // If we hit load/store with the same invariant.group metadata (and the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="">      // same pointer operand) we can assume that value pointed by pointer</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="">      // operand didn't change.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="uncoveredLine">      if ((isa<LoadInst>(U) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="uncoveredLine">           (isa<StoreInst>(U) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="uncoveredLine">            cast<StoreInst>(U)->getPointerOperand() == Ptr)) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="uncoveredLine">          U->hasMetadata(LLVMContext::MD_invariant_group))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="uncoveredLine">        ClosestDependency = GetClosestDependency(ClosestDependency, U);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="uncoveredLine">  if (!ClosestDependency)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="uncoveredLine">    return MemDepResult::getUnknown();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="uncoveredLine">  if (ClosestDependency->getParent() == BB)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="uncoveredLine">    return MemDepResult::getDef(ClosestDependency);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="">  // Def(U) can't be returned here because it is non-local. If local</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="">  // dependency won't be found then return nonLocal counting that the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="">  // user will call getNonLocalPointerDependency, which will return cached</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="">  // result.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="uncoveredLine">  NonLocalDefsCache.try_emplace(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="uncoveredLine">      LI, NonLocalDepResult(ClosestDependency->getParent(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="">                            MemDepResult::getDef(ClosestDependency), nullptr));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="uncoveredLine">  ReverseNonLocalDefsCache[ClosestDependency].insert(LI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="uncoveredLine">  return MemDepResult::getNonLocal();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="uncoveredLine">MemDepResult MemoryDependenceResults::getSimplePointerDependencyFrom(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="">    const MemoryLocation &MemLoc, bool isLoad, BasicBlock::iterator ScanIt,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="">    BasicBlock *BB, Instruction *QueryInst, unsigned *Limit,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="">    BatchAAResults &BatchAA) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="uncoveredLine">  bool isInvariantLoad = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="uncoveredLine">  unsigned DefaultLimit = getDefaultBlockScanLimit();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="uncoveredLine">  if (!Limit)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="uncoveredLine">    Limit = &DefaultLimit;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="">  // We must be careful with atomic accesses, as they may allow another thread</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="">  //   to touch this location, clobbering it. We are conservative: if the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="">  //   QueryInst is not a simple (non-atomic) memory access, we automatically</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="">  //   return getClobber.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="">  // If it is simple, we know based on the results of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="">  // "Compiler testing via a theory of sound optimisations in the C11/C++11</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="">  //   memory model" in PLDI 2013, that a non-atomic location can only be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="">  //   clobbered between a pair of a release and an acquire action, with no</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="">  //   access to the location in between.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="">  // Here is an example for giving the general intuition behind this rule.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="">  // In the following code:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="">  //   store x 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="">  //   release action; [1]</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="">  //   acquire action; [4]</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="">  //   %val = load x;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="">  // It is unsafe to replace %val by 0 because another thread may be running:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="">  //   acquire action; [2]</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="">  //   store x 42;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="">  //   release action; [3]</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="">  // with synchronization from 1 to 2 and from 3 to 4, resulting in %val</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="">  // being 42. A key property of this program however is that if either</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="">  // 1 or 4 were missing, there would be a race between the store of 42</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="">  // either the store of 0 or the load (making the whole program racy).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="">  // The paper mentioned above shows that the same property is respected</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="">  // by every program that can detect any optimization of that kind: either</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="">  // it is racy (undefined) or there is a release followed by an acquire</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="">  // between the pair of accesses under consideration.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="">  // If the load is invariant, we "know" that it doesn't alias *any* write. We</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="">  // do want to respect mustalias results since defs are useful for value</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="">  // forwarding, but any mayalias write can be assumed to be noalias.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="">  // Arguably, this logic should be pushed inside AliasAnalysis itself.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="uncoveredLine">  if (isLoad && QueryInst) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="uncoveredLine">    LoadInst *LI = dyn_cast<LoadInst>(QueryInst);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="uncoveredLine">    if (LI && LI->hasMetadata(LLVMContext::MD_invariant_load))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="uncoveredLine">      isInvariantLoad = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="">  // True for volatile instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="">  // For Load/Store return true if atomic ordering is stronger than AO,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="">  // for other instruction just true if it can read or write to memory.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="uncoveredLine">  auto isComplexForReordering = [](Instruction * I, AtomicOrdering AO)->bool {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="uncoveredLine">    if (I->isVolatile())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="uncoveredLine">      return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="uncoveredLine">    if (auto *LI = dyn_cast<LoadInst>(I))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="uncoveredLine">      return isStrongerThan(LI->getOrdering(), AO);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="uncoveredLine">    if (auto *SI = dyn_cast<StoreInst>(I))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="uncoveredLine">      return isStrongerThan(SI->getOrdering(), AO);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="uncoveredLine">    return I->mayReadOrWriteMemory();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="">  // Walk backwards through the basic block, looking for dependencies.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="uncoveredLine">  while (ScanIt != BB->begin()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="uncoveredLine">    Instruction *Inst = &*--ScanIt;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="uncoveredLine">    if (IntrinsicInst *II = dyn_cast<IntrinsicInst>(Inst))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="">      // Debug intrinsics don't (and can't) cause dependencies.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="uncoveredLine">      if (isa<DbgInfoIntrinsic>(II))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="">    // Limit the amount of scanning we do so we don't end up with quadratic</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="">    // running time on extreme testcases.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="uncoveredLine">    --*Limit;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="uncoveredLine">    if (!*Limit)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="uncoveredLine">      return MemDepResult::getUnknown();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="uncoveredLine">    if (IntrinsicInst *II = dyn_cast<IntrinsicInst>(Inst)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="">      // If we reach a lifetime begin or end marker, then the query ends here</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="">      // because the value is undefined.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="uncoveredLine">      Intrinsic::ID ID = II->getIntrinsicID();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="uncoveredLine">      switch (ID) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="uncoveredLine">      case Intrinsic::lifetime_start: {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="">        // FIXME: This only considers queries directly on the invariant-tagged</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="">        // pointer, not on query pointers that are indexed off of them.  It'd</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="">        // be nice to handle that at some point (the right approach is to use</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="">        // GetPointerBaseWithConstantOffset).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="uncoveredLine">        MemoryLocation ArgLoc = MemoryLocation::getAfter(II->getArgOperand(1));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="uncoveredLine">        if (BatchAA.isMustAlias(ArgLoc, MemLoc))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="uncoveredLine">          return MemDepResult::getDef(II);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="uncoveredLine">      }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="uncoveredLine">      case Intrinsic::masked_load:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="">      case Intrinsic::masked_store: {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="uncoveredLine">        MemoryLocation Loc;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="uncoveredLine">        /*ModRefInfo MR =*/ GetLocation(II, Loc, TLI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="uncoveredLine">        AliasResult R = BatchAA.alias(Loc, MemLoc);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="uncoveredLine">        if (R == AliasResult::NoAlias)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="uncoveredLine">          continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="uncoveredLine">        if (R == AliasResult::MustAlias)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="uncoveredLine">          return MemDepResult::getDef(II);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="uncoveredLine">        if (ID == Intrinsic::masked_load)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="uncoveredLine">          continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="uncoveredLine">        return MemDepResult::getClobber(II);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="">    // Values depend on loads if the pointers are must aliased.  This means</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="">    // that a load depends on another must aliased load from the same value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="">    // One exception is atomic loads: a value can depend on an atomic load that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="">    // it does not alias with when this atomic load indicates that another</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="">    // thread may be accessing the location.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="uncoveredLine">    if (LoadInst *LI = dyn_cast<LoadInst>(Inst)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="">      // While volatile access cannot be eliminated, they do not have to clobber</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="">      // non-aliasing locations, as normal accesses, for example, can be safely</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="">      // reordered with volatile accesses.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="uncoveredLine">      if (LI->isVolatile()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="uncoveredLine">        if (!QueryInst)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="">          // Original QueryInst *may* be volatile</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="uncoveredLine">          return MemDepResult::getClobber(LI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="uncoveredLine">        if (QueryInst->isVolatile())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="">          // Ordering required if QueryInst is itself volatile</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="uncoveredLine">          return MemDepResult::getClobber(LI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="">        // Otherwise, volatile doesn't imply any special ordering</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="">      // Atomic loads have complications involved.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="">      // A Monotonic (or higher) load is OK if the query inst is itself not</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="">      // atomic.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="">      // FIXME: This is overly conservative.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="uncoveredLine">      if (LI->isAtomic() && isStrongerThanUnordered(LI->getOrdering())) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="uncoveredLine">        if (!QueryInst ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="uncoveredLine">            isComplexForReordering(QueryInst, AtomicOrdering::NotAtomic))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="uncoveredLine">          return MemDepResult::getClobber(LI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="uncoveredLine">        if (LI->getOrdering() != AtomicOrdering::Monotonic)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="uncoveredLine">          return MemDepResult::getClobber(LI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="uncoveredLine">      MemoryLocation LoadLoc = MemoryLocation::get(LI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="">      // If we found a pointer, check if it could be the same as our pointer.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class="uncoveredLine">      AliasResult R = BatchAA.alias(LoadLoc, MemLoc);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="uncoveredLine">      if (R == AliasResult::NoAlias)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="uncoveredLine">      if (isLoad) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="">        // Must aliased loads are defs of each other.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="uncoveredLine">        if (R == AliasResult::MustAlias)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="uncoveredLine">          return MemDepResult::getDef(Inst);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="">        // If we have a partial alias, then return this as a clobber for the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="">        // client to handle.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="uncoveredLine">        if (R == AliasResult::PartialAlias && R.hasOffset()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class="uncoveredLine">          ClobberOffsets[LI] = R.getOffset();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="uncoveredLine">          return MemDepResult::getClobber(Inst);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="">        // Random may-alias loads don't depend on each other without a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="">        // dependence.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class="">      // Stores don't alias loads from read-only memory.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="uncoveredLine">      if (!isModSet(BatchAA.getModRefInfoMask(LoadLoc)))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="">      // Stores depend on may/must aliased loads.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="uncoveredLine">      return MemDepResult::getDef(Inst);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="uncoveredLine">    if (StoreInst *SI = dyn_cast<StoreInst>(Inst)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="">      // Atomic stores have complications involved.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="">      // A Monotonic store is OK if the query inst is itself not atomic.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="">      // FIXME: This is overly conservative.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="uncoveredLine">      if (!SI->isUnordered() && SI->isAtomic()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="uncoveredLine">        if (!QueryInst ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class="uncoveredLine">            isComplexForReordering(QueryInst, AtomicOrdering::Unordered))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="uncoveredLine">          return MemDepResult::getClobber(SI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="">        // Ok, if we are here the guard above guarantee us that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="">        // QueryInst is a non-atomic or unordered load/store.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="">        // SI is atomic with monotonic or release semantic (seq_cst for store</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="">        // is actually a release semantic plus total order over other seq_cst</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="">        // instructions, as soon as QueryInst is not seq_cst we can consider it</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="">        // as simple release semantic).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="">        // Monotonic and Release semantic allows re-ordering before store</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="">        // so we are safe to go further and check the aliasing. It will prohibit</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="">        // re-ordering in case locations are may or must alias.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="">      // While volatile access cannot be eliminated, they do not have to clobber</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="">      // non-aliasing locations, as normal accesses can for example be reordered</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="">      // with volatile accesses.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="uncoveredLine">      if (SI->isVolatile())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="uncoveredLine">        if (!QueryInst || QueryInst->isVolatile())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="uncoveredLine">          return MemDepResult::getClobber(SI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="">      // If alias analysis can tell that this store is guaranteed to not modify</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="">      // the query pointer, ignore it.  Use getModRefInfo to handle cases where</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="">      // the query pointer points to constant memory etc.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="uncoveredLine">      if (!isModOrRefSet(BatchAA.getModRefInfo(SI, MemLoc)))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="">      // Ok, this store might clobber the query pointer.  Check to see if it is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="">      // a must alias: in this case, we want to return this as a def.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="">      // FIXME: Use ModRefInfo::Must bit from getModRefInfo call above.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="uncoveredLine">      MemoryLocation StoreLoc = MemoryLocation::get(SI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="">      // If we found a pointer, check if it could be the same as our pointer.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="uncoveredLine">      AliasResult R = BatchAA.alias(StoreLoc, MemLoc);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="uncoveredLine">      if (R == AliasResult::NoAlias)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="uncoveredLine">      if (R == AliasResult::MustAlias)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="uncoveredLine">        return MemDepResult::getDef(Inst);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="uncoveredLine">      if (isInvariantLoad)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="uncoveredLine">      return MemDepResult::getClobber(Inst);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="">    // If this is an allocation, and if we know that the accessed pointer is to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="">    // the allocation, return Def.  This means that there is no dependence and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="">    // the access can be optimized based on that.  For example, a load could</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="">    // turn into undef.  Note that we can bypass the allocation itself when</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class="">    // looking for a clobber in many cases; that's an alias property and is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="">    // handled by BasicAA.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="uncoveredLine">    if (isa<AllocaInst>(Inst) || isNoAliasCall(Inst)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class="uncoveredLine">      const Value *AccessPtr = getUnderlyingObject(MemLoc.Ptr);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="uncoveredLine">      if (AccessPtr == Inst || BatchAA.isMustAlias(Inst, AccessPtr))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="uncoveredLine">        return MemDepResult::getDef(Inst);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="">    // If we found a select instruction for MemLoc pointer, return it as Def</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="">    // dependency.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class="uncoveredLine">    if (isa<SelectInst>(Inst) && MemLoc.Ptr == Inst)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="uncoveredLine">      return MemDepResult::getDef(Inst);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="uncoveredLine">    if (isInvariantLoad)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="">    // A release fence requires that all stores complete before it, but does</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="">    // not prevent the reordering of following loads or stores 'before' the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="">    // fence.  As a result, we look past it when finding a dependency for</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="">    // loads.  DSE uses this to find preceding stores to delete and thus we</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="">    // can't bypass the fence if the query instruction is a store.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="uncoveredLine">    if (FenceInst *FI = dyn_cast<FenceInst>(Inst))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="uncoveredLine">      if (isLoad && FI->getOrdering() == AtomicOrdering::Release)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="">    // See if this instruction (e.g. a call or vaarg) mod/ref's the pointer.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class="uncoveredLine">    ModRefInfo MR = BatchAA.getModRefInfo(Inst, MemLoc);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class="">    // If necessary, perform additional analysis.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="uncoveredLine">    if (isModAndRefSet(MR))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="uncoveredLine">      MR = BatchAA.callCapturesBefore(Inst, MemLoc, &DT);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="uncoveredLine">    switch (MR) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class="uncoveredLine">    case ModRefInfo::NoModRef:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="">      // If the call has no effect on the queried pointer, just ignore it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class="uncoveredLine">    case ModRefInfo::Mod:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="uncoveredLine">      return MemDepResult::getClobber(Inst);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="uncoveredLine">    case ModRefInfo::Ref:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="">      // If the call is known to never store to the pointer, and if this is a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="">      // load query, we can safely ignore it (scan past it).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="uncoveredLine">      if (isLoad)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class="">      [[fallthrough]];</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="">    default:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class="">      // Otherwise, there is a potential dependence.  Return a clobber.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="uncoveredLine">      return MemDepResult::getClobber(Inst);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="">  // No dependence found.  If this is the entry block of the function, it is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="">  // unknown, otherwise it is non-local.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="uncoveredLine">  if (BB != &BB->getParent()->getEntryBlock())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="uncoveredLine">    return MemDepResult::getNonLocal();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="uncoveredLine">  return MemDepResult::getNonFuncLocal();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="uncoveredLine">MemDepResult MemoryDependenceResults::getDependency(Instruction *QueryInst) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="uncoveredLine">  ClobberOffsets.clear();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class="uncoveredLine">  Instruction *ScanPos = QueryInst;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="">  // Check for a cached result</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="uncoveredLine">  MemDepResult &LocalCache = LocalDeps[QueryInst];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="">  // If the cached entry is non-dirty, just return it.  Note that this depends</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="">  // on MemDepResult's default constructing to 'dirty'.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="uncoveredLine">  if (!LocalCache.isDirty())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="uncoveredLine">    return LocalCache;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="">  // Otherwise, if we have a dirty entry, we know we can start the scan at that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="">  // instruction, which may save us some work.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="uncoveredLine">  if (Instruction *Inst = LocalCache.getInst()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class="uncoveredLine">    ScanPos = Inst;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="uncoveredLine">    RemoveFromReverseMap(ReverseLocalDeps, Inst, QueryInst);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="uncoveredLine">  BasicBlock *QueryParent = QueryInst->getParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="">  // Do the scan.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="uncoveredLine">  if (BasicBlock::iterator(QueryInst) == QueryParent->begin()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="">    // No dependence found. If this is the entry block of the function, it is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="">    // unknown, otherwise it is non-local.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="uncoveredLine">    if (QueryParent != &QueryParent->getParent()->getEntryBlock())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="uncoveredLine">      LocalCache = MemDepResult::getNonLocal();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="">    else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="uncoveredLine">      LocalCache = MemDepResult::getNonFuncLocal();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class="">  } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="uncoveredLine">    MemoryLocation MemLoc;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="uncoveredLine">    ModRefInfo MR = GetLocation(QueryInst, MemLoc, TLI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class="uncoveredLine">    if (MemLoc.Ptr) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class="">      // If we can do a pointer scan, make it happen.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="uncoveredLine">      bool isLoad = !isModSet(MR);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="uncoveredLine">      if (auto *II = dyn_cast<IntrinsicInst>(QueryInst))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="uncoveredLine">        isLoad |= II->getIntrinsicID() == Intrinsic::lifetime_start;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="">      LocalCache =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="uncoveredLine">          getPointerDependencyFrom(MemLoc, isLoad, ScanPos->getIterator(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class="">                                   QueryParent, QueryInst, nullptr);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="uncoveredLine">    } else if (auto *QueryCall = dyn_cast<CallBase>(QueryInst)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class="uncoveredLine">      bool isReadOnly = AA.onlyReadsMemory(QueryCall);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="uncoveredLine">      LocalCache = getCallDependencyFrom(QueryCall, isReadOnly,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="">                                         ScanPos->getIterator(), QueryParent);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class="">    } else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class="">      // Non-memory instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class="uncoveredLine">      LocalCache = MemDepResult::getUnknown();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class="">  // Remember the result!</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class="uncoveredLine">  if (Instruction *I = LocalCache.getInst())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="uncoveredLine">    ReverseLocalDeps[I].insert(QueryInst);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class="uncoveredLine">  return LocalCache;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="">#ifndef NDEBUG</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="">/// This method is used when -debug is specified to verify that cache arrays</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class="">/// are properly kept sorted.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="uncoveredLine">static void AssertSorted(MemoryDependenceResults::NonLocalDepInfo &Cache,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class="">                         int Count = -1) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="uncoveredLine">  if (Count == -1)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class="uncoveredLine">    Count = Cache.size();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class="uncoveredLine">  assert(std::is_sorted(Cache.begin(), Cache.begin() + Count) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class="">         "Cache isn't sorted!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="">#endif</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class="">const MemoryDependenceResults::NonLocalDepInfo &</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="uncoveredLine">MemoryDependenceResults::getNonLocalCallDependency(CallBase *QueryCall) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="uncoveredLine">  assert(getDependency(QueryCall).isNonLocal() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="">         "getNonLocalCallDependency should only be used on calls with "</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="">         "non-local deps!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class="uncoveredLine">  PerInstNLInfo &CacheP = NonLocalDepsMap[QueryCall];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class="uncoveredLine">  NonLocalDepInfo &Cache = CacheP.first;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class="">  // This is the set of blocks that need to be recomputed.  In the cached case,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="">  // this can happen due to instructions being deleted etc. In the uncached</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class="">  // case, this starts out as the set of predecessors we care about.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="uncoveredLine">  SmallVector<BasicBlock *, 32> DirtyBlocks;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="uncoveredLine">  if (!Cache.empty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class="">    // Okay, we have a cache entry.  If we know it is not dirty, just return it</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class="">    // with no computation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class="uncoveredLine">    if (!CacheP.second) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="uncoveredLine">      ++NumCacheNonLocal;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class="uncoveredLine">      return Cache;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="">    // If we already have a partially computed set of results, scan them to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="">    // determine what is dirty, seeding our initial DirtyBlocks worklist.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class="uncoveredLine">    for (auto &Entry : Cache)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class="uncoveredLine">      if (Entry.getResult().isDirty())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class="uncoveredLine">        DirtyBlocks.push_back(Entry.getBB());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class="">    // Sort the cache so that we can do fast binary search lookups below.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="uncoveredLine">    llvm::sort(Cache);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class="uncoveredLine">    ++NumCacheDirtyNonLocal;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class="">  } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="">    // Seed DirtyBlocks with each of the preds of QueryInst's block.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="uncoveredLine">    BasicBlock *QueryBB = QueryCall->getParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class="uncoveredLine">    append_range(DirtyBlocks, PredCache.get(QueryBB));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class="uncoveredLine">    ++NumUncacheNonLocal;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="">  // isReadonlyCall - If this is a read-only call, we can be more aggressive.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class="uncoveredLine">  bool isReadonlyCall = AA.onlyReadsMemory(QueryCall);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class="uncoveredLine">  SmallPtrSet<BasicBlock *, 32> Visited;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class="uncoveredLine">  unsigned NumSortedEntries = Cache.size();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="uncoveredLine">  LLVM_DEBUG(AssertSorted(Cache));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="">  // Iterate while we still have blocks to update.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="uncoveredLine">  while (!DirtyBlocks.empty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class="uncoveredLine">    BasicBlock *DirtyBB = DirtyBlocks.pop_back_val();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class="">    // Already processed this block?</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="uncoveredLine">    if (!Visited.insert(DirtyBB).second)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class="">    // Do a binary search to see if we already have an entry for this block in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="">    // the cache set.  If so, find it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class="uncoveredLine">    LLVM_DEBUG(AssertSorted(Cache, NumSortedEntries));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="">    NonLocalDepInfo::iterator Entry =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="uncoveredLine">        std::upper_bound(Cache.begin(), Cache.begin() + NumSortedEntries,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class="uncoveredLine">                         NonLocalDepEntry(DirtyBB));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="uncoveredLine">    if (Entry != Cache.begin() && std::prev(Entry)->getBB() == DirtyBB)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class="uncoveredLine">      --Entry;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class="uncoveredLine">    NonLocalDepEntry *ExistingResult = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class="uncoveredLine">    if (Entry != Cache.begin() + NumSortedEntries &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="uncoveredLine">        Entry->getBB() == DirtyBB) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class="">      // If we already have an entry, and if it isn't already dirty, the block</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="">      // is done.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class="uncoveredLine">      if (!Entry->getResult().isDirty())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="">      // Otherwise, remember this slot so we can update the value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class="uncoveredLine">      ExistingResult = &*Entry;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class="">    // If the dirty entry has a pointer, start scanning from it so we don't have</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="">    // to rescan the entire block.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class="uncoveredLine">    BasicBlock::iterator ScanPos = DirtyBB->end();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class="uncoveredLine">    if (ExistingResult) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class="uncoveredLine">      if (Instruction *Inst = ExistingResult->getResult().getInst()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class="uncoveredLine">        ScanPos = Inst->getIterator();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="">        // We're removing QueryInst's use of Inst.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class="uncoveredLine">        RemoveFromReverseMap<Instruction *>(ReverseNonLocalDeps, Inst,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="">                                            QueryCall);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class="">    // Find out if this block has a local dependency for QueryInst.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class="uncoveredLine">    MemDepResult Dep;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class="uncoveredLine">    if (ScanPos != DirtyBB->begin()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class="uncoveredLine">      Dep = getCallDependencyFrom(QueryCall, isReadonlyCall, ScanPos, DirtyBB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class="uncoveredLine">    } else if (DirtyBB != &DirtyBB->getParent()->getEntryBlock()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class="">      // No dependence found.  If this is the entry block of the function, it is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class="">      // a clobber, otherwise it is unknown.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class="uncoveredLine">      Dep = MemDepResult::getNonLocal();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class="">    } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class="uncoveredLine">      Dep = MemDepResult::getNonFuncLocal();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class="">    // If we had a dirty entry for the block, update it.  Otherwise, just add</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class="">    // a new entry.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class="uncoveredLine">    if (ExistingResult)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class="uncoveredLine">      ExistingResult->setResult(Dep);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class="">    else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class="uncoveredLine">      Cache.push_back(NonLocalDepEntry(DirtyBB, Dep));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class="">    // If the block has a dependency (i.e. it isn't completely transparent to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class="">    // the value), remember the association!</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class="uncoveredLine">    if (!Dep.isNonLocal()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class="">      // Keep the ReverseNonLocalDeps map up to date so we can efficiently</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class="">      // update this when we remove instructions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class="uncoveredLine">      if (Instruction *Inst = Dep.getInst())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class="uncoveredLine">        ReverseNonLocalDeps[Inst].insert(QueryCall);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class="">    } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class="">      // If the block *is* completely transparent to the load, we need to check</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class="">      // the predecessors of this block.  Add them to our worklist.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class="uncoveredLine">      append_range(DirtyBlocks, PredCache.get(DirtyBB));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class="uncoveredLine">  return Cache;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class="uncoveredLine">void MemoryDependenceResults::getNonLocalPointerDependency(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class="">    Instruction *QueryInst, SmallVectorImpl<NonLocalDepResult> &Result) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class="uncoveredLine">  const MemoryLocation Loc = MemoryLocation::get(QueryInst);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class="uncoveredLine">  bool isLoad = isa<LoadInst>(QueryInst);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class="uncoveredLine">  BasicBlock *FromBB = QueryInst->getParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class="uncoveredLine">  assert(FromBB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class="uncoveredLine">  assert(Loc.Ptr->getType()->isPointerTy() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class="">         "Can't get pointer deps of a non-pointer!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class="uncoveredLine">  Result.clear();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class="">  {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class="">    // Check if there is cached Def with invariant.group.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class="uncoveredLine">    auto NonLocalDefIt = NonLocalDefsCache.find(QueryInst);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class="uncoveredLine">    if (NonLocalDefIt != NonLocalDefsCache.end()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class="uncoveredLine">      Result.push_back(NonLocalDefIt->second);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class="uncoveredLine">      ReverseNonLocalDefsCache[NonLocalDefIt->second.getResult().getInst()]</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class="uncoveredLine">          .erase(QueryInst);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class="uncoveredLine">      NonLocalDefsCache.erase(NonLocalDefIt);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class="uncoveredLine">      return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class="">  // This routine does not expect to deal with volatile instructions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class="">  // Doing so would require piping through the QueryInst all the way through.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class="">  // TODO: volatiles can't be elided, but they can be reordered with other</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class="">  // non-volatile accesses.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class="">  // We currently give up on any instruction which is ordered, but we do handle</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class="">  // atomic instructions which are unordered.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class="">  // TODO: Handle ordered instructions</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class="uncoveredLine">  auto isOrdered = [](Instruction *Inst) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class="uncoveredLine">    if (LoadInst *LI = dyn_cast<LoadInst>(Inst)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class="uncoveredLine">      return !LI->isUnordered();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class="uncoveredLine">    } else if (StoreInst *SI = dyn_cast<StoreInst>(Inst)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="uncoveredLine">      return !SI->isUnordered();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">872</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">873</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">874</td>
    <td class="uncoveredLine">  if (QueryInst->isVolatile() || isOrdered(QueryInst)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">875</td>
    <td class="uncoveredLine">    Result.push_back(NonLocalDepResult(FromBB, MemDepResult::getUnknown(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">876</td>
    <td class="uncoveredLine">                                       const_cast<Value *>(Loc.Ptr)));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">877</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">878</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">879</td>
    <td class="uncoveredLine">  const DataLayout &DL = FromBB->getModule()->getDataLayout();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">880</td>
    <td class="uncoveredLine">  PHITransAddr Address(const_cast<Value *>(Loc.Ptr), DL, &AC);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">881</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">882</td>
    <td class="">  // This is the set of blocks we've inspected, and the pointer we consider in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">883</td>
    <td class="">  // each block.  Because of critical edges, we currently bail out if querying</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">884</td>
    <td class="">  // a block with multiple different pointers.  This can happen during PHI</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">885</td>
    <td class="">  // translation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">886</td>
    <td class="uncoveredLine">  DenseMap<BasicBlock *, Value *> Visited;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">887</td>
    <td class="uncoveredLine">  if (getNonLocalPointerDepFromBB(QueryInst, Address, Loc, isLoad, FromBB,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">888</td>
    <td class="">                                   Result, Visited, true))</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">889</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">890</td>
    <td class="uncoveredLine">  Result.clear();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">891</td>
    <td class="uncoveredLine">  Result.push_back(NonLocalDepResult(FromBB, MemDepResult::getUnknown(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">892</td>
    <td class="uncoveredLine">                                     const_cast<Value *>(Loc.Ptr)));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">893</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">894</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">895</td>
    <td class="">/// Compute the memdep value for BB with Pointer/PointeeSize using either</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">896</td>
    <td class="">/// cached information in Cache or by doing a lookup (which may use dirty cache</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">897</td>
    <td class="">/// info if available).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">898</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">899</td>
    <td class="">/// If we do a lookup, add the result to the cache.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">900</td>
    <td class="uncoveredLine">MemDepResult MemoryDependenceResults::getNonLocalInfoForBlock(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">901</td>
    <td class="">    Instruction *QueryInst, const MemoryLocation &Loc, bool isLoad,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">902</td>
    <td class="">    BasicBlock *BB, NonLocalDepInfo *Cache, unsigned NumSortedEntries,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">903</td>
    <td class="">    BatchAAResults &BatchAA) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">904</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">905</td>
    <td class="uncoveredLine">  bool isInvariantLoad = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">906</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">907</td>
    <td class="uncoveredLine">  if (LoadInst *LI = dyn_cast_or_null<LoadInst>(QueryInst))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">908</td>
    <td class="uncoveredLine">    isInvariantLoad = LI->getMetadata(LLVMContext::MD_invariant_load);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">909</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">910</td>
    <td class="">  // Do a binary search to see if we already have an entry for this block in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">911</td>
    <td class="">  // the cache set.  If so, find it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">912</td>
    <td class="uncoveredLine">  NonLocalDepInfo::iterator Entry = std::upper_bound(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">913</td>
    <td class="uncoveredLine">      Cache->begin(), Cache->begin() + NumSortedEntries, NonLocalDepEntry(BB));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">914</td>
    <td class="uncoveredLine">  if (Entry != Cache->begin() && (Entry - 1)->getBB() == BB)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">915</td>
    <td class="uncoveredLine">    --Entry;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">916</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">917</td>
    <td class="uncoveredLine">  NonLocalDepEntry *ExistingResult = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">918</td>
    <td class="uncoveredLine">  if (Entry != Cache->begin() + NumSortedEntries && Entry->getBB() == BB)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">919</td>
    <td class="uncoveredLine">    ExistingResult = &*Entry;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">920</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">921</td>
    <td class="">  // Use cached result for invariant load only if there is no dependency for non</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">922</td>
    <td class="">  // invariant load. In this case invariant load can not have any dependency as</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">923</td>
    <td class="">  // well.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">924</td>
    <td class="uncoveredLine">  if (ExistingResult && isInvariantLoad &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">925</td>
    <td class="uncoveredLine">      !ExistingResult->getResult().isNonFuncLocal())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">926</td>
    <td class="uncoveredLine">    ExistingResult = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">927</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">928</td>
    <td class="">  // If we have a cached entry, and it is non-dirty, use it as the value for</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">929</td>
    <td class="">  // this dependency.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">930</td>
    <td class="uncoveredLine">  if (ExistingResult && !ExistingResult->getResult().isDirty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">931</td>
    <td class="uncoveredLine">    ++NumCacheNonLocalPtr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">932</td>
    <td class="uncoveredLine">    return ExistingResult->getResult();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">933</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">934</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">935</td>
    <td class="">  // Otherwise, we have to scan for the value.  If we have a dirty cache</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">936</td>
    <td class="">  // entry, start scanning from its position, otherwise we scan from the end</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">937</td>
    <td class="">  // of the block.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">938</td>
    <td class="uncoveredLine">  BasicBlock::iterator ScanPos = BB->end();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">939</td>
    <td class="uncoveredLine">  if (ExistingResult && ExistingResult->getResult().getInst()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">940</td>
    <td class="uncoveredLine">    assert(ExistingResult->getResult().getInst()->getParent() == BB &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">941</td>
    <td class="">           "Instruction invalidated?");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">942</td>
    <td class="uncoveredLine">    ++NumCacheDirtyNonLocalPtr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">943</td>
    <td class="uncoveredLine">    ScanPos = ExistingResult->getResult().getInst()->getIterator();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">944</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">945</td>
    <td class="">    // Eliminating the dirty entry from 'Cache', so update the reverse info.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">946</td>
    <td class="uncoveredLine">    ValueIsLoadPair CacheKey(Loc.Ptr, isLoad);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">947</td>
    <td class="uncoveredLine">    RemoveFromReverseMap(ReverseNonLocalPtrDeps, &*ScanPos, CacheKey);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">948</td>
    <td class="">  } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">949</td>
    <td class="uncoveredLine">    ++NumUncacheNonLocalPtr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">950</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">951</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">952</td>
    <td class="">  // Scan the block for the dependency.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">953</td>
    <td class="uncoveredLine">  MemDepResult Dep = getPointerDependencyFrom(Loc, isLoad, ScanPos, BB,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">954</td>
    <td class="">                                              QueryInst, nullptr, BatchAA);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">955</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">956</td>
    <td class="">  // Don't cache results for invariant load.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">957</td>
    <td class="uncoveredLine">  if (isInvariantLoad)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">958</td>
    <td class="uncoveredLine">    return Dep;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">959</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">960</td>
    <td class="">  // If we had a dirty entry for the block, update it.  Otherwise, just add</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">961</td>
    <td class="">  // a new entry.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">962</td>
    <td class="uncoveredLine">  if (ExistingResult)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">963</td>
    <td class="uncoveredLine">    ExistingResult->setResult(Dep);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">964</td>
    <td class="">  else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">965</td>
    <td class="uncoveredLine">    Cache->push_back(NonLocalDepEntry(BB, Dep));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">966</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">967</td>
    <td class="">  // If the block has a dependency (i.e. it isn't completely transparent to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">968</td>
    <td class="">  // the value), remember the reverse association because we just added it</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">969</td>
    <td class="">  // to Cache!</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">970</td>
    <td class="uncoveredLine">  if (!Dep.isLocal())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">971</td>
    <td class="uncoveredLine">    return Dep;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">972</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">973</td>
    <td class="">  // Keep the ReverseNonLocalPtrDeps map up to date so we can efficiently</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">974</td>
    <td class="">  // update MemDep when we remove instructions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">975</td>
    <td class="uncoveredLine">  Instruction *Inst = Dep.getInst();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">976</td>
    <td class="uncoveredLine">  assert(Inst && "Didn't depend on anything?");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">977</td>
    <td class="uncoveredLine">  ValueIsLoadPair CacheKey(Loc.Ptr, isLoad);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">978</td>
    <td class="uncoveredLine">  ReverseNonLocalPtrDeps[Inst].insert(CacheKey);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">979</td>
    <td class="uncoveredLine">  return Dep;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">980</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">981</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">982</td>
    <td class="">/// Sort the NonLocalDepInfo cache, given a certain number of elements in the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">983</td>
    <td class="">/// array that are already properly ordered.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">984</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">985</td>
    <td class="">/// This is optimized for the case when only a few entries are added.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">986</td>
    <td class="">static void</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">987</td>
    <td class="uncoveredLine">SortNonLocalDepInfoCache(MemoryDependenceResults::NonLocalDepInfo &Cache,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">988</td>
    <td class="">                         unsigned NumSortedEntries) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">989</td>
    <td class="uncoveredLine">  switch (Cache.size() - NumSortedEntries) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">990</td>
    <td class="uncoveredLine">  case 0:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">991</td>
    <td class="">    // done, no new entries.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">992</td>
    <td class="uncoveredLine">    break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">993</td>
    <td class="uncoveredLine">  case 2: {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">994</td>
    <td class="">    // Two new entries, insert the last one into place.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">995</td>
    <td class="uncoveredLine">    NonLocalDepEntry Val = Cache.back();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">996</td>
    <td class="uncoveredLine">    Cache.pop_back();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">997</td>
    <td class="">    MemoryDependenceResults::NonLocalDepInfo::iterator Entry =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">998</td>
    <td class="uncoveredLine">        std::upper_bound(Cache.begin(), Cache.end() - 1, Val);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">999</td>
    <td class="uncoveredLine">    Cache.insert(Entry, Val);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1000</td>
    <td class="">    [[fallthrough]];</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1001</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1002</td>
    <td class="uncoveredLine">  case 1:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1003</td>
    <td class="">    // One new entry, Just insert the new value at the appropriate position.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1004</td>
    <td class="uncoveredLine">    if (Cache.size() != 1) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1005</td>
    <td class="uncoveredLine">      NonLocalDepEntry Val = Cache.back();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1006</td>
    <td class="uncoveredLine">      Cache.pop_back();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1007</td>
    <td class="">      MemoryDependenceResults::NonLocalDepInfo::iterator Entry =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1008</td>
    <td class="uncoveredLine">          llvm::upper_bound(Cache, Val);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1009</td>
    <td class="uncoveredLine">      Cache.insert(Entry, Val);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1010</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1011</td>
    <td class="uncoveredLine">    break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1012</td>
    <td class="uncoveredLine">  default:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1013</td>
    <td class="">    // Added many values, do a full scale sort.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1014</td>
    <td class="uncoveredLine">    llvm::sort(Cache);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1015</td>
    <td class="uncoveredLine">    break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1016</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1017</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1018</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1019</td>
    <td class="">/// Perform a dependency query based on pointer/pointeesize starting at the end</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1020</td>
    <td class="">/// of StartBB.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1021</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1022</td>
    <td class="">/// Add any clobber/def results to the results vector and keep track of which</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1023</td>
    <td class="">/// blocks are visited in 'Visited'.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1024</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1025</td>
    <td class="">/// This has special behavior for the first block queries (when SkipFirstBlock</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1026</td>
    <td class="">/// is true).  In this special case, it ignores the contents of the specified</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1027</td>
    <td class="">/// block and starts returning dependence info for its predecessors.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1028</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1029</td>
    <td class="">/// This function returns true on success, or false to indicate that it could</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1030</td>
    <td class="">/// not compute dependence information for some reason.  This should be treated</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1031</td>
    <td class="">/// as a clobber dependence on the first instruction in the predecessor block.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1032</td>
    <td class="uncoveredLine">bool MemoryDependenceResults::getNonLocalPointerDepFromBB(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1033</td>
    <td class="">    Instruction *QueryInst, const PHITransAddr &Pointer,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1034</td>
    <td class="">    const MemoryLocation &Loc, bool isLoad, BasicBlock *StartBB,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1035</td>
    <td class="">    SmallVectorImpl<NonLocalDepResult> &Result,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1036</td>
    <td class="">    DenseMap<BasicBlock *, Value *> &Visited, bool SkipFirstBlock,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1037</td>
    <td class="">    bool IsIncomplete) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1038</td>
    <td class="">  // Look up the cached info for Pointer.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1039</td>
    <td class="uncoveredLine">  ValueIsLoadPair CacheKey(Pointer.getAddr(), isLoad);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1040</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1041</td>
    <td class="">  // Set up a temporary NLPI value. If the map doesn't yet have an entry for</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1042</td>
    <td class="">  // CacheKey, this value will be inserted as the associated value. Otherwise,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1043</td>
    <td class="">  // it'll be ignored, and we'll have to check to see if the cached size and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1044</td>
    <td class="">  // aa tags are consistent with the current query.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1045</td>
    <td class="uncoveredLine">  NonLocalPointerInfo InitialNLPI;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1046</td>
    <td class="uncoveredLine">  InitialNLPI.Size = Loc.Size;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1047</td>
    <td class="uncoveredLine">  InitialNLPI.AATags = Loc.AATags;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1048</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1049</td>
    <td class="uncoveredLine">  bool isInvariantLoad = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1050</td>
    <td class="uncoveredLine">  if (LoadInst *LI = dyn_cast_or_null<LoadInst>(QueryInst))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1051</td>
    <td class="uncoveredLine">    isInvariantLoad = LI->getMetadata(LLVMContext::MD_invariant_load);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1052</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1053</td>
    <td class="">  // Get the NLPI for CacheKey, inserting one into the map if it doesn't</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1054</td>
    <td class="">  // already have one.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1055</td>
    <td class="">  std::pair<CachedNonLocalPointerInfo::iterator, bool> Pair =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1056</td>
    <td class="uncoveredLine">      NonLocalPointerDeps.insert(std::make_pair(CacheKey, InitialNLPI));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1057</td>
    <td class="uncoveredLine">  NonLocalPointerInfo *CacheInfo = &Pair.first->second;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1058</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1059</td>
    <td class="">  // If we already have a cache entry for this CacheKey, we may need to do some</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1060</td>
    <td class="">  // work to reconcile the cache entry and the current query.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1061</td>
    <td class="">  // Invariant loads don't participate in caching. Thus no need to reconcile.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1062</td>
    <td class="uncoveredLine">  if (!isInvariantLoad && !Pair.second) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1063</td>
    <td class="uncoveredLine">    if (CacheInfo->Size != Loc.Size) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1064</td>
    <td class="">      bool ThrowOutEverything;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1065</td>
    <td class="uncoveredLine">      if (CacheInfo->Size.hasValue() && Loc.Size.hasValue()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1066</td>
    <td class="">        // FIXME: We may be able to do better in the face of results with mixed</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1067</td>
    <td class="">        // precision. We don't appear to get them in practice, though, so just</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1068</td>
    <td class="">        // be conservative.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1069</td>
    <td class="uncoveredLine">        ThrowOutEverything =</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1070</td>
    <td class="uncoveredLine">            CacheInfo->Size.isPrecise() != Loc.Size.isPrecise() ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1071</td>
    <td class="uncoveredLine">            CacheInfo->Size.getValue() < Loc.Size.getValue();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1072</td>
    <td class="">      } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1073</td>
    <td class="">        // For our purposes, unknown size > all others.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1074</td>
    <td class="uncoveredLine">        ThrowOutEverything = !Loc.Size.hasValue();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1075</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1076</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1077</td>
    <td class="uncoveredLine">      if (ThrowOutEverything) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1078</td>
    <td class="">        // The query's Size is greater than the cached one. Throw out the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1079</td>
    <td class="">        // cached data and proceed with the query at the greater size.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1080</td>
    <td class="uncoveredLine">        CacheInfo->Pair = BBSkipFirstBlockPair();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1081</td>
    <td class="uncoveredLine">        CacheInfo->Size = Loc.Size;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1082</td>
    <td class="uncoveredLine">        for (auto &Entry : CacheInfo->NonLocalDeps)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1083</td>
    <td class="uncoveredLine">          if (Instruction *Inst = Entry.getResult().getInst())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1084</td>
    <td class="uncoveredLine">            RemoveFromReverseMap(ReverseNonLocalPtrDeps, Inst, CacheKey);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1085</td>
    <td class="uncoveredLine">        CacheInfo->NonLocalDeps.clear();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1086</td>
    <td class="">        // The cache is cleared (in the above line) so we will have lost</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1087</td>
    <td class="">        // information about blocks we have already visited. We therefore must</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1088</td>
    <td class="">        // assume that the cache information is incomplete.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1089</td>
    <td class="uncoveredLine">        IsIncomplete = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1090</td>
    <td class="">      } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1091</td>
    <td class="">        // This query's Size is less than the cached one. Conservatively restart</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1092</td>
    <td class="">        // the query using the greater size.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1093</td>
    <td class="uncoveredLine">        return getNonLocalPointerDepFromBB(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1094</td>
    <td class="uncoveredLine">            QueryInst, Pointer, Loc.getWithNewSize(CacheInfo->Size), isLoad,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1095</td>
    <td class="uncoveredLine">            StartBB, Result, Visited, SkipFirstBlock, IsIncomplete);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1096</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1097</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1098</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1099</td>
    <td class="">    // If the query's AATags are inconsistent with the cached one,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1100</td>
    <td class="">    // conservatively throw out the cached data and restart the query with</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1101</td>
    <td class="">    // no tag if needed.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1102</td>
    <td class="uncoveredLine">    if (CacheInfo->AATags != Loc.AATags) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1103</td>
    <td class="uncoveredLine">      if (CacheInfo->AATags) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1104</td>
    <td class="uncoveredLine">        CacheInfo->Pair = BBSkipFirstBlockPair();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1105</td>
    <td class="uncoveredLine">        CacheInfo->AATags = AAMDNodes();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1106</td>
    <td class="uncoveredLine">        for (auto &Entry : CacheInfo->NonLocalDeps)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1107</td>
    <td class="uncoveredLine">          if (Instruction *Inst = Entry.getResult().getInst())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1108</td>
    <td class="uncoveredLine">            RemoveFromReverseMap(ReverseNonLocalPtrDeps, Inst, CacheKey);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1109</td>
    <td class="uncoveredLine">        CacheInfo->NonLocalDeps.clear();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1110</td>
    <td class="">        // The cache is cleared (in the above line) so we will have lost</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1111</td>
    <td class="">        // information about blocks we have already visited. We therefore must</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1112</td>
    <td class="">        // assume that the cache information is incomplete.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1113</td>
    <td class="uncoveredLine">        IsIncomplete = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1114</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1115</td>
    <td class="uncoveredLine">      if (Loc.AATags)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1116</td>
    <td class="uncoveredLine">        return getNonLocalPointerDepFromBB(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1117</td>
    <td class="uncoveredLine">            QueryInst, Pointer, Loc.getWithoutAATags(), isLoad, StartBB, Result,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1118</td>
    <td class="uncoveredLine">            Visited, SkipFirstBlock, IsIncomplete);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1119</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1120</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1121</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1122</td>
    <td class="uncoveredLine">  NonLocalDepInfo *Cache = &CacheInfo->NonLocalDeps;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1123</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1124</td>
    <td class="">  // If we have valid cached information for exactly the block we are</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1125</td>
    <td class="">  // investigating, just return it with no recomputation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1126</td>
    <td class="">  // Don't use cached information for invariant loads since it is valid for</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1127</td>
    <td class="">  // non-invariant loads only.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1128</td>
    <td class="uncoveredLine">  if (!IsIncomplete && !isInvariantLoad &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1129</td>
    <td class="uncoveredLine">      CacheInfo->Pair == BBSkipFirstBlockPair(StartBB, SkipFirstBlock)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1130</td>
    <td class="">    // We have a fully cached result for this query then we can just return the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1131</td>
    <td class="">    // cached results and populate the visited set.  However, we have to verify</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1132</td>
    <td class="">    // that we don't already have conflicting results for these blocks.  Check</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1133</td>
    <td class="">    // to ensure that if a block in the results set is in the visited set that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1134</td>
    <td class="">    // it was for the same pointer query.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1135</td>
    <td class="uncoveredLine">    if (!Visited.empty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1136</td>
    <td class="uncoveredLine">      for (auto &Entry : *Cache) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1137</td>
    <td class="">        DenseMap<BasicBlock *, Value *>::iterator VI =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1138</td>
    <td class="uncoveredLine">            Visited.find(Entry.getBB());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1139</td>
    <td class="uncoveredLine">        if (VI == Visited.end() || VI->second == Pointer.getAddr())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1140</td>
    <td class="uncoveredLine">          continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1141</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1142</td>
    <td class="">        // We have a pointer mismatch in a block.  Just return false, saying</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1143</td>
    <td class="">        // that something was clobbered in this result.  We could also do a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1144</td>
    <td class="">        // non-fully cached query, but there is little point in doing this.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1145</td>
    <td class="uncoveredLine">        return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1146</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1147</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1148</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1149</td>
    <td class="uncoveredLine">    Value *Addr = Pointer.getAddr();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1150</td>
    <td class="uncoveredLine">    for (auto &Entry : *Cache) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1151</td>
    <td class="uncoveredLine">      Visited.insert(std::make_pair(Entry.getBB(), Addr));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1152</td>
    <td class="uncoveredLine">      if (Entry.getResult().isNonLocal()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1153</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1154</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1155</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1156</td>
    <td class="uncoveredLine">      if (DT.isReachableFromEntry(Entry.getBB())) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1157</td>
    <td class="uncoveredLine">        Result.push_back(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1158</td>
    <td class="uncoveredLine">            NonLocalDepResult(Entry.getBB(), Entry.getResult(), Addr));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1159</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1160</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1161</td>
    <td class="uncoveredLine">    ++NumCacheCompleteNonLocalPtr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1162</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1163</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1164</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1165</td>
    <td class="">  // Otherwise, either this is a new block, a block with an invalid cache</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1166</td>
    <td class="">  // pointer or one that we're about to invalidate by putting more info into</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1167</td>
    <td class="">  // it than its valid cache info.  If empty and not explicitly indicated as</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1168</td>
    <td class="">  // incomplete, the result will be valid cache info, otherwise it isn't.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1169</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1170</td>
    <td class="">  // Invariant loads don't affect cache in any way thus no need to update</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1171</td>
    <td class="">  // CacheInfo as well.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1172</td>
    <td class="uncoveredLine">  if (!isInvariantLoad) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1173</td>
    <td class="uncoveredLine">    if (!IsIncomplete && Cache->empty())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1174</td>
    <td class="uncoveredLine">      CacheInfo->Pair = BBSkipFirstBlockPair(StartBB, SkipFirstBlock);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1175</td>
    <td class="">    else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1176</td>
    <td class="uncoveredLine">      CacheInfo->Pair = BBSkipFirstBlockPair();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1177</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1178</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1179</td>
    <td class="uncoveredLine">  SmallVector<BasicBlock *, 32> Worklist;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1180</td>
    <td class="uncoveredLine">  Worklist.push_back(StartBB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1181</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1182</td>
    <td class="">  // PredList used inside loop.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1183</td>
    <td class="uncoveredLine">  SmallVector<std::pair<BasicBlock *, PHITransAddr>, 16> PredList;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1184</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1185</td>
    <td class="">  // Keep track of the entries that we know are sorted.  Previously cached</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1186</td>
    <td class="">  // entries will all be sorted.  The entries we add we only sort on demand (we</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1187</td>
    <td class="">  // don't insert every element into its sorted position).  We know that we</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1188</td>
    <td class="">  // won't get any reuse from currently inserted values, because we don't</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1189</td>
    <td class="">  // revisit blocks after we insert info for them.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1190</td>
    <td class="uncoveredLine">  unsigned NumSortedEntries = Cache->size();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1191</td>
    <td class="uncoveredLine">  unsigned WorklistEntries = BlockNumberLimit;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1192</td>
    <td class="uncoveredLine">  bool GotWorklistLimit = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1193</td>
    <td class="uncoveredLine">  LLVM_DEBUG(AssertSorted(*Cache));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1194</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1195</td>
    <td class="uncoveredLine">  BatchAAResults BatchAA(AA);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1196</td>
    <td class="uncoveredLine">  while (!Worklist.empty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1197</td>
    <td class="uncoveredLine">    BasicBlock *BB = Worklist.pop_back_val();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1198</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1199</td>
    <td class="">    // If we do process a large number of blocks it becomes very expensive and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1200</td>
    <td class="">    // likely it isn't worth worrying about</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1201</td>
    <td class="uncoveredLine">    if (Result.size() > NumResultsLimit) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1202</td>
    <td class="">      // Sort it now (if needed) so that recursive invocations of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1203</td>
    <td class="">      // getNonLocalPointerDepFromBB and other routines that could reuse the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1204</td>
    <td class="">      // cache value will only see properly sorted cache arrays.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1205</td>
    <td class="uncoveredLine">      if (Cache && NumSortedEntries != Cache->size()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1206</td>
    <td class="uncoveredLine">        SortNonLocalDepInfoCache(*Cache, NumSortedEntries);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1207</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1208</td>
    <td class="">      // Since we bail out, the "Cache" set won't contain all of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1209</td>
    <td class="">      // results for the query.  This is ok (we can still use it to accelerate</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1210</td>
    <td class="">      // specific block queries) but we can't do the fastpath "return all</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1211</td>
    <td class="">      // results from the set".  Clear out the indicator for this.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1212</td>
    <td class="uncoveredLine">      CacheInfo->Pair = BBSkipFirstBlockPair();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1213</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1214</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1215</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1216</td>
    <td class="">    // Skip the first block if we have it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1217</td>
    <td class="uncoveredLine">    if (!SkipFirstBlock) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1218</td>
    <td class="">      // Analyze the dependency of *Pointer in FromBB.  See if we already have</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1219</td>
    <td class="">      // been here.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1220</td>
    <td class="uncoveredLine">      assert(Visited.count(BB) && "Should check 'visited' before adding to WL");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1221</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1222</td>
    <td class="">      // Get the dependency info for Pointer in BB.  If we have cached</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1223</td>
    <td class="">      // information, we will use it, otherwise we compute it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1224</td>
    <td class="uncoveredLine">      LLVM_DEBUG(AssertSorted(*Cache, NumSortedEntries));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1225</td>
    <td class="uncoveredLine">      MemDepResult Dep = getNonLocalInfoForBlock(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1226</td>
    <td class="">          QueryInst, Loc, isLoad, BB, Cache, NumSortedEntries, BatchAA);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1227</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1228</td>
    <td class="">      // If we got a Def or Clobber, add this to the list of results.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1229</td>
    <td class="uncoveredLine">      if (!Dep.isNonLocal()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1230</td>
    <td class="uncoveredLine">        if (DT.isReachableFromEntry(BB)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1231</td>
    <td class="uncoveredLine">          Result.push_back(NonLocalDepResult(BB, Dep, Pointer.getAddr()));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1232</td>
    <td class="uncoveredLine">          continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1233</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1234</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1235</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1236</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1237</td>
    <td class="">    // If 'Pointer' is an instruction defined in this block, then we need to do</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1238</td>
    <td class="">    // phi translation to change it into a value live in the predecessor block.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1239</td>
    <td class="">    // If not, we just add the predecessors to the worklist and scan them with</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1240</td>
    <td class="">    // the same Pointer.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1241</td>
    <td class="uncoveredLine">    if (!Pointer.needsPHITranslationFromBlock(BB)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1242</td>
    <td class="uncoveredLine">      SkipFirstBlock = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1243</td>
    <td class="uncoveredLine">      SmallVector<BasicBlock *, 16> NewBlocks;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1244</td>
    <td class="uncoveredLine">      for (BasicBlock *Pred : PredCache.get(BB)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1245</td>
    <td class="">        // Verify that we haven't looked at this block yet.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1246</td>
    <td class="">        std::pair<DenseMap<BasicBlock *, Value *>::iterator, bool> InsertRes =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1247</td>
    <td class="uncoveredLine">            Visited.insert(std::make_pair(Pred, Pointer.getAddr()));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1248</td>
    <td class="uncoveredLine">        if (InsertRes.second) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1249</td>
    <td class="">          // First time we've looked at *PI.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1250</td>
    <td class="uncoveredLine">          NewBlocks.push_back(Pred);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1251</td>
    <td class="uncoveredLine">          continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1252</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1253</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1254</td>
    <td class="">        // If we have seen this block before, but it was with a different</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1255</td>
    <td class="">        // pointer then we have a phi translation failure and we have to treat</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1256</td>
    <td class="">        // this as a clobber.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1257</td>
    <td class="uncoveredLine">        if (InsertRes.first->second != Pointer.getAddr()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1258</td>
    <td class="">          // Make sure to clean up the Visited map before continuing on to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1259</td>
    <td class="">          // PredTranslationFailure.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1260</td>
    <td class="uncoveredLine">          for (unsigned i = 0; i < NewBlocks.size(); i++)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1261</td>
    <td class="uncoveredLine">            Visited.erase(NewBlocks[i]);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1262</td>
    <td class="uncoveredLine">          goto PredTranslationFailure;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1263</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1264</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1265</td>
    <td class="uncoveredLine">      if (NewBlocks.size() > WorklistEntries) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1266</td>
    <td class="">        // Make sure to clean up the Visited map before continuing on to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1267</td>
    <td class="">        // PredTranslationFailure.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1268</td>
    <td class="uncoveredLine">        for (unsigned i = 0; i < NewBlocks.size(); i++)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1269</td>
    <td class="uncoveredLine">          Visited.erase(NewBlocks[i]);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1270</td>
    <td class="uncoveredLine">        GotWorklistLimit = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1271</td>
    <td class="uncoveredLine">        goto PredTranslationFailure;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1272</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1273</td>
    <td class="uncoveredLine">      WorklistEntries -= NewBlocks.size();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1274</td>
    <td class="uncoveredLine">      Worklist.append(NewBlocks.begin(), NewBlocks.end());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1275</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1276</td>
    <td class="uncoveredLine">    }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1277</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1278</td>
    <td class="">    // We do need to do phi translation, if we know ahead of time we can't phi</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1279</td>
    <td class="">    // translate this value, don't even try.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1280</td>
    <td class="uncoveredLine">    if (!Pointer.isPotentiallyPHITranslatable())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1281</td>
    <td class="uncoveredLine">      goto PredTranslationFailure;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1282</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1283</td>
    <td class="">    // We may have added values to the cache list before this PHI translation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1284</td>
    <td class="">    // If so, we haven't done anything to ensure that the cache remains sorted.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1285</td>
    <td class="">    // Sort it now (if needed) so that recursive invocations of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1286</td>
    <td class="">    // getNonLocalPointerDepFromBB and other routines that could reuse the cache</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1287</td>
    <td class="">    // value will only see properly sorted cache arrays.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1288</td>
    <td class="uncoveredLine">    if (Cache && NumSortedEntries != Cache->size()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1289</td>
    <td class="uncoveredLine">      SortNonLocalDepInfoCache(*Cache, NumSortedEntries);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1290</td>
    <td class="uncoveredLine">      NumSortedEntries = Cache->size();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1291</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1292</td>
    <td class="uncoveredLine">    Cache = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1293</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1294</td>
    <td class="uncoveredLine">    PredList.clear();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1295</td>
    <td class="uncoveredLine">    for (BasicBlock *Pred : PredCache.get(BB)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1296</td>
    <td class="uncoveredLine">      PredList.push_back(std::make_pair(Pred, Pointer));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1297</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1298</td>
    <td class="">      // Get the PHI translated pointer in this predecessor.  This can fail if</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1299</td>
    <td class="">      // not translatable, in which case the getAddr() returns null.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1300</td>
    <td class="uncoveredLine">      PHITransAddr &PredPointer = PredList.back().second;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1301</td>
    <td class="">      Value *PredPtrVal =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1302</td>
    <td class="uncoveredLine">          PredPointer.translateValue(BB, Pred, &DT, /*MustDominate=*/false);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1303</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1304</td>
    <td class="">      // Check to see if we have already visited this pred block with another</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1305</td>
    <td class="">      // pointer.  If so, we can't do this lookup.  This failure can occur</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1306</td>
    <td class="">      // with PHI translation when a critical edge exists and the PHI node in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1307</td>
    <td class="">      // the successor translates to a pointer value different than the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1308</td>
    <td class="">      // pointer the block was first analyzed with.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1309</td>
    <td class="">      std::pair<DenseMap<BasicBlock *, Value *>::iterator, bool> InsertRes =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1310</td>
    <td class="uncoveredLine">          Visited.insert(std::make_pair(Pred, PredPtrVal));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1311</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1312</td>
    <td class="uncoveredLine">      if (!InsertRes.second) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1313</td>
    <td class="">        // We found the pred; take it off the list of preds to visit.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1314</td>
    <td class="uncoveredLine">        PredList.pop_back();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1315</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1316</td>
    <td class="">        // If the predecessor was visited with PredPtr, then we already did</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1317</td>
    <td class="">        // the analysis and can ignore it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1318</td>
    <td class="uncoveredLine">        if (InsertRes.first->second == PredPtrVal)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1319</td>
    <td class="uncoveredLine">          continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1320</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1321</td>
    <td class="">        // Otherwise, the block was previously analyzed with a different</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1322</td>
    <td class="">        // pointer.  We can't represent the result of this case, so we just</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1323</td>
    <td class="">        // treat this as a phi translation failure.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1324</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1325</td>
    <td class="">        // Make sure to clean up the Visited map before continuing on to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1326</td>
    <td class="">        // PredTranslationFailure.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1327</td>
    <td class="uncoveredLine">        for (unsigned i = 0, n = PredList.size(); i < n; ++i)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1328</td>
    <td class="uncoveredLine">          Visited.erase(PredList[i].first);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1329</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1330</td>
    <td class="uncoveredLine">        goto PredTranslationFailure;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1331</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1332</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1333</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1334</td>
    <td class="">    // Actually process results here; this need to be a separate loop to avoid</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1335</td>
    <td class="">    // calling getNonLocalPointerDepFromBB for blocks we don't want to return</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1336</td>
    <td class="">    // any results for.  (getNonLocalPointerDepFromBB will modify our</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1337</td>
    <td class="">    // datastructures in ways the code after the PredTranslationFailure label</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1338</td>
    <td class="">    // doesn't expect.)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1339</td>
    <td class="uncoveredLine">    for (unsigned i = 0, n = PredList.size(); i < n; ++i) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1340</td>
    <td class="uncoveredLine">      BasicBlock *Pred = PredList[i].first;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1341</td>
    <td class="uncoveredLine">      PHITransAddr &PredPointer = PredList[i].second;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1342</td>
    <td class="uncoveredLine">      Value *PredPtrVal = PredPointer.getAddr();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1343</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1344</td>
    <td class="uncoveredLine">      bool CanTranslate = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1345</td>
    <td class="">      // If PHI translation was unable to find an available pointer in this</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1346</td>
    <td class="">      // predecessor, then we have to assume that the pointer is clobbered in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1347</td>
    <td class="">      // that predecessor.  We can still do PRE of the load, which would insert</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1348</td>
    <td class="">      // a computation of the pointer in this predecessor.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1349</td>
    <td class="uncoveredLine">      if (!PredPtrVal)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1350</td>
    <td class="uncoveredLine">        CanTranslate = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1351</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1352</td>
    <td class="">      // FIXME: it is entirely possible that PHI translating will end up with</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1353</td>
    <td class="">      // the same value.  Consider PHI translating something like:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1354</td>
    <td class="">      // X = phi [x, bb1], [y, bb2].  PHI translating for bb1 doesn't *need*</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1355</td>
    <td class="">      // to recurse here, pedantically speaking.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1356</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1357</td>
    <td class="">      // If getNonLocalPointerDepFromBB fails here, that means the cached</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1358</td>
    <td class="">      // result conflicted with the Visited list; we have to conservatively</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1359</td>
    <td class="">      // assume it is unknown, but this also does not block PRE of the load.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1360</td>
    <td class="uncoveredLine">      if (!CanTranslate ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1361</td>
    <td class="uncoveredLine">          !getNonLocalPointerDepFromBB(QueryInst, PredPointer,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1362</td>
    <td class="uncoveredLine">                                      Loc.getWithNewPtr(PredPtrVal), isLoad,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1363</td>
    <td class="">                                      Pred, Result, Visited)) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1364</td>
    <td class="">        // Add the entry to the Result list.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1365</td>
    <td class="uncoveredLine">        NonLocalDepResult Entry(Pred, MemDepResult::getUnknown(), PredPtrVal);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1366</td>
    <td class="uncoveredLine">        Result.push_back(Entry);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1367</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1368</td>
    <td class="">        // Since we had a phi translation failure, the cache for CacheKey won't</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1369</td>
    <td class="">        // include all of the entries that we need to immediately satisfy future</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1370</td>
    <td class="">        // queries.  Mark this in NonLocalPointerDeps by setting the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1371</td>
    <td class="">        // BBSkipFirstBlockPair pointer to null.  This requires reuse of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1372</td>
    <td class="">        // cached value to do more work but not miss the phi trans failure.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1373</td>
    <td class="uncoveredLine">        NonLocalPointerInfo &NLPI = NonLocalPointerDeps[CacheKey];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1374</td>
    <td class="uncoveredLine">        NLPI.Pair = BBSkipFirstBlockPair();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1375</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1376</td>
    <td class="uncoveredLine">      }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1377</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1378</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1379</td>
    <td class="">    // Refresh the CacheInfo/Cache pointer so that it isn't invalidated.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1380</td>
    <td class="uncoveredLine">    CacheInfo = &NonLocalPointerDeps[CacheKey];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1381</td>
    <td class="uncoveredLine">    Cache = &CacheInfo->NonLocalDeps;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1382</td>
    <td class="uncoveredLine">    NumSortedEntries = Cache->size();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1383</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1384</td>
    <td class="">    // Since we did phi translation, the "Cache" set won't contain all of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1385</td>
    <td class="">    // results for the query.  This is ok (we can still use it to accelerate</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1386</td>
    <td class="">    // specific block queries) but we can't do the fastpath "return all</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1387</td>
    <td class="">    // results from the set"  Clear out the indicator for this.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1388</td>
    <td class="uncoveredLine">    CacheInfo->Pair = BBSkipFirstBlockPair();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1389</td>
    <td class="uncoveredLine">    SkipFirstBlock = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1390</td>
    <td class="uncoveredLine">    continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1391</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1392</td>
    <td class="uncoveredLine">  PredTranslationFailure:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1393</td>
    <td class="">    // The following code is "failure"; we can't produce a sane translation</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1394</td>
    <td class="">    // for the given block.  It assumes that we haven't modified any of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1395</td>
    <td class="">    // our datastructures while processing the current block.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1396</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1397</td>
    <td class="uncoveredLine">    if (!Cache) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1398</td>
    <td class="">      // Refresh the CacheInfo/Cache pointer if it got invalidated.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1399</td>
    <td class="uncoveredLine">      CacheInfo = &NonLocalPointerDeps[CacheKey];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1400</td>
    <td class="uncoveredLine">      Cache = &CacheInfo->NonLocalDeps;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1401</td>
    <td class="uncoveredLine">      NumSortedEntries = Cache->size();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1402</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1403</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1404</td>
    <td class="">    // Since we failed phi translation, the "Cache" set won't contain all of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1405</td>
    <td class="">    // results for the query.  This is ok (we can still use it to accelerate</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1406</td>
    <td class="">    // specific block queries) but we can't do the fastpath "return all</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1407</td>
    <td class="">    // results from the set".  Clear out the indicator for this.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1408</td>
    <td class="uncoveredLine">    CacheInfo->Pair = BBSkipFirstBlockPair();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1409</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1410</td>
    <td class="">    // If *nothing* works, mark the pointer as unknown.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1411</td>
    <td class="">    //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1412</td>
    <td class="">    // If this is the magic first block, return this as a clobber of the whole</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1413</td>
    <td class="">    // incoming value.  Since we can't phi translate to one of the predecessors,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1414</td>
    <td class="">    // we have to bail out.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1415</td>
    <td class="uncoveredLine">    if (SkipFirstBlock)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1416</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1417</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1418</td>
    <td class="">    // Results of invariant loads are not cached thus no need to update cached</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1419</td>
    <td class="">    // information.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1420</td>
    <td class="uncoveredLine">    if (!isInvariantLoad) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1421</td>
    <td class="uncoveredLine">      for (NonLocalDepEntry &I : llvm::reverse(*Cache)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1422</td>
    <td class="uncoveredLine">        if (I.getBB() != BB)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1423</td>
    <td class="uncoveredLine">          continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1424</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1425</td>
    <td class="uncoveredLine">        assert((GotWorklistLimit || I.getResult().isNonLocal() ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1426</td>
    <td class="">                !DT.isReachableFromEntry(BB)) &&</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1427</td>
    <td class="">               "Should only be here with transparent block");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1428</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1429</td>
    <td class="uncoveredLine">        I.setResult(MemDepResult::getUnknown());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1430</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1431</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1432</td>
    <td class="uncoveredLine">        break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1433</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1434</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1435</td>
    <td class="">    (void)GotWorklistLimit;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1436</td>
    <td class="">    // Go ahead and report unknown dependence.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1437</td>
    <td class="uncoveredLine">    Result.push_back(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1438</td>
    <td class="uncoveredLine">        NonLocalDepResult(BB, MemDepResult::getUnknown(), Pointer.getAddr()));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1439</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1440</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1441</td>
    <td class="">  // Okay, we're done now.  If we added new values to the cache, re-sort it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1442</td>
    <td class="uncoveredLine">  SortNonLocalDepInfoCache(*Cache, NumSortedEntries);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1443</td>
    <td class="uncoveredLine">  LLVM_DEBUG(AssertSorted(*Cache));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1444</td>
    <td class="uncoveredLine">  return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1445</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1446</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1447</td>
    <td class="">/// If P exists in CachedNonLocalPointerInfo or NonLocalDefsCache, remove it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1448</td>
    <td class="uncoveredLine">void MemoryDependenceResults::removeCachedNonLocalPointerDependencies(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1449</td>
    <td class="">    ValueIsLoadPair P) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1450</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1451</td>
    <td class="">  // Most of the time this cache is empty.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1452</td>
    <td class="uncoveredLine">  if (!NonLocalDefsCache.empty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1453</td>
    <td class="uncoveredLine">    auto it = NonLocalDefsCache.find(P.getPointer());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1454</td>
    <td class="uncoveredLine">    if (it != NonLocalDefsCache.end()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1455</td>
    <td class="uncoveredLine">      RemoveFromReverseMap(ReverseNonLocalDefsCache,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1456</td>
    <td class="uncoveredLine">                           it->second.getResult().getInst(), P.getPointer());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1457</td>
    <td class="uncoveredLine">      NonLocalDefsCache.erase(it);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1458</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1459</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1460</td>
    <td class="uncoveredLine">    if (auto *I = dyn_cast<Instruction>(P.getPointer())) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1461</td>
    <td class="uncoveredLine">      auto toRemoveIt = ReverseNonLocalDefsCache.find(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1462</td>
    <td class="uncoveredLine">      if (toRemoveIt != ReverseNonLocalDefsCache.end()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1463</td>
    <td class="uncoveredLine">        for (const auto *entry : toRemoveIt->second)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1464</td>
    <td class="uncoveredLine">          NonLocalDefsCache.erase(entry);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1465</td>
    <td class="uncoveredLine">        ReverseNonLocalDefsCache.erase(toRemoveIt);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1466</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1467</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1468</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1469</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1470</td>
    <td class="uncoveredLine">  CachedNonLocalPointerInfo::iterator It = NonLocalPointerDeps.find(P);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1471</td>
    <td class="uncoveredLine">  if (It == NonLocalPointerDeps.end())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1472</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1473</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1474</td>
    <td class="">  // Remove all of the entries in the BB->val map.  This involves removing</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1475</td>
    <td class="">  // instructions from the reverse map.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1476</td>
    <td class="uncoveredLine">  NonLocalDepInfo &PInfo = It->second.NonLocalDeps;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1477</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1478</td>
    <td class="uncoveredLine">  for (const NonLocalDepEntry &DE : PInfo) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1479</td>
    <td class="uncoveredLine">    Instruction *Target = DE.getResult().getInst();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1480</td>
    <td class="uncoveredLine">    if (!Target)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1481</td>
    <td class="uncoveredLine">      continue; // Ignore non-local dep results.</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1482</td>
    <td class="uncoveredLine">    assert(Target->getParent() == DE.getBB());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1483</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1484</td>
    <td class="">    // Eliminating the dirty entry from 'Cache', so update the reverse info.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1485</td>
    <td class="uncoveredLine">    RemoveFromReverseMap(ReverseNonLocalPtrDeps, Target, P);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1486</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1487</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1488</td>
    <td class="">  // Remove P from NonLocalPointerDeps (which deletes NonLocalDepInfo).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1489</td>
    <td class="uncoveredLine">  NonLocalPointerDeps.erase(It);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1490</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1491</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1492</td>
    <td class="uncoveredLine">void MemoryDependenceResults::invalidateCachedPointerInfo(Value *Ptr) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1493</td>
    <td class="">  // If Ptr isn't really a pointer, just ignore it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1494</td>
    <td class="uncoveredLine">  if (!Ptr->getType()->isPointerTy())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1495</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1496</td>
    <td class="">  // Flush store info for the pointer.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1497</td>
    <td class="uncoveredLine">  removeCachedNonLocalPointerDependencies(ValueIsLoadPair(Ptr, false));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1498</td>
    <td class="">  // Flush load info for the pointer.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1499</td>
    <td class="uncoveredLine">  removeCachedNonLocalPointerDependencies(ValueIsLoadPair(Ptr, true));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1500</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1501</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1502</td>
    <td class="uncoveredLine">void MemoryDependenceResults::invalidateCachedPredecessors() {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1503</td>
    <td class="uncoveredLine">  PredCache.clear();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1504</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1505</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1506</td>
    <td class="uncoveredLine">void MemoryDependenceResults::removeInstruction(Instruction *RemInst) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1507</td>
    <td class="">  // Walk through the Non-local dependencies, removing this one as the value</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1508</td>
    <td class="">  // for any cached queries.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1509</td>
    <td class="uncoveredLine">  NonLocalDepMapType::iterator NLDI = NonLocalDepsMap.find(RemInst);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1510</td>
    <td class="uncoveredLine">  if (NLDI != NonLocalDepsMap.end()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1511</td>
    <td class="uncoveredLine">    NonLocalDepInfo &BlockMap = NLDI->second.first;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1512</td>
    <td class="uncoveredLine">    for (auto &Entry : BlockMap)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1513</td>
    <td class="uncoveredLine">      if (Instruction *Inst = Entry.getResult().getInst())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1514</td>
    <td class="uncoveredLine">        RemoveFromReverseMap(ReverseNonLocalDeps, Inst, RemInst);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1515</td>
    <td class="uncoveredLine">    NonLocalDepsMap.erase(NLDI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1516</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1517</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1518</td>
    <td class="">  // If we have a cached local dependence query for this instruction, remove it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1519</td>
    <td class="uncoveredLine">  LocalDepMapType::iterator LocalDepEntry = LocalDeps.find(RemInst);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1520</td>
    <td class="uncoveredLine">  if (LocalDepEntry != LocalDeps.end()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1521</td>
    <td class="">    // Remove us from DepInst's reverse set now that the local dep info is gone.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1522</td>
    <td class="uncoveredLine">    if (Instruction *Inst = LocalDepEntry->second.getInst())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1523</td>
    <td class="uncoveredLine">      RemoveFromReverseMap(ReverseLocalDeps, Inst, RemInst);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1524</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1525</td>
    <td class="">    // Remove this local dependency info.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1526</td>
    <td class="uncoveredLine">    LocalDeps.erase(LocalDepEntry);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1527</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1528</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1529</td>
    <td class="">  // If we have any cached dependencies on this instruction, remove</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1530</td>
    <td class="">  // them.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1531</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1532</td>
    <td class="">  // If the instruction is a pointer, remove it from both the load info and the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1533</td>
    <td class="">  // store info.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1534</td>
    <td class="uncoveredLine">  if (RemInst->getType()->isPointerTy()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1535</td>
    <td class="uncoveredLine">    removeCachedNonLocalPointerDependencies(ValueIsLoadPair(RemInst, false));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1536</td>
    <td class="uncoveredLine">    removeCachedNonLocalPointerDependencies(ValueIsLoadPair(RemInst, true));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1537</td>
    <td class="">  } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1538</td>
    <td class="">    // Otherwise, if the instructions is in the map directly, it must be a load.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1539</td>
    <td class="">    // Remove it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1540</td>
    <td class="uncoveredLine">    auto toRemoveIt = NonLocalDefsCache.find(RemInst);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1541</td>
    <td class="uncoveredLine">    if (toRemoveIt != NonLocalDefsCache.end()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1542</td>
    <td class="uncoveredLine">      assert(isa<LoadInst>(RemInst) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1543</td>
    <td class="">             "only load instructions should be added directly");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1544</td>
    <td class="uncoveredLine">      const Instruction *DepV = toRemoveIt->second.getResult().getInst();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1545</td>
    <td class="uncoveredLine">      ReverseNonLocalDefsCache.find(DepV)->second.erase(RemInst);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1546</td>
    <td class="uncoveredLine">      NonLocalDefsCache.erase(toRemoveIt);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1547</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1548</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1549</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1550</td>
    <td class="">  // Loop over all of the things that depend on the instruction we're removing.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1551</td>
    <td class="uncoveredLine">  SmallVector<std::pair<Instruction *, Instruction *>, 8> ReverseDepsToAdd;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1552</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1553</td>
    <td class="">  // If we find RemInst as a clobber or Def in any of the maps for other values,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1554</td>
    <td class="">  // we need to replace its entry with a dirty version of the instruction after</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1555</td>
    <td class="">  // it.  If RemInst is a terminator, we use a null dirty value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1556</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1557</td>
    <td class="">  // Using a dirty version of the instruction after RemInst saves having to scan</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1558</td>
    <td class="">  // the entire block to get to this point.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1559</td>
    <td class="uncoveredLine">  MemDepResult NewDirtyVal;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1560</td>
    <td class="uncoveredLine">  if (!RemInst->isTerminator())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1561</td>
    <td class="uncoveredLine">    NewDirtyVal = MemDepResult::getDirty(&*++RemInst->getIterator());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1562</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1563</td>
    <td class="uncoveredLine">  ReverseDepMapType::iterator ReverseDepIt = ReverseLocalDeps.find(RemInst);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1564</td>
    <td class="uncoveredLine">  if (ReverseDepIt != ReverseLocalDeps.end()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1565</td>
    <td class="">    // RemInst can't be the terminator if it has local stuff depending on it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1566</td>
    <td class="uncoveredLine">    assert(!ReverseDepIt->second.empty() && !RemInst->isTerminator() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1567</td>
    <td class="">           "Nothing can locally depend on a terminator");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1568</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1569</td>
    <td class="uncoveredLine">    for (Instruction *InstDependingOnRemInst : ReverseDepIt->second) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1570</td>
    <td class="uncoveredLine">      assert(InstDependingOnRemInst != RemInst &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1571</td>
    <td class="">             "Already removed our local dep info");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1572</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1573</td>
    <td class="uncoveredLine">      LocalDeps[InstDependingOnRemInst] = NewDirtyVal;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1574</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1575</td>
    <td class="">      // Make sure to remember that new things depend on NewDepInst.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1576</td>
    <td class="uncoveredLine">      assert(NewDirtyVal.getInst() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1577</td>
    <td class="">             "There is no way something else can have "</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1578</td>
    <td class="">             "a local dep on this if it is a terminator!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1579</td>
    <td class="uncoveredLine">      ReverseDepsToAdd.push_back(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1580</td>
    <td class="uncoveredLine">          std::make_pair(NewDirtyVal.getInst(), InstDependingOnRemInst));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1581</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1582</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1583</td>
    <td class="uncoveredLine">    ReverseLocalDeps.erase(ReverseDepIt);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1584</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1585</td>
    <td class="">    // Add new reverse deps after scanning the set, to avoid invalidating the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1586</td>
    <td class="">    // 'ReverseDeps' reference.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1587</td>
    <td class="uncoveredLine">    while (!ReverseDepsToAdd.empty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1588</td>
    <td class="uncoveredLine">      ReverseLocalDeps[ReverseDepsToAdd.back().first].insert(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1589</td>
    <td class="uncoveredLine">          ReverseDepsToAdd.back().second);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1590</td>
    <td class="uncoveredLine">      ReverseDepsToAdd.pop_back();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1591</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1592</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1593</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1594</td>
    <td class="uncoveredLine">  ReverseDepIt = ReverseNonLocalDeps.find(RemInst);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1595</td>
    <td class="uncoveredLine">  if (ReverseDepIt != ReverseNonLocalDeps.end()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1596</td>
    <td class="uncoveredLine">    for (Instruction *I : ReverseDepIt->second) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1597</td>
    <td class="uncoveredLine">      assert(I != RemInst && "Already removed NonLocalDep info for RemInst");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1598</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1599</td>
    <td class="uncoveredLine">      PerInstNLInfo &INLD = NonLocalDepsMap[I];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1600</td>
    <td class="">      // The information is now dirty!</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1601</td>
    <td class="uncoveredLine">      INLD.second = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1602</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1603</td>
    <td class="uncoveredLine">      for (auto &Entry : INLD.first) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1604</td>
    <td class="uncoveredLine">        if (Entry.getResult().getInst() != RemInst)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1605</td>
    <td class="uncoveredLine">          continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1606</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1607</td>
    <td class="">        // Convert to a dirty entry for the subsequent instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1608</td>
    <td class="uncoveredLine">        Entry.setResult(NewDirtyVal);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1609</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1610</td>
    <td class="uncoveredLine">        if (Instruction *NextI = NewDirtyVal.getInst())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1611</td>
    <td class="uncoveredLine">          ReverseDepsToAdd.push_back(std::make_pair(NextI, I));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1612</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1613</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1614</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1615</td>
    <td class="uncoveredLine">    ReverseNonLocalDeps.erase(ReverseDepIt);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1616</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1617</td>
    <td class="">    // Add new reverse deps after scanning the set, to avoid invalidating 'Set'</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1618</td>
    <td class="uncoveredLine">    while (!ReverseDepsToAdd.empty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1619</td>
    <td class="uncoveredLine">      ReverseNonLocalDeps[ReverseDepsToAdd.back().first].insert(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1620</td>
    <td class="uncoveredLine">          ReverseDepsToAdd.back().second);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1621</td>
    <td class="uncoveredLine">      ReverseDepsToAdd.pop_back();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1622</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1623</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1624</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1625</td>
    <td class="">  // If the instruction is in ReverseNonLocalPtrDeps then it appears as a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1626</td>
    <td class="">  // value in the NonLocalPointerDeps info.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1627</td>
    <td class="">  ReverseNonLocalPtrDepTy::iterator ReversePtrDepIt =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1628</td>
    <td class="uncoveredLine">      ReverseNonLocalPtrDeps.find(RemInst);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1629</td>
    <td class="uncoveredLine">  if (ReversePtrDepIt != ReverseNonLocalPtrDeps.end()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1630</td>
    <td class="">    SmallVector<std::pair<Instruction *, ValueIsLoadPair>, 8></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1631</td>
    <td class="uncoveredLine">        ReversePtrDepsToAdd;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1632</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1633</td>
    <td class="uncoveredLine">    for (ValueIsLoadPair P : ReversePtrDepIt->second) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1634</td>
    <td class="uncoveredLine">      assert(P.getPointer() != RemInst &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1635</td>
    <td class="">             "Already removed NonLocalPointerDeps info for RemInst");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1636</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1637</td>
    <td class="uncoveredLine">      NonLocalDepInfo &NLPDI = NonLocalPointerDeps[P].NonLocalDeps;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1638</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1639</td>
    <td class="">      // The cache is not valid for any specific block anymore.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1640</td>
    <td class="uncoveredLine">      NonLocalPointerDeps[P].Pair = BBSkipFirstBlockPair();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1641</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1642</td>
    <td class="">      // Update any entries for RemInst to use the instruction after it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1643</td>
    <td class="uncoveredLine">      for (auto &Entry : NLPDI) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1644</td>
    <td class="uncoveredLine">        if (Entry.getResult().getInst() != RemInst)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1645</td>
    <td class="uncoveredLine">          continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1646</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1647</td>
    <td class="">        // Convert to a dirty entry for the subsequent instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1648</td>
    <td class="uncoveredLine">        Entry.setResult(NewDirtyVal);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1649</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1650</td>
    <td class="uncoveredLine">        if (Instruction *NewDirtyInst = NewDirtyVal.getInst())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1651</td>
    <td class="uncoveredLine">          ReversePtrDepsToAdd.push_back(std::make_pair(NewDirtyInst, P));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1652</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1653</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1654</td>
    <td class="">      // Re-sort the NonLocalDepInfo.  Changing the dirty entry to its</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1655</td>
    <td class="">      // subsequent value may invalidate the sortedness.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1656</td>
    <td class="uncoveredLine">      llvm::sort(NLPDI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1657</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1658</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1659</td>
    <td class="uncoveredLine">    ReverseNonLocalPtrDeps.erase(ReversePtrDepIt);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1660</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1661</td>
    <td class="uncoveredLine">    while (!ReversePtrDepsToAdd.empty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1662</td>
    <td class="uncoveredLine">      ReverseNonLocalPtrDeps[ReversePtrDepsToAdd.back().first].insert(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1663</td>
    <td class="uncoveredLine">          ReversePtrDepsToAdd.back().second);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1664</td>
    <td class="uncoveredLine">      ReversePtrDepsToAdd.pop_back();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1665</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1666</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1667</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1668</td>
    <td class="uncoveredLine">  assert(!NonLocalDepsMap.count(RemInst) && "RemInst got reinserted?");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1669</td>
    <td class="uncoveredLine">  LLVM_DEBUG(verifyRemoved(RemInst));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1670</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1671</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1672</td>
    <td class="">/// Verify that the specified instruction does not occur in our internal data</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1673</td>
    <td class="">/// structures.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1674</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1675</td>
    <td class="">/// This function verifies by asserting in debug builds.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1676</td>
    <td class="uncoveredLine">void MemoryDependenceResults::verifyRemoved(Instruction *D) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1677</td>
    <td class="">#ifndef NDEBUG</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1678</td>
    <td class="uncoveredLine">  for (const auto &DepKV : LocalDeps) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1679</td>
    <td class="uncoveredLine">    assert(DepKV.first != D && "Inst occurs in data structures");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1680</td>
    <td class="uncoveredLine">    assert(DepKV.second.getInst() != D && "Inst occurs in data structures");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1681</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1682</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1683</td>
    <td class="uncoveredLine">  for (const auto &DepKV : NonLocalPointerDeps) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1684</td>
    <td class="uncoveredLine">    assert(DepKV.first.getPointer() != D && "Inst occurs in NLPD map key");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1685</td>
    <td class="uncoveredLine">    for (const auto &Entry : DepKV.second.NonLocalDeps)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1686</td>
    <td class="uncoveredLine">      assert(Entry.getResult().getInst() != D && "Inst occurs as NLPD value");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1687</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1688</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1689</td>
    <td class="uncoveredLine">  for (const auto &DepKV : NonLocalDepsMap) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1690</td>
    <td class="uncoveredLine">    assert(DepKV.first != D && "Inst occurs in data structures");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1691</td>
    <td class="uncoveredLine">    const PerInstNLInfo &INLD = DepKV.second;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1692</td>
    <td class="uncoveredLine">    for (const auto &Entry : INLD.first)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1693</td>
    <td class="uncoveredLine">      assert(Entry.getResult().getInst() != D &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1694</td>
    <td class="">             "Inst occurs in data structures");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1695</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1696</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1697</td>
    <td class="uncoveredLine">  for (const auto &DepKV : ReverseLocalDeps) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1698</td>
    <td class="uncoveredLine">    assert(DepKV.first != D && "Inst occurs in data structures");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1699</td>
    <td class="uncoveredLine">    for (Instruction *Inst : DepKV.second)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1700</td>
    <td class="uncoveredLine">      assert(Inst != D && "Inst occurs in data structures");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1701</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1702</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1703</td>
    <td class="uncoveredLine">  for (const auto &DepKV : ReverseNonLocalDeps) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1704</td>
    <td class="uncoveredLine">    assert(DepKV.first != D && "Inst occurs in data structures");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1705</td>
    <td class="uncoveredLine">    for (Instruction *Inst : DepKV.second)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1706</td>
    <td class="uncoveredLine">      assert(Inst != D && "Inst occurs in data structures");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1707</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1708</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1709</td>
    <td class="uncoveredLine">  for (const auto &DepKV : ReverseNonLocalPtrDeps) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1710</td>
    <td class="uncoveredLine">    assert(DepKV.first != D && "Inst occurs in rev NLPD map");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1711</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1712</td>
    <td class="uncoveredLine">    for (ValueIsLoadPair P : DepKV.second)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1713</td>
    <td class="uncoveredLine">      assert(P != ValueIsLoadPair(D, false) && P != ValueIsLoadPair(D, true) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1714</td>
    <td class="">             "Inst occurs in ReverseNonLocalPtrDeps map");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1715</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1716</td>
    <td class="">#endif</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1717</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1718</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1719</td>
    <td class="">AnalysisKey MemoryDependenceAnalysis::Key;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1720</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1721</td>
    <td class="uncoveredLine">MemoryDependenceAnalysis::MemoryDependenceAnalysis()</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1722</td>
    <td class="uncoveredLine">    : DefaultBlockScanLimit(BlockScanLimit) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1723</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1724</td>
    <td class="">MemoryDependenceResults</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1725</td>
    <td class="uncoveredLine">MemoryDependenceAnalysis::run(Function &F, FunctionAnalysisManager &AM) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1726</td>
    <td class="uncoveredLine">  auto &AA = AM.getResult<AAManager>(F);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1727</td>
    <td class="uncoveredLine">  auto &AC = AM.getResult<AssumptionAnalysis>(F);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1728</td>
    <td class="uncoveredLine">  auto &TLI = AM.getResult<TargetLibraryAnalysis>(F);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1729</td>
    <td class="uncoveredLine">  auto &DT = AM.getResult<DominatorTreeAnalysis>(F);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1730</td>
    <td class="uncoveredLine">  return MemoryDependenceResults(AA, AC, TLI, DT, DefaultBlockScanLimit);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1731</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1732</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1733</td>
    <td class="">char MemoryDependenceWrapperPass::ID = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1734</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1735</td>
    <td class="coveredLine">INITIALIZE_PASS_BEGIN(MemoryDependenceWrapperPass, "memdep",</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1736</td>
    <td class="">                      "Memory Dependence Analysis", false, true)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1737</td>
    <td class="coveredLine">INITIALIZE_PASS_DEPENDENCY(AssumptionCacheTracker)</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1738</td>
    <td class="coveredLine">INITIALIZE_PASS_DEPENDENCY(AAResultsWrapperPass)</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1739</td>
    <td class="coveredLine">INITIALIZE_PASS_DEPENDENCY(DominatorTreeWrapperPass)</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1740</td>
    <td class="coveredLine">INITIALIZE_PASS_DEPENDENCY(TargetLibraryInfoWrapperPass)</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1741</td>
    <td class="coveredLine">INITIALIZE_PASS_END(MemoryDependenceWrapperPass, "memdep",</td>
    <td>6</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1742</td>
    <td class="">                    "Memory Dependence Analysis", false, true)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1743</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1744</td>
    <td class="uncoveredLine">MemoryDependenceWrapperPass::MemoryDependenceWrapperPass() : FunctionPass(ID) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1745</td>
    <td class="uncoveredLine">  initializeMemoryDependenceWrapperPassPass(*PassRegistry::getPassRegistry());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1746</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1747</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1748</td>
    <td class="uncoveredLine">MemoryDependenceWrapperPass::~MemoryDependenceWrapperPass() = default;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1749</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1750</td>
    <td class="uncoveredLine">void MemoryDependenceWrapperPass::releaseMemory() {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1751</td>
    <td class="uncoveredLine">  MemDep.reset();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1752</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1753</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1754</td>
    <td class="uncoveredLine">void MemoryDependenceWrapperPass::getAnalysisUsage(AnalysisUsage &AU) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1755</td>
    <td class="uncoveredLine">  AU.setPreservesAll();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1756</td>
    <td class="uncoveredLine">  AU.addRequired<AssumptionCacheTracker>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1757</td>
    <td class="uncoveredLine">  AU.addRequired<DominatorTreeWrapperPass>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1758</td>
    <td class="uncoveredLine">  AU.addRequiredTransitive<AAResultsWrapperPass>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1759</td>
    <td class="uncoveredLine">  AU.addRequiredTransitive<TargetLibraryInfoWrapperPass>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1760</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1761</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1762</td>
    <td class="uncoveredLine">bool MemoryDependenceResults::invalidate(Function &F, const PreservedAnalyses &PA,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1763</td>
    <td class="">                               FunctionAnalysisManager::Invalidator &Inv) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1764</td>
    <td class="">  // Check whether our analysis is preserved.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1765</td>
    <td class="uncoveredLine">  auto PAC = PA.getChecker<MemoryDependenceAnalysis>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1766</td>
    <td class="uncoveredLine">  if (!PAC.preserved() && !PAC.preservedSet<AllAnalysesOn<Function>>())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1767</td>
    <td class="">    // If not, give up now.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1768</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1769</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1770</td>
    <td class="">  // Check whether the analyses we depend on became invalid for any reason.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1771</td>
    <td class="uncoveredLine">  if (Inv.invalidate<AAManager>(F, PA) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1772</td>
    <td class="uncoveredLine">      Inv.invalidate<AssumptionAnalysis>(F, PA) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1773</td>
    <td class="uncoveredLine">      Inv.invalidate<DominatorTreeAnalysis>(F, PA))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1774</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1775</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1776</td>
    <td class="">  // Otherwise this analysis result remains valid.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1777</td>
    <td class="uncoveredLine">  return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1778</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1779</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1780</td>
    <td class="uncoveredLine">unsigned MemoryDependenceResults::getDefaultBlockScanLimit() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1781</td>
    <td class="uncoveredLine">  return DefaultBlockScanLimit;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1782</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1783</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1784</td>
    <td class="uncoveredLine">bool MemoryDependenceWrapperPass::runOnFunction(Function &F) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1785</td>
    <td class="uncoveredLine">  auto &AA = getAnalysis<AAResultsWrapperPass>().getAAResults();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1786</td>
    <td class="uncoveredLine">  auto &AC = getAnalysis<AssumptionCacheTracker>().getAssumptionCache(F);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1787</td>
    <td class="uncoveredLine">  auto &TLI = getAnalysis<TargetLibraryInfoWrapperPass>().getTLI(F);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1788</td>
    <td class="uncoveredLine">  auto &DT = getAnalysis<DominatorTreeWrapperPass>().getDomTree();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1789</td>
    <td class="uncoveredLine">  MemDep.emplace(AA, AC, TLI, DT, BlockScanLimit);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1790</td>
    <td class="uncoveredLine">  return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1791</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1792</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Functions Report</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Functions Report</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Function name</th>
    <th class="mainTh">Number of hits</th>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_Z20RemoveFromReverseMapIN4llvm14PointerIntPairIPKNS0_5ValueELj1EbNS0_21PointerLikeTypeTraitsIS4_EENS0_18PointerIntPairInfoIS4_Lj1ES6_EEEEEvRNS0_8DenseMapIPNS0_11InstructionENS0_11SmallPtrSetIT_Lj4EEENS0_12DenseMapInfoISC_vEENS0_6detail12DenseMapPairISC_SF_EEEESC_SE_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_Z20RemoveFromReverseMapIPN4llvm11InstructionEEvRNS0_8DenseMapIS2_NS0_11SmallPtrSetIT_Lj4EEENS0_12DenseMapInfoIS2_vEENS0_6detail12DenseMapPairIS2_S6_EEEES2_S5_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_Z20RemoveFromReverseMapIPKN4llvm5ValueEEvRNS0_8DenseMapIPNS0_11InstructionENS0_11SmallPtrSetIT_Lj4EEENS0_12DenseMapInfoIS6_vEENS0_6detail12DenseMapPairIS6_S9_EEEES6_S8_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL11GetLocationPKN4llvm11InstructionERNS_14MemoryLocationERKNS_17TargetLibraryInfoE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm23MemoryDependenceResults21getCallDependencyFromEPNS_8CallBaseEbNS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_11InstructionELb1ELb0EvEELb0ELb0EEEPNS_10BasicBlockE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm23MemoryDependenceResults24getPointerDependencyFromERKNS_14MemoryLocationEbNS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_11InstructionELb1ELb0EvEELb0ELb0EEEPNS_10BasicBlockEPS7_PjRNS_14BatchAAResultsE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm23MemoryDependenceResults24getPointerDependencyFromERKNS_14MemoryLocationEbNS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_11InstructionELb1ELb0EvEELb0ELb0EEEPNS_10BasicBlockEPS7_Pj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm23MemoryDependenceResults34getInvariantGroupPointerDependencyEPNS_8LoadInstEPNS_10BasicBlockE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN4llvm23MemoryDependenceResults34getInvariantGroupPointerDependencyEPNS_8LoadInstEPNS_10BasicBlockEENKUlPNS_11InstructionES6_E_clES6_S6_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm23MemoryDependenceResults30getSimplePointerDependencyFromERKNS_14MemoryLocationEbNS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_11InstructionELb1ELb0EvEELb0ELb0EEEPNS_10BasicBlockEPS7_PjRNS_14BatchAAResultsE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN4llvm23MemoryDependenceResults30getSimplePointerDependencyFromERKNS_14MemoryLocationEbNS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_11InstructionELb1ELb0EvEELb0ELb0EEEPNS_10BasicBlockEPS7_PjRNS_14BatchAAResultsEENKUlSC_NS_14AtomicOrderingEE_clESC_SG_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm23MemoryDependenceResults13getDependencyEPNS_11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL12AssertSortedRSt6vectorIN4llvm16NonLocalDepEntryESaIS1_EEi</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm23MemoryDependenceResults25getNonLocalCallDependencyEPNS_8CallBaseE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm23MemoryDependenceResults28getNonLocalPointerDependencyEPNS_11InstructionERNS_15SmallVectorImplINS_17NonLocalDepResultEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN4llvm23MemoryDependenceResults28getNonLocalPointerDependencyEPNS_11InstructionERNS_15SmallVectorImplINS_17NonLocalDepResultEEEENKUlS2_E_clES2_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm23MemoryDependenceResults23getNonLocalInfoForBlockEPNS_11InstructionERKNS_14MemoryLocationEbPNS_10BasicBlockEPSt6vectorINS_16NonLocalDepEntryESaIS9_EEjRNS_14BatchAAResultsE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL24SortNonLocalDepInfoCacheRSt6vectorIN4llvm16NonLocalDepEntryESaIS1_EEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm23MemoryDependenceResults27getNonLocalPointerDepFromBBEPNS_11InstructionERKNS_12PHITransAddrERKNS_14MemoryLocationEbPNS_10BasicBlockERNS_15SmallVectorImplINS_17NonLocalDepResultEEERNS_8DenseMapISA_PNS_5ValueENS_12DenseMapInfoISA_vEENS_6detail12DenseMapPairISA_SH_EEEEbb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm23MemoryDependenceResults39removeCachedNonLocalPointerDependenciesENS_14PointerIntPairIPKNS_5ValueELj1EbNS_21PointerLikeTypeTraitsIS4_EENS_18PointerIntPairInfoIS4_Lj1ES6_EEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm23MemoryDependenceResults27invalidateCachedPointerInfoEPNS_5ValueE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm23MemoryDependenceResults28invalidateCachedPredecessorsEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm23MemoryDependenceResults17removeInstructionEPNS_11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm23MemoryDependenceResults13verifyRemovedEPNS_11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm24MemoryDependenceAnalysisC2Ev</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm24MemoryDependenceAnalysis3runERNS_8FunctionERNS_15AnalysisManagerIS1_JEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL45initializeMemoryDependenceWrapperPassPassOnceRN4llvm12PassRegistryE</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm41initializeMemoryDependenceWrapperPassPassERNS_12PassRegistryE</td>
    <td class="numberOfCalls">4</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm27MemoryDependenceWrapperPassC2Ev</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm27MemoryDependenceWrapperPassD2Ev</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm27MemoryDependenceWrapperPassD0Ev</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm27MemoryDependenceWrapperPass13releaseMemoryEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm27MemoryDependenceWrapperPass16getAnalysisUsageERNS_13AnalysisUsageE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm23MemoryDependenceResults10invalidateERNS_8FunctionERKNS_17PreservedAnalysesERNS_15AnalysisManagerIS1_JEE11InvalidatorE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm23MemoryDependenceResults24getDefaultBlockScanLimitEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm27MemoryDependenceWrapperPass13runOnFunctionERNS_8FunctionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Coverage Diff</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Coverage Diff</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span> BUT NOT </span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </th>
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
      <span> BUT NOT </span>
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="codeline">//===- MemoryDependenceAnalysis.cpp - Mem Deps Implementation -------------===//</td>
    <td class="lineNumber">1</td>
    <td class="codeline">//===- MemoryDependenceAnalysis.cpp - Mem Deps Implementation -------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="codeline">//</td>
    <td class="lineNumber">2</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="codeline">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">3</td>
    <td class="codeline">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="codeline">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">4</td>
    <td class="codeline">// See https://llvm.org/LICENSE.txt for license information.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="codeline">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">5</td>
    <td class="codeline">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="codeline">//</td>
    <td class="lineNumber">6</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">7</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="codeline">//</td>
    <td class="lineNumber">8</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="codeline">// This file implements an analysis that determines, for a given memory</td>
    <td class="lineNumber">9</td>
    <td class="codeline">// This file implements an analysis that determines, for a given memory</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="codeline">// operation, what preceding memory operations it depends on.  It builds on</td>
    <td class="lineNumber">10</td>
    <td class="codeline">// operation, what preceding memory operations it depends on.  It builds on</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="codeline">// alias analysis information, and tries to provide a lazy, caching interface to</td>
    <td class="lineNumber">11</td>
    <td class="codeline">// alias analysis information, and tries to provide a lazy, caching interface to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="codeline">// a common kind of alias information query.</td>
    <td class="lineNumber">12</td>
    <td class="codeline">// a common kind of alias information query.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="codeline">//</td>
    <td class="lineNumber">13</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">14</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="codeline"></td>
    <td class="lineNumber">15</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="codeline">#include "llvm/Analysis/MemoryDependenceAnalysis.h"</td>
    <td class="lineNumber">16</td>
    <td class="codeline">#include "llvm/Analysis/MemoryDependenceAnalysis.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="codeline">#include "llvm/ADT/DenseMap.h"</td>
    <td class="lineNumber">17</td>
    <td class="codeline">#include "llvm/ADT/DenseMap.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="codeline">#include "llvm/ADT/STLExtras.h"</td>
    <td class="lineNumber">18</td>
    <td class="codeline">#include "llvm/ADT/STLExtras.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="codeline">#include "llvm/ADT/SmallPtrSet.h"</td>
    <td class="lineNumber">19</td>
    <td class="codeline">#include "llvm/ADT/SmallPtrSet.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="codeline">#include "llvm/ADT/SmallVector.h"</td>
    <td class="lineNumber">20</td>
    <td class="codeline">#include "llvm/ADT/SmallVector.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="codeline">#include "llvm/ADT/Statistic.h"</td>
    <td class="lineNumber">21</td>
    <td class="codeline">#include "llvm/ADT/Statistic.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="codeline">#include "llvm/Analysis/AliasAnalysis.h"</td>
    <td class="lineNumber">22</td>
    <td class="codeline">#include "llvm/Analysis/AliasAnalysis.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="codeline">#include "llvm/Analysis/AssumptionCache.h"</td>
    <td class="lineNumber">23</td>
    <td class="codeline">#include "llvm/Analysis/AssumptionCache.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="codeline">#include "llvm/Analysis/MemoryBuiltins.h"</td>
    <td class="lineNumber">24</td>
    <td class="codeline">#include "llvm/Analysis/MemoryBuiltins.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="codeline">#include "llvm/Analysis/MemoryLocation.h"</td>
    <td class="lineNumber">25</td>
    <td class="codeline">#include "llvm/Analysis/MemoryLocation.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="codeline">#include "llvm/Analysis/PHITransAddr.h"</td>
    <td class="lineNumber">26</td>
    <td class="codeline">#include "llvm/Analysis/PHITransAddr.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="codeline">#include "llvm/Analysis/TargetLibraryInfo.h"</td>
    <td class="lineNumber">27</td>
    <td class="codeline">#include "llvm/Analysis/TargetLibraryInfo.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="codeline">#include "llvm/Analysis/ValueTracking.h"</td>
    <td class="lineNumber">28</td>
    <td class="codeline">#include "llvm/Analysis/ValueTracking.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="codeline">#include "llvm/IR/BasicBlock.h"</td>
    <td class="lineNumber">29</td>
    <td class="codeline">#include "llvm/IR/BasicBlock.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="codeline">#include "llvm/IR/Dominators.h"</td>
    <td class="lineNumber">30</td>
    <td class="codeline">#include "llvm/IR/Dominators.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="codeline">#include "llvm/IR/Function.h"</td>
    <td class="lineNumber">31</td>
    <td class="codeline">#include "llvm/IR/Function.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="codeline">#include "llvm/IR/InstrTypes.h"</td>
    <td class="lineNumber">32</td>
    <td class="codeline">#include "llvm/IR/InstrTypes.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="codeline">#include "llvm/IR/Instruction.h"</td>
    <td class="lineNumber">33</td>
    <td class="codeline">#include "llvm/IR/Instruction.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="codeline">#include "llvm/IR/Instructions.h"</td>
    <td class="lineNumber">34</td>
    <td class="codeline">#include "llvm/IR/Instructions.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="codeline">#include "llvm/IR/IntrinsicInst.h"</td>
    <td class="lineNumber">35</td>
    <td class="codeline">#include "llvm/IR/IntrinsicInst.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="codeline">#include "llvm/IR/LLVMContext.h"</td>
    <td class="lineNumber">36</td>
    <td class="codeline">#include "llvm/IR/LLVMContext.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="codeline">#include "llvm/IR/Metadata.h"</td>
    <td class="lineNumber">37</td>
    <td class="codeline">#include "llvm/IR/Metadata.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="codeline">#include "llvm/IR/Module.h"</td>
    <td class="lineNumber">38</td>
    <td class="codeline">#include "llvm/IR/Module.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="codeline">#include "llvm/IR/PredIteratorCache.h"</td>
    <td class="lineNumber">39</td>
    <td class="codeline">#include "llvm/IR/PredIteratorCache.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="codeline">#include "llvm/IR/Type.h"</td>
    <td class="lineNumber">40</td>
    <td class="codeline">#include "llvm/IR/Type.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="codeline">#include "llvm/IR/Use.h"</td>
    <td class="lineNumber">41</td>
    <td class="codeline">#include "llvm/IR/Use.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="codeline">#include "llvm/IR/Value.h"</td>
    <td class="lineNumber">42</td>
    <td class="codeline">#include "llvm/IR/Value.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="codeline">#include "llvm/InitializePasses.h"</td>
    <td class="lineNumber">43</td>
    <td class="codeline">#include "llvm/InitializePasses.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="codeline">#include "llvm/Pass.h"</td>
    <td class="lineNumber">44</td>
    <td class="codeline">#include "llvm/Pass.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="codeline">#include "llvm/Support/AtomicOrdering.h"</td>
    <td class="lineNumber">45</td>
    <td class="codeline">#include "llvm/Support/AtomicOrdering.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="codeline">#include "llvm/Support/Casting.h"</td>
    <td class="lineNumber">46</td>
    <td class="codeline">#include "llvm/Support/Casting.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="codeline">#include "llvm/Support/CommandLine.h"</td>
    <td class="lineNumber">47</td>
    <td class="codeline">#include "llvm/Support/CommandLine.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="codeline">#include "llvm/Support/Compiler.h"</td>
    <td class="lineNumber">48</td>
    <td class="codeline">#include "llvm/Support/Compiler.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="codeline">#include "llvm/Support/Debug.h"</td>
    <td class="lineNumber">49</td>
    <td class="codeline">#include "llvm/Support/Debug.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="codeline">#include <algorithm></td>
    <td class="lineNumber">50</td>
    <td class="codeline">#include <algorithm></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="codeline">#include <cassert></td>
    <td class="lineNumber">51</td>
    <td class="codeline">#include <cassert></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="codeline">#include <iterator></td>
    <td class="lineNumber">52</td>
    <td class="codeline">#include <iterator></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="codeline">#include <utility></td>
    <td class="lineNumber">53</td>
    <td class="codeline">#include <utility></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="codeline"></td>
    <td class="lineNumber">54</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="codeline">using namespace llvm;</td>
    <td class="lineNumber">55</td>
    <td class="codeline">using namespace llvm;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="codeline"></td>
    <td class="lineNumber">56</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="codeline">#define DEBUG_TYPE "memdep"</td>
    <td class="lineNumber">57</td>
    <td class="codeline">#define DEBUG_TYPE "memdep"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="codeline"></td>
    <td class="lineNumber">58</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="codeline">STATISTIC(NumCacheNonLocal, "Number of fully cached non-local responses");</td>
    <td class="lineNumber">59</td>
    <td class="codeline">STATISTIC(NumCacheNonLocal, "Number of fully cached non-local responses");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="codeline">STATISTIC(NumCacheDirtyNonLocal, "Number of dirty cached non-local responses");</td>
    <td class="lineNumber">60</td>
    <td class="codeline">STATISTIC(NumCacheDirtyNonLocal, "Number of dirty cached non-local responses");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="codeline">STATISTIC(NumUncacheNonLocal, "Number of uncached non-local responses");</td>
    <td class="lineNumber">61</td>
    <td class="codeline">STATISTIC(NumUncacheNonLocal, "Number of uncached non-local responses");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="codeline"></td>
    <td class="lineNumber">62</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="codeline">STATISTIC(NumCacheNonLocalPtr,</td>
    <td class="lineNumber">63</td>
    <td class="codeline">STATISTIC(NumCacheNonLocalPtr,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="codeline">          "Number of fully cached non-local ptr responses");</td>
    <td class="lineNumber">64</td>
    <td class="codeline">          "Number of fully cached non-local ptr responses");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="codeline">STATISTIC(NumCacheDirtyNonLocalPtr,</td>
    <td class="lineNumber">65</td>
    <td class="codeline">STATISTIC(NumCacheDirtyNonLocalPtr,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="codeline">          "Number of cached, but dirty, non-local ptr responses");</td>
    <td class="lineNumber">66</td>
    <td class="codeline">          "Number of cached, but dirty, non-local ptr responses");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="codeline">STATISTIC(NumUncacheNonLocalPtr, "Number of uncached non-local ptr responses");</td>
    <td class="lineNumber">67</td>
    <td class="codeline">STATISTIC(NumUncacheNonLocalPtr, "Number of uncached non-local ptr responses");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="codeline">STATISTIC(NumCacheCompleteNonLocalPtr,</td>
    <td class="lineNumber">68</td>
    <td class="codeline">STATISTIC(NumCacheCompleteNonLocalPtr,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="codeline">          "Number of block queries that were completely cached");</td>
    <td class="lineNumber">69</td>
    <td class="codeline">          "Number of block queries that were completely cached");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="codeline"></td>
    <td class="lineNumber">70</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="codeline">// Limit for the number of instructions to scan in a block.</td>
    <td class="lineNumber">71</td>
    <td class="codeline">// Limit for the number of instructions to scan in a block.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="codeline"></td>
    <td class="lineNumber">72</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="codeline">static cl::opt<unsigned> BlockScanLimit(</td>
    <td class="lineNumber">73</td>
    <td class="codeline">static cl::opt<unsigned> BlockScanLimit(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="codeline">    "memdep-block-scan-limit", cl::Hidden, cl::init(100),</td>
    <td class="lineNumber">74</td>
    <td class="codeline">    "memdep-block-scan-limit", cl::Hidden, cl::init(100),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="codeline">    cl::desc("The number of instructions to scan in a block in memory "</td>
    <td class="lineNumber">75</td>
    <td class="codeline">    cl::desc("The number of instructions to scan in a block in memory "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="codeline">             "dependency analysis (default = 100)"));</td>
    <td class="lineNumber">76</td>
    <td class="codeline">             "dependency analysis (default = 100)"));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="codeline"></td>
    <td class="lineNumber">77</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="codeline">static cl::opt<unsigned></td>
    <td class="lineNumber">78</td>
    <td class="codeline">static cl::opt<unsigned></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="codeline">    BlockNumberLimit("memdep-block-number-limit", cl::Hidden, cl::init(200),</td>
    <td class="lineNumber">79</td>
    <td class="codeline">    BlockNumberLimit("memdep-block-number-limit", cl::Hidden, cl::init(200),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="codeline">                     cl::desc("The number of blocks to scan during memory "</td>
    <td class="lineNumber">80</td>
    <td class="codeline">                     cl::desc("The number of blocks to scan during memory "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="codeline">                              "dependency analysis (default = 200)"));</td>
    <td class="lineNumber">81</td>
    <td class="codeline">                              "dependency analysis (default = 200)"));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="codeline"></td>
    <td class="lineNumber">82</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="codeline">// Limit on the number of memdep results to process.</td>
    <td class="lineNumber">83</td>
    <td class="codeline">// Limit on the number of memdep results to process.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="codeline">static const unsigned int NumResultsLimit = 100;</td>
    <td class="lineNumber">84</td>
    <td class="codeline">static const unsigned int NumResultsLimit = 100;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="codeline"></td>
    <td class="lineNumber">85</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="codeline">/// This is a helper function that removes Val from 'Inst's set in ReverseMap.</td>
    <td class="lineNumber">86</td>
    <td class="codeline">/// This is a helper function that removes Val from 'Inst's set in ReverseMap.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="codeline">///</td>
    <td class="lineNumber">87</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="codeline">/// If the set becomes empty, remove Inst's entry.</td>
    <td class="lineNumber">88</td>
    <td class="codeline">/// If the set becomes empty, remove Inst's entry.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="codeline">template <typename KeyTy></td>
    <td class="lineNumber">89</td>
    <td class="codeline">template <typename KeyTy></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="codeline">static void</td>
    <td class="lineNumber">90</td>
    <td class="codeline">static void</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="codeline">RemoveFromReverseMap(DenseMap<Instruction *, SmallPtrSet<KeyTy, 4>> &ReverseMap,</td>
    <td class="lineNumber">91</td>
    <td class="codeline">RemoveFromReverseMap(DenseMap<Instruction *, SmallPtrSet<KeyTy, 4>> &ReverseMap,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="codeline">                     Instruction *Inst, KeyTy Val) {</td>
    <td class="lineNumber">92</td>
    <td class="codeline">                     Instruction *Inst, KeyTy Val) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="codeline">  typename DenseMap<Instruction *, SmallPtrSet<KeyTy, 4>>::iterator InstIt =</td>
    <td class="lineNumber">93</td>
    <td class="codeline">  typename DenseMap<Instruction *, SmallPtrSet<KeyTy, 4>>::iterator InstIt =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="codeline">      ReverseMap.find(Inst);</td>
    <td class="lineNumber">94</td>
    <td class="codeline">      ReverseMap.find(Inst);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="codeline">  assert(InstIt != ReverseMap.end() && "Reverse map out of sync?");</td>
    <td class="lineNumber">95</td>
    <td class="codeline">  assert(InstIt != ReverseMap.end() && "Reverse map out of sync?");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="codeline">  bool Found = InstIt->second.erase(Val);</td>
    <td class="lineNumber">96</td>
    <td class="codeline">  bool Found = InstIt->second.erase(Val);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="codeline">  assert(Found && "Invalid reverse map!");</td>
    <td class="lineNumber">97</td>
    <td class="codeline">  assert(Found && "Invalid reverse map!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="codeline">  (void)Found;</td>
    <td class="lineNumber">98</td>
    <td class="codeline">  (void)Found;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="codeline">  if (InstIt->second.empty())</td>
    <td class="lineNumber">99</td>
    <td class="codeline">  if (InstIt->second.empty())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="codeline">    ReverseMap.erase(InstIt);</td>
    <td class="lineNumber">100</td>
    <td class="codeline">    ReverseMap.erase(InstIt);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="codeline">}</td>
    <td class="lineNumber">101</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="codeline"></td>
    <td class="lineNumber">102</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="codeline">/// If the given instruction references a specific memory location, fill in Loc</td>
    <td class="lineNumber">103</td>
    <td class="codeline">/// If the given instruction references a specific memory location, fill in Loc</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="codeline">/// with the details, otherwise set Loc.Ptr to null.</td>
    <td class="lineNumber">104</td>
    <td class="codeline">/// with the details, otherwise set Loc.Ptr to null.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="codeline">///</td>
    <td class="lineNumber">105</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="codeline">/// Returns a ModRefInfo value describing the general behavior of the</td>
    <td class="lineNumber">106</td>
    <td class="codeline">/// Returns a ModRefInfo value describing the general behavior of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="codeline">/// instruction.</td>
    <td class="lineNumber">107</td>
    <td class="codeline">/// instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="codeline">static ModRefInfo GetLocation(const Instruction *Inst, MemoryLocation &Loc,</td>
    <td class="lineNumber">108</td>
    <td class="codeline">static ModRefInfo GetLocation(const Instruction *Inst, MemoryLocation &Loc,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="codeline">                              const TargetLibraryInfo &TLI) {</td>
    <td class="lineNumber">109</td>
    <td class="codeline">                              const TargetLibraryInfo &TLI) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="codeline">  if (const LoadInst *LI = dyn_cast<LoadInst>(Inst)) {</td>
    <td class="lineNumber">110</td>
    <td class="codeline">  if (const LoadInst *LI = dyn_cast<LoadInst>(Inst)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="codeline">    if (LI->isUnordered()) {</td>
    <td class="lineNumber">111</td>
    <td class="codeline">    if (LI->isUnordered()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="codeline">      Loc = MemoryLocation::get(LI);</td>
    <td class="lineNumber">112</td>
    <td class="codeline">      Loc = MemoryLocation::get(LI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="codeline">      return ModRefInfo::Ref;</td>
    <td class="lineNumber">113</td>
    <td class="codeline">      return ModRefInfo::Ref;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">114</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="codeline">    if (LI->getOrdering() == AtomicOrdering::Monotonic) {</td>
    <td class="lineNumber">115</td>
    <td class="codeline">    if (LI->getOrdering() == AtomicOrdering::Monotonic) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="codeline">      Loc = MemoryLocation::get(LI);</td>
    <td class="lineNumber">116</td>
    <td class="codeline">      Loc = MemoryLocation::get(LI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="codeline">      return ModRefInfo::ModRef;</td>
    <td class="lineNumber">117</td>
    <td class="codeline">      return ModRefInfo::ModRef;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">118</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="codeline">    Loc = MemoryLocation();</td>
    <td class="lineNumber">119</td>
    <td class="codeline">    Loc = MemoryLocation();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="codeline">    return ModRefInfo::ModRef;</td>
    <td class="lineNumber">120</td>
    <td class="codeline">    return ModRefInfo::ModRef;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">121</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="codeline"></td>
    <td class="lineNumber">122</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="codeline">  if (const StoreInst *SI = dyn_cast<StoreInst>(Inst)) {</td>
    <td class="lineNumber">123</td>
    <td class="codeline">  if (const StoreInst *SI = dyn_cast<StoreInst>(Inst)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="codeline">    if (SI->isUnordered()) {</td>
    <td class="lineNumber">124</td>
    <td class="codeline">    if (SI->isUnordered()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="codeline">      Loc = MemoryLocation::get(SI);</td>
    <td class="lineNumber">125</td>
    <td class="codeline">      Loc = MemoryLocation::get(SI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="codeline">      return ModRefInfo::Mod;</td>
    <td class="lineNumber">126</td>
    <td class="codeline">      return ModRefInfo::Mod;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">127</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="codeline">    if (SI->getOrdering() == AtomicOrdering::Monotonic) {</td>
    <td class="lineNumber">128</td>
    <td class="codeline">    if (SI->getOrdering() == AtomicOrdering::Monotonic) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="codeline">      Loc = MemoryLocation::get(SI);</td>
    <td class="lineNumber">129</td>
    <td class="codeline">      Loc = MemoryLocation::get(SI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="codeline">      return ModRefInfo::ModRef;</td>
    <td class="lineNumber">130</td>
    <td class="codeline">      return ModRefInfo::ModRef;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">131</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="codeline">    Loc = MemoryLocation();</td>
    <td class="lineNumber">132</td>
    <td class="codeline">    Loc = MemoryLocation();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="codeline">    return ModRefInfo::ModRef;</td>
    <td class="lineNumber">133</td>
    <td class="codeline">    return ModRefInfo::ModRef;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">134</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="codeline"></td>
    <td class="lineNumber">135</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="codeline">  if (const VAArgInst *V = dyn_cast<VAArgInst>(Inst)) {</td>
    <td class="lineNumber">136</td>
    <td class="codeline">  if (const VAArgInst *V = dyn_cast<VAArgInst>(Inst)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="codeline">    Loc = MemoryLocation::get(V);</td>
    <td class="lineNumber">137</td>
    <td class="codeline">    Loc = MemoryLocation::get(V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="codeline">    return ModRefInfo::ModRef;</td>
    <td class="lineNumber">138</td>
    <td class="codeline">    return ModRefInfo::ModRef;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">139</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="codeline"></td>
    <td class="lineNumber">140</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="codeline">  if (const CallBase *CB = dyn_cast<CallBase>(Inst)) {</td>
    <td class="lineNumber">141</td>
    <td class="codeline">  if (const CallBase *CB = dyn_cast<CallBase>(Inst)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="codeline">    if (Value *FreedOp = getFreedOperand(CB, &TLI)) {</td>
    <td class="lineNumber">142</td>
    <td class="codeline">    if (Value *FreedOp = getFreedOperand(CB, &TLI)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="codeline">      // calls to free() deallocate the entire structure</td>
    <td class="lineNumber">143</td>
    <td class="codeline">      // calls to free() deallocate the entire structure</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="codeline">      Loc = MemoryLocation::getAfter(FreedOp);</td>
    <td class="lineNumber">144</td>
    <td class="codeline">      Loc = MemoryLocation::getAfter(FreedOp);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="codeline">      return ModRefInfo::Mod;</td>
    <td class="lineNumber">145</td>
    <td class="codeline">      return ModRefInfo::Mod;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">146</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">147</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="codeline"></td>
    <td class="lineNumber">148</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="codeline">  if (const IntrinsicInst *II = dyn_cast<IntrinsicInst>(Inst)) {</td>
    <td class="lineNumber">149</td>
    <td class="codeline">  if (const IntrinsicInst *II = dyn_cast<IntrinsicInst>(Inst)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="codeline">    switch (II->getIntrinsicID()) {</td>
    <td class="lineNumber">150</td>
    <td class="codeline">    switch (II->getIntrinsicID()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="codeline">    case Intrinsic::lifetime_start:</td>
    <td class="lineNumber">151</td>
    <td class="codeline">    case Intrinsic::lifetime_start:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="codeline">    case Intrinsic::lifetime_end:</td>
    <td class="lineNumber">152</td>
    <td class="codeline">    case Intrinsic::lifetime_end:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="codeline">    case Intrinsic::invariant_start:</td>
    <td class="lineNumber">153</td>
    <td class="codeline">    case Intrinsic::invariant_start:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="codeline">      Loc = MemoryLocation::getForArgument(II, 1, TLI);</td>
    <td class="lineNumber">154</td>
    <td class="codeline">      Loc = MemoryLocation::getForArgument(II, 1, TLI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="codeline">      // These intrinsics don't really modify the memory, but returning Mod</td>
    <td class="lineNumber">155</td>
    <td class="codeline">      // These intrinsics don't really modify the memory, but returning Mod</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="codeline">      // will allow them to be handled conservatively.</td>
    <td class="lineNumber">156</td>
    <td class="codeline">      // will allow them to be handled conservatively.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="codeline">      return ModRefInfo::Mod;</td>
    <td class="lineNumber">157</td>
    <td class="codeline">      return ModRefInfo::Mod;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="codeline">    case Intrinsic::invariant_end:</td>
    <td class="lineNumber">158</td>
    <td class="codeline">    case Intrinsic::invariant_end:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="codeline">      Loc = MemoryLocation::getForArgument(II, 2, TLI);</td>
    <td class="lineNumber">159</td>
    <td class="codeline">      Loc = MemoryLocation::getForArgument(II, 2, TLI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="codeline">      // These intrinsics don't really modify the memory, but returning Mod</td>
    <td class="lineNumber">160</td>
    <td class="codeline">      // These intrinsics don't really modify the memory, but returning Mod</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="codeline">      // will allow them to be handled conservatively.</td>
    <td class="lineNumber">161</td>
    <td class="codeline">      // will allow them to be handled conservatively.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="codeline">      return ModRefInfo::Mod;</td>
    <td class="lineNumber">162</td>
    <td class="codeline">      return ModRefInfo::Mod;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="codeline">    case Intrinsic::masked_load:</td>
    <td class="lineNumber">163</td>
    <td class="codeline">    case Intrinsic::masked_load:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="codeline">      Loc = MemoryLocation::getForArgument(II, 0, TLI);</td>
    <td class="lineNumber">164</td>
    <td class="codeline">      Loc = MemoryLocation::getForArgument(II, 0, TLI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="codeline">      return ModRefInfo::Ref;</td>
    <td class="lineNumber">165</td>
    <td class="codeline">      return ModRefInfo::Ref;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="codeline">    case Intrinsic::masked_store:</td>
    <td class="lineNumber">166</td>
    <td class="codeline">    case Intrinsic::masked_store:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="codeline">      Loc = MemoryLocation::getForArgument(II, 1, TLI);</td>
    <td class="lineNumber">167</td>
    <td class="codeline">      Loc = MemoryLocation::getForArgument(II, 1, TLI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="codeline">      return ModRefInfo::Mod;</td>
    <td class="lineNumber">168</td>
    <td class="codeline">      return ModRefInfo::Mod;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="codeline">    default:</td>
    <td class="lineNumber">169</td>
    <td class="codeline">    default:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">170</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">171</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">172</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="codeline"></td>
    <td class="lineNumber">173</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="codeline">  // Otherwise, just do the coarse-grained thing that always works.</td>
    <td class="lineNumber">174</td>
    <td class="codeline">  // Otherwise, just do the coarse-grained thing that always works.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="codeline">  if (Inst->mayWriteToMemory())</td>
    <td class="lineNumber">175</td>
    <td class="codeline">  if (Inst->mayWriteToMemory())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="codeline">    return ModRefInfo::ModRef;</td>
    <td class="lineNumber">176</td>
    <td class="codeline">    return ModRefInfo::ModRef;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="codeline">  if (Inst->mayReadFromMemory())</td>
    <td class="lineNumber">177</td>
    <td class="codeline">  if (Inst->mayReadFromMemory())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="codeline">    return ModRefInfo::Ref;</td>
    <td class="lineNumber">178</td>
    <td class="codeline">    return ModRefInfo::Ref;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="codeline">  return ModRefInfo::NoModRef;</td>
    <td class="lineNumber">179</td>
    <td class="codeline">  return ModRefInfo::NoModRef;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="codeline">}</td>
    <td class="lineNumber">180</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="codeline"></td>
    <td class="lineNumber">181</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="codeline">/// Private helper for finding the local dependencies of a call site.</td>
    <td class="lineNumber">182</td>
    <td class="codeline">/// Private helper for finding the local dependencies of a call site.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="codeline">MemDepResult MemoryDependenceResults::getCallDependencyFrom(</td>
    <td class="lineNumber">183</td>
    <td class="codeline">MemDepResult MemoryDependenceResults::getCallDependencyFrom(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="codeline">    CallBase *Call, bool isReadOnlyCall, BasicBlock::iterator ScanIt,</td>
    <td class="lineNumber">184</td>
    <td class="codeline">    CallBase *Call, bool isReadOnlyCall, BasicBlock::iterator ScanIt,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="codeline">    BasicBlock *BB) {</td>
    <td class="lineNumber">185</td>
    <td class="codeline">    BasicBlock *BB) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="codeline">  unsigned Limit = getDefaultBlockScanLimit();</td>
    <td class="lineNumber">186</td>
    <td class="codeline">  unsigned Limit = getDefaultBlockScanLimit();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="codeline"></td>
    <td class="lineNumber">187</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="codeline">  // Walk backwards through the block, looking for dependencies.</td>
    <td class="lineNumber">188</td>
    <td class="codeline">  // Walk backwards through the block, looking for dependencies.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="codeline">  while (ScanIt != BB->begin()) {</td>
    <td class="lineNumber">189</td>
    <td class="codeline">  while (ScanIt != BB->begin()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="codeline">    Instruction *Inst = &*--ScanIt;</td>
    <td class="lineNumber">190</td>
    <td class="codeline">    Instruction *Inst = &*--ScanIt;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="codeline">    // Debug intrinsics don't cause dependences and should not affect Limit</td>
    <td class="lineNumber">191</td>
    <td class="codeline">    // Debug intrinsics don't cause dependences and should not affect Limit</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="codeline">    if (isa<DbgInfoIntrinsic>(Inst))</td>
    <td class="lineNumber">192</td>
    <td class="codeline">    if (isa<DbgInfoIntrinsic>(Inst))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">193</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="codeline"></td>
    <td class="lineNumber">194</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="codeline">    // Limit the amount of scanning we do so we don't end up with quadratic</td>
    <td class="lineNumber">195</td>
    <td class="codeline">    // Limit the amount of scanning we do so we don't end up with quadratic</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="codeline">    // running time on extreme testcases.</td>
    <td class="lineNumber">196</td>
    <td class="codeline">    // running time on extreme testcases.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="codeline">    --Limit;</td>
    <td class="lineNumber">197</td>
    <td class="codeline">    --Limit;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="codeline">    if (!Limit)</td>
    <td class="lineNumber">198</td>
    <td class="codeline">    if (!Limit)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="codeline">      return MemDepResult::getUnknown();</td>
    <td class="lineNumber">199</td>
    <td class="codeline">      return MemDepResult::getUnknown();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="codeline"></td>
    <td class="lineNumber">200</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="codeline">    // If this inst is a memory op, get the pointer it accessed</td>
    <td class="lineNumber">201</td>
    <td class="codeline">    // If this inst is a memory op, get the pointer it accessed</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="codeline">    MemoryLocation Loc;</td>
    <td class="lineNumber">202</td>
    <td class="codeline">    MemoryLocation Loc;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="codeline">    ModRefInfo MR = GetLocation(Inst, Loc, TLI);</td>
    <td class="lineNumber">203</td>
    <td class="codeline">    ModRefInfo MR = GetLocation(Inst, Loc, TLI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="codeline">    if (Loc.Ptr) {</td>
    <td class="lineNumber">204</td>
    <td class="codeline">    if (Loc.Ptr) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="codeline">      // A simple instruction.</td>
    <td class="lineNumber">205</td>
    <td class="codeline">      // A simple instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="codeline">      if (isModOrRefSet(AA.getModRefInfo(Call, Loc)))</td>
    <td class="lineNumber">206</td>
    <td class="codeline">      if (isModOrRefSet(AA.getModRefInfo(Call, Loc)))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="codeline">        return MemDepResult::getClobber(Inst);</td>
    <td class="lineNumber">207</td>
    <td class="codeline">        return MemDepResult::getClobber(Inst);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">208</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">209</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="codeline"></td>
    <td class="lineNumber">210</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="codeline">    if (auto *CallB = dyn_cast<CallBase>(Inst)) {</td>
    <td class="lineNumber">211</td>
    <td class="codeline">    if (auto *CallB = dyn_cast<CallBase>(Inst)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="codeline">      // If these two calls do not interfere, look past it.</td>
    <td class="lineNumber">212</td>
    <td class="codeline">      // If these two calls do not interfere, look past it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="codeline">      if (isNoModRef(AA.getModRefInfo(Call, CallB))) {</td>
    <td class="lineNumber">213</td>
    <td class="codeline">      if (isNoModRef(AA.getModRefInfo(Call, CallB))) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="codeline">        // If the two calls are the same, return Inst as a Def, so that</td>
    <td class="lineNumber">214</td>
    <td class="codeline">        // If the two calls are the same, return Inst as a Def, so that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="codeline">        // Call can be found redundant and eliminated.</td>
    <td class="lineNumber">215</td>
    <td class="codeline">        // Call can be found redundant and eliminated.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="codeline">        if (isReadOnlyCall && !isModSet(MR) &&</td>
    <td class="lineNumber">216</td>
    <td class="codeline">        if (isReadOnlyCall && !isModSet(MR) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="codeline">            Call->isIdenticalToWhenDefined(CallB))</td>
    <td class="lineNumber">217</td>
    <td class="codeline">            Call->isIdenticalToWhenDefined(CallB))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="codeline">          return MemDepResult::getDef(Inst);</td>
    <td class="lineNumber">218</td>
    <td class="codeline">          return MemDepResult::getDef(Inst);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="codeline"></td>
    <td class="lineNumber">219</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="codeline">        // Otherwise if the two calls don't interact (e.g. CallB is readnone)</td>
    <td class="lineNumber">220</td>
    <td class="codeline">        // Otherwise if the two calls don't interact (e.g. CallB is readnone)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="codeline">        // keep scanning.</td>
    <td class="lineNumber">221</td>
    <td class="codeline">        // keep scanning.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">222</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="codeline">      } else</td>
    <td class="lineNumber">223</td>
    <td class="codeline">      } else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="codeline">        return MemDepResult::getClobber(Inst);</td>
    <td class="lineNumber">224</td>
    <td class="codeline">        return MemDepResult::getClobber(Inst);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">225</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="codeline"></td>
    <td class="lineNumber">226</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="codeline">    // If we could not obtain a pointer for the instruction and the instruction</td>
    <td class="lineNumber">227</td>
    <td class="codeline">    // If we could not obtain a pointer for the instruction and the instruction</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="codeline">    // touches memory then assume that this is a dependency.</td>
    <td class="lineNumber">228</td>
    <td class="codeline">    // touches memory then assume that this is a dependency.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="codeline">    if (isModOrRefSet(MR))</td>
    <td class="lineNumber">229</td>
    <td class="codeline">    if (isModOrRefSet(MR))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="codeline">      return MemDepResult::getClobber(Inst);</td>
    <td class="lineNumber">230</td>
    <td class="codeline">      return MemDepResult::getClobber(Inst);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">231</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="codeline"></td>
    <td class="lineNumber">232</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="codeline">  // No dependence found.  If this is the entry block of the function, it is</td>
    <td class="lineNumber">233</td>
    <td class="codeline">  // No dependence found.  If this is the entry block of the function, it is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="codeline">  // unknown, otherwise it is non-local.</td>
    <td class="lineNumber">234</td>
    <td class="codeline">  // unknown, otherwise it is non-local.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="codeline">  if (BB != &BB->getParent()->getEntryBlock())</td>
    <td class="lineNumber">235</td>
    <td class="codeline">  if (BB != &BB->getParent()->getEntryBlock())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="codeline">    return MemDepResult::getNonLocal();</td>
    <td class="lineNumber">236</td>
    <td class="codeline">    return MemDepResult::getNonLocal();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="codeline">  return MemDepResult::getNonFuncLocal();</td>
    <td class="lineNumber">237</td>
    <td class="codeline">  return MemDepResult::getNonFuncLocal();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="codeline">}</td>
    <td class="lineNumber">238</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="codeline"></td>
    <td class="lineNumber">239</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="codeline">MemDepResult MemoryDependenceResults::getPointerDependencyFrom(</td>
    <td class="lineNumber">240</td>
    <td class="codeline">MemDepResult MemoryDependenceResults::getPointerDependencyFrom(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="codeline">    const MemoryLocation &MemLoc, bool isLoad, BasicBlock::iterator ScanIt,</td>
    <td class="lineNumber">241</td>
    <td class="codeline">    const MemoryLocation &MemLoc, bool isLoad, BasicBlock::iterator ScanIt,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="codeline">    BasicBlock *BB, Instruction *QueryInst, unsigned *Limit,</td>
    <td class="lineNumber">242</td>
    <td class="codeline">    BasicBlock *BB, Instruction *QueryInst, unsigned *Limit,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="codeline">    BatchAAResults &BatchAA) {</td>
    <td class="lineNumber">243</td>
    <td class="codeline">    BatchAAResults &BatchAA) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="codeline">  MemDepResult InvariantGroupDependency = MemDepResult::getUnknown();</td>
    <td class="lineNumber">244</td>
    <td class="codeline">  MemDepResult InvariantGroupDependency = MemDepResult::getUnknown();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="codeline">  if (QueryInst != nullptr) {</td>
    <td class="lineNumber">245</td>
    <td class="codeline">  if (QueryInst != nullptr) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="codeline">    if (auto *LI = dyn_cast<LoadInst>(QueryInst)) {</td>
    <td class="lineNumber">246</td>
    <td class="codeline">    if (auto *LI = dyn_cast<LoadInst>(QueryInst)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="codeline">      InvariantGroupDependency = getInvariantGroupPointerDependency(LI, BB);</td>
    <td class="lineNumber">247</td>
    <td class="codeline">      InvariantGroupDependency = getInvariantGroupPointerDependency(LI, BB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="codeline"></td>
    <td class="lineNumber">248</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="codeline">      if (InvariantGroupDependency.isDef())</td>
    <td class="lineNumber">249</td>
    <td class="codeline">      if (InvariantGroupDependency.isDef())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="codeline">        return InvariantGroupDependency;</td>
    <td class="lineNumber">250</td>
    <td class="codeline">        return InvariantGroupDependency;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">251</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">252</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="codeline">  MemDepResult SimpleDep = getSimplePointerDependencyFrom(</td>
    <td class="lineNumber">253</td>
    <td class="codeline">  MemDepResult SimpleDep = getSimplePointerDependencyFrom(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="codeline">      MemLoc, isLoad, ScanIt, BB, QueryInst, Limit, BatchAA);</td>
    <td class="lineNumber">254</td>
    <td class="codeline">      MemLoc, isLoad, ScanIt, BB, QueryInst, Limit, BatchAA);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="codeline">  if (SimpleDep.isDef())</td>
    <td class="lineNumber">255</td>
    <td class="codeline">  if (SimpleDep.isDef())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="codeline">    return SimpleDep;</td>
    <td class="lineNumber">256</td>
    <td class="codeline">    return SimpleDep;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="codeline">  // Non-local invariant group dependency indicates there is non local Def</td>
    <td class="lineNumber">257</td>
    <td class="codeline">  // Non-local invariant group dependency indicates there is non local Def</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="codeline">  // (it only returns nonLocal if it finds nonLocal def), which is better than</td>
    <td class="lineNumber">258</td>
    <td class="codeline">  // (it only returns nonLocal if it finds nonLocal def), which is better than</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="codeline">  // local clobber and everything else.</td>
    <td class="lineNumber">259</td>
    <td class="codeline">  // local clobber and everything else.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="codeline">  if (InvariantGroupDependency.isNonLocal())</td>
    <td class="lineNumber">260</td>
    <td class="codeline">  if (InvariantGroupDependency.isNonLocal())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="codeline">    return InvariantGroupDependency;</td>
    <td class="lineNumber">261</td>
    <td class="codeline">    return InvariantGroupDependency;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="codeline"></td>
    <td class="lineNumber">262</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="codeline">  assert(InvariantGroupDependency.isUnknown() &&</td>
    <td class="lineNumber">263</td>
    <td class="codeline">  assert(InvariantGroupDependency.isUnknown() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="codeline">         "InvariantGroupDependency should be only unknown at this point");</td>
    <td class="lineNumber">264</td>
    <td class="codeline">         "InvariantGroupDependency should be only unknown at this point");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="codeline">  return SimpleDep;</td>
    <td class="lineNumber">265</td>
    <td class="codeline">  return SimpleDep;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="codeline">}</td>
    <td class="lineNumber">266</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="codeline"></td>
    <td class="lineNumber">267</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="codeline">MemDepResult MemoryDependenceResults::getPointerDependencyFrom(</td>
    <td class="lineNumber">268</td>
    <td class="codeline">MemDepResult MemoryDependenceResults::getPointerDependencyFrom(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="codeline">    const MemoryLocation &MemLoc, bool isLoad, BasicBlock::iterator ScanIt,</td>
    <td class="lineNumber">269</td>
    <td class="codeline">    const MemoryLocation &MemLoc, bool isLoad, BasicBlock::iterator ScanIt,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="codeline">    BasicBlock *BB, Instruction *QueryInst, unsigned *Limit) {</td>
    <td class="lineNumber">270</td>
    <td class="codeline">    BasicBlock *BB, Instruction *QueryInst, unsigned *Limit) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="codeline">  BatchAAResults BatchAA(AA);</td>
    <td class="lineNumber">271</td>
    <td class="codeline">  BatchAAResults BatchAA(AA);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="codeline">  return getPointerDependencyFrom(MemLoc, isLoad, ScanIt, BB, QueryInst, Limit,</td>
    <td class="lineNumber">272</td>
    <td class="codeline">  return getPointerDependencyFrom(MemLoc, isLoad, ScanIt, BB, QueryInst, Limit,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="codeline">                                  BatchAA);</td>
    <td class="lineNumber">273</td>
    <td class="codeline">                                  BatchAA);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="codeline">}</td>
    <td class="lineNumber">274</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="codeline"></td>
    <td class="lineNumber">275</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="codeline">MemDepResult</td>
    <td class="lineNumber">276</td>
    <td class="codeline">MemDepResult</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="codeline">MemoryDependenceResults::getInvariantGroupPointerDependency(LoadInst *LI,</td>
    <td class="lineNumber">277</td>
    <td class="codeline">MemoryDependenceResults::getInvariantGroupPointerDependency(LoadInst *LI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="codeline">                                                            BasicBlock *BB) {</td>
    <td class="lineNumber">278</td>
    <td class="codeline">                                                            BasicBlock *BB) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="codeline"></td>
    <td class="lineNumber">279</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="codeline">  if (!LI->hasMetadata(LLVMContext::MD_invariant_group))</td>
    <td class="lineNumber">280</td>
    <td class="codeline">  if (!LI->hasMetadata(LLVMContext::MD_invariant_group))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="codeline">    return MemDepResult::getUnknown();</td>
    <td class="lineNumber">281</td>
    <td class="codeline">    return MemDepResult::getUnknown();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="codeline"></td>
    <td class="lineNumber">282</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="codeline">  // Take the ptr operand after all casts and geps 0. This way we can search</td>
    <td class="lineNumber">283</td>
    <td class="codeline">  // Take the ptr operand after all casts and geps 0. This way we can search</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="codeline">  // cast graph down only.</td>
    <td class="lineNumber">284</td>
    <td class="codeline">  // cast graph down only.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="codeline">  Value *LoadOperand = LI->getPointerOperand()->stripPointerCasts();</td>
    <td class="lineNumber">285</td>
    <td class="codeline">  Value *LoadOperand = LI->getPointerOperand()->stripPointerCasts();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="codeline"></td>
    <td class="lineNumber">286</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="codeline">  // It's is not safe to walk the use list of global value, because function</td>
    <td class="lineNumber">287</td>
    <td class="codeline">  // It's is not safe to walk the use list of global value, because function</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="codeline">  // passes aren't allowed to look outside their functions.</td>
    <td class="lineNumber">288</td>
    <td class="codeline">  // passes aren't allowed to look outside their functions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="codeline">  // FIXME: this could be fixed by filtering instructions from outside</td>
    <td class="lineNumber">289</td>
    <td class="codeline">  // FIXME: this could be fixed by filtering instructions from outside</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="codeline">  // of current function.</td>
    <td class="lineNumber">290</td>
    <td class="codeline">  // of current function.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="codeline">  if (isa<GlobalValue>(LoadOperand))</td>
    <td class="lineNumber">291</td>
    <td class="codeline">  if (isa<GlobalValue>(LoadOperand))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="codeline">    return MemDepResult::getUnknown();</td>
    <td class="lineNumber">292</td>
    <td class="codeline">    return MemDepResult::getUnknown();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="codeline"></td>
    <td class="lineNumber">293</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="codeline">  // Queue to process all pointers that are equivalent to load operand.</td>
    <td class="lineNumber">294</td>
    <td class="codeline">  // Queue to process all pointers that are equivalent to load operand.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="codeline">  SmallVector<const Value *, 8> LoadOperandsQueue;</td>
    <td class="lineNumber">295</td>
    <td class="codeline">  SmallVector<const Value *, 8> LoadOperandsQueue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="codeline">  LoadOperandsQueue.push_back(LoadOperand);</td>
    <td class="lineNumber">296</td>
    <td class="codeline">  LoadOperandsQueue.push_back(LoadOperand);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="codeline"></td>
    <td class="lineNumber">297</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="codeline">  Instruction *ClosestDependency = nullptr;</td>
    <td class="lineNumber">298</td>
    <td class="codeline">  Instruction *ClosestDependency = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="codeline">  // Order of instructions in uses list is unpredictible. In order to always</td>
    <td class="lineNumber">299</td>
    <td class="codeline">  // Order of instructions in uses list is unpredictible. In order to always</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="codeline">  // get the same result, we will look for the closest dominance.</td>
    <td class="lineNumber">300</td>
    <td class="codeline">  // get the same result, we will look for the closest dominance.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="codeline">  auto GetClosestDependency = [this](Instruction *Best, Instruction *Other) {</td>
    <td class="lineNumber">301</td>
    <td class="codeline">  auto GetClosestDependency = [this](Instruction *Best, Instruction *Other) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="codeline">    assert(Other && "Must call it with not null instruction");</td>
    <td class="lineNumber">302</td>
    <td class="codeline">    assert(Other && "Must call it with not null instruction");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="codeline">    if (Best == nullptr || DT.dominates(Best, Other))</td>
    <td class="lineNumber">303</td>
    <td class="codeline">    if (Best == nullptr || DT.dominates(Best, Other))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="codeline">      return Other;</td>
    <td class="lineNumber">304</td>
    <td class="codeline">      return Other;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="codeline">    return Best;</td>
    <td class="lineNumber">305</td>
    <td class="codeline">    return Best;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">306</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="codeline"></td>
    <td class="lineNumber">307</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="codeline">  // FIXME: This loop is O(N^2) because dominates can be O(n) and in worst case</td>
    <td class="lineNumber">308</td>
    <td class="codeline">  // FIXME: This loop is O(N^2) because dominates can be O(n) and in worst case</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="codeline">  // we will see all the instructions. This should be fixed in MSSA.</td>
    <td class="lineNumber">309</td>
    <td class="codeline">  // we will see all the instructions. This should be fixed in MSSA.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="codeline">  while (!LoadOperandsQueue.empty()) {</td>
    <td class="lineNumber">310</td>
    <td class="codeline">  while (!LoadOperandsQueue.empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="codeline">    const Value *Ptr = LoadOperandsQueue.pop_back_val();</td>
    <td class="lineNumber">311</td>
    <td class="codeline">    const Value *Ptr = LoadOperandsQueue.pop_back_val();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="codeline">    assert(Ptr && !isa<GlobalValue>(Ptr) &&</td>
    <td class="lineNumber">312</td>
    <td class="codeline">    assert(Ptr && !isa<GlobalValue>(Ptr) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="codeline">           "Null or GlobalValue should not be inserted");</td>
    <td class="lineNumber">313</td>
    <td class="codeline">           "Null or GlobalValue should not be inserted");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="codeline"></td>
    <td class="lineNumber">314</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="codeline">    for (const Use &Us : Ptr->uses()) {</td>
    <td class="lineNumber">315</td>
    <td class="codeline">    for (const Use &Us : Ptr->uses()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="codeline">      auto *U = dyn_cast<Instruction>(Us.getUser());</td>
    <td class="lineNumber">316</td>
    <td class="codeline">      auto *U = dyn_cast<Instruction>(Us.getUser());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="codeline">      if (!U || U == LI || !DT.dominates(U, LI))</td>
    <td class="lineNumber">317</td>
    <td class="codeline">      if (!U || U == LI || !DT.dominates(U, LI))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">318</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="codeline"></td>
    <td class="lineNumber">319</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="codeline">      // Bitcast or gep with zeros are using Ptr. Add to queue to check it's</td>
    <td class="lineNumber">320</td>
    <td class="codeline">      // Bitcast or gep with zeros are using Ptr. Add to queue to check it's</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="codeline">      // users.      U = bitcast Ptr</td>
    <td class="lineNumber">321</td>
    <td class="codeline">      // users.      U = bitcast Ptr</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="codeline">      if (isa<BitCastInst>(U)) {</td>
    <td class="lineNumber">322</td>
    <td class="codeline">      if (isa<BitCastInst>(U)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="codeline">        LoadOperandsQueue.push_back(U);</td>
    <td class="lineNumber">323</td>
    <td class="codeline">        LoadOperandsQueue.push_back(U);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">324</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">325</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="codeline">      // Gep with zeros is equivalent to bitcast.</td>
    <td class="lineNumber">326</td>
    <td class="codeline">      // Gep with zeros is equivalent to bitcast.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="codeline">      // FIXME: we are not sure if some bitcast should be canonicalized to gep 0</td>
    <td class="lineNumber">327</td>
    <td class="codeline">      // FIXME: we are not sure if some bitcast should be canonicalized to gep 0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="codeline">      // or gep 0 to bitcast because of SROA, so there are 2 forms. When</td>
    <td class="lineNumber">328</td>
    <td class="codeline">      // or gep 0 to bitcast because of SROA, so there are 2 forms. When</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="codeline">      // typeless pointers will be ready then both cases will be gone</td>
    <td class="lineNumber">329</td>
    <td class="codeline">      // typeless pointers will be ready then both cases will be gone</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="codeline">      // (and this BFS also won't be needed).</td>
    <td class="lineNumber">330</td>
    <td class="codeline">      // (and this BFS also won't be needed).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="codeline">      if (auto *GEP = dyn_cast<GetElementPtrInst>(U))</td>
    <td class="lineNumber">331</td>
    <td class="codeline">      if (auto *GEP = dyn_cast<GetElementPtrInst>(U))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="codeline">        if (GEP->hasAllZeroIndices()) {</td>
    <td class="lineNumber">332</td>
    <td class="codeline">        if (GEP->hasAllZeroIndices()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="codeline">          LoadOperandsQueue.push_back(U);</td>
    <td class="lineNumber">333</td>
    <td class="codeline">          LoadOperandsQueue.push_back(U);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="codeline">          continue;</td>
    <td class="lineNumber">334</td>
    <td class="codeline">          continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">335</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="codeline"></td>
    <td class="lineNumber">336</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="codeline">      // If we hit load/store with the same invariant.group metadata (and the</td>
    <td class="lineNumber">337</td>
    <td class="codeline">      // If we hit load/store with the same invariant.group metadata (and the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="codeline">      // same pointer operand) we can assume that value pointed by pointer</td>
    <td class="lineNumber">338</td>
    <td class="codeline">      // same pointer operand) we can assume that value pointed by pointer</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="codeline">      // operand didn't change.</td>
    <td class="lineNumber">339</td>
    <td class="codeline">      // operand didn't change.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="codeline">      if ((isa<LoadInst>(U) ||</td>
    <td class="lineNumber">340</td>
    <td class="codeline">      if ((isa<LoadInst>(U) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="codeline">           (isa<StoreInst>(U) &&</td>
    <td class="lineNumber">341</td>
    <td class="codeline">           (isa<StoreInst>(U) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="codeline">            cast<StoreInst>(U)->getPointerOperand() == Ptr)) &&</td>
    <td class="lineNumber">342</td>
    <td class="codeline">            cast<StoreInst>(U)->getPointerOperand() == Ptr)) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="codeline">          U->hasMetadata(LLVMContext::MD_invariant_group))</td>
    <td class="lineNumber">343</td>
    <td class="codeline">          U->hasMetadata(LLVMContext::MD_invariant_group))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="codeline">        ClosestDependency = GetClosestDependency(ClosestDependency, U);</td>
    <td class="lineNumber">344</td>
    <td class="codeline">        ClosestDependency = GetClosestDependency(ClosestDependency, U);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">345</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">346</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="codeline"></td>
    <td class="lineNumber">347</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="codeline">  if (!ClosestDependency)</td>
    <td class="lineNumber">348</td>
    <td class="codeline">  if (!ClosestDependency)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="codeline">    return MemDepResult::getUnknown();</td>
    <td class="lineNumber">349</td>
    <td class="codeline">    return MemDepResult::getUnknown();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="codeline">  if (ClosestDependency->getParent() == BB)</td>
    <td class="lineNumber">350</td>
    <td class="codeline">  if (ClosestDependency->getParent() == BB)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="codeline">    return MemDepResult::getDef(ClosestDependency);</td>
    <td class="lineNumber">351</td>
    <td class="codeline">    return MemDepResult::getDef(ClosestDependency);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="codeline">  // Def(U) can't be returned here because it is non-local. If local</td>
    <td class="lineNumber">352</td>
    <td class="codeline">  // Def(U) can't be returned here because it is non-local. If local</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="codeline">  // dependency won't be found then return nonLocal counting that the</td>
    <td class="lineNumber">353</td>
    <td class="codeline">  // dependency won't be found then return nonLocal counting that the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="codeline">  // user will call getNonLocalPointerDependency, which will return cached</td>
    <td class="lineNumber">354</td>
    <td class="codeline">  // user will call getNonLocalPointerDependency, which will return cached</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="codeline">  // result.</td>
    <td class="lineNumber">355</td>
    <td class="codeline">  // result.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="codeline">  NonLocalDefsCache.try_emplace(</td>
    <td class="lineNumber">356</td>
    <td class="codeline">  NonLocalDefsCache.try_emplace(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="codeline">      LI, NonLocalDepResult(ClosestDependency->getParent(),</td>
    <td class="lineNumber">357</td>
    <td class="codeline">      LI, NonLocalDepResult(ClosestDependency->getParent(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="codeline">                            MemDepResult::getDef(ClosestDependency), nullptr));</td>
    <td class="lineNumber">358</td>
    <td class="codeline">                            MemDepResult::getDef(ClosestDependency), nullptr));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="codeline">  ReverseNonLocalDefsCache[ClosestDependency].insert(LI);</td>
    <td class="lineNumber">359</td>
    <td class="codeline">  ReverseNonLocalDefsCache[ClosestDependency].insert(LI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="codeline">  return MemDepResult::getNonLocal();</td>
    <td class="lineNumber">360</td>
    <td class="codeline">  return MemDepResult::getNonLocal();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="codeline">}</td>
    <td class="lineNumber">361</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="codeline"></td>
    <td class="lineNumber">362</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="codeline">MemDepResult MemoryDependenceResults::getSimplePointerDependencyFrom(</td>
    <td class="lineNumber">363</td>
    <td class="codeline">MemDepResult MemoryDependenceResults::getSimplePointerDependencyFrom(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="codeline">    const MemoryLocation &MemLoc, bool isLoad, BasicBlock::iterator ScanIt,</td>
    <td class="lineNumber">364</td>
    <td class="codeline">    const MemoryLocation &MemLoc, bool isLoad, BasicBlock::iterator ScanIt,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="codeline">    BasicBlock *BB, Instruction *QueryInst, unsigned *Limit,</td>
    <td class="lineNumber">365</td>
    <td class="codeline">    BasicBlock *BB, Instruction *QueryInst, unsigned *Limit,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="codeline">    BatchAAResults &BatchAA) {</td>
    <td class="lineNumber">366</td>
    <td class="codeline">    BatchAAResults &BatchAA) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="codeline">  bool isInvariantLoad = false;</td>
    <td class="lineNumber">367</td>
    <td class="codeline">  bool isInvariantLoad = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="codeline"></td>
    <td class="lineNumber">368</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="codeline">  unsigned DefaultLimit = getDefaultBlockScanLimit();</td>
    <td class="lineNumber">369</td>
    <td class="codeline">  unsigned DefaultLimit = getDefaultBlockScanLimit();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="codeline">  if (!Limit)</td>
    <td class="lineNumber">370</td>
    <td class="codeline">  if (!Limit)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="codeline">    Limit = &DefaultLimit;</td>
    <td class="lineNumber">371</td>
    <td class="codeline">    Limit = &DefaultLimit;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="codeline"></td>
    <td class="lineNumber">372</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="codeline">  // We must be careful with atomic accesses, as they may allow another thread</td>
    <td class="lineNumber">373</td>
    <td class="codeline">  // We must be careful with atomic accesses, as they may allow another thread</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="codeline">  //   to touch this location, clobbering it. We are conservative: if the</td>
    <td class="lineNumber">374</td>
    <td class="codeline">  //   to touch this location, clobbering it. We are conservative: if the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="codeline">  //   QueryInst is not a simple (non-atomic) memory access, we automatically</td>
    <td class="lineNumber">375</td>
    <td class="codeline">  //   QueryInst is not a simple (non-atomic) memory access, we automatically</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="codeline">  //   return getClobber.</td>
    <td class="lineNumber">376</td>
    <td class="codeline">  //   return getClobber.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="codeline">  // If it is simple, we know based on the results of</td>
    <td class="lineNumber">377</td>
    <td class="codeline">  // If it is simple, we know based on the results of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="codeline">  // "Compiler testing via a theory of sound optimisations in the C11/C++11</td>
    <td class="lineNumber">378</td>
    <td class="codeline">  // "Compiler testing via a theory of sound optimisations in the C11/C++11</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="codeline">  //   memory model" in PLDI 2013, that a non-atomic location can only be</td>
    <td class="lineNumber">379</td>
    <td class="codeline">  //   memory model" in PLDI 2013, that a non-atomic location can only be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="codeline">  //   clobbered between a pair of a release and an acquire action, with no</td>
    <td class="lineNumber">380</td>
    <td class="codeline">  //   clobbered between a pair of a release and an acquire action, with no</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="codeline">  //   access to the location in between.</td>
    <td class="lineNumber">381</td>
    <td class="codeline">  //   access to the location in between.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="codeline">  // Here is an example for giving the general intuition behind this rule.</td>
    <td class="lineNumber">382</td>
    <td class="codeline">  // Here is an example for giving the general intuition behind this rule.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="codeline">  // In the following code:</td>
    <td class="lineNumber">383</td>
    <td class="codeline">  // In the following code:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="codeline">  //   store x 0;</td>
    <td class="lineNumber">384</td>
    <td class="codeline">  //   store x 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="codeline">  //   release action; [1]</td>
    <td class="lineNumber">385</td>
    <td class="codeline">  //   release action; [1]</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="codeline">  //   acquire action; [4]</td>
    <td class="lineNumber">386</td>
    <td class="codeline">  //   acquire action; [4]</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="codeline">  //   %val = load x;</td>
    <td class="lineNumber">387</td>
    <td class="codeline">  //   %val = load x;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="codeline">  // It is unsafe to replace %val by 0 because another thread may be running:</td>
    <td class="lineNumber">388</td>
    <td class="codeline">  // It is unsafe to replace %val by 0 because another thread may be running:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="codeline">  //   acquire action; [2]</td>
    <td class="lineNumber">389</td>
    <td class="codeline">  //   acquire action; [2]</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="codeline">  //   store x 42;</td>
    <td class="lineNumber">390</td>
    <td class="codeline">  //   store x 42;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="codeline">  //   release action; [3]</td>
    <td class="lineNumber">391</td>
    <td class="codeline">  //   release action; [3]</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="codeline">  // with synchronization from 1 to 2 and from 3 to 4, resulting in %val</td>
    <td class="lineNumber">392</td>
    <td class="codeline">  // with synchronization from 1 to 2 and from 3 to 4, resulting in %val</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="codeline">  // being 42. A key property of this program however is that if either</td>
    <td class="lineNumber">393</td>
    <td class="codeline">  // being 42. A key property of this program however is that if either</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="codeline">  // 1 or 4 were missing, there would be a race between the store of 42</td>
    <td class="lineNumber">394</td>
    <td class="codeline">  // 1 or 4 were missing, there would be a race between the store of 42</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="codeline">  // either the store of 0 or the load (making the whole program racy).</td>
    <td class="lineNumber">395</td>
    <td class="codeline">  // either the store of 0 or the load (making the whole program racy).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="codeline">  // The paper mentioned above shows that the same property is respected</td>
    <td class="lineNumber">396</td>
    <td class="codeline">  // The paper mentioned above shows that the same property is respected</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="codeline">  // by every program that can detect any optimization of that kind: either</td>
    <td class="lineNumber">397</td>
    <td class="codeline">  // by every program that can detect any optimization of that kind: either</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="codeline">  // it is racy (undefined) or there is a release followed by an acquire</td>
    <td class="lineNumber">398</td>
    <td class="codeline">  // it is racy (undefined) or there is a release followed by an acquire</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="codeline">  // between the pair of accesses under consideration.</td>
    <td class="lineNumber">399</td>
    <td class="codeline">  // between the pair of accesses under consideration.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="codeline"></td>
    <td class="lineNumber">400</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="codeline">  // If the load is invariant, we "know" that it doesn't alias *any* write. We</td>
    <td class="lineNumber">401</td>
    <td class="codeline">  // If the load is invariant, we "know" that it doesn't alias *any* write. We</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="codeline">  // do want to respect mustalias results since defs are useful for value</td>
    <td class="lineNumber">402</td>
    <td class="codeline">  // do want to respect mustalias results since defs are useful for value</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="codeline">  // forwarding, but any mayalias write can be assumed to be noalias.</td>
    <td class="lineNumber">403</td>
    <td class="codeline">  // forwarding, but any mayalias write can be assumed to be noalias.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="codeline">  // Arguably, this logic should be pushed inside AliasAnalysis itself.</td>
    <td class="lineNumber">404</td>
    <td class="codeline">  // Arguably, this logic should be pushed inside AliasAnalysis itself.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="codeline">  if (isLoad && QueryInst) {</td>
    <td class="lineNumber">405</td>
    <td class="codeline">  if (isLoad && QueryInst) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="codeline">    LoadInst *LI = dyn_cast<LoadInst>(QueryInst);</td>
    <td class="lineNumber">406</td>
    <td class="codeline">    LoadInst *LI = dyn_cast<LoadInst>(QueryInst);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="codeline">    if (LI && LI->hasMetadata(LLVMContext::MD_invariant_load))</td>
    <td class="lineNumber">407</td>
    <td class="codeline">    if (LI && LI->hasMetadata(LLVMContext::MD_invariant_load))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="codeline">      isInvariantLoad = true;</td>
    <td class="lineNumber">408</td>
    <td class="codeline">      isInvariantLoad = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">409</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="codeline"></td>
    <td class="lineNumber">410</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="codeline">  // True for volatile instruction.</td>
    <td class="lineNumber">411</td>
    <td class="codeline">  // True for volatile instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="codeline">  // For Load/Store return true if atomic ordering is stronger than AO,</td>
    <td class="lineNumber">412</td>
    <td class="codeline">  // For Load/Store return true if atomic ordering is stronger than AO,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="codeline">  // for other instruction just true if it can read or write to memory.</td>
    <td class="lineNumber">413</td>
    <td class="codeline">  // for other instruction just true if it can read or write to memory.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="codeline">  auto isComplexForReordering = [](Instruction * I, AtomicOrdering AO)->bool {</td>
    <td class="lineNumber">414</td>
    <td class="codeline">  auto isComplexForReordering = [](Instruction * I, AtomicOrdering AO)->bool {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="codeline">    if (I->isVolatile())</td>
    <td class="lineNumber">415</td>
    <td class="codeline">    if (I->isVolatile())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="codeline">      return true;</td>
    <td class="lineNumber">416</td>
    <td class="codeline">      return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="codeline">    if (auto *LI = dyn_cast<LoadInst>(I))</td>
    <td class="lineNumber">417</td>
    <td class="codeline">    if (auto *LI = dyn_cast<LoadInst>(I))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="codeline">      return isStrongerThan(LI->getOrdering(), AO);</td>
    <td class="lineNumber">418</td>
    <td class="codeline">      return isStrongerThan(LI->getOrdering(), AO);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="codeline">    if (auto *SI = dyn_cast<StoreInst>(I))</td>
    <td class="lineNumber">419</td>
    <td class="codeline">    if (auto *SI = dyn_cast<StoreInst>(I))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="codeline">      return isStrongerThan(SI->getOrdering(), AO);</td>
    <td class="lineNumber">420</td>
    <td class="codeline">      return isStrongerThan(SI->getOrdering(), AO);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="codeline">    return I->mayReadOrWriteMemory();</td>
    <td class="lineNumber">421</td>
    <td class="codeline">    return I->mayReadOrWriteMemory();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">422</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="codeline"></td>
    <td class="lineNumber">423</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="codeline">  // Walk backwards through the basic block, looking for dependencies.</td>
    <td class="lineNumber">424</td>
    <td class="codeline">  // Walk backwards through the basic block, looking for dependencies.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="codeline">  while (ScanIt != BB->begin()) {</td>
    <td class="lineNumber">425</td>
    <td class="codeline">  while (ScanIt != BB->begin()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="codeline">    Instruction *Inst = &*--ScanIt;</td>
    <td class="lineNumber">426</td>
    <td class="codeline">    Instruction *Inst = &*--ScanIt;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="codeline"></td>
    <td class="lineNumber">427</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="codeline">    if (IntrinsicInst *II = dyn_cast<IntrinsicInst>(Inst))</td>
    <td class="lineNumber">428</td>
    <td class="codeline">    if (IntrinsicInst *II = dyn_cast<IntrinsicInst>(Inst))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="codeline">      // Debug intrinsics don't (and can't) cause dependencies.</td>
    <td class="lineNumber">429</td>
    <td class="codeline">      // Debug intrinsics don't (and can't) cause dependencies.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="codeline">      if (isa<DbgInfoIntrinsic>(II))</td>
    <td class="lineNumber">430</td>
    <td class="codeline">      if (isa<DbgInfoIntrinsic>(II))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">431</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="codeline"></td>
    <td class="lineNumber">432</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="codeline">    // Limit the amount of scanning we do so we don't end up with quadratic</td>
    <td class="lineNumber">433</td>
    <td class="codeline">    // Limit the amount of scanning we do so we don't end up with quadratic</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="codeline">    // running time on extreme testcases.</td>
    <td class="lineNumber">434</td>
    <td class="codeline">    // running time on extreme testcases.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="codeline">    --*Limit;</td>
    <td class="lineNumber">435</td>
    <td class="codeline">    --*Limit;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="codeline">    if (!*Limit)</td>
    <td class="lineNumber">436</td>
    <td class="codeline">    if (!*Limit)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="codeline">      return MemDepResult::getUnknown();</td>
    <td class="lineNumber">437</td>
    <td class="codeline">      return MemDepResult::getUnknown();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="codeline"></td>
    <td class="lineNumber">438</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="codeline">    if (IntrinsicInst *II = dyn_cast<IntrinsicInst>(Inst)) {</td>
    <td class="lineNumber">439</td>
    <td class="codeline">    if (IntrinsicInst *II = dyn_cast<IntrinsicInst>(Inst)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="codeline">      // If we reach a lifetime begin or end marker, then the query ends here</td>
    <td class="lineNumber">440</td>
    <td class="codeline">      // If we reach a lifetime begin or end marker, then the query ends here</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="codeline">      // because the value is undefined.</td>
    <td class="lineNumber">441</td>
    <td class="codeline">      // because the value is undefined.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="codeline">      Intrinsic::ID ID = II->getIntrinsicID();</td>
    <td class="lineNumber">442</td>
    <td class="codeline">      Intrinsic::ID ID = II->getIntrinsicID();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="codeline">      switch (ID) {</td>
    <td class="lineNumber">443</td>
    <td class="codeline">      switch (ID) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="codeline">      case Intrinsic::lifetime_start: {</td>
    <td class="lineNumber">444</td>
    <td class="codeline">      case Intrinsic::lifetime_start: {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="codeline">        // FIXME: This only considers queries directly on the invariant-tagged</td>
    <td class="lineNumber">445</td>
    <td class="codeline">        // FIXME: This only considers queries directly on the invariant-tagged</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="codeline">        // pointer, not on query pointers that are indexed off of them.  It'd</td>
    <td class="lineNumber">446</td>
    <td class="codeline">        // pointer, not on query pointers that are indexed off of them.  It'd</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="codeline">        // be nice to handle that at some point (the right approach is to use</td>
    <td class="lineNumber">447</td>
    <td class="codeline">        // be nice to handle that at some point (the right approach is to use</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="codeline">        // GetPointerBaseWithConstantOffset).</td>
    <td class="lineNumber">448</td>
    <td class="codeline">        // GetPointerBaseWithConstantOffset).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="codeline">        MemoryLocation ArgLoc = MemoryLocation::getAfter(II->getArgOperand(1));</td>
    <td class="lineNumber">449</td>
    <td class="codeline">        MemoryLocation ArgLoc = MemoryLocation::getAfter(II->getArgOperand(1));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="codeline">        if (BatchAA.isMustAlias(ArgLoc, MemLoc))</td>
    <td class="lineNumber">450</td>
    <td class="codeline">        if (BatchAA.isMustAlias(ArgLoc, MemLoc))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="codeline">          return MemDepResult::getDef(II);</td>
    <td class="lineNumber">451</td>
    <td class="codeline">          return MemDepResult::getDef(II);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">452</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">453</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="codeline">      case Intrinsic::masked_load:</td>
    <td class="lineNumber">454</td>
    <td class="codeline">      case Intrinsic::masked_load:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="codeline">      case Intrinsic::masked_store: {</td>
    <td class="lineNumber">455</td>
    <td class="codeline">      case Intrinsic::masked_store: {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="codeline">        MemoryLocation Loc;</td>
    <td class="lineNumber">456</td>
    <td class="codeline">        MemoryLocation Loc;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="codeline">        /*ModRefInfo MR =*/ GetLocation(II, Loc, TLI);</td>
    <td class="lineNumber">457</td>
    <td class="codeline">        /*ModRefInfo MR =*/ GetLocation(II, Loc, TLI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="codeline">        AliasResult R = BatchAA.alias(Loc, MemLoc);</td>
    <td class="lineNumber">458</td>
    <td class="codeline">        AliasResult R = BatchAA.alias(Loc, MemLoc);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="codeline">        if (R == AliasResult::NoAlias)</td>
    <td class="lineNumber">459</td>
    <td class="codeline">        if (R == AliasResult::NoAlias)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="codeline">          continue;</td>
    <td class="lineNumber">460</td>
    <td class="codeline">          continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="codeline">        if (R == AliasResult::MustAlias)</td>
    <td class="lineNumber">461</td>
    <td class="codeline">        if (R == AliasResult::MustAlias)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="codeline">          return MemDepResult::getDef(II);</td>
    <td class="lineNumber">462</td>
    <td class="codeline">          return MemDepResult::getDef(II);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="codeline">        if (ID == Intrinsic::masked_load)</td>
    <td class="lineNumber">463</td>
    <td class="codeline">        if (ID == Intrinsic::masked_load)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="codeline">          continue;</td>
    <td class="lineNumber">464</td>
    <td class="codeline">          continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="codeline">        return MemDepResult::getClobber(II);</td>
    <td class="lineNumber">465</td>
    <td class="codeline">        return MemDepResult::getClobber(II);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">466</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">467</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">468</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="codeline"></td>
    <td class="lineNumber">469</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="codeline">    // Values depend on loads if the pointers are must aliased.  This means</td>
    <td class="lineNumber">470</td>
    <td class="codeline">    // Values depend on loads if the pointers are must aliased.  This means</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="codeline">    // that a load depends on another must aliased load from the same value.</td>
    <td class="lineNumber">471</td>
    <td class="codeline">    // that a load depends on another must aliased load from the same value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="codeline">    // One exception is atomic loads: a value can depend on an atomic load that</td>
    <td class="lineNumber">472</td>
    <td class="codeline">    // One exception is atomic loads: a value can depend on an atomic load that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="codeline">    // it does not alias with when this atomic load indicates that another</td>
    <td class="lineNumber">473</td>
    <td class="codeline">    // it does not alias with when this atomic load indicates that another</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="codeline">    // thread may be accessing the location.</td>
    <td class="lineNumber">474</td>
    <td class="codeline">    // thread may be accessing the location.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="codeline">    if (LoadInst *LI = dyn_cast<LoadInst>(Inst)) {</td>
    <td class="lineNumber">475</td>
    <td class="codeline">    if (LoadInst *LI = dyn_cast<LoadInst>(Inst)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="codeline">      // While volatile access cannot be eliminated, they do not have to clobber</td>
    <td class="lineNumber">476</td>
    <td class="codeline">      // While volatile access cannot be eliminated, they do not have to clobber</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="codeline">      // non-aliasing locations, as normal accesses, for example, can be safely</td>
    <td class="lineNumber">477</td>
    <td class="codeline">      // non-aliasing locations, as normal accesses, for example, can be safely</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="codeline">      // reordered with volatile accesses.</td>
    <td class="lineNumber">478</td>
    <td class="codeline">      // reordered with volatile accesses.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="codeline">      if (LI->isVolatile()) {</td>
    <td class="lineNumber">479</td>
    <td class="codeline">      if (LI->isVolatile()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="codeline">        if (!QueryInst)</td>
    <td class="lineNumber">480</td>
    <td class="codeline">        if (!QueryInst)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="codeline">          // Original QueryInst *may* be volatile</td>
    <td class="lineNumber">481</td>
    <td class="codeline">          // Original QueryInst *may* be volatile</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="codeline">          return MemDepResult::getClobber(LI);</td>
    <td class="lineNumber">482</td>
    <td class="codeline">          return MemDepResult::getClobber(LI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="codeline">        if (QueryInst->isVolatile())</td>
    <td class="lineNumber">483</td>
    <td class="codeline">        if (QueryInst->isVolatile())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="codeline">          // Ordering required if QueryInst is itself volatile</td>
    <td class="lineNumber">484</td>
    <td class="codeline">          // Ordering required if QueryInst is itself volatile</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="codeline">          return MemDepResult::getClobber(LI);</td>
    <td class="lineNumber">485</td>
    <td class="codeline">          return MemDepResult::getClobber(LI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="codeline">        // Otherwise, volatile doesn't imply any special ordering</td>
    <td class="lineNumber">486</td>
    <td class="codeline">        // Otherwise, volatile doesn't imply any special ordering</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">487</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="codeline"></td>
    <td class="lineNumber">488</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="codeline">      // Atomic loads have complications involved.</td>
    <td class="lineNumber">489</td>
    <td class="codeline">      // Atomic loads have complications involved.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="codeline">      // A Monotonic (or higher) load is OK if the query inst is itself not</td>
    <td class="lineNumber">490</td>
    <td class="codeline">      // A Monotonic (or higher) load is OK if the query inst is itself not</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="codeline">      // atomic.</td>
    <td class="lineNumber">491</td>
    <td class="codeline">      // atomic.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="codeline">      // FIXME: This is overly conservative.</td>
    <td class="lineNumber">492</td>
    <td class="codeline">      // FIXME: This is overly conservative.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="codeline">      if (LI->isAtomic() && isStrongerThanUnordered(LI->getOrdering())) {</td>
    <td class="lineNumber">493</td>
    <td class="codeline">      if (LI->isAtomic() && isStrongerThanUnordered(LI->getOrdering())) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="codeline">        if (!QueryInst ||</td>
    <td class="lineNumber">494</td>
    <td class="codeline">        if (!QueryInst ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="codeline">            isComplexForReordering(QueryInst, AtomicOrdering::NotAtomic))</td>
    <td class="lineNumber">495</td>
    <td class="codeline">            isComplexForReordering(QueryInst, AtomicOrdering::NotAtomic))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="codeline">          return MemDepResult::getClobber(LI);</td>
    <td class="lineNumber">496</td>
    <td class="codeline">          return MemDepResult::getClobber(LI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="codeline">        if (LI->getOrdering() != AtomicOrdering::Monotonic)</td>
    <td class="lineNumber">497</td>
    <td class="codeline">        if (LI->getOrdering() != AtomicOrdering::Monotonic)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="codeline">          return MemDepResult::getClobber(LI);</td>
    <td class="lineNumber">498</td>
    <td class="codeline">          return MemDepResult::getClobber(LI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">499</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="codeline"></td>
    <td class="lineNumber">500</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="codeline">      MemoryLocation LoadLoc = MemoryLocation::get(LI);</td>
    <td class="lineNumber">501</td>
    <td class="codeline">      MemoryLocation LoadLoc = MemoryLocation::get(LI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="codeline"></td>
    <td class="lineNumber">502</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="codeline">      // If we found a pointer, check if it could be the same as our pointer.</td>
    <td class="lineNumber">503</td>
    <td class="codeline">      // If we found a pointer, check if it could be the same as our pointer.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class="codeline">      AliasResult R = BatchAA.alias(LoadLoc, MemLoc);</td>
    <td class="lineNumber">504</td>
    <td class="codeline">      AliasResult R = BatchAA.alias(LoadLoc, MemLoc);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="codeline"></td>
    <td class="lineNumber">505</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="codeline">      if (R == AliasResult::NoAlias)</td>
    <td class="lineNumber">506</td>
    <td class="codeline">      if (R == AliasResult::NoAlias)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">507</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="codeline"></td>
    <td class="lineNumber">508</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="codeline">      if (isLoad) {</td>
    <td class="lineNumber">509</td>
    <td class="codeline">      if (isLoad) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="codeline">        // Must aliased loads are defs of each other.</td>
    <td class="lineNumber">510</td>
    <td class="codeline">        // Must aliased loads are defs of each other.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="codeline">        if (R == AliasResult::MustAlias)</td>
    <td class="lineNumber">511</td>
    <td class="codeline">        if (R == AliasResult::MustAlias)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="codeline">          return MemDepResult::getDef(Inst);</td>
    <td class="lineNumber">512</td>
    <td class="codeline">          return MemDepResult::getDef(Inst);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class="codeline"></td>
    <td class="lineNumber">513</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="codeline">        // If we have a partial alias, then return this as a clobber for the</td>
    <td class="lineNumber">514</td>
    <td class="codeline">        // If we have a partial alias, then return this as a clobber for the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="codeline">        // client to handle.</td>
    <td class="lineNumber">515</td>
    <td class="codeline">        // client to handle.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="codeline">        if (R == AliasResult::PartialAlias && R.hasOffset()) {</td>
    <td class="lineNumber">516</td>
    <td class="codeline">        if (R == AliasResult::PartialAlias && R.hasOffset()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class="codeline">          ClobberOffsets[LI] = R.getOffset();</td>
    <td class="lineNumber">517</td>
    <td class="codeline">          ClobberOffsets[LI] = R.getOffset();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="codeline">          return MemDepResult::getClobber(Inst);</td>
    <td class="lineNumber">518</td>
    <td class="codeline">          return MemDepResult::getClobber(Inst);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">519</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class="codeline"></td>
    <td class="lineNumber">520</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="codeline">        // Random may-alias loads don't depend on each other without a</td>
    <td class="lineNumber">521</td>
    <td class="codeline">        // Random may-alias loads don't depend on each other without a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="codeline">        // dependence.</td>
    <td class="lineNumber">522</td>
    <td class="codeline">        // dependence.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">523</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">524</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="codeline"></td>
    <td class="lineNumber">525</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class="codeline">      // Stores don't alias loads from read-only memory.</td>
    <td class="lineNumber">526</td>
    <td class="codeline">      // Stores don't alias loads from read-only memory.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="codeline">      if (!isModSet(BatchAA.getModRefInfoMask(LoadLoc)))</td>
    <td class="lineNumber">527</td>
    <td class="codeline">      if (!isModSet(BatchAA.getModRefInfoMask(LoadLoc)))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">528</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="codeline"></td>
    <td class="lineNumber">529</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="codeline">      // Stores depend on may/must aliased loads.</td>
    <td class="lineNumber">530</td>
    <td class="codeline">      // Stores depend on may/must aliased loads.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="codeline">      return MemDepResult::getDef(Inst);</td>
    <td class="lineNumber">531</td>
    <td class="codeline">      return MemDepResult::getDef(Inst);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">532</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class="codeline"></td>
    <td class="lineNumber">533</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="codeline">    if (StoreInst *SI = dyn_cast<StoreInst>(Inst)) {</td>
    <td class="lineNumber">534</td>
    <td class="codeline">    if (StoreInst *SI = dyn_cast<StoreInst>(Inst)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="codeline">      // Atomic stores have complications involved.</td>
    <td class="lineNumber">535</td>
    <td class="codeline">      // Atomic stores have complications involved.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="codeline">      // A Monotonic store is OK if the query inst is itself not atomic.</td>
    <td class="lineNumber">536</td>
    <td class="codeline">      // A Monotonic store is OK if the query inst is itself not atomic.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="codeline">      // FIXME: This is overly conservative.</td>
    <td class="lineNumber">537</td>
    <td class="codeline">      // FIXME: This is overly conservative.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="codeline">      if (!SI->isUnordered() && SI->isAtomic()) {</td>
    <td class="lineNumber">538</td>
    <td class="codeline">      if (!SI->isUnordered() && SI->isAtomic()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="codeline">        if (!QueryInst ||</td>
    <td class="lineNumber">539</td>
    <td class="codeline">        if (!QueryInst ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class="codeline">            isComplexForReordering(QueryInst, AtomicOrdering::Unordered))</td>
    <td class="lineNumber">540</td>
    <td class="codeline">            isComplexForReordering(QueryInst, AtomicOrdering::Unordered))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="codeline">          return MemDepResult::getClobber(SI);</td>
    <td class="lineNumber">541</td>
    <td class="codeline">          return MemDepResult::getClobber(SI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="codeline">        // Ok, if we are here the guard above guarantee us that</td>
    <td class="lineNumber">542</td>
    <td class="codeline">        // Ok, if we are here the guard above guarantee us that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="codeline">        // QueryInst is a non-atomic or unordered load/store.</td>
    <td class="lineNumber">543</td>
    <td class="codeline">        // QueryInst is a non-atomic or unordered load/store.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="codeline">        // SI is atomic with monotonic or release semantic (seq_cst for store</td>
    <td class="lineNumber">544</td>
    <td class="codeline">        // SI is atomic with monotonic or release semantic (seq_cst for store</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="codeline">        // is actually a release semantic plus total order over other seq_cst</td>
    <td class="lineNumber">545</td>
    <td class="codeline">        // is actually a release semantic plus total order over other seq_cst</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="codeline">        // instructions, as soon as QueryInst is not seq_cst we can consider it</td>
    <td class="lineNumber">546</td>
    <td class="codeline">        // instructions, as soon as QueryInst is not seq_cst we can consider it</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="codeline">        // as simple release semantic).</td>
    <td class="lineNumber">547</td>
    <td class="codeline">        // as simple release semantic).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="codeline">        // Monotonic and Release semantic allows re-ordering before store</td>
    <td class="lineNumber">548</td>
    <td class="codeline">        // Monotonic and Release semantic allows re-ordering before store</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="codeline">        // so we are safe to go further and check the aliasing. It will prohibit</td>
    <td class="lineNumber">549</td>
    <td class="codeline">        // so we are safe to go further and check the aliasing. It will prohibit</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="codeline">        // re-ordering in case locations are may or must alias.</td>
    <td class="lineNumber">550</td>
    <td class="codeline">        // re-ordering in case locations are may or must alias.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">551</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="codeline"></td>
    <td class="lineNumber">552</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="codeline">      // While volatile access cannot be eliminated, they do not have to clobber</td>
    <td class="lineNumber">553</td>
    <td class="codeline">      // While volatile access cannot be eliminated, they do not have to clobber</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="codeline">      // non-aliasing locations, as normal accesses can for example be reordered</td>
    <td class="lineNumber">554</td>
    <td class="codeline">      // non-aliasing locations, as normal accesses can for example be reordered</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="codeline">      // with volatile accesses.</td>
    <td class="lineNumber">555</td>
    <td class="codeline">      // with volatile accesses.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="codeline">      if (SI->isVolatile())</td>
    <td class="lineNumber">556</td>
    <td class="codeline">      if (SI->isVolatile())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="codeline">        if (!QueryInst || QueryInst->isVolatile())</td>
    <td class="lineNumber">557</td>
    <td class="codeline">        if (!QueryInst || QueryInst->isVolatile())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="codeline">          return MemDepResult::getClobber(SI);</td>
    <td class="lineNumber">558</td>
    <td class="codeline">          return MemDepResult::getClobber(SI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="codeline"></td>
    <td class="lineNumber">559</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="codeline">      // If alias analysis can tell that this store is guaranteed to not modify</td>
    <td class="lineNumber">560</td>
    <td class="codeline">      // If alias analysis can tell that this store is guaranteed to not modify</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="codeline">      // the query pointer, ignore it.  Use getModRefInfo to handle cases where</td>
    <td class="lineNumber">561</td>
    <td class="codeline">      // the query pointer, ignore it.  Use getModRefInfo to handle cases where</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="codeline">      // the query pointer points to constant memory etc.</td>
    <td class="lineNumber">562</td>
    <td class="codeline">      // the query pointer points to constant memory etc.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="codeline">      if (!isModOrRefSet(BatchAA.getModRefInfo(SI, MemLoc)))</td>
    <td class="lineNumber">563</td>
    <td class="codeline">      if (!isModOrRefSet(BatchAA.getModRefInfo(SI, MemLoc)))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">564</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class="codeline"></td>
    <td class="lineNumber">565</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="codeline">      // Ok, this store might clobber the query pointer.  Check to see if it is</td>
    <td class="lineNumber">566</td>
    <td class="codeline">      // Ok, this store might clobber the query pointer.  Check to see if it is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="codeline">      // a must alias: in this case, we want to return this as a def.</td>
    <td class="lineNumber">567</td>
    <td class="codeline">      // a must alias: in this case, we want to return this as a def.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="codeline">      // FIXME: Use ModRefInfo::Must bit from getModRefInfo call above.</td>
    <td class="lineNumber">568</td>
    <td class="codeline">      // FIXME: Use ModRefInfo::Must bit from getModRefInfo call above.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="codeline">      MemoryLocation StoreLoc = MemoryLocation::get(SI);</td>
    <td class="lineNumber">569</td>
    <td class="codeline">      MemoryLocation StoreLoc = MemoryLocation::get(SI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="codeline"></td>
    <td class="lineNumber">570</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="codeline">      // If we found a pointer, check if it could be the same as our pointer.</td>
    <td class="lineNumber">571</td>
    <td class="codeline">      // If we found a pointer, check if it could be the same as our pointer.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="codeline">      AliasResult R = BatchAA.alias(StoreLoc, MemLoc);</td>
    <td class="lineNumber">572</td>
    <td class="codeline">      AliasResult R = BatchAA.alias(StoreLoc, MemLoc);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="codeline"></td>
    <td class="lineNumber">573</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="codeline">      if (R == AliasResult::NoAlias)</td>
    <td class="lineNumber">574</td>
    <td class="codeline">      if (R == AliasResult::NoAlias)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">575</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="codeline">      if (R == AliasResult::MustAlias)</td>
    <td class="lineNumber">576</td>
    <td class="codeline">      if (R == AliasResult::MustAlias)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="codeline">        return MemDepResult::getDef(Inst);</td>
    <td class="lineNumber">577</td>
    <td class="codeline">        return MemDepResult::getDef(Inst);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="codeline">      if (isInvariantLoad)</td>
    <td class="lineNumber">578</td>
    <td class="codeline">      if (isInvariantLoad)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">579</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="codeline">      return MemDepResult::getClobber(Inst);</td>
    <td class="lineNumber">580</td>
    <td class="codeline">      return MemDepResult::getClobber(Inst);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">581</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class="codeline"></td>
    <td class="lineNumber">582</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="codeline">    // If this is an allocation, and if we know that the accessed pointer is to</td>
    <td class="lineNumber">583</td>
    <td class="codeline">    // If this is an allocation, and if we know that the accessed pointer is to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="codeline">    // the allocation, return Def.  This means that there is no dependence and</td>
    <td class="lineNumber">584</td>
    <td class="codeline">    // the allocation, return Def.  This means that there is no dependence and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="codeline">    // the access can be optimized based on that.  For example, a load could</td>
    <td class="lineNumber">585</td>
    <td class="codeline">    // the access can be optimized based on that.  For example, a load could</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="codeline">    // turn into undef.  Note that we can bypass the allocation itself when</td>
    <td class="lineNumber">586</td>
    <td class="codeline">    // turn into undef.  Note that we can bypass the allocation itself when</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class="codeline">    // looking for a clobber in many cases; that's an alias property and is</td>
    <td class="lineNumber">587</td>
    <td class="codeline">    // looking for a clobber in many cases; that's an alias property and is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="codeline">    // handled by BasicAA.</td>
    <td class="lineNumber">588</td>
    <td class="codeline">    // handled by BasicAA.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="codeline">    if (isa<AllocaInst>(Inst) || isNoAliasCall(Inst)) {</td>
    <td class="lineNumber">589</td>
    <td class="codeline">    if (isa<AllocaInst>(Inst) || isNoAliasCall(Inst)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class="codeline">      const Value *AccessPtr = getUnderlyingObject(MemLoc.Ptr);</td>
    <td class="lineNumber">590</td>
    <td class="codeline">      const Value *AccessPtr = getUnderlyingObject(MemLoc.Ptr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="codeline">      if (AccessPtr == Inst || BatchAA.isMustAlias(Inst, AccessPtr))</td>
    <td class="lineNumber">591</td>
    <td class="codeline">      if (AccessPtr == Inst || BatchAA.isMustAlias(Inst, AccessPtr))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="codeline">        return MemDepResult::getDef(Inst);</td>
    <td class="lineNumber">592</td>
    <td class="codeline">        return MemDepResult::getDef(Inst);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">593</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="codeline"></td>
    <td class="lineNumber">594</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="codeline">    // If we found a select instruction for MemLoc pointer, return it as Def</td>
    <td class="lineNumber">595</td>
    <td class="codeline">    // If we found a select instruction for MemLoc pointer, return it as Def</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="codeline">    // dependency.</td>
    <td class="lineNumber">596</td>
    <td class="codeline">    // dependency.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class="codeline">    if (isa<SelectInst>(Inst) && MemLoc.Ptr == Inst)</td>
    <td class="lineNumber">597</td>
    <td class="codeline">    if (isa<SelectInst>(Inst) && MemLoc.Ptr == Inst)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="codeline">      return MemDepResult::getDef(Inst);</td>
    <td class="lineNumber">598</td>
    <td class="codeline">      return MemDepResult::getDef(Inst);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="codeline"></td>
    <td class="lineNumber">599</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="codeline">    if (isInvariantLoad)</td>
    <td class="lineNumber">600</td>
    <td class="codeline">    if (isInvariantLoad)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">601</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="codeline"></td>
    <td class="lineNumber">602</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="codeline">    // A release fence requires that all stores complete before it, but does</td>
    <td class="lineNumber">603</td>
    <td class="codeline">    // A release fence requires that all stores complete before it, but does</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="codeline">    // not prevent the reordering of following loads or stores 'before' the</td>
    <td class="lineNumber">604</td>
    <td class="codeline">    // not prevent the reordering of following loads or stores 'before' the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="codeline">    // fence.  As a result, we look past it when finding a dependency for</td>
    <td class="lineNumber">605</td>
    <td class="codeline">    // fence.  As a result, we look past it when finding a dependency for</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="codeline">    // loads.  DSE uses this to find preceding stores to delete and thus we</td>
    <td class="lineNumber">606</td>
    <td class="codeline">    // loads.  DSE uses this to find preceding stores to delete and thus we</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="codeline">    // can't bypass the fence if the query instruction is a store.</td>
    <td class="lineNumber">607</td>
    <td class="codeline">    // can't bypass the fence if the query instruction is a store.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="codeline">    if (FenceInst *FI = dyn_cast<FenceInst>(Inst))</td>
    <td class="lineNumber">608</td>
    <td class="codeline">    if (FenceInst *FI = dyn_cast<FenceInst>(Inst))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="codeline">      if (isLoad && FI->getOrdering() == AtomicOrdering::Release)</td>
    <td class="lineNumber">609</td>
    <td class="codeline">      if (isLoad && FI->getOrdering() == AtomicOrdering::Release)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">610</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="codeline"></td>
    <td class="lineNumber">611</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="codeline">    // See if this instruction (e.g. a call or vaarg) mod/ref's the pointer.</td>
    <td class="lineNumber">612</td>
    <td class="codeline">    // See if this instruction (e.g. a call or vaarg) mod/ref's the pointer.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class="codeline">    ModRefInfo MR = BatchAA.getModRefInfo(Inst, MemLoc);</td>
    <td class="lineNumber">613</td>
    <td class="codeline">    ModRefInfo MR = BatchAA.getModRefInfo(Inst, MemLoc);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class="codeline">    // If necessary, perform additional analysis.</td>
    <td class="lineNumber">614</td>
    <td class="codeline">    // If necessary, perform additional analysis.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="codeline">    if (isModAndRefSet(MR))</td>
    <td class="lineNumber">615</td>
    <td class="codeline">    if (isModAndRefSet(MR))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="codeline">      MR = BatchAA.callCapturesBefore(Inst, MemLoc, &DT);</td>
    <td class="lineNumber">616</td>
    <td class="codeline">      MR = BatchAA.callCapturesBefore(Inst, MemLoc, &DT);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="codeline">    switch (MR) {</td>
    <td class="lineNumber">617</td>
    <td class="codeline">    switch (MR) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class="codeline">    case ModRefInfo::NoModRef:</td>
    <td class="lineNumber">618</td>
    <td class="codeline">    case ModRefInfo::NoModRef:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="codeline">      // If the call has no effect on the queried pointer, just ignore it.</td>
    <td class="lineNumber">619</td>
    <td class="codeline">      // If the call has no effect on the queried pointer, just ignore it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">620</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class="codeline">    case ModRefInfo::Mod:</td>
    <td class="lineNumber">621</td>
    <td class="codeline">    case ModRefInfo::Mod:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="codeline">      return MemDepResult::getClobber(Inst);</td>
    <td class="lineNumber">622</td>
    <td class="codeline">      return MemDepResult::getClobber(Inst);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="codeline">    case ModRefInfo::Ref:</td>
    <td class="lineNumber">623</td>
    <td class="codeline">    case ModRefInfo::Ref:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="codeline">      // If the call is known to never store to the pointer, and if this is a</td>
    <td class="lineNumber">624</td>
    <td class="codeline">      // If the call is known to never store to the pointer, and if this is a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="codeline">      // load query, we can safely ignore it (scan past it).</td>
    <td class="lineNumber">625</td>
    <td class="codeline">      // load query, we can safely ignore it (scan past it).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="codeline">      if (isLoad)</td>
    <td class="lineNumber">626</td>
    <td class="codeline">      if (isLoad)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">627</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class="codeline">      [[fallthrough]];</td>
    <td class="lineNumber">628</td>
    <td class="codeline">      [[fallthrough]];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="codeline">    default:</td>
    <td class="lineNumber">629</td>
    <td class="codeline">    default:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class="codeline">      // Otherwise, there is a potential dependence.  Return a clobber.</td>
    <td class="lineNumber">630</td>
    <td class="codeline">      // Otherwise, there is a potential dependence.  Return a clobber.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="codeline">      return MemDepResult::getClobber(Inst);</td>
    <td class="lineNumber">631</td>
    <td class="codeline">      return MemDepResult::getClobber(Inst);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">632</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">633</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="codeline"></td>
    <td class="lineNumber">634</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="codeline">  // No dependence found.  If this is the entry block of the function, it is</td>
    <td class="lineNumber">635</td>
    <td class="codeline">  // No dependence found.  If this is the entry block of the function, it is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="codeline">  // unknown, otherwise it is non-local.</td>
    <td class="lineNumber">636</td>
    <td class="codeline">  // unknown, otherwise it is non-local.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="codeline">  if (BB != &BB->getParent()->getEntryBlock())</td>
    <td class="lineNumber">637</td>
    <td class="codeline">  if (BB != &BB->getParent()->getEntryBlock())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="codeline">    return MemDepResult::getNonLocal();</td>
    <td class="lineNumber">638</td>
    <td class="codeline">    return MemDepResult::getNonLocal();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="codeline">  return MemDepResult::getNonFuncLocal();</td>
    <td class="lineNumber">639</td>
    <td class="codeline">  return MemDepResult::getNonFuncLocal();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="codeline">}</td>
    <td class="lineNumber">640</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="codeline"></td>
    <td class="lineNumber">641</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="codeline">MemDepResult MemoryDependenceResults::getDependency(Instruction *QueryInst) {</td>
    <td class="lineNumber">642</td>
    <td class="codeline">MemDepResult MemoryDependenceResults::getDependency(Instruction *QueryInst) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="codeline">  ClobberOffsets.clear();</td>
    <td class="lineNumber">643</td>
    <td class="codeline">  ClobberOffsets.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class="codeline">  Instruction *ScanPos = QueryInst;</td>
    <td class="lineNumber">644</td>
    <td class="codeline">  Instruction *ScanPos = QueryInst;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="codeline"></td>
    <td class="lineNumber">645</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="codeline">  // Check for a cached result</td>
    <td class="lineNumber">646</td>
    <td class="codeline">  // Check for a cached result</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="codeline">  MemDepResult &LocalCache = LocalDeps[QueryInst];</td>
    <td class="lineNumber">647</td>
    <td class="codeline">  MemDepResult &LocalCache = LocalDeps[QueryInst];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="codeline"></td>
    <td class="lineNumber">648</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="codeline">  // If the cached entry is non-dirty, just return it.  Note that this depends</td>
    <td class="lineNumber">649</td>
    <td class="codeline">  // If the cached entry is non-dirty, just return it.  Note that this depends</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="codeline">  // on MemDepResult's default constructing to 'dirty'.</td>
    <td class="lineNumber">650</td>
    <td class="codeline">  // on MemDepResult's default constructing to 'dirty'.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="codeline">  if (!LocalCache.isDirty())</td>
    <td class="lineNumber">651</td>
    <td class="codeline">  if (!LocalCache.isDirty())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="codeline">    return LocalCache;</td>
    <td class="lineNumber">652</td>
    <td class="codeline">    return LocalCache;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="codeline"></td>
    <td class="lineNumber">653</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="codeline">  // Otherwise, if we have a dirty entry, we know we can start the scan at that</td>
    <td class="lineNumber">654</td>
    <td class="codeline">  // Otherwise, if we have a dirty entry, we know we can start the scan at that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="codeline">  // instruction, which may save us some work.</td>
    <td class="lineNumber">655</td>
    <td class="codeline">  // instruction, which may save us some work.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="codeline">  if (Instruction *Inst = LocalCache.getInst()) {</td>
    <td class="lineNumber">656</td>
    <td class="codeline">  if (Instruction *Inst = LocalCache.getInst()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class="codeline">    ScanPos = Inst;</td>
    <td class="lineNumber">657</td>
    <td class="codeline">    ScanPos = Inst;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="codeline"></td>
    <td class="lineNumber">658</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="codeline">    RemoveFromReverseMap(ReverseLocalDeps, Inst, QueryInst);</td>
    <td class="lineNumber">659</td>
    <td class="codeline">    RemoveFromReverseMap(ReverseLocalDeps, Inst, QueryInst);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">660</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="codeline"></td>
    <td class="lineNumber">661</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="codeline">  BasicBlock *QueryParent = QueryInst->getParent();</td>
    <td class="lineNumber">662</td>
    <td class="codeline">  BasicBlock *QueryParent = QueryInst->getParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="codeline"></td>
    <td class="lineNumber">663</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="codeline">  // Do the scan.</td>
    <td class="lineNumber">664</td>
    <td class="codeline">  // Do the scan.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="codeline">  if (BasicBlock::iterator(QueryInst) == QueryParent->begin()) {</td>
    <td class="lineNumber">665</td>
    <td class="codeline">  if (BasicBlock::iterator(QueryInst) == QueryParent->begin()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="codeline">    // No dependence found. If this is the entry block of the function, it is</td>
    <td class="lineNumber">666</td>
    <td class="codeline">    // No dependence found. If this is the entry block of the function, it is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="codeline">    // unknown, otherwise it is non-local.</td>
    <td class="lineNumber">667</td>
    <td class="codeline">    // unknown, otherwise it is non-local.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="codeline">    if (QueryParent != &QueryParent->getParent()->getEntryBlock())</td>
    <td class="lineNumber">668</td>
    <td class="codeline">    if (QueryParent != &QueryParent->getParent()->getEntryBlock())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="codeline">      LocalCache = MemDepResult::getNonLocal();</td>
    <td class="lineNumber">669</td>
    <td class="codeline">      LocalCache = MemDepResult::getNonLocal();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="codeline">    else</td>
    <td class="lineNumber">670</td>
    <td class="codeline">    else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="codeline">      LocalCache = MemDepResult::getNonFuncLocal();</td>
    <td class="lineNumber">671</td>
    <td class="codeline">      LocalCache = MemDepResult::getNonFuncLocal();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">672</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="codeline">    MemoryLocation MemLoc;</td>
    <td class="lineNumber">673</td>
    <td class="codeline">    MemoryLocation MemLoc;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="codeline">    ModRefInfo MR = GetLocation(QueryInst, MemLoc, TLI);</td>
    <td class="lineNumber">674</td>
    <td class="codeline">    ModRefInfo MR = GetLocation(QueryInst, MemLoc, TLI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class="codeline">    if (MemLoc.Ptr) {</td>
    <td class="lineNumber">675</td>
    <td class="codeline">    if (MemLoc.Ptr) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class="codeline">      // If we can do a pointer scan, make it happen.</td>
    <td class="lineNumber">676</td>
    <td class="codeline">      // If we can do a pointer scan, make it happen.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="codeline">      bool isLoad = !isModSet(MR);</td>
    <td class="lineNumber">677</td>
    <td class="codeline">      bool isLoad = !isModSet(MR);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="codeline">      if (auto *II = dyn_cast<IntrinsicInst>(QueryInst))</td>
    <td class="lineNumber">678</td>
    <td class="codeline">      if (auto *II = dyn_cast<IntrinsicInst>(QueryInst))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="codeline">        isLoad |= II->getIntrinsicID() == Intrinsic::lifetime_start;</td>
    <td class="lineNumber">679</td>
    <td class="codeline">        isLoad |= II->getIntrinsicID() == Intrinsic::lifetime_start;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="codeline"></td>
    <td class="lineNumber">680</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="codeline">      LocalCache =</td>
    <td class="lineNumber">681</td>
    <td class="codeline">      LocalCache =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="codeline">          getPointerDependencyFrom(MemLoc, isLoad, ScanPos->getIterator(),</td>
    <td class="lineNumber">682</td>
    <td class="codeline">          getPointerDependencyFrom(MemLoc, isLoad, ScanPos->getIterator(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class="codeline">                                   QueryParent, QueryInst, nullptr);</td>
    <td class="lineNumber">683</td>
    <td class="codeline">                                   QueryParent, QueryInst, nullptr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="codeline">    } else if (auto *QueryCall = dyn_cast<CallBase>(QueryInst)) {</td>
    <td class="lineNumber">684</td>
    <td class="codeline">    } else if (auto *QueryCall = dyn_cast<CallBase>(QueryInst)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class="codeline">      bool isReadOnly = AA.onlyReadsMemory(QueryCall);</td>
    <td class="lineNumber">685</td>
    <td class="codeline">      bool isReadOnly = AA.onlyReadsMemory(QueryCall);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="codeline">      LocalCache = getCallDependencyFrom(QueryCall, isReadOnly,</td>
    <td class="lineNumber">686</td>
    <td class="codeline">      LocalCache = getCallDependencyFrom(QueryCall, isReadOnly,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="codeline">                                         ScanPos->getIterator(), QueryParent);</td>
    <td class="lineNumber">687</td>
    <td class="codeline">                                         ScanPos->getIterator(), QueryParent);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class="codeline">    } else</td>
    <td class="lineNumber">688</td>
    <td class="codeline">    } else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class="codeline">      // Non-memory instruction.</td>
    <td class="lineNumber">689</td>
    <td class="codeline">      // Non-memory instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class="codeline">      LocalCache = MemDepResult::getUnknown();</td>
    <td class="lineNumber">690</td>
    <td class="codeline">      LocalCache = MemDepResult::getUnknown();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">691</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="codeline"></td>
    <td class="lineNumber">692</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class="codeline">  // Remember the result!</td>
    <td class="lineNumber">693</td>
    <td class="codeline">  // Remember the result!</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class="codeline">  if (Instruction *I = LocalCache.getInst())</td>
    <td class="lineNumber">694</td>
    <td class="codeline">  if (Instruction *I = LocalCache.getInst())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="codeline">    ReverseLocalDeps[I].insert(QueryInst);</td>
    <td class="lineNumber">695</td>
    <td class="codeline">    ReverseLocalDeps[I].insert(QueryInst);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="codeline"></td>
    <td class="lineNumber">696</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class="codeline">  return LocalCache;</td>
    <td class="lineNumber">697</td>
    <td class="codeline">  return LocalCache;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class="codeline">}</td>
    <td class="lineNumber">698</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class="codeline"></td>
    <td class="lineNumber">699</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="codeline">#ifndef NDEBUG</td>
    <td class="lineNumber">700</td>
    <td class="codeline">#ifndef NDEBUG</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="codeline">/// This method is used when -debug is specified to verify that cache arrays</td>
    <td class="lineNumber">701</td>
    <td class="codeline">/// This method is used when -debug is specified to verify that cache arrays</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class="codeline">/// are properly kept sorted.</td>
    <td class="lineNumber">702</td>
    <td class="codeline">/// are properly kept sorted.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="codeline">static void AssertSorted(MemoryDependenceResults::NonLocalDepInfo &Cache,</td>
    <td class="lineNumber">703</td>
    <td class="codeline">static void AssertSorted(MemoryDependenceResults::NonLocalDepInfo &Cache,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class="codeline">                         int Count = -1) {</td>
    <td class="lineNumber">704</td>
    <td class="codeline">                         int Count = -1) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="codeline">  if (Count == -1)</td>
    <td class="lineNumber">705</td>
    <td class="codeline">  if (Count == -1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class="codeline">    Count = Cache.size();</td>
    <td class="lineNumber">706</td>
    <td class="codeline">    Count = Cache.size();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class="codeline">  assert(std::is_sorted(Cache.begin(), Cache.begin() + Count) &&</td>
    <td class="lineNumber">707</td>
    <td class="codeline">  assert(std::is_sorted(Cache.begin(), Cache.begin() + Count) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class="codeline">         "Cache isn't sorted!");</td>
    <td class="lineNumber">708</td>
    <td class="codeline">         "Cache isn't sorted!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class="codeline">}</td>
    <td class="lineNumber">709</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="codeline">#endif</td>
    <td class="lineNumber">710</td>
    <td class="codeline">#endif</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class="codeline"></td>
    <td class="lineNumber">711</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class="codeline">const MemoryDependenceResults::NonLocalDepInfo &</td>
    <td class="lineNumber">712</td>
    <td class="codeline">const MemoryDependenceResults::NonLocalDepInfo &</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="codeline">MemoryDependenceResults::getNonLocalCallDependency(CallBase *QueryCall) {</td>
    <td class="lineNumber">713</td>
    <td class="codeline">MemoryDependenceResults::getNonLocalCallDependency(CallBase *QueryCall) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="codeline">  assert(getDependency(QueryCall).isNonLocal() &&</td>
    <td class="lineNumber">714</td>
    <td class="codeline">  assert(getDependency(QueryCall).isNonLocal() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="codeline">         "getNonLocalCallDependency should only be used on calls with "</td>
    <td class="lineNumber">715</td>
    <td class="codeline">         "getNonLocalCallDependency should only be used on calls with "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="codeline">         "non-local deps!");</td>
    <td class="lineNumber">716</td>
    <td class="codeline">         "non-local deps!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class="codeline">  PerInstNLInfo &CacheP = NonLocalDepsMap[QueryCall];</td>
    <td class="lineNumber">717</td>
    <td class="codeline">  PerInstNLInfo &CacheP = NonLocalDepsMap[QueryCall];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class="codeline">  NonLocalDepInfo &Cache = CacheP.first;</td>
    <td class="lineNumber">718</td>
    <td class="codeline">  NonLocalDepInfo &Cache = CacheP.first;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class="codeline"></td>
    <td class="lineNumber">719</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class="codeline">  // This is the set of blocks that need to be recomputed.  In the cached case,</td>
    <td class="lineNumber">720</td>
    <td class="codeline">  // This is the set of blocks that need to be recomputed.  In the cached case,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="codeline">  // this can happen due to instructions being deleted etc. In the uncached</td>
    <td class="lineNumber">721</td>
    <td class="codeline">  // this can happen due to instructions being deleted etc. In the uncached</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class="codeline">  // case, this starts out as the set of predecessors we care about.</td>
    <td class="lineNumber">722</td>
    <td class="codeline">  // case, this starts out as the set of predecessors we care about.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="codeline">  SmallVector<BasicBlock *, 32> DirtyBlocks;</td>
    <td class="lineNumber">723</td>
    <td class="codeline">  SmallVector<BasicBlock *, 32> DirtyBlocks;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class="codeline"></td>
    <td class="lineNumber">724</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="codeline">  if (!Cache.empty()) {</td>
    <td class="lineNumber">725</td>
    <td class="codeline">  if (!Cache.empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class="codeline">    // Okay, we have a cache entry.  If we know it is not dirty, just return it</td>
    <td class="lineNumber">726</td>
    <td class="codeline">    // Okay, we have a cache entry.  If we know it is not dirty, just return it</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class="codeline">    // with no computation.</td>
    <td class="lineNumber">727</td>
    <td class="codeline">    // with no computation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class="codeline">    if (!CacheP.second) {</td>
    <td class="lineNumber">728</td>
    <td class="codeline">    if (!CacheP.second) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="codeline">      ++NumCacheNonLocal;</td>
    <td class="lineNumber">729</td>
    <td class="codeline">      ++NumCacheNonLocal;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class="codeline">      return Cache;</td>
    <td class="lineNumber">730</td>
    <td class="codeline">      return Cache;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">731</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class="codeline"></td>
    <td class="lineNumber">732</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="codeline">    // If we already have a partially computed set of results, scan them to</td>
    <td class="lineNumber">733</td>
    <td class="codeline">    // If we already have a partially computed set of results, scan them to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="codeline">    // determine what is dirty, seeding our initial DirtyBlocks worklist.</td>
    <td class="lineNumber">734</td>
    <td class="codeline">    // determine what is dirty, seeding our initial DirtyBlocks worklist.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class="codeline">    for (auto &Entry : Cache)</td>
    <td class="lineNumber">735</td>
    <td class="codeline">    for (auto &Entry : Cache)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class="codeline">      if (Entry.getResult().isDirty())</td>
    <td class="lineNumber">736</td>
    <td class="codeline">      if (Entry.getResult().isDirty())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class="codeline">        DirtyBlocks.push_back(Entry.getBB());</td>
    <td class="lineNumber">737</td>
    <td class="codeline">        DirtyBlocks.push_back(Entry.getBB());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class="codeline"></td>
    <td class="lineNumber">738</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class="codeline">    // Sort the cache so that we can do fast binary search lookups below.</td>
    <td class="lineNumber">739</td>
    <td class="codeline">    // Sort the cache so that we can do fast binary search lookups below.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="codeline">    llvm::sort(Cache);</td>
    <td class="lineNumber">740</td>
    <td class="codeline">    llvm::sort(Cache);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class="codeline"></td>
    <td class="lineNumber">741</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class="codeline">    ++NumCacheDirtyNonLocal;</td>
    <td class="lineNumber">742</td>
    <td class="codeline">    ++NumCacheDirtyNonLocal;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">743</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="codeline">    // Seed DirtyBlocks with each of the preds of QueryInst's block.</td>
    <td class="lineNumber">744</td>
    <td class="codeline">    // Seed DirtyBlocks with each of the preds of QueryInst's block.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="codeline">    BasicBlock *QueryBB = QueryCall->getParent();</td>
    <td class="lineNumber">745</td>
    <td class="codeline">    BasicBlock *QueryBB = QueryCall->getParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class="codeline">    append_range(DirtyBlocks, PredCache.get(QueryBB));</td>
    <td class="lineNumber">746</td>
    <td class="codeline">    append_range(DirtyBlocks, PredCache.get(QueryBB));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class="codeline">    ++NumUncacheNonLocal;</td>
    <td class="lineNumber">747</td>
    <td class="codeline">    ++NumUncacheNonLocal;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">748</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="codeline"></td>
    <td class="lineNumber">749</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="codeline">  // isReadonlyCall - If this is a read-only call, we can be more aggressive.</td>
    <td class="lineNumber">750</td>
    <td class="codeline">  // isReadonlyCall - If this is a read-only call, we can be more aggressive.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class="codeline">  bool isReadonlyCall = AA.onlyReadsMemory(QueryCall);</td>
    <td class="lineNumber">751</td>
    <td class="codeline">  bool isReadonlyCall = AA.onlyReadsMemory(QueryCall);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class="codeline"></td>
    <td class="lineNumber">752</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class="codeline">  SmallPtrSet<BasicBlock *, 32> Visited;</td>
    <td class="lineNumber">753</td>
    <td class="codeline">  SmallPtrSet<BasicBlock *, 32> Visited;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class="codeline"></td>
    <td class="lineNumber">754</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class="codeline">  unsigned NumSortedEntries = Cache.size();</td>
    <td class="lineNumber">755</td>
    <td class="codeline">  unsigned NumSortedEntries = Cache.size();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="codeline">  LLVM_DEBUG(AssertSorted(Cache));</td>
    <td class="lineNumber">756</td>
    <td class="codeline">  LLVM_DEBUG(AssertSorted(Cache));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="codeline"></td>
    <td class="lineNumber">757</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="codeline">  // Iterate while we still have blocks to update.</td>
    <td class="lineNumber">758</td>
    <td class="codeline">  // Iterate while we still have blocks to update.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="codeline">  while (!DirtyBlocks.empty()) {</td>
    <td class="lineNumber">759</td>
    <td class="codeline">  while (!DirtyBlocks.empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class="codeline">    BasicBlock *DirtyBB = DirtyBlocks.pop_back_val();</td>
    <td class="lineNumber">760</td>
    <td class="codeline">    BasicBlock *DirtyBB = DirtyBlocks.pop_back_val();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class="codeline"></td>
    <td class="lineNumber">761</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class="codeline">    // Already processed this block?</td>
    <td class="lineNumber">762</td>
    <td class="codeline">    // Already processed this block?</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="codeline">    if (!Visited.insert(DirtyBB).second)</td>
    <td class="lineNumber">763</td>
    <td class="codeline">    if (!Visited.insert(DirtyBB).second)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">764</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class="codeline"></td>
    <td class="lineNumber">765</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class="codeline">    // Do a binary search to see if we already have an entry for this block in</td>
    <td class="lineNumber">766</td>
    <td class="codeline">    // Do a binary search to see if we already have an entry for this block in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="codeline">    // the cache set.  If so, find it.</td>
    <td class="lineNumber">767</td>
    <td class="codeline">    // the cache set.  If so, find it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class="codeline">    LLVM_DEBUG(AssertSorted(Cache, NumSortedEntries));</td>
    <td class="lineNumber">768</td>
    <td class="codeline">    LLVM_DEBUG(AssertSorted(Cache, NumSortedEntries));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="codeline">    NonLocalDepInfo::iterator Entry =</td>
    <td class="lineNumber">769</td>
    <td class="codeline">    NonLocalDepInfo::iterator Entry =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="codeline">        std::upper_bound(Cache.begin(), Cache.begin() + NumSortedEntries,</td>
    <td class="lineNumber">770</td>
    <td class="codeline">        std::upper_bound(Cache.begin(), Cache.begin() + NumSortedEntries,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class="codeline">                         NonLocalDepEntry(DirtyBB));</td>
    <td class="lineNumber">771</td>
    <td class="codeline">                         NonLocalDepEntry(DirtyBB));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="codeline">    if (Entry != Cache.begin() && std::prev(Entry)->getBB() == DirtyBB)</td>
    <td class="lineNumber">772</td>
    <td class="codeline">    if (Entry != Cache.begin() && std::prev(Entry)->getBB() == DirtyBB)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class="codeline">      --Entry;</td>
    <td class="lineNumber">773</td>
    <td class="codeline">      --Entry;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="codeline"></td>
    <td class="lineNumber">774</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class="codeline">    NonLocalDepEntry *ExistingResult = nullptr;</td>
    <td class="lineNumber">775</td>
    <td class="codeline">    NonLocalDepEntry *ExistingResult = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class="codeline">    if (Entry != Cache.begin() + NumSortedEntries &&</td>
    <td class="lineNumber">776</td>
    <td class="codeline">    if (Entry != Cache.begin() + NumSortedEntries &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="codeline">        Entry->getBB() == DirtyBB) {</td>
    <td class="lineNumber">777</td>
    <td class="codeline">        Entry->getBB() == DirtyBB) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class="codeline">      // If we already have an entry, and if it isn't already dirty, the block</td>
    <td class="lineNumber">778</td>
    <td class="codeline">      // If we already have an entry, and if it isn't already dirty, the block</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="codeline">      // is done.</td>
    <td class="lineNumber">779</td>
    <td class="codeline">      // is done.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class="codeline">      if (!Entry->getResult().isDirty())</td>
    <td class="lineNumber">780</td>
    <td class="codeline">      if (!Entry->getResult().isDirty())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">781</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="codeline"></td>
    <td class="lineNumber">782</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="codeline">      // Otherwise, remember this slot so we can update the value.</td>
    <td class="lineNumber">783</td>
    <td class="codeline">      // Otherwise, remember this slot so we can update the value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class="codeline">      ExistingResult = &*Entry;</td>
    <td class="lineNumber">784</td>
    <td class="codeline">      ExistingResult = &*Entry;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">785</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class="codeline"></td>
    <td class="lineNumber">786</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class="codeline">    // If the dirty entry has a pointer, start scanning from it so we don't have</td>
    <td class="lineNumber">787</td>
    <td class="codeline">    // If the dirty entry has a pointer, start scanning from it so we don't have</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="codeline">    // to rescan the entire block.</td>
    <td class="lineNumber">788</td>
    <td class="codeline">    // to rescan the entire block.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class="codeline">    BasicBlock::iterator ScanPos = DirtyBB->end();</td>
    <td class="lineNumber">789</td>
    <td class="codeline">    BasicBlock::iterator ScanPos = DirtyBB->end();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class="codeline">    if (ExistingResult) {</td>
    <td class="lineNumber">790</td>
    <td class="codeline">    if (ExistingResult) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class="codeline">      if (Instruction *Inst = ExistingResult->getResult().getInst()) {</td>
    <td class="lineNumber">791</td>
    <td class="codeline">      if (Instruction *Inst = ExistingResult->getResult().getInst()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class="codeline">        ScanPos = Inst->getIterator();</td>
    <td class="lineNumber">792</td>
    <td class="codeline">        ScanPos = Inst->getIterator();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="codeline">        // We're removing QueryInst's use of Inst.</td>
    <td class="lineNumber">793</td>
    <td class="codeline">        // We're removing QueryInst's use of Inst.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class="codeline">        RemoveFromReverseMap<Instruction *>(ReverseNonLocalDeps, Inst,</td>
    <td class="lineNumber">794</td>
    <td class="codeline">        RemoveFromReverseMap<Instruction *>(ReverseNonLocalDeps, Inst,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="codeline">                                            QueryCall);</td>
    <td class="lineNumber">795</td>
    <td class="codeline">                                            QueryCall);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">796</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">797</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class="codeline"></td>
    <td class="lineNumber">798</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class="codeline">    // Find out if this block has a local dependency for QueryInst.</td>
    <td class="lineNumber">799</td>
    <td class="codeline">    // Find out if this block has a local dependency for QueryInst.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class="codeline">    MemDepResult Dep;</td>
    <td class="lineNumber">800</td>
    <td class="codeline">    MemDepResult Dep;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class="codeline"></td>
    <td class="lineNumber">801</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class="codeline">    if (ScanPos != DirtyBB->begin()) {</td>
    <td class="lineNumber">802</td>
    <td class="codeline">    if (ScanPos != DirtyBB->begin()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class="codeline">      Dep = getCallDependencyFrom(QueryCall, isReadonlyCall, ScanPos, DirtyBB);</td>
    <td class="lineNumber">803</td>
    <td class="codeline">      Dep = getCallDependencyFrom(QueryCall, isReadonlyCall, ScanPos, DirtyBB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class="codeline">    } else if (DirtyBB != &DirtyBB->getParent()->getEntryBlock()) {</td>
    <td class="lineNumber">804</td>
    <td class="codeline">    } else if (DirtyBB != &DirtyBB->getParent()->getEntryBlock()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class="codeline">      // No dependence found.  If this is the entry block of the function, it is</td>
    <td class="lineNumber">805</td>
    <td class="codeline">      // No dependence found.  If this is the entry block of the function, it is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class="codeline">      // a clobber, otherwise it is unknown.</td>
    <td class="lineNumber">806</td>
    <td class="codeline">      // a clobber, otherwise it is unknown.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class="codeline">      Dep = MemDepResult::getNonLocal();</td>
    <td class="lineNumber">807</td>
    <td class="codeline">      Dep = MemDepResult::getNonLocal();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class="codeline">    } else {</td>
    <td class="lineNumber">808</td>
    <td class="codeline">    } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class="codeline">      Dep = MemDepResult::getNonFuncLocal();</td>
    <td class="lineNumber">809</td>
    <td class="codeline">      Dep = MemDepResult::getNonFuncLocal();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">810</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class="codeline"></td>
    <td class="lineNumber">811</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class="codeline">    // If we had a dirty entry for the block, update it.  Otherwise, just add</td>
    <td class="lineNumber">812</td>
    <td class="codeline">    // If we had a dirty entry for the block, update it.  Otherwise, just add</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class="codeline">    // a new entry.</td>
    <td class="lineNumber">813</td>
    <td class="codeline">    // a new entry.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class="codeline">    if (ExistingResult)</td>
    <td class="lineNumber">814</td>
    <td class="codeline">    if (ExistingResult)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class="codeline">      ExistingResult->setResult(Dep);</td>
    <td class="lineNumber">815</td>
    <td class="codeline">      ExistingResult->setResult(Dep);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class="codeline">    else</td>
    <td class="lineNumber">816</td>
    <td class="codeline">    else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class="codeline">      Cache.push_back(NonLocalDepEntry(DirtyBB, Dep));</td>
    <td class="lineNumber">817</td>
    <td class="codeline">      Cache.push_back(NonLocalDepEntry(DirtyBB, Dep));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class="codeline"></td>
    <td class="lineNumber">818</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class="codeline">    // If the block has a dependency (i.e. it isn't completely transparent to</td>
    <td class="lineNumber">819</td>
    <td class="codeline">    // If the block has a dependency (i.e. it isn't completely transparent to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class="codeline">    // the value), remember the association!</td>
    <td class="lineNumber">820</td>
    <td class="codeline">    // the value), remember the association!</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class="codeline">    if (!Dep.isNonLocal()) {</td>
    <td class="lineNumber">821</td>
    <td class="codeline">    if (!Dep.isNonLocal()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class="codeline">      // Keep the ReverseNonLocalDeps map up to date so we can efficiently</td>
    <td class="lineNumber">822</td>
    <td class="codeline">      // Keep the ReverseNonLocalDeps map up to date so we can efficiently</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class="codeline">      // update this when we remove instructions.</td>
    <td class="lineNumber">823</td>
    <td class="codeline">      // update this when we remove instructions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class="codeline">      if (Instruction *Inst = Dep.getInst())</td>
    <td class="lineNumber">824</td>
    <td class="codeline">      if (Instruction *Inst = Dep.getInst())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class="codeline">        ReverseNonLocalDeps[Inst].insert(QueryCall);</td>
    <td class="lineNumber">825</td>
    <td class="codeline">        ReverseNonLocalDeps[Inst].insert(QueryCall);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class="codeline">    } else {</td>
    <td class="lineNumber">826</td>
    <td class="codeline">    } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class="codeline"></td>
    <td class="lineNumber">827</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class="codeline">      // If the block *is* completely transparent to the load, we need to check</td>
    <td class="lineNumber">828</td>
    <td class="codeline">      // If the block *is* completely transparent to the load, we need to check</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class="codeline">      // the predecessors of this block.  Add them to our worklist.</td>
    <td class="lineNumber">829</td>
    <td class="codeline">      // the predecessors of this block.  Add them to our worklist.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class="codeline">      append_range(DirtyBlocks, PredCache.get(DirtyBB));</td>
    <td class="lineNumber">830</td>
    <td class="codeline">      append_range(DirtyBlocks, PredCache.get(DirtyBB));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">831</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">832</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class="codeline"></td>
    <td class="lineNumber">833</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class="codeline">  return Cache;</td>
    <td class="lineNumber">834</td>
    <td class="codeline">  return Cache;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class="codeline">}</td>
    <td class="lineNumber">835</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class="codeline"></td>
    <td class="lineNumber">836</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class="codeline">void MemoryDependenceResults::getNonLocalPointerDependency(</td>
    <td class="lineNumber">837</td>
    <td class="codeline">void MemoryDependenceResults::getNonLocalPointerDependency(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class="codeline">    Instruction *QueryInst, SmallVectorImpl<NonLocalDepResult> &Result) {</td>
    <td class="lineNumber">838</td>
    <td class="codeline">    Instruction *QueryInst, SmallVectorImpl<NonLocalDepResult> &Result) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class="codeline">  const MemoryLocation Loc = MemoryLocation::get(QueryInst);</td>
    <td class="lineNumber">839</td>
    <td class="codeline">  const MemoryLocation Loc = MemoryLocation::get(QueryInst);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class="codeline">  bool isLoad = isa<LoadInst>(QueryInst);</td>
    <td class="lineNumber">840</td>
    <td class="codeline">  bool isLoad = isa<LoadInst>(QueryInst);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class="codeline">  BasicBlock *FromBB = QueryInst->getParent();</td>
    <td class="lineNumber">841</td>
    <td class="codeline">  BasicBlock *FromBB = QueryInst->getParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class="codeline">  assert(FromBB);</td>
    <td class="lineNumber">842</td>
    <td class="codeline">  assert(FromBB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class="codeline"></td>
    <td class="lineNumber">843</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class="codeline">  assert(Loc.Ptr->getType()->isPointerTy() &&</td>
    <td class="lineNumber">844</td>
    <td class="codeline">  assert(Loc.Ptr->getType()->isPointerTy() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class="codeline">         "Can't get pointer deps of a non-pointer!");</td>
    <td class="lineNumber">845</td>
    <td class="codeline">         "Can't get pointer deps of a non-pointer!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class="codeline">  Result.clear();</td>
    <td class="lineNumber">846</td>
    <td class="codeline">  Result.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class="codeline">  {</td>
    <td class="lineNumber">847</td>
    <td class="codeline">  {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class="codeline">    // Check if there is cached Def with invariant.group.</td>
    <td class="lineNumber">848</td>
    <td class="codeline">    // Check if there is cached Def with invariant.group.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class="codeline">    auto NonLocalDefIt = NonLocalDefsCache.find(QueryInst);</td>
    <td class="lineNumber">849</td>
    <td class="codeline">    auto NonLocalDefIt = NonLocalDefsCache.find(QueryInst);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class="codeline">    if (NonLocalDefIt != NonLocalDefsCache.end()) {</td>
    <td class="lineNumber">850</td>
    <td class="codeline">    if (NonLocalDefIt != NonLocalDefsCache.end()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class="codeline">      Result.push_back(NonLocalDefIt->second);</td>
    <td class="lineNumber">851</td>
    <td class="codeline">      Result.push_back(NonLocalDefIt->second);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class="codeline">      ReverseNonLocalDefsCache[NonLocalDefIt->second.getResult().getInst()]</td>
    <td class="lineNumber">852</td>
    <td class="codeline">      ReverseNonLocalDefsCache[NonLocalDefIt->second.getResult().getInst()]</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class="codeline">          .erase(QueryInst);</td>
    <td class="lineNumber">853</td>
    <td class="codeline">          .erase(QueryInst);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class="codeline">      NonLocalDefsCache.erase(NonLocalDefIt);</td>
    <td class="lineNumber">854</td>
    <td class="codeline">      NonLocalDefsCache.erase(NonLocalDefIt);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class="codeline">      return;</td>
    <td class="lineNumber">855</td>
    <td class="codeline">      return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">856</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">857</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class="codeline">  // This routine does not expect to deal with volatile instructions.</td>
    <td class="lineNumber">858</td>
    <td class="codeline">  // This routine does not expect to deal with volatile instructions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class="codeline">  // Doing so would require piping through the QueryInst all the way through.</td>
    <td class="lineNumber">859</td>
    <td class="codeline">  // Doing so would require piping through the QueryInst all the way through.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class="codeline">  // TODO: volatiles can't be elided, but they can be reordered with other</td>
    <td class="lineNumber">860</td>
    <td class="codeline">  // TODO: volatiles can't be elided, but they can be reordered with other</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class="codeline">  // non-volatile accesses.</td>
    <td class="lineNumber">861</td>
    <td class="codeline">  // non-volatile accesses.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class="codeline"></td>
    <td class="lineNumber">862</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class="codeline">  // We currently give up on any instruction which is ordered, but we do handle</td>
    <td class="lineNumber">863</td>
    <td class="codeline">  // We currently give up on any instruction which is ordered, but we do handle</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class="codeline">  // atomic instructions which are unordered.</td>
    <td class="lineNumber">864</td>
    <td class="codeline">  // atomic instructions which are unordered.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class="codeline">  // TODO: Handle ordered instructions</td>
    <td class="lineNumber">865</td>
    <td class="codeline">  // TODO: Handle ordered instructions</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class="codeline">  auto isOrdered = [](Instruction *Inst) {</td>
    <td class="lineNumber">866</td>
    <td class="codeline">  auto isOrdered = [](Instruction *Inst) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class="codeline">    if (LoadInst *LI = dyn_cast<LoadInst>(Inst)) {</td>
    <td class="lineNumber">867</td>
    <td class="codeline">    if (LoadInst *LI = dyn_cast<LoadInst>(Inst)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class="codeline">      return !LI->isUnordered();</td>
    <td class="lineNumber">868</td>
    <td class="codeline">      return !LI->isUnordered();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class="codeline">    } else if (StoreInst *SI = dyn_cast<StoreInst>(Inst)) {</td>
    <td class="lineNumber">869</td>
    <td class="codeline">    } else if (StoreInst *SI = dyn_cast<StoreInst>(Inst)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="codeline">      return !SI->isUnordered();</td>
    <td class="lineNumber">870</td>
    <td class="codeline">      return !SI->isUnordered();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">871</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">872</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">872</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">873</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">873</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">874</td>
    <td class="codeline">  if (QueryInst->isVolatile() || isOrdered(QueryInst)) {</td>
    <td class="lineNumber">874</td>
    <td class="codeline">  if (QueryInst->isVolatile() || isOrdered(QueryInst)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">875</td>
    <td class="codeline">    Result.push_back(NonLocalDepResult(FromBB, MemDepResult::getUnknown(),</td>
    <td class="lineNumber">875</td>
    <td class="codeline">    Result.push_back(NonLocalDepResult(FromBB, MemDepResult::getUnknown(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">876</td>
    <td class="codeline">                                       const_cast<Value *>(Loc.Ptr)));</td>
    <td class="lineNumber">876</td>
    <td class="codeline">                                       const_cast<Value *>(Loc.Ptr)));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">877</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">877</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">878</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">878</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">879</td>
    <td class="codeline">  const DataLayout &DL = FromBB->getModule()->getDataLayout();</td>
    <td class="lineNumber">879</td>
    <td class="codeline">  const DataLayout &DL = FromBB->getModule()->getDataLayout();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">880</td>
    <td class="codeline">  PHITransAddr Address(const_cast<Value *>(Loc.Ptr), DL, &AC);</td>
    <td class="lineNumber">880</td>
    <td class="codeline">  PHITransAddr Address(const_cast<Value *>(Loc.Ptr), DL, &AC);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">881</td>
    <td class="codeline"></td>
    <td class="lineNumber">881</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">882</td>
    <td class="codeline">  // This is the set of blocks we've inspected, and the pointer we consider in</td>
    <td class="lineNumber">882</td>
    <td class="codeline">  // This is the set of blocks we've inspected, and the pointer we consider in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">883</td>
    <td class="codeline">  // each block.  Because of critical edges, we currently bail out if querying</td>
    <td class="lineNumber">883</td>
    <td class="codeline">  // each block.  Because of critical edges, we currently bail out if querying</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">884</td>
    <td class="codeline">  // a block with multiple different pointers.  This can happen during PHI</td>
    <td class="lineNumber">884</td>
    <td class="codeline">  // a block with multiple different pointers.  This can happen during PHI</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">885</td>
    <td class="codeline">  // translation.</td>
    <td class="lineNumber">885</td>
    <td class="codeline">  // translation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">886</td>
    <td class="codeline">  DenseMap<BasicBlock *, Value *> Visited;</td>
    <td class="lineNumber">886</td>
    <td class="codeline">  DenseMap<BasicBlock *, Value *> Visited;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">887</td>
    <td class="codeline">  if (getNonLocalPointerDepFromBB(QueryInst, Address, Loc, isLoad, FromBB,</td>
    <td class="lineNumber">887</td>
    <td class="codeline">  if (getNonLocalPointerDepFromBB(QueryInst, Address, Loc, isLoad, FromBB,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">888</td>
    <td class="codeline">                                   Result, Visited, true))</td>
    <td class="lineNumber">888</td>
    <td class="codeline">                                   Result, Visited, true))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">889</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">889</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">890</td>
    <td class="codeline">  Result.clear();</td>
    <td class="lineNumber">890</td>
    <td class="codeline">  Result.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">891</td>
    <td class="codeline">  Result.push_back(NonLocalDepResult(FromBB, MemDepResult::getUnknown(),</td>
    <td class="lineNumber">891</td>
    <td class="codeline">  Result.push_back(NonLocalDepResult(FromBB, MemDepResult::getUnknown(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">892</td>
    <td class="codeline">                                     const_cast<Value *>(Loc.Ptr)));</td>
    <td class="lineNumber">892</td>
    <td class="codeline">                                     const_cast<Value *>(Loc.Ptr)));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">893</td>
    <td class="codeline">}</td>
    <td class="lineNumber">893</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">894</td>
    <td class="codeline"></td>
    <td class="lineNumber">894</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">895</td>
    <td class="codeline">/// Compute the memdep value for BB with Pointer/PointeeSize using either</td>
    <td class="lineNumber">895</td>
    <td class="codeline">/// Compute the memdep value for BB with Pointer/PointeeSize using either</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">896</td>
    <td class="codeline">/// cached information in Cache or by doing a lookup (which may use dirty cache</td>
    <td class="lineNumber">896</td>
    <td class="codeline">/// cached information in Cache or by doing a lookup (which may use dirty cache</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">897</td>
    <td class="codeline">/// info if available).</td>
    <td class="lineNumber">897</td>
    <td class="codeline">/// info if available).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">898</td>
    <td class="codeline">///</td>
    <td class="lineNumber">898</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">899</td>
    <td class="codeline">/// If we do a lookup, add the result to the cache.</td>
    <td class="lineNumber">899</td>
    <td class="codeline">/// If we do a lookup, add the result to the cache.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">900</td>
    <td class="codeline">MemDepResult MemoryDependenceResults::getNonLocalInfoForBlock(</td>
    <td class="lineNumber">900</td>
    <td class="codeline">MemDepResult MemoryDependenceResults::getNonLocalInfoForBlock(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">901</td>
    <td class="codeline">    Instruction *QueryInst, const MemoryLocation &Loc, bool isLoad,</td>
    <td class="lineNumber">901</td>
    <td class="codeline">    Instruction *QueryInst, const MemoryLocation &Loc, bool isLoad,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">902</td>
    <td class="codeline">    BasicBlock *BB, NonLocalDepInfo *Cache, unsigned NumSortedEntries,</td>
    <td class="lineNumber">902</td>
    <td class="codeline">    BasicBlock *BB, NonLocalDepInfo *Cache, unsigned NumSortedEntries,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">903</td>
    <td class="codeline">    BatchAAResults &BatchAA) {</td>
    <td class="lineNumber">903</td>
    <td class="codeline">    BatchAAResults &BatchAA) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">904</td>
    <td class="codeline"></td>
    <td class="lineNumber">904</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">905</td>
    <td class="codeline">  bool isInvariantLoad = false;</td>
    <td class="lineNumber">905</td>
    <td class="codeline">  bool isInvariantLoad = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">906</td>
    <td class="codeline"></td>
    <td class="lineNumber">906</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">907</td>
    <td class="codeline">  if (LoadInst *LI = dyn_cast_or_null<LoadInst>(QueryInst))</td>
    <td class="lineNumber">907</td>
    <td class="codeline">  if (LoadInst *LI = dyn_cast_or_null<LoadInst>(QueryInst))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">908</td>
    <td class="codeline">    isInvariantLoad = LI->getMetadata(LLVMContext::MD_invariant_load);</td>
    <td class="lineNumber">908</td>
    <td class="codeline">    isInvariantLoad = LI->getMetadata(LLVMContext::MD_invariant_load);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">909</td>
    <td class="codeline"></td>
    <td class="lineNumber">909</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">910</td>
    <td class="codeline">  // Do a binary search to see if we already have an entry for this block in</td>
    <td class="lineNumber">910</td>
    <td class="codeline">  // Do a binary search to see if we already have an entry for this block in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">911</td>
    <td class="codeline">  // the cache set.  If so, find it.</td>
    <td class="lineNumber">911</td>
    <td class="codeline">  // the cache set.  If so, find it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">912</td>
    <td class="codeline">  NonLocalDepInfo::iterator Entry = std::upper_bound(</td>
    <td class="lineNumber">912</td>
    <td class="codeline">  NonLocalDepInfo::iterator Entry = std::upper_bound(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">913</td>
    <td class="codeline">      Cache->begin(), Cache->begin() + NumSortedEntries, NonLocalDepEntry(BB));</td>
    <td class="lineNumber">913</td>
    <td class="codeline">      Cache->begin(), Cache->begin() + NumSortedEntries, NonLocalDepEntry(BB));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">914</td>
    <td class="codeline">  if (Entry != Cache->begin() && (Entry - 1)->getBB() == BB)</td>
    <td class="lineNumber">914</td>
    <td class="codeline">  if (Entry != Cache->begin() && (Entry - 1)->getBB() == BB)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">915</td>
    <td class="codeline">    --Entry;</td>
    <td class="lineNumber">915</td>
    <td class="codeline">    --Entry;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">916</td>
    <td class="codeline"></td>
    <td class="lineNumber">916</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">917</td>
    <td class="codeline">  NonLocalDepEntry *ExistingResult = nullptr;</td>
    <td class="lineNumber">917</td>
    <td class="codeline">  NonLocalDepEntry *ExistingResult = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">918</td>
    <td class="codeline">  if (Entry != Cache->begin() + NumSortedEntries && Entry->getBB() == BB)</td>
    <td class="lineNumber">918</td>
    <td class="codeline">  if (Entry != Cache->begin() + NumSortedEntries && Entry->getBB() == BB)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">919</td>
    <td class="codeline">    ExistingResult = &*Entry;</td>
    <td class="lineNumber">919</td>
    <td class="codeline">    ExistingResult = &*Entry;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">920</td>
    <td class="codeline"></td>
    <td class="lineNumber">920</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">921</td>
    <td class="codeline">  // Use cached result for invariant load only if there is no dependency for non</td>
    <td class="lineNumber">921</td>
    <td class="codeline">  // Use cached result for invariant load only if there is no dependency for non</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">922</td>
    <td class="codeline">  // invariant load. In this case invariant load can not have any dependency as</td>
    <td class="lineNumber">922</td>
    <td class="codeline">  // invariant load. In this case invariant load can not have any dependency as</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">923</td>
    <td class="codeline">  // well.</td>
    <td class="lineNumber">923</td>
    <td class="codeline">  // well.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">924</td>
    <td class="codeline">  if (ExistingResult && isInvariantLoad &&</td>
    <td class="lineNumber">924</td>
    <td class="codeline">  if (ExistingResult && isInvariantLoad &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">925</td>
    <td class="codeline">      !ExistingResult->getResult().isNonFuncLocal())</td>
    <td class="lineNumber">925</td>
    <td class="codeline">      !ExistingResult->getResult().isNonFuncLocal())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">926</td>
    <td class="codeline">    ExistingResult = nullptr;</td>
    <td class="lineNumber">926</td>
    <td class="codeline">    ExistingResult = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">927</td>
    <td class="codeline"></td>
    <td class="lineNumber">927</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">928</td>
    <td class="codeline">  // If we have a cached entry, and it is non-dirty, use it as the value for</td>
    <td class="lineNumber">928</td>
    <td class="codeline">  // If we have a cached entry, and it is non-dirty, use it as the value for</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">929</td>
    <td class="codeline">  // this dependency.</td>
    <td class="lineNumber">929</td>
    <td class="codeline">  // this dependency.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">930</td>
    <td class="codeline">  if (ExistingResult && !ExistingResult->getResult().isDirty()) {</td>
    <td class="lineNumber">930</td>
    <td class="codeline">  if (ExistingResult && !ExistingResult->getResult().isDirty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">931</td>
    <td class="codeline">    ++NumCacheNonLocalPtr;</td>
    <td class="lineNumber">931</td>
    <td class="codeline">    ++NumCacheNonLocalPtr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">932</td>
    <td class="codeline">    return ExistingResult->getResult();</td>
    <td class="lineNumber">932</td>
    <td class="codeline">    return ExistingResult->getResult();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">933</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">933</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">934</td>
    <td class="codeline"></td>
    <td class="lineNumber">934</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">935</td>
    <td class="codeline">  // Otherwise, we have to scan for the value.  If we have a dirty cache</td>
    <td class="lineNumber">935</td>
    <td class="codeline">  // Otherwise, we have to scan for the value.  If we have a dirty cache</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">936</td>
    <td class="codeline">  // entry, start scanning from its position, otherwise we scan from the end</td>
    <td class="lineNumber">936</td>
    <td class="codeline">  // entry, start scanning from its position, otherwise we scan from the end</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">937</td>
    <td class="codeline">  // of the block.</td>
    <td class="lineNumber">937</td>
    <td class="codeline">  // of the block.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">938</td>
    <td class="codeline">  BasicBlock::iterator ScanPos = BB->end();</td>
    <td class="lineNumber">938</td>
    <td class="codeline">  BasicBlock::iterator ScanPos = BB->end();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">939</td>
    <td class="codeline">  if (ExistingResult && ExistingResult->getResult().getInst()) {</td>
    <td class="lineNumber">939</td>
    <td class="codeline">  if (ExistingResult && ExistingResult->getResult().getInst()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">940</td>
    <td class="codeline">    assert(ExistingResult->getResult().getInst()->getParent() == BB &&</td>
    <td class="lineNumber">940</td>
    <td class="codeline">    assert(ExistingResult->getResult().getInst()->getParent() == BB &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">941</td>
    <td class="codeline">           "Instruction invalidated?");</td>
    <td class="lineNumber">941</td>
    <td class="codeline">           "Instruction invalidated?");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">942</td>
    <td class="codeline">    ++NumCacheDirtyNonLocalPtr;</td>
    <td class="lineNumber">942</td>
    <td class="codeline">    ++NumCacheDirtyNonLocalPtr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">943</td>
    <td class="codeline">    ScanPos = ExistingResult->getResult().getInst()->getIterator();</td>
    <td class="lineNumber">943</td>
    <td class="codeline">    ScanPos = ExistingResult->getResult().getInst()->getIterator();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">944</td>
    <td class="codeline"></td>
    <td class="lineNumber">944</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">945</td>
    <td class="codeline">    // Eliminating the dirty entry from 'Cache', so update the reverse info.</td>
    <td class="lineNumber">945</td>
    <td class="codeline">    // Eliminating the dirty entry from 'Cache', so update the reverse info.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">946</td>
    <td class="codeline">    ValueIsLoadPair CacheKey(Loc.Ptr, isLoad);</td>
    <td class="lineNumber">946</td>
    <td class="codeline">    ValueIsLoadPair CacheKey(Loc.Ptr, isLoad);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">947</td>
    <td class="codeline">    RemoveFromReverseMap(ReverseNonLocalPtrDeps, &*ScanPos, CacheKey);</td>
    <td class="lineNumber">947</td>
    <td class="codeline">    RemoveFromReverseMap(ReverseNonLocalPtrDeps, &*ScanPos, CacheKey);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">948</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">948</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">949</td>
    <td class="codeline">    ++NumUncacheNonLocalPtr;</td>
    <td class="lineNumber">949</td>
    <td class="codeline">    ++NumUncacheNonLocalPtr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">950</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">950</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">951</td>
    <td class="codeline"></td>
    <td class="lineNumber">951</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">952</td>
    <td class="codeline">  // Scan the block for the dependency.</td>
    <td class="lineNumber">952</td>
    <td class="codeline">  // Scan the block for the dependency.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">953</td>
    <td class="codeline">  MemDepResult Dep = getPointerDependencyFrom(Loc, isLoad, ScanPos, BB,</td>
    <td class="lineNumber">953</td>
    <td class="codeline">  MemDepResult Dep = getPointerDependencyFrom(Loc, isLoad, ScanPos, BB,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">954</td>
    <td class="codeline">                                              QueryInst, nullptr, BatchAA);</td>
    <td class="lineNumber">954</td>
    <td class="codeline">                                              QueryInst, nullptr, BatchAA);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">955</td>
    <td class="codeline"></td>
    <td class="lineNumber">955</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">956</td>
    <td class="codeline">  // Don't cache results for invariant load.</td>
    <td class="lineNumber">956</td>
    <td class="codeline">  // Don't cache results for invariant load.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">957</td>
    <td class="codeline">  if (isInvariantLoad)</td>
    <td class="lineNumber">957</td>
    <td class="codeline">  if (isInvariantLoad)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">958</td>
    <td class="codeline">    return Dep;</td>
    <td class="lineNumber">958</td>
    <td class="codeline">    return Dep;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">959</td>
    <td class="codeline"></td>
    <td class="lineNumber">959</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">960</td>
    <td class="codeline">  // If we had a dirty entry for the block, update it.  Otherwise, just add</td>
    <td class="lineNumber">960</td>
    <td class="codeline">  // If we had a dirty entry for the block, update it.  Otherwise, just add</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">961</td>
    <td class="codeline">  // a new entry.</td>
    <td class="lineNumber">961</td>
    <td class="codeline">  // a new entry.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">962</td>
    <td class="codeline">  if (ExistingResult)</td>
    <td class="lineNumber">962</td>
    <td class="codeline">  if (ExistingResult)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">963</td>
    <td class="codeline">    ExistingResult->setResult(Dep);</td>
    <td class="lineNumber">963</td>
    <td class="codeline">    ExistingResult->setResult(Dep);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">964</td>
    <td class="codeline">  else</td>
    <td class="lineNumber">964</td>
    <td class="codeline">  else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">965</td>
    <td class="codeline">    Cache->push_back(NonLocalDepEntry(BB, Dep));</td>
    <td class="lineNumber">965</td>
    <td class="codeline">    Cache->push_back(NonLocalDepEntry(BB, Dep));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">966</td>
    <td class="codeline"></td>
    <td class="lineNumber">966</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">967</td>
    <td class="codeline">  // If the block has a dependency (i.e. it isn't completely transparent to</td>
    <td class="lineNumber">967</td>
    <td class="codeline">  // If the block has a dependency (i.e. it isn't completely transparent to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">968</td>
    <td class="codeline">  // the value), remember the reverse association because we just added it</td>
    <td class="lineNumber">968</td>
    <td class="codeline">  // the value), remember the reverse association because we just added it</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">969</td>
    <td class="codeline">  // to Cache!</td>
    <td class="lineNumber">969</td>
    <td class="codeline">  // to Cache!</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">970</td>
    <td class="codeline">  if (!Dep.isLocal())</td>
    <td class="lineNumber">970</td>
    <td class="codeline">  if (!Dep.isLocal())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">971</td>
    <td class="codeline">    return Dep;</td>
    <td class="lineNumber">971</td>
    <td class="codeline">    return Dep;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">972</td>
    <td class="codeline"></td>
    <td class="lineNumber">972</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">973</td>
    <td class="codeline">  // Keep the ReverseNonLocalPtrDeps map up to date so we can efficiently</td>
    <td class="lineNumber">973</td>
    <td class="codeline">  // Keep the ReverseNonLocalPtrDeps map up to date so we can efficiently</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">974</td>
    <td class="codeline">  // update MemDep when we remove instructions.</td>
    <td class="lineNumber">974</td>
    <td class="codeline">  // update MemDep when we remove instructions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">975</td>
    <td class="codeline">  Instruction *Inst = Dep.getInst();</td>
    <td class="lineNumber">975</td>
    <td class="codeline">  Instruction *Inst = Dep.getInst();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">976</td>
    <td class="codeline">  assert(Inst && "Didn't depend on anything?");</td>
    <td class="lineNumber">976</td>
    <td class="codeline">  assert(Inst && "Didn't depend on anything?");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">977</td>
    <td class="codeline">  ValueIsLoadPair CacheKey(Loc.Ptr, isLoad);</td>
    <td class="lineNumber">977</td>
    <td class="codeline">  ValueIsLoadPair CacheKey(Loc.Ptr, isLoad);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">978</td>
    <td class="codeline">  ReverseNonLocalPtrDeps[Inst].insert(CacheKey);</td>
    <td class="lineNumber">978</td>
    <td class="codeline">  ReverseNonLocalPtrDeps[Inst].insert(CacheKey);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">979</td>
    <td class="codeline">  return Dep;</td>
    <td class="lineNumber">979</td>
    <td class="codeline">  return Dep;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">980</td>
    <td class="codeline">}</td>
    <td class="lineNumber">980</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">981</td>
    <td class="codeline"></td>
    <td class="lineNumber">981</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">982</td>
    <td class="codeline">/// Sort the NonLocalDepInfo cache, given a certain number of elements in the</td>
    <td class="lineNumber">982</td>
    <td class="codeline">/// Sort the NonLocalDepInfo cache, given a certain number of elements in the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">983</td>
    <td class="codeline">/// array that are already properly ordered.</td>
    <td class="lineNumber">983</td>
    <td class="codeline">/// array that are already properly ordered.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">984</td>
    <td class="codeline">///</td>
    <td class="lineNumber">984</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">985</td>
    <td class="codeline">/// This is optimized for the case when only a few entries are added.</td>
    <td class="lineNumber">985</td>
    <td class="codeline">/// This is optimized for the case when only a few entries are added.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">986</td>
    <td class="codeline">static void</td>
    <td class="lineNumber">986</td>
    <td class="codeline">static void</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">987</td>
    <td class="codeline">SortNonLocalDepInfoCache(MemoryDependenceResults::NonLocalDepInfo &Cache,</td>
    <td class="lineNumber">987</td>
    <td class="codeline">SortNonLocalDepInfoCache(MemoryDependenceResults::NonLocalDepInfo &Cache,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">988</td>
    <td class="codeline">                         unsigned NumSortedEntries) {</td>
    <td class="lineNumber">988</td>
    <td class="codeline">                         unsigned NumSortedEntries) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">989</td>
    <td class="codeline">  switch (Cache.size() - NumSortedEntries) {</td>
    <td class="lineNumber">989</td>
    <td class="codeline">  switch (Cache.size() - NumSortedEntries) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">990</td>
    <td class="codeline">  case 0:</td>
    <td class="lineNumber">990</td>
    <td class="codeline">  case 0:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">991</td>
    <td class="codeline">    // done, no new entries.</td>
    <td class="lineNumber">991</td>
    <td class="codeline">    // done, no new entries.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">992</td>
    <td class="codeline">    break;</td>
    <td class="lineNumber">992</td>
    <td class="codeline">    break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">993</td>
    <td class="codeline">  case 2: {</td>
    <td class="lineNumber">993</td>
    <td class="codeline">  case 2: {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">994</td>
    <td class="codeline">    // Two new entries, insert the last one into place.</td>
    <td class="lineNumber">994</td>
    <td class="codeline">    // Two new entries, insert the last one into place.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">995</td>
    <td class="codeline">    NonLocalDepEntry Val = Cache.back();</td>
    <td class="lineNumber">995</td>
    <td class="codeline">    NonLocalDepEntry Val = Cache.back();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">996</td>
    <td class="codeline">    Cache.pop_back();</td>
    <td class="lineNumber">996</td>
    <td class="codeline">    Cache.pop_back();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">997</td>
    <td class="codeline">    MemoryDependenceResults::NonLocalDepInfo::iterator Entry =</td>
    <td class="lineNumber">997</td>
    <td class="codeline">    MemoryDependenceResults::NonLocalDepInfo::iterator Entry =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">998</td>
    <td class="codeline">        std::upper_bound(Cache.begin(), Cache.end() - 1, Val);</td>
    <td class="lineNumber">998</td>
    <td class="codeline">        std::upper_bound(Cache.begin(), Cache.end() - 1, Val);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">999</td>
    <td class="codeline">    Cache.insert(Entry, Val);</td>
    <td class="lineNumber">999</td>
    <td class="codeline">    Cache.insert(Entry, Val);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1000</td>
    <td class="codeline">    [[fallthrough]];</td>
    <td class="lineNumber">1000</td>
    <td class="codeline">    [[fallthrough]];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1001</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1001</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1002</td>
    <td class="codeline">  case 1:</td>
    <td class="lineNumber">1002</td>
    <td class="codeline">  case 1:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1003</td>
    <td class="codeline">    // One new entry, Just insert the new value at the appropriate position.</td>
    <td class="lineNumber">1003</td>
    <td class="codeline">    // One new entry, Just insert the new value at the appropriate position.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1004</td>
    <td class="codeline">    if (Cache.size() != 1) {</td>
    <td class="lineNumber">1004</td>
    <td class="codeline">    if (Cache.size() != 1) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1005</td>
    <td class="codeline">      NonLocalDepEntry Val = Cache.back();</td>
    <td class="lineNumber">1005</td>
    <td class="codeline">      NonLocalDepEntry Val = Cache.back();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1006</td>
    <td class="codeline">      Cache.pop_back();</td>
    <td class="lineNumber">1006</td>
    <td class="codeline">      Cache.pop_back();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1007</td>
    <td class="codeline">      MemoryDependenceResults::NonLocalDepInfo::iterator Entry =</td>
    <td class="lineNumber">1007</td>
    <td class="codeline">      MemoryDependenceResults::NonLocalDepInfo::iterator Entry =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1008</td>
    <td class="codeline">          llvm::upper_bound(Cache, Val);</td>
    <td class="lineNumber">1008</td>
    <td class="codeline">          llvm::upper_bound(Cache, Val);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1009</td>
    <td class="codeline">      Cache.insert(Entry, Val);</td>
    <td class="lineNumber">1009</td>
    <td class="codeline">      Cache.insert(Entry, Val);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1010</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1010</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1011</td>
    <td class="codeline">    break;</td>
    <td class="lineNumber">1011</td>
    <td class="codeline">    break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1012</td>
    <td class="codeline">  default:</td>
    <td class="lineNumber">1012</td>
    <td class="codeline">  default:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1013</td>
    <td class="codeline">    // Added many values, do a full scale sort.</td>
    <td class="lineNumber">1013</td>
    <td class="codeline">    // Added many values, do a full scale sort.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1014</td>
    <td class="codeline">    llvm::sort(Cache);</td>
    <td class="lineNumber">1014</td>
    <td class="codeline">    llvm::sort(Cache);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1015</td>
    <td class="codeline">    break;</td>
    <td class="lineNumber">1015</td>
    <td class="codeline">    break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1016</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1016</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1017</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1017</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1018</td>
    <td class="codeline"></td>
    <td class="lineNumber">1018</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1019</td>
    <td class="codeline">/// Perform a dependency query based on pointer/pointeesize starting at the end</td>
    <td class="lineNumber">1019</td>
    <td class="codeline">/// Perform a dependency query based on pointer/pointeesize starting at the end</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1020</td>
    <td class="codeline">/// of StartBB.</td>
    <td class="lineNumber">1020</td>
    <td class="codeline">/// of StartBB.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1021</td>
    <td class="codeline">///</td>
    <td class="lineNumber">1021</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1022</td>
    <td class="codeline">/// Add any clobber/def results to the results vector and keep track of which</td>
    <td class="lineNumber">1022</td>
    <td class="codeline">/// Add any clobber/def results to the results vector and keep track of which</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1023</td>
    <td class="codeline">/// blocks are visited in 'Visited'.</td>
    <td class="lineNumber">1023</td>
    <td class="codeline">/// blocks are visited in 'Visited'.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1024</td>
    <td class="codeline">///</td>
    <td class="lineNumber">1024</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1025</td>
    <td class="codeline">/// This has special behavior for the first block queries (when SkipFirstBlock</td>
    <td class="lineNumber">1025</td>
    <td class="codeline">/// This has special behavior for the first block queries (when SkipFirstBlock</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1026</td>
    <td class="codeline">/// is true).  In this special case, it ignores the contents of the specified</td>
    <td class="lineNumber">1026</td>
    <td class="codeline">/// is true).  In this special case, it ignores the contents of the specified</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1027</td>
    <td class="codeline">/// block and starts returning dependence info for its predecessors.</td>
    <td class="lineNumber">1027</td>
    <td class="codeline">/// block and starts returning dependence info for its predecessors.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1028</td>
    <td class="codeline">///</td>
    <td class="lineNumber">1028</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1029</td>
    <td class="codeline">/// This function returns true on success, or false to indicate that it could</td>
    <td class="lineNumber">1029</td>
    <td class="codeline">/// This function returns true on success, or false to indicate that it could</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1030</td>
    <td class="codeline">/// not compute dependence information for some reason.  This should be treated</td>
    <td class="lineNumber">1030</td>
    <td class="codeline">/// not compute dependence information for some reason.  This should be treated</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1031</td>
    <td class="codeline">/// as a clobber dependence on the first instruction in the predecessor block.</td>
    <td class="lineNumber">1031</td>
    <td class="codeline">/// as a clobber dependence on the first instruction in the predecessor block.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1032</td>
    <td class="codeline">bool MemoryDependenceResults::getNonLocalPointerDepFromBB(</td>
    <td class="lineNumber">1032</td>
    <td class="codeline">bool MemoryDependenceResults::getNonLocalPointerDepFromBB(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1033</td>
    <td class="codeline">    Instruction *QueryInst, const PHITransAddr &Pointer,</td>
    <td class="lineNumber">1033</td>
    <td class="codeline">    Instruction *QueryInst, const PHITransAddr &Pointer,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1034</td>
    <td class="codeline">    const MemoryLocation &Loc, bool isLoad, BasicBlock *StartBB,</td>
    <td class="lineNumber">1034</td>
    <td class="codeline">    const MemoryLocation &Loc, bool isLoad, BasicBlock *StartBB,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1035</td>
    <td class="codeline">    SmallVectorImpl<NonLocalDepResult> &Result,</td>
    <td class="lineNumber">1035</td>
    <td class="codeline">    SmallVectorImpl<NonLocalDepResult> &Result,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1036</td>
    <td class="codeline">    DenseMap<BasicBlock *, Value *> &Visited, bool SkipFirstBlock,</td>
    <td class="lineNumber">1036</td>
    <td class="codeline">    DenseMap<BasicBlock *, Value *> &Visited, bool SkipFirstBlock,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1037</td>
    <td class="codeline">    bool IsIncomplete) {</td>
    <td class="lineNumber">1037</td>
    <td class="codeline">    bool IsIncomplete) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1038</td>
    <td class="codeline">  // Look up the cached info for Pointer.</td>
    <td class="lineNumber">1038</td>
    <td class="codeline">  // Look up the cached info for Pointer.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1039</td>
    <td class="codeline">  ValueIsLoadPair CacheKey(Pointer.getAddr(), isLoad);</td>
    <td class="lineNumber">1039</td>
    <td class="codeline">  ValueIsLoadPair CacheKey(Pointer.getAddr(), isLoad);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1040</td>
    <td class="codeline"></td>
    <td class="lineNumber">1040</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1041</td>
    <td class="codeline">  // Set up a temporary NLPI value. If the map doesn't yet have an entry for</td>
    <td class="lineNumber">1041</td>
    <td class="codeline">  // Set up a temporary NLPI value. If the map doesn't yet have an entry for</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1042</td>
    <td class="codeline">  // CacheKey, this value will be inserted as the associated value. Otherwise,</td>
    <td class="lineNumber">1042</td>
    <td class="codeline">  // CacheKey, this value will be inserted as the associated value. Otherwise,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1043</td>
    <td class="codeline">  // it'll be ignored, and we'll have to check to see if the cached size and</td>
    <td class="lineNumber">1043</td>
    <td class="codeline">  // it'll be ignored, and we'll have to check to see if the cached size and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1044</td>
    <td class="codeline">  // aa tags are consistent with the current query.</td>
    <td class="lineNumber">1044</td>
    <td class="codeline">  // aa tags are consistent with the current query.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1045</td>
    <td class="codeline">  NonLocalPointerInfo InitialNLPI;</td>
    <td class="lineNumber">1045</td>
    <td class="codeline">  NonLocalPointerInfo InitialNLPI;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1046</td>
    <td class="codeline">  InitialNLPI.Size = Loc.Size;</td>
    <td class="lineNumber">1046</td>
    <td class="codeline">  InitialNLPI.Size = Loc.Size;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1047</td>
    <td class="codeline">  InitialNLPI.AATags = Loc.AATags;</td>
    <td class="lineNumber">1047</td>
    <td class="codeline">  InitialNLPI.AATags = Loc.AATags;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1048</td>
    <td class="codeline"></td>
    <td class="lineNumber">1048</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1049</td>
    <td class="codeline">  bool isInvariantLoad = false;</td>
    <td class="lineNumber">1049</td>
    <td class="codeline">  bool isInvariantLoad = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1050</td>
    <td class="codeline">  if (LoadInst *LI = dyn_cast_or_null<LoadInst>(QueryInst))</td>
    <td class="lineNumber">1050</td>
    <td class="codeline">  if (LoadInst *LI = dyn_cast_or_null<LoadInst>(QueryInst))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1051</td>
    <td class="codeline">    isInvariantLoad = LI->getMetadata(LLVMContext::MD_invariant_load);</td>
    <td class="lineNumber">1051</td>
    <td class="codeline">    isInvariantLoad = LI->getMetadata(LLVMContext::MD_invariant_load);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1052</td>
    <td class="codeline"></td>
    <td class="lineNumber">1052</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1053</td>
    <td class="codeline">  // Get the NLPI for CacheKey, inserting one into the map if it doesn't</td>
    <td class="lineNumber">1053</td>
    <td class="codeline">  // Get the NLPI for CacheKey, inserting one into the map if it doesn't</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1054</td>
    <td class="codeline">  // already have one.</td>
    <td class="lineNumber">1054</td>
    <td class="codeline">  // already have one.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1055</td>
    <td class="codeline">  std::pair<CachedNonLocalPointerInfo::iterator, bool> Pair =</td>
    <td class="lineNumber">1055</td>
    <td class="codeline">  std::pair<CachedNonLocalPointerInfo::iterator, bool> Pair =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1056</td>
    <td class="codeline">      NonLocalPointerDeps.insert(std::make_pair(CacheKey, InitialNLPI));</td>
    <td class="lineNumber">1056</td>
    <td class="codeline">      NonLocalPointerDeps.insert(std::make_pair(CacheKey, InitialNLPI));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1057</td>
    <td class="codeline">  NonLocalPointerInfo *CacheInfo = &Pair.first->second;</td>
    <td class="lineNumber">1057</td>
    <td class="codeline">  NonLocalPointerInfo *CacheInfo = &Pair.first->second;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1058</td>
    <td class="codeline"></td>
    <td class="lineNumber">1058</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1059</td>
    <td class="codeline">  // If we already have a cache entry for this CacheKey, we may need to do some</td>
    <td class="lineNumber">1059</td>
    <td class="codeline">  // If we already have a cache entry for this CacheKey, we may need to do some</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1060</td>
    <td class="codeline">  // work to reconcile the cache entry and the current query.</td>
    <td class="lineNumber">1060</td>
    <td class="codeline">  // work to reconcile the cache entry and the current query.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1061</td>
    <td class="codeline">  // Invariant loads don't participate in caching. Thus no need to reconcile.</td>
    <td class="lineNumber">1061</td>
    <td class="codeline">  // Invariant loads don't participate in caching. Thus no need to reconcile.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1062</td>
    <td class="codeline">  if (!isInvariantLoad && !Pair.second) {</td>
    <td class="lineNumber">1062</td>
    <td class="codeline">  if (!isInvariantLoad && !Pair.second) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1063</td>
    <td class="codeline">    if (CacheInfo->Size != Loc.Size) {</td>
    <td class="lineNumber">1063</td>
    <td class="codeline">    if (CacheInfo->Size != Loc.Size) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1064</td>
    <td class="codeline">      bool ThrowOutEverything;</td>
    <td class="lineNumber">1064</td>
    <td class="codeline">      bool ThrowOutEverything;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1065</td>
    <td class="codeline">      if (CacheInfo->Size.hasValue() && Loc.Size.hasValue()) {</td>
    <td class="lineNumber">1065</td>
    <td class="codeline">      if (CacheInfo->Size.hasValue() && Loc.Size.hasValue()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1066</td>
    <td class="codeline">        // FIXME: We may be able to do better in the face of results with mixed</td>
    <td class="lineNumber">1066</td>
    <td class="codeline">        // FIXME: We may be able to do better in the face of results with mixed</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1067</td>
    <td class="codeline">        // precision. We don't appear to get them in practice, though, so just</td>
    <td class="lineNumber">1067</td>
    <td class="codeline">        // precision. We don't appear to get them in practice, though, so just</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1068</td>
    <td class="codeline">        // be conservative.</td>
    <td class="lineNumber">1068</td>
    <td class="codeline">        // be conservative.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1069</td>
    <td class="codeline">        ThrowOutEverything =</td>
    <td class="lineNumber">1069</td>
    <td class="codeline">        ThrowOutEverything =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1070</td>
    <td class="codeline">            CacheInfo->Size.isPrecise() != Loc.Size.isPrecise() ||</td>
    <td class="lineNumber">1070</td>
    <td class="codeline">            CacheInfo->Size.isPrecise() != Loc.Size.isPrecise() ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1071</td>
    <td class="codeline">            CacheInfo->Size.getValue() < Loc.Size.getValue();</td>
    <td class="lineNumber">1071</td>
    <td class="codeline">            CacheInfo->Size.getValue() < Loc.Size.getValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1072</td>
    <td class="codeline">      } else {</td>
    <td class="lineNumber">1072</td>
    <td class="codeline">      } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1073</td>
    <td class="codeline">        // For our purposes, unknown size > all others.</td>
    <td class="lineNumber">1073</td>
    <td class="codeline">        // For our purposes, unknown size > all others.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1074</td>
    <td class="codeline">        ThrowOutEverything = !Loc.Size.hasValue();</td>
    <td class="lineNumber">1074</td>
    <td class="codeline">        ThrowOutEverything = !Loc.Size.hasValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1075</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1075</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1076</td>
    <td class="codeline"></td>
    <td class="lineNumber">1076</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1077</td>
    <td class="codeline">      if (ThrowOutEverything) {</td>
    <td class="lineNumber">1077</td>
    <td class="codeline">      if (ThrowOutEverything) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1078</td>
    <td class="codeline">        // The query's Size is greater than the cached one. Throw out the</td>
    <td class="lineNumber">1078</td>
    <td class="codeline">        // The query's Size is greater than the cached one. Throw out the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1079</td>
    <td class="codeline">        // cached data and proceed with the query at the greater size.</td>
    <td class="lineNumber">1079</td>
    <td class="codeline">        // cached data and proceed with the query at the greater size.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1080</td>
    <td class="codeline">        CacheInfo->Pair = BBSkipFirstBlockPair();</td>
    <td class="lineNumber">1080</td>
    <td class="codeline">        CacheInfo->Pair = BBSkipFirstBlockPair();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1081</td>
    <td class="codeline">        CacheInfo->Size = Loc.Size;</td>
    <td class="lineNumber">1081</td>
    <td class="codeline">        CacheInfo->Size = Loc.Size;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1082</td>
    <td class="codeline">        for (auto &Entry : CacheInfo->NonLocalDeps)</td>
    <td class="lineNumber">1082</td>
    <td class="codeline">        for (auto &Entry : CacheInfo->NonLocalDeps)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1083</td>
    <td class="codeline">          if (Instruction *Inst = Entry.getResult().getInst())</td>
    <td class="lineNumber">1083</td>
    <td class="codeline">          if (Instruction *Inst = Entry.getResult().getInst())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1084</td>
    <td class="codeline">            RemoveFromReverseMap(ReverseNonLocalPtrDeps, Inst, CacheKey);</td>
    <td class="lineNumber">1084</td>
    <td class="codeline">            RemoveFromReverseMap(ReverseNonLocalPtrDeps, Inst, CacheKey);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1085</td>
    <td class="codeline">        CacheInfo->NonLocalDeps.clear();</td>
    <td class="lineNumber">1085</td>
    <td class="codeline">        CacheInfo->NonLocalDeps.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1086</td>
    <td class="codeline">        // The cache is cleared (in the above line) so we will have lost</td>
    <td class="lineNumber">1086</td>
    <td class="codeline">        // The cache is cleared (in the above line) so we will have lost</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1087</td>
    <td class="codeline">        // information about blocks we have already visited. We therefore must</td>
    <td class="lineNumber">1087</td>
    <td class="codeline">        // information about blocks we have already visited. We therefore must</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1088</td>
    <td class="codeline">        // assume that the cache information is incomplete.</td>
    <td class="lineNumber">1088</td>
    <td class="codeline">        // assume that the cache information is incomplete.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1089</td>
    <td class="codeline">        IsIncomplete = true;</td>
    <td class="lineNumber">1089</td>
    <td class="codeline">        IsIncomplete = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1090</td>
    <td class="codeline">      } else {</td>
    <td class="lineNumber">1090</td>
    <td class="codeline">      } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1091</td>
    <td class="codeline">        // This query's Size is less than the cached one. Conservatively restart</td>
    <td class="lineNumber">1091</td>
    <td class="codeline">        // This query's Size is less than the cached one. Conservatively restart</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1092</td>
    <td class="codeline">        // the query using the greater size.</td>
    <td class="lineNumber">1092</td>
    <td class="codeline">        // the query using the greater size.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1093</td>
    <td class="codeline">        return getNonLocalPointerDepFromBB(</td>
    <td class="lineNumber">1093</td>
    <td class="codeline">        return getNonLocalPointerDepFromBB(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1094</td>
    <td class="codeline">            QueryInst, Pointer, Loc.getWithNewSize(CacheInfo->Size), isLoad,</td>
    <td class="lineNumber">1094</td>
    <td class="codeline">            QueryInst, Pointer, Loc.getWithNewSize(CacheInfo->Size), isLoad,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1095</td>
    <td class="codeline">            StartBB, Result, Visited, SkipFirstBlock, IsIncomplete);</td>
    <td class="lineNumber">1095</td>
    <td class="codeline">            StartBB, Result, Visited, SkipFirstBlock, IsIncomplete);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1096</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1096</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1097</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1097</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1098</td>
    <td class="codeline"></td>
    <td class="lineNumber">1098</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1099</td>
    <td class="codeline">    // If the query's AATags are inconsistent with the cached one,</td>
    <td class="lineNumber">1099</td>
    <td class="codeline">    // If the query's AATags are inconsistent with the cached one,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1100</td>
    <td class="codeline">    // conservatively throw out the cached data and restart the query with</td>
    <td class="lineNumber">1100</td>
    <td class="codeline">    // conservatively throw out the cached data and restart the query with</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1101</td>
    <td class="codeline">    // no tag if needed.</td>
    <td class="lineNumber">1101</td>
    <td class="codeline">    // no tag if needed.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1102</td>
    <td class="codeline">    if (CacheInfo->AATags != Loc.AATags) {</td>
    <td class="lineNumber">1102</td>
    <td class="codeline">    if (CacheInfo->AATags != Loc.AATags) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1103</td>
    <td class="codeline">      if (CacheInfo->AATags) {</td>
    <td class="lineNumber">1103</td>
    <td class="codeline">      if (CacheInfo->AATags) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1104</td>
    <td class="codeline">        CacheInfo->Pair = BBSkipFirstBlockPair();</td>
    <td class="lineNumber">1104</td>
    <td class="codeline">        CacheInfo->Pair = BBSkipFirstBlockPair();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1105</td>
    <td class="codeline">        CacheInfo->AATags = AAMDNodes();</td>
    <td class="lineNumber">1105</td>
    <td class="codeline">        CacheInfo->AATags = AAMDNodes();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1106</td>
    <td class="codeline">        for (auto &Entry : CacheInfo->NonLocalDeps)</td>
    <td class="lineNumber">1106</td>
    <td class="codeline">        for (auto &Entry : CacheInfo->NonLocalDeps)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1107</td>
    <td class="codeline">          if (Instruction *Inst = Entry.getResult().getInst())</td>
    <td class="lineNumber">1107</td>
    <td class="codeline">          if (Instruction *Inst = Entry.getResult().getInst())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1108</td>
    <td class="codeline">            RemoveFromReverseMap(ReverseNonLocalPtrDeps, Inst, CacheKey);</td>
    <td class="lineNumber">1108</td>
    <td class="codeline">            RemoveFromReverseMap(ReverseNonLocalPtrDeps, Inst, CacheKey);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1109</td>
    <td class="codeline">        CacheInfo->NonLocalDeps.clear();</td>
    <td class="lineNumber">1109</td>
    <td class="codeline">        CacheInfo->NonLocalDeps.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1110</td>
    <td class="codeline">        // The cache is cleared (in the above line) so we will have lost</td>
    <td class="lineNumber">1110</td>
    <td class="codeline">        // The cache is cleared (in the above line) so we will have lost</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1111</td>
    <td class="codeline">        // information about blocks we have already visited. We therefore must</td>
    <td class="lineNumber">1111</td>
    <td class="codeline">        // information about blocks we have already visited. We therefore must</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1112</td>
    <td class="codeline">        // assume that the cache information is incomplete.</td>
    <td class="lineNumber">1112</td>
    <td class="codeline">        // assume that the cache information is incomplete.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1113</td>
    <td class="codeline">        IsIncomplete = true;</td>
    <td class="lineNumber">1113</td>
    <td class="codeline">        IsIncomplete = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1114</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1114</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1115</td>
    <td class="codeline">      if (Loc.AATags)</td>
    <td class="lineNumber">1115</td>
    <td class="codeline">      if (Loc.AATags)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1116</td>
    <td class="codeline">        return getNonLocalPointerDepFromBB(</td>
    <td class="lineNumber">1116</td>
    <td class="codeline">        return getNonLocalPointerDepFromBB(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1117</td>
    <td class="codeline">            QueryInst, Pointer, Loc.getWithoutAATags(), isLoad, StartBB, Result,</td>
    <td class="lineNumber">1117</td>
    <td class="codeline">            QueryInst, Pointer, Loc.getWithoutAATags(), isLoad, StartBB, Result,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1118</td>
    <td class="codeline">            Visited, SkipFirstBlock, IsIncomplete);</td>
    <td class="lineNumber">1118</td>
    <td class="codeline">            Visited, SkipFirstBlock, IsIncomplete);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1119</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1119</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1120</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1120</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1121</td>
    <td class="codeline"></td>
    <td class="lineNumber">1121</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1122</td>
    <td class="codeline">  NonLocalDepInfo *Cache = &CacheInfo->NonLocalDeps;</td>
    <td class="lineNumber">1122</td>
    <td class="codeline">  NonLocalDepInfo *Cache = &CacheInfo->NonLocalDeps;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1123</td>
    <td class="codeline"></td>
    <td class="lineNumber">1123</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1124</td>
    <td class="codeline">  // If we have valid cached information for exactly the block we are</td>
    <td class="lineNumber">1124</td>
    <td class="codeline">  // If we have valid cached information for exactly the block we are</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1125</td>
    <td class="codeline">  // investigating, just return it with no recomputation.</td>
    <td class="lineNumber">1125</td>
    <td class="codeline">  // investigating, just return it with no recomputation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1126</td>
    <td class="codeline">  // Don't use cached information for invariant loads since it is valid for</td>
    <td class="lineNumber">1126</td>
    <td class="codeline">  // Don't use cached information for invariant loads since it is valid for</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1127</td>
    <td class="codeline">  // non-invariant loads only.</td>
    <td class="lineNumber">1127</td>
    <td class="codeline">  // non-invariant loads only.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1128</td>
    <td class="codeline">  if (!IsIncomplete && !isInvariantLoad &&</td>
    <td class="lineNumber">1128</td>
    <td class="codeline">  if (!IsIncomplete && !isInvariantLoad &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1129</td>
    <td class="codeline">      CacheInfo->Pair == BBSkipFirstBlockPair(StartBB, SkipFirstBlock)) {</td>
    <td class="lineNumber">1129</td>
    <td class="codeline">      CacheInfo->Pair == BBSkipFirstBlockPair(StartBB, SkipFirstBlock)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1130</td>
    <td class="codeline">    // We have a fully cached result for this query then we can just return the</td>
    <td class="lineNumber">1130</td>
    <td class="codeline">    // We have a fully cached result for this query then we can just return the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1131</td>
    <td class="codeline">    // cached results and populate the visited set.  However, we have to verify</td>
    <td class="lineNumber">1131</td>
    <td class="codeline">    // cached results and populate the visited set.  However, we have to verify</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1132</td>
    <td class="codeline">    // that we don't already have conflicting results for these blocks.  Check</td>
    <td class="lineNumber">1132</td>
    <td class="codeline">    // that we don't already have conflicting results for these blocks.  Check</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1133</td>
    <td class="codeline">    // to ensure that if a block in the results set is in the visited set that</td>
    <td class="lineNumber">1133</td>
    <td class="codeline">    // to ensure that if a block in the results set is in the visited set that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1134</td>
    <td class="codeline">    // it was for the same pointer query.</td>
    <td class="lineNumber">1134</td>
    <td class="codeline">    // it was for the same pointer query.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1135</td>
    <td class="codeline">    if (!Visited.empty()) {</td>
    <td class="lineNumber">1135</td>
    <td class="codeline">    if (!Visited.empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1136</td>
    <td class="codeline">      for (auto &Entry : *Cache) {</td>
    <td class="lineNumber">1136</td>
    <td class="codeline">      for (auto &Entry : *Cache) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1137</td>
    <td class="codeline">        DenseMap<BasicBlock *, Value *>::iterator VI =</td>
    <td class="lineNumber">1137</td>
    <td class="codeline">        DenseMap<BasicBlock *, Value *>::iterator VI =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1138</td>
    <td class="codeline">            Visited.find(Entry.getBB());</td>
    <td class="lineNumber">1138</td>
    <td class="codeline">            Visited.find(Entry.getBB());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1139</td>
    <td class="codeline">        if (VI == Visited.end() || VI->second == Pointer.getAddr())</td>
    <td class="lineNumber">1139</td>
    <td class="codeline">        if (VI == Visited.end() || VI->second == Pointer.getAddr())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1140</td>
    <td class="codeline">          continue;</td>
    <td class="lineNumber">1140</td>
    <td class="codeline">          continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1141</td>
    <td class="codeline"></td>
    <td class="lineNumber">1141</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1142</td>
    <td class="codeline">        // We have a pointer mismatch in a block.  Just return false, saying</td>
    <td class="lineNumber">1142</td>
    <td class="codeline">        // We have a pointer mismatch in a block.  Just return false, saying</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1143</td>
    <td class="codeline">        // that something was clobbered in this result.  We could also do a</td>
    <td class="lineNumber">1143</td>
    <td class="codeline">        // that something was clobbered in this result.  We could also do a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1144</td>
    <td class="codeline">        // non-fully cached query, but there is little point in doing this.</td>
    <td class="lineNumber">1144</td>
    <td class="codeline">        // non-fully cached query, but there is little point in doing this.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1145</td>
    <td class="codeline">        return false;</td>
    <td class="lineNumber">1145</td>
    <td class="codeline">        return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1146</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1146</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1147</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1147</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1148</td>
    <td class="codeline"></td>
    <td class="lineNumber">1148</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1149</td>
    <td class="codeline">    Value *Addr = Pointer.getAddr();</td>
    <td class="lineNumber">1149</td>
    <td class="codeline">    Value *Addr = Pointer.getAddr();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1150</td>
    <td class="codeline">    for (auto &Entry : *Cache) {</td>
    <td class="lineNumber">1150</td>
    <td class="codeline">    for (auto &Entry : *Cache) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1151</td>
    <td class="codeline">      Visited.insert(std::make_pair(Entry.getBB(), Addr));</td>
    <td class="lineNumber">1151</td>
    <td class="codeline">      Visited.insert(std::make_pair(Entry.getBB(), Addr));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1152</td>
    <td class="codeline">      if (Entry.getResult().isNonLocal()) {</td>
    <td class="lineNumber">1152</td>
    <td class="codeline">      if (Entry.getResult().isNonLocal()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1153</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">1153</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1154</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1154</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1155</td>
    <td class="codeline"></td>
    <td class="lineNumber">1155</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1156</td>
    <td class="codeline">      if (DT.isReachableFromEntry(Entry.getBB())) {</td>
    <td class="lineNumber">1156</td>
    <td class="codeline">      if (DT.isReachableFromEntry(Entry.getBB())) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1157</td>
    <td class="codeline">        Result.push_back(</td>
    <td class="lineNumber">1157</td>
    <td class="codeline">        Result.push_back(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1158</td>
    <td class="codeline">            NonLocalDepResult(Entry.getBB(), Entry.getResult(), Addr));</td>
    <td class="lineNumber">1158</td>
    <td class="codeline">            NonLocalDepResult(Entry.getBB(), Entry.getResult(), Addr));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1159</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1159</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1160</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1160</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1161</td>
    <td class="codeline">    ++NumCacheCompleteNonLocalPtr;</td>
    <td class="lineNumber">1161</td>
    <td class="codeline">    ++NumCacheCompleteNonLocalPtr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1162</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">1162</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1163</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1163</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1164</td>
    <td class="codeline"></td>
    <td class="lineNumber">1164</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1165</td>
    <td class="codeline">  // Otherwise, either this is a new block, a block with an invalid cache</td>
    <td class="lineNumber">1165</td>
    <td class="codeline">  // Otherwise, either this is a new block, a block with an invalid cache</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1166</td>
    <td class="codeline">  // pointer or one that we're about to invalidate by putting more info into</td>
    <td class="lineNumber">1166</td>
    <td class="codeline">  // pointer or one that we're about to invalidate by putting more info into</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1167</td>
    <td class="codeline">  // it than its valid cache info.  If empty and not explicitly indicated as</td>
    <td class="lineNumber">1167</td>
    <td class="codeline">  // it than its valid cache info.  If empty and not explicitly indicated as</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1168</td>
    <td class="codeline">  // incomplete, the result will be valid cache info, otherwise it isn't.</td>
    <td class="lineNumber">1168</td>
    <td class="codeline">  // incomplete, the result will be valid cache info, otherwise it isn't.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1169</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">1169</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1170</td>
    <td class="codeline">  // Invariant loads don't affect cache in any way thus no need to update</td>
    <td class="lineNumber">1170</td>
    <td class="codeline">  // Invariant loads don't affect cache in any way thus no need to update</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1171</td>
    <td class="codeline">  // CacheInfo as well.</td>
    <td class="lineNumber">1171</td>
    <td class="codeline">  // CacheInfo as well.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1172</td>
    <td class="codeline">  if (!isInvariantLoad) {</td>
    <td class="lineNumber">1172</td>
    <td class="codeline">  if (!isInvariantLoad) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1173</td>
    <td class="codeline">    if (!IsIncomplete && Cache->empty())</td>
    <td class="lineNumber">1173</td>
    <td class="codeline">    if (!IsIncomplete && Cache->empty())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1174</td>
    <td class="codeline">      CacheInfo->Pair = BBSkipFirstBlockPair(StartBB, SkipFirstBlock);</td>
    <td class="lineNumber">1174</td>
    <td class="codeline">      CacheInfo->Pair = BBSkipFirstBlockPair(StartBB, SkipFirstBlock);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1175</td>
    <td class="codeline">    else</td>
    <td class="lineNumber">1175</td>
    <td class="codeline">    else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1176</td>
    <td class="codeline">      CacheInfo->Pair = BBSkipFirstBlockPair();</td>
    <td class="lineNumber">1176</td>
    <td class="codeline">      CacheInfo->Pair = BBSkipFirstBlockPair();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1177</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1177</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1178</td>
    <td class="codeline"></td>
    <td class="lineNumber">1178</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1179</td>
    <td class="codeline">  SmallVector<BasicBlock *, 32> Worklist;</td>
    <td class="lineNumber">1179</td>
    <td class="codeline">  SmallVector<BasicBlock *, 32> Worklist;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1180</td>
    <td class="codeline">  Worklist.push_back(StartBB);</td>
    <td class="lineNumber">1180</td>
    <td class="codeline">  Worklist.push_back(StartBB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1181</td>
    <td class="codeline"></td>
    <td class="lineNumber">1181</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1182</td>
    <td class="codeline">  // PredList used inside loop.</td>
    <td class="lineNumber">1182</td>
    <td class="codeline">  // PredList used inside loop.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1183</td>
    <td class="codeline">  SmallVector<std::pair<BasicBlock *, PHITransAddr>, 16> PredList;</td>
    <td class="lineNumber">1183</td>
    <td class="codeline">  SmallVector<std::pair<BasicBlock *, PHITransAddr>, 16> PredList;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1184</td>
    <td class="codeline"></td>
    <td class="lineNumber">1184</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1185</td>
    <td class="codeline">  // Keep track of the entries that we know are sorted.  Previously cached</td>
    <td class="lineNumber">1185</td>
    <td class="codeline">  // Keep track of the entries that we know are sorted.  Previously cached</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1186</td>
    <td class="codeline">  // entries will all be sorted.  The entries we add we only sort on demand (we</td>
    <td class="lineNumber">1186</td>
    <td class="codeline">  // entries will all be sorted.  The entries we add we only sort on demand (we</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1187</td>
    <td class="codeline">  // don't insert every element into its sorted position).  We know that we</td>
    <td class="lineNumber">1187</td>
    <td class="codeline">  // don't insert every element into its sorted position).  We know that we</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1188</td>
    <td class="codeline">  // won't get any reuse from currently inserted values, because we don't</td>
    <td class="lineNumber">1188</td>
    <td class="codeline">  // won't get any reuse from currently inserted values, because we don't</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1189</td>
    <td class="codeline">  // revisit blocks after we insert info for them.</td>
    <td class="lineNumber">1189</td>
    <td class="codeline">  // revisit blocks after we insert info for them.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1190</td>
    <td class="codeline">  unsigned NumSortedEntries = Cache->size();</td>
    <td class="lineNumber">1190</td>
    <td class="codeline">  unsigned NumSortedEntries = Cache->size();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1191</td>
    <td class="codeline">  unsigned WorklistEntries = BlockNumberLimit;</td>
    <td class="lineNumber">1191</td>
    <td class="codeline">  unsigned WorklistEntries = BlockNumberLimit;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1192</td>
    <td class="codeline">  bool GotWorklistLimit = false;</td>
    <td class="lineNumber">1192</td>
    <td class="codeline">  bool GotWorklistLimit = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1193</td>
    <td class="codeline">  LLVM_DEBUG(AssertSorted(*Cache));</td>
    <td class="lineNumber">1193</td>
    <td class="codeline">  LLVM_DEBUG(AssertSorted(*Cache));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1194</td>
    <td class="codeline"></td>
    <td class="lineNumber">1194</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1195</td>
    <td class="codeline">  BatchAAResults BatchAA(AA);</td>
    <td class="lineNumber">1195</td>
    <td class="codeline">  BatchAAResults BatchAA(AA);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1196</td>
    <td class="codeline">  while (!Worklist.empty()) {</td>
    <td class="lineNumber">1196</td>
    <td class="codeline">  while (!Worklist.empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1197</td>
    <td class="codeline">    BasicBlock *BB = Worklist.pop_back_val();</td>
    <td class="lineNumber">1197</td>
    <td class="codeline">    BasicBlock *BB = Worklist.pop_back_val();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1198</td>
    <td class="codeline"></td>
    <td class="lineNumber">1198</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1199</td>
    <td class="codeline">    // If we do process a large number of blocks it becomes very expensive and</td>
    <td class="lineNumber">1199</td>
    <td class="codeline">    // If we do process a large number of blocks it becomes very expensive and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1200</td>
    <td class="codeline">    // likely it isn't worth worrying about</td>
    <td class="lineNumber">1200</td>
    <td class="codeline">    // likely it isn't worth worrying about</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1201</td>
    <td class="codeline">    if (Result.size() > NumResultsLimit) {</td>
    <td class="lineNumber">1201</td>
    <td class="codeline">    if (Result.size() > NumResultsLimit) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1202</td>
    <td class="codeline">      // Sort it now (if needed) so that recursive invocations of</td>
    <td class="lineNumber">1202</td>
    <td class="codeline">      // Sort it now (if needed) so that recursive invocations of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1203</td>
    <td class="codeline">      // getNonLocalPointerDepFromBB and other routines that could reuse the</td>
    <td class="lineNumber">1203</td>
    <td class="codeline">      // getNonLocalPointerDepFromBB and other routines that could reuse the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1204</td>
    <td class="codeline">      // cache value will only see properly sorted cache arrays.</td>
    <td class="lineNumber">1204</td>
    <td class="codeline">      // cache value will only see properly sorted cache arrays.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1205</td>
    <td class="codeline">      if (Cache && NumSortedEntries != Cache->size()) {</td>
    <td class="lineNumber">1205</td>
    <td class="codeline">      if (Cache && NumSortedEntries != Cache->size()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1206</td>
    <td class="codeline">        SortNonLocalDepInfoCache(*Cache, NumSortedEntries);</td>
    <td class="lineNumber">1206</td>
    <td class="codeline">        SortNonLocalDepInfoCache(*Cache, NumSortedEntries);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1207</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1207</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1208</td>
    <td class="codeline">      // Since we bail out, the "Cache" set won't contain all of the</td>
    <td class="lineNumber">1208</td>
    <td class="codeline">      // Since we bail out, the "Cache" set won't contain all of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1209</td>
    <td class="codeline">      // results for the query.  This is ok (we can still use it to accelerate</td>
    <td class="lineNumber">1209</td>
    <td class="codeline">      // results for the query.  This is ok (we can still use it to accelerate</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1210</td>
    <td class="codeline">      // specific block queries) but we can't do the fastpath "return all</td>
    <td class="lineNumber">1210</td>
    <td class="codeline">      // specific block queries) but we can't do the fastpath "return all</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1211</td>
    <td class="codeline">      // results from the set".  Clear out the indicator for this.</td>
    <td class="lineNumber">1211</td>
    <td class="codeline">      // results from the set".  Clear out the indicator for this.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1212</td>
    <td class="codeline">      CacheInfo->Pair = BBSkipFirstBlockPair();</td>
    <td class="lineNumber">1212</td>
    <td class="codeline">      CacheInfo->Pair = BBSkipFirstBlockPair();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1213</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">1213</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1214</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1214</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1215</td>
    <td class="codeline"></td>
    <td class="lineNumber">1215</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1216</td>
    <td class="codeline">    // Skip the first block if we have it.</td>
    <td class="lineNumber">1216</td>
    <td class="codeline">    // Skip the first block if we have it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1217</td>
    <td class="codeline">    if (!SkipFirstBlock) {</td>
    <td class="lineNumber">1217</td>
    <td class="codeline">    if (!SkipFirstBlock) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1218</td>
    <td class="codeline">      // Analyze the dependency of *Pointer in FromBB.  See if we already have</td>
    <td class="lineNumber">1218</td>
    <td class="codeline">      // Analyze the dependency of *Pointer in FromBB.  See if we already have</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1219</td>
    <td class="codeline">      // been here.</td>
    <td class="lineNumber">1219</td>
    <td class="codeline">      // been here.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1220</td>
    <td class="codeline">      assert(Visited.count(BB) && "Should check 'visited' before adding to WL");</td>
    <td class="lineNumber">1220</td>
    <td class="codeline">      assert(Visited.count(BB) && "Should check 'visited' before adding to WL");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1221</td>
    <td class="codeline"></td>
    <td class="lineNumber">1221</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1222</td>
    <td class="codeline">      // Get the dependency info for Pointer in BB.  If we have cached</td>
    <td class="lineNumber">1222</td>
    <td class="codeline">      // Get the dependency info for Pointer in BB.  If we have cached</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1223</td>
    <td class="codeline">      // information, we will use it, otherwise we compute it.</td>
    <td class="lineNumber">1223</td>
    <td class="codeline">      // information, we will use it, otherwise we compute it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1224</td>
    <td class="codeline">      LLVM_DEBUG(AssertSorted(*Cache, NumSortedEntries));</td>
    <td class="lineNumber">1224</td>
    <td class="codeline">      LLVM_DEBUG(AssertSorted(*Cache, NumSortedEntries));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1225</td>
    <td class="codeline">      MemDepResult Dep = getNonLocalInfoForBlock(</td>
    <td class="lineNumber">1225</td>
    <td class="codeline">      MemDepResult Dep = getNonLocalInfoForBlock(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1226</td>
    <td class="codeline">          QueryInst, Loc, isLoad, BB, Cache, NumSortedEntries, BatchAA);</td>
    <td class="lineNumber">1226</td>
    <td class="codeline">          QueryInst, Loc, isLoad, BB, Cache, NumSortedEntries, BatchAA);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1227</td>
    <td class="codeline"></td>
    <td class="lineNumber">1227</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1228</td>
    <td class="codeline">      // If we got a Def or Clobber, add this to the list of results.</td>
    <td class="lineNumber">1228</td>
    <td class="codeline">      // If we got a Def or Clobber, add this to the list of results.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1229</td>
    <td class="codeline">      if (!Dep.isNonLocal()) {</td>
    <td class="lineNumber">1229</td>
    <td class="codeline">      if (!Dep.isNonLocal()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1230</td>
    <td class="codeline">        if (DT.isReachableFromEntry(BB)) {</td>
    <td class="lineNumber">1230</td>
    <td class="codeline">        if (DT.isReachableFromEntry(BB)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1231</td>
    <td class="codeline">          Result.push_back(NonLocalDepResult(BB, Dep, Pointer.getAddr()));</td>
    <td class="lineNumber">1231</td>
    <td class="codeline">          Result.push_back(NonLocalDepResult(BB, Dep, Pointer.getAddr()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1232</td>
    <td class="codeline">          continue;</td>
    <td class="lineNumber">1232</td>
    <td class="codeline">          continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1233</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">1233</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1234</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1234</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1235</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1235</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1236</td>
    <td class="codeline"></td>
    <td class="lineNumber">1236</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1237</td>
    <td class="codeline">    // If 'Pointer' is an instruction defined in this block, then we need to do</td>
    <td class="lineNumber">1237</td>
    <td class="codeline">    // If 'Pointer' is an instruction defined in this block, then we need to do</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1238</td>
    <td class="codeline">    // phi translation to change it into a value live in the predecessor block.</td>
    <td class="lineNumber">1238</td>
    <td class="codeline">    // phi translation to change it into a value live in the predecessor block.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1239</td>
    <td class="codeline">    // If not, we just add the predecessors to the worklist and scan them with</td>
    <td class="lineNumber">1239</td>
    <td class="codeline">    // If not, we just add the predecessors to the worklist and scan them with</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1240</td>
    <td class="codeline">    // the same Pointer.</td>
    <td class="lineNumber">1240</td>
    <td class="codeline">    // the same Pointer.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1241</td>
    <td class="codeline">    if (!Pointer.needsPHITranslationFromBlock(BB)) {</td>
    <td class="lineNumber">1241</td>
    <td class="codeline">    if (!Pointer.needsPHITranslationFromBlock(BB)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1242</td>
    <td class="codeline">      SkipFirstBlock = false;</td>
    <td class="lineNumber">1242</td>
    <td class="codeline">      SkipFirstBlock = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1243</td>
    <td class="codeline">      SmallVector<BasicBlock *, 16> NewBlocks;</td>
    <td class="lineNumber">1243</td>
    <td class="codeline">      SmallVector<BasicBlock *, 16> NewBlocks;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1244</td>
    <td class="codeline">      for (BasicBlock *Pred : PredCache.get(BB)) {</td>
    <td class="lineNumber">1244</td>
    <td class="codeline">      for (BasicBlock *Pred : PredCache.get(BB)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1245</td>
    <td class="codeline">        // Verify that we haven't looked at this block yet.</td>
    <td class="lineNumber">1245</td>
    <td class="codeline">        // Verify that we haven't looked at this block yet.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1246</td>
    <td class="codeline">        std::pair<DenseMap<BasicBlock *, Value *>::iterator, bool> InsertRes =</td>
    <td class="lineNumber">1246</td>
    <td class="codeline">        std::pair<DenseMap<BasicBlock *, Value *>::iterator, bool> InsertRes =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1247</td>
    <td class="codeline">            Visited.insert(std::make_pair(Pred, Pointer.getAddr()));</td>
    <td class="lineNumber">1247</td>
    <td class="codeline">            Visited.insert(std::make_pair(Pred, Pointer.getAddr()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1248</td>
    <td class="codeline">        if (InsertRes.second) {</td>
    <td class="lineNumber">1248</td>
    <td class="codeline">        if (InsertRes.second) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1249</td>
    <td class="codeline">          // First time we've looked at *PI.</td>
    <td class="lineNumber">1249</td>
    <td class="codeline">          // First time we've looked at *PI.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1250</td>
    <td class="codeline">          NewBlocks.push_back(Pred);</td>
    <td class="lineNumber">1250</td>
    <td class="codeline">          NewBlocks.push_back(Pred);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1251</td>
    <td class="codeline">          continue;</td>
    <td class="lineNumber">1251</td>
    <td class="codeline">          continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1252</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">1252</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1253</td>
    <td class="codeline"></td>
    <td class="lineNumber">1253</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1254</td>
    <td class="codeline">        // If we have seen this block before, but it was with a different</td>
    <td class="lineNumber">1254</td>
    <td class="codeline">        // If we have seen this block before, but it was with a different</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1255</td>
    <td class="codeline">        // pointer then we have a phi translation failure and we have to treat</td>
    <td class="lineNumber">1255</td>
    <td class="codeline">        // pointer then we have a phi translation failure and we have to treat</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1256</td>
    <td class="codeline">        // this as a clobber.</td>
    <td class="lineNumber">1256</td>
    <td class="codeline">        // this as a clobber.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1257</td>
    <td class="codeline">        if (InsertRes.first->second != Pointer.getAddr()) {</td>
    <td class="lineNumber">1257</td>
    <td class="codeline">        if (InsertRes.first->second != Pointer.getAddr()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1258</td>
    <td class="codeline">          // Make sure to clean up the Visited map before continuing on to</td>
    <td class="lineNumber">1258</td>
    <td class="codeline">          // Make sure to clean up the Visited map before continuing on to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1259</td>
    <td class="codeline">          // PredTranslationFailure.</td>
    <td class="lineNumber">1259</td>
    <td class="codeline">          // PredTranslationFailure.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1260</td>
    <td class="codeline">          for (unsigned i = 0; i < NewBlocks.size(); i++)</td>
    <td class="lineNumber">1260</td>
    <td class="codeline">          for (unsigned i = 0; i < NewBlocks.size(); i++)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1261</td>
    <td class="codeline">            Visited.erase(NewBlocks[i]);</td>
    <td class="lineNumber">1261</td>
    <td class="codeline">            Visited.erase(NewBlocks[i]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1262</td>
    <td class="codeline">          goto PredTranslationFailure;</td>
    <td class="lineNumber">1262</td>
    <td class="codeline">          goto PredTranslationFailure;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1263</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">1263</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1264</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1264</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1265</td>
    <td class="codeline">      if (NewBlocks.size() > WorklistEntries) {</td>
    <td class="lineNumber">1265</td>
    <td class="codeline">      if (NewBlocks.size() > WorklistEntries) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1266</td>
    <td class="codeline">        // Make sure to clean up the Visited map before continuing on to</td>
    <td class="lineNumber">1266</td>
    <td class="codeline">        // Make sure to clean up the Visited map before continuing on to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1267</td>
    <td class="codeline">        // PredTranslationFailure.</td>
    <td class="lineNumber">1267</td>
    <td class="codeline">        // PredTranslationFailure.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1268</td>
    <td class="codeline">        for (unsigned i = 0; i < NewBlocks.size(); i++)</td>
    <td class="lineNumber">1268</td>
    <td class="codeline">        for (unsigned i = 0; i < NewBlocks.size(); i++)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1269</td>
    <td class="codeline">          Visited.erase(NewBlocks[i]);</td>
    <td class="lineNumber">1269</td>
    <td class="codeline">          Visited.erase(NewBlocks[i]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1270</td>
    <td class="codeline">        GotWorklistLimit = true;</td>
    <td class="lineNumber">1270</td>
    <td class="codeline">        GotWorklistLimit = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1271</td>
    <td class="codeline">        goto PredTranslationFailure;</td>
    <td class="lineNumber">1271</td>
    <td class="codeline">        goto PredTranslationFailure;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1272</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1272</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1273</td>
    <td class="codeline">      WorklistEntries -= NewBlocks.size();</td>
    <td class="lineNumber">1273</td>
    <td class="codeline">      WorklistEntries -= NewBlocks.size();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1274</td>
    <td class="codeline">      Worklist.append(NewBlocks.begin(), NewBlocks.end());</td>
    <td class="lineNumber">1274</td>
    <td class="codeline">      Worklist.append(NewBlocks.begin(), NewBlocks.end());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1275</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">1275</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1276</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1276</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1277</td>
    <td class="codeline"></td>
    <td class="lineNumber">1277</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1278</td>
    <td class="codeline">    // We do need to do phi translation, if we know ahead of time we can't phi</td>
    <td class="lineNumber">1278</td>
    <td class="codeline">    // We do need to do phi translation, if we know ahead of time we can't phi</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1279</td>
    <td class="codeline">    // translate this value, don't even try.</td>
    <td class="lineNumber">1279</td>
    <td class="codeline">    // translate this value, don't even try.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1280</td>
    <td class="codeline">    if (!Pointer.isPotentiallyPHITranslatable())</td>
    <td class="lineNumber">1280</td>
    <td class="codeline">    if (!Pointer.isPotentiallyPHITranslatable())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1281</td>
    <td class="codeline">      goto PredTranslationFailure;</td>
    <td class="lineNumber">1281</td>
    <td class="codeline">      goto PredTranslationFailure;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1282</td>
    <td class="codeline"></td>
    <td class="lineNumber">1282</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1283</td>
    <td class="codeline">    // We may have added values to the cache list before this PHI translation.</td>
    <td class="lineNumber">1283</td>
    <td class="codeline">    // We may have added values to the cache list before this PHI translation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1284</td>
    <td class="codeline">    // If so, we haven't done anything to ensure that the cache remains sorted.</td>
    <td class="lineNumber">1284</td>
    <td class="codeline">    // If so, we haven't done anything to ensure that the cache remains sorted.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1285</td>
    <td class="codeline">    // Sort it now (if needed) so that recursive invocations of</td>
    <td class="lineNumber">1285</td>
    <td class="codeline">    // Sort it now (if needed) so that recursive invocations of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1286</td>
    <td class="codeline">    // getNonLocalPointerDepFromBB and other routines that could reuse the cache</td>
    <td class="lineNumber">1286</td>
    <td class="codeline">    // getNonLocalPointerDepFromBB and other routines that could reuse the cache</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1287</td>
    <td class="codeline">    // value will only see properly sorted cache arrays.</td>
    <td class="lineNumber">1287</td>
    <td class="codeline">    // value will only see properly sorted cache arrays.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1288</td>
    <td class="codeline">    if (Cache && NumSortedEntries != Cache->size()) {</td>
    <td class="lineNumber">1288</td>
    <td class="codeline">    if (Cache && NumSortedEntries != Cache->size()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1289</td>
    <td class="codeline">      SortNonLocalDepInfoCache(*Cache, NumSortedEntries);</td>
    <td class="lineNumber">1289</td>
    <td class="codeline">      SortNonLocalDepInfoCache(*Cache, NumSortedEntries);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1290</td>
    <td class="codeline">      NumSortedEntries = Cache->size();</td>
    <td class="lineNumber">1290</td>
    <td class="codeline">      NumSortedEntries = Cache->size();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1291</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1291</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1292</td>
    <td class="codeline">    Cache = nullptr;</td>
    <td class="lineNumber">1292</td>
    <td class="codeline">    Cache = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1293</td>
    <td class="codeline"></td>
    <td class="lineNumber">1293</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1294</td>
    <td class="codeline">    PredList.clear();</td>
    <td class="lineNumber">1294</td>
    <td class="codeline">    PredList.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1295</td>
    <td class="codeline">    for (BasicBlock *Pred : PredCache.get(BB)) {</td>
    <td class="lineNumber">1295</td>
    <td class="codeline">    for (BasicBlock *Pred : PredCache.get(BB)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1296</td>
    <td class="codeline">      PredList.push_back(std::make_pair(Pred, Pointer));</td>
    <td class="lineNumber">1296</td>
    <td class="codeline">      PredList.push_back(std::make_pair(Pred, Pointer));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1297</td>
    <td class="codeline"></td>
    <td class="lineNumber">1297</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1298</td>
    <td class="codeline">      // Get the PHI translated pointer in this predecessor.  This can fail if</td>
    <td class="lineNumber">1298</td>
    <td class="codeline">      // Get the PHI translated pointer in this predecessor.  This can fail if</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1299</td>
    <td class="codeline">      // not translatable, in which case the getAddr() returns null.</td>
    <td class="lineNumber">1299</td>
    <td class="codeline">      // not translatable, in which case the getAddr() returns null.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1300</td>
    <td class="codeline">      PHITransAddr &PredPointer = PredList.back().second;</td>
    <td class="lineNumber">1300</td>
    <td class="codeline">      PHITransAddr &PredPointer = PredList.back().second;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1301</td>
    <td class="codeline">      Value *PredPtrVal =</td>
    <td class="lineNumber">1301</td>
    <td class="codeline">      Value *PredPtrVal =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1302</td>
    <td class="codeline">          PredPointer.translateValue(BB, Pred, &DT, /*MustDominate=*/false);</td>
    <td class="lineNumber">1302</td>
    <td class="codeline">          PredPointer.translateValue(BB, Pred, &DT, /*MustDominate=*/false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1303</td>
    <td class="codeline"></td>
    <td class="lineNumber">1303</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1304</td>
    <td class="codeline">      // Check to see if we have already visited this pred block with another</td>
    <td class="lineNumber">1304</td>
    <td class="codeline">      // Check to see if we have already visited this pred block with another</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1305</td>
    <td class="codeline">      // pointer.  If so, we can't do this lookup.  This failure can occur</td>
    <td class="lineNumber">1305</td>
    <td class="codeline">      // pointer.  If so, we can't do this lookup.  This failure can occur</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1306</td>
    <td class="codeline">      // with PHI translation when a critical edge exists and the PHI node in</td>
    <td class="lineNumber">1306</td>
    <td class="codeline">      // with PHI translation when a critical edge exists and the PHI node in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1307</td>
    <td class="codeline">      // the successor translates to a pointer value different than the</td>
    <td class="lineNumber">1307</td>
    <td class="codeline">      // the successor translates to a pointer value different than the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1308</td>
    <td class="codeline">      // pointer the block was first analyzed with.</td>
    <td class="lineNumber">1308</td>
    <td class="codeline">      // pointer the block was first analyzed with.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1309</td>
    <td class="codeline">      std::pair<DenseMap<BasicBlock *, Value *>::iterator, bool> InsertRes =</td>
    <td class="lineNumber">1309</td>
    <td class="codeline">      std::pair<DenseMap<BasicBlock *, Value *>::iterator, bool> InsertRes =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1310</td>
    <td class="codeline">          Visited.insert(std::make_pair(Pred, PredPtrVal));</td>
    <td class="lineNumber">1310</td>
    <td class="codeline">          Visited.insert(std::make_pair(Pred, PredPtrVal));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1311</td>
    <td class="codeline"></td>
    <td class="lineNumber">1311</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1312</td>
    <td class="codeline">      if (!InsertRes.second) {</td>
    <td class="lineNumber">1312</td>
    <td class="codeline">      if (!InsertRes.second) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1313</td>
    <td class="codeline">        // We found the pred; take it off the list of preds to visit.</td>
    <td class="lineNumber">1313</td>
    <td class="codeline">        // We found the pred; take it off the list of preds to visit.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1314</td>
    <td class="codeline">        PredList.pop_back();</td>
    <td class="lineNumber">1314</td>
    <td class="codeline">        PredList.pop_back();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1315</td>
    <td class="codeline"></td>
    <td class="lineNumber">1315</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1316</td>
    <td class="codeline">        // If the predecessor was visited with PredPtr, then we already did</td>
    <td class="lineNumber">1316</td>
    <td class="codeline">        // If the predecessor was visited with PredPtr, then we already did</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1317</td>
    <td class="codeline">        // the analysis and can ignore it.</td>
    <td class="lineNumber">1317</td>
    <td class="codeline">        // the analysis and can ignore it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1318</td>
    <td class="codeline">        if (InsertRes.first->second == PredPtrVal)</td>
    <td class="lineNumber">1318</td>
    <td class="codeline">        if (InsertRes.first->second == PredPtrVal)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1319</td>
    <td class="codeline">          continue;</td>
    <td class="lineNumber">1319</td>
    <td class="codeline">          continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1320</td>
    <td class="codeline"></td>
    <td class="lineNumber">1320</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1321</td>
    <td class="codeline">        // Otherwise, the block was previously analyzed with a different</td>
    <td class="lineNumber">1321</td>
    <td class="codeline">        // Otherwise, the block was previously analyzed with a different</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1322</td>
    <td class="codeline">        // pointer.  We can't represent the result of this case, so we just</td>
    <td class="lineNumber">1322</td>
    <td class="codeline">        // pointer.  We can't represent the result of this case, so we just</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1323</td>
    <td class="codeline">        // treat this as a phi translation failure.</td>
    <td class="lineNumber">1323</td>
    <td class="codeline">        // treat this as a phi translation failure.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1324</td>
    <td class="codeline"></td>
    <td class="lineNumber">1324</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1325</td>
    <td class="codeline">        // Make sure to clean up the Visited map before continuing on to</td>
    <td class="lineNumber">1325</td>
    <td class="codeline">        // Make sure to clean up the Visited map before continuing on to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1326</td>
    <td class="codeline">        // PredTranslationFailure.</td>
    <td class="lineNumber">1326</td>
    <td class="codeline">        // PredTranslationFailure.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1327</td>
    <td class="codeline">        for (unsigned i = 0, n = PredList.size(); i < n; ++i)</td>
    <td class="lineNumber">1327</td>
    <td class="codeline">        for (unsigned i = 0, n = PredList.size(); i < n; ++i)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1328</td>
    <td class="codeline">          Visited.erase(PredList[i].first);</td>
    <td class="lineNumber">1328</td>
    <td class="codeline">          Visited.erase(PredList[i].first);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1329</td>
    <td class="codeline"></td>
    <td class="lineNumber">1329</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1330</td>
    <td class="codeline">        goto PredTranslationFailure;</td>
    <td class="lineNumber">1330</td>
    <td class="codeline">        goto PredTranslationFailure;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1331</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1331</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1332</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1332</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1333</td>
    <td class="codeline"></td>
    <td class="lineNumber">1333</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1334</td>
    <td class="codeline">    // Actually process results here; this need to be a separate loop to avoid</td>
    <td class="lineNumber">1334</td>
    <td class="codeline">    // Actually process results here; this need to be a separate loop to avoid</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1335</td>
    <td class="codeline">    // calling getNonLocalPointerDepFromBB for blocks we don't want to return</td>
    <td class="lineNumber">1335</td>
    <td class="codeline">    // calling getNonLocalPointerDepFromBB for blocks we don't want to return</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1336</td>
    <td class="codeline">    // any results for.  (getNonLocalPointerDepFromBB will modify our</td>
    <td class="lineNumber">1336</td>
    <td class="codeline">    // any results for.  (getNonLocalPointerDepFromBB will modify our</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1337</td>
    <td class="codeline">    // datastructures in ways the code after the PredTranslationFailure label</td>
    <td class="lineNumber">1337</td>
    <td class="codeline">    // datastructures in ways the code after the PredTranslationFailure label</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1338</td>
    <td class="codeline">    // doesn't expect.)</td>
    <td class="lineNumber">1338</td>
    <td class="codeline">    // doesn't expect.)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1339</td>
    <td class="codeline">    for (unsigned i = 0, n = PredList.size(); i < n; ++i) {</td>
    <td class="lineNumber">1339</td>
    <td class="codeline">    for (unsigned i = 0, n = PredList.size(); i < n; ++i) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1340</td>
    <td class="codeline">      BasicBlock *Pred = PredList[i].first;</td>
    <td class="lineNumber">1340</td>
    <td class="codeline">      BasicBlock *Pred = PredList[i].first;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1341</td>
    <td class="codeline">      PHITransAddr &PredPointer = PredList[i].second;</td>
    <td class="lineNumber">1341</td>
    <td class="codeline">      PHITransAddr &PredPointer = PredList[i].second;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1342</td>
    <td class="codeline">      Value *PredPtrVal = PredPointer.getAddr();</td>
    <td class="lineNumber">1342</td>
    <td class="codeline">      Value *PredPtrVal = PredPointer.getAddr();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1343</td>
    <td class="codeline"></td>
    <td class="lineNumber">1343</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1344</td>
    <td class="codeline">      bool CanTranslate = true;</td>
    <td class="lineNumber">1344</td>
    <td class="codeline">      bool CanTranslate = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1345</td>
    <td class="codeline">      // If PHI translation was unable to find an available pointer in this</td>
    <td class="lineNumber">1345</td>
    <td class="codeline">      // If PHI translation was unable to find an available pointer in this</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1346</td>
    <td class="codeline">      // predecessor, then we have to assume that the pointer is clobbered in</td>
    <td class="lineNumber">1346</td>
    <td class="codeline">      // predecessor, then we have to assume that the pointer is clobbered in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1347</td>
    <td class="codeline">      // that predecessor.  We can still do PRE of the load, which would insert</td>
    <td class="lineNumber">1347</td>
    <td class="codeline">      // that predecessor.  We can still do PRE of the load, which would insert</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1348</td>
    <td class="codeline">      // a computation of the pointer in this predecessor.</td>
    <td class="lineNumber">1348</td>
    <td class="codeline">      // a computation of the pointer in this predecessor.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1349</td>
    <td class="codeline">      if (!PredPtrVal)</td>
    <td class="lineNumber">1349</td>
    <td class="codeline">      if (!PredPtrVal)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1350</td>
    <td class="codeline">        CanTranslate = false;</td>
    <td class="lineNumber">1350</td>
    <td class="codeline">        CanTranslate = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1351</td>
    <td class="codeline"></td>
    <td class="lineNumber">1351</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1352</td>
    <td class="codeline">      // FIXME: it is entirely possible that PHI translating will end up with</td>
    <td class="lineNumber">1352</td>
    <td class="codeline">      // FIXME: it is entirely possible that PHI translating will end up with</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1353</td>
    <td class="codeline">      // the same value.  Consider PHI translating something like:</td>
    <td class="lineNumber">1353</td>
    <td class="codeline">      // the same value.  Consider PHI translating something like:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1354</td>
    <td class="codeline">      // X = phi [x, bb1], [y, bb2].  PHI translating for bb1 doesn't *need*</td>
    <td class="lineNumber">1354</td>
    <td class="codeline">      // X = phi [x, bb1], [y, bb2].  PHI translating for bb1 doesn't *need*</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1355</td>
    <td class="codeline">      // to recurse here, pedantically speaking.</td>
    <td class="lineNumber">1355</td>
    <td class="codeline">      // to recurse here, pedantically speaking.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1356</td>
    <td class="codeline"></td>
    <td class="lineNumber">1356</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1357</td>
    <td class="codeline">      // If getNonLocalPointerDepFromBB fails here, that means the cached</td>
    <td class="lineNumber">1357</td>
    <td class="codeline">      // If getNonLocalPointerDepFromBB fails here, that means the cached</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1358</td>
    <td class="codeline">      // result conflicted with the Visited list; we have to conservatively</td>
    <td class="lineNumber">1358</td>
    <td class="codeline">      // result conflicted with the Visited list; we have to conservatively</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1359</td>
    <td class="codeline">      // assume it is unknown, but this also does not block PRE of the load.</td>
    <td class="lineNumber">1359</td>
    <td class="codeline">      // assume it is unknown, but this also does not block PRE of the load.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1360</td>
    <td class="codeline">      if (!CanTranslate ||</td>
    <td class="lineNumber">1360</td>
    <td class="codeline">      if (!CanTranslate ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1361</td>
    <td class="codeline">          !getNonLocalPointerDepFromBB(QueryInst, PredPointer,</td>
    <td class="lineNumber">1361</td>
    <td class="codeline">          !getNonLocalPointerDepFromBB(QueryInst, PredPointer,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1362</td>
    <td class="codeline">                                      Loc.getWithNewPtr(PredPtrVal), isLoad,</td>
    <td class="lineNumber">1362</td>
    <td class="codeline">                                      Loc.getWithNewPtr(PredPtrVal), isLoad,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1363</td>
    <td class="codeline">                                      Pred, Result, Visited)) {</td>
    <td class="lineNumber">1363</td>
    <td class="codeline">                                      Pred, Result, Visited)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1364</td>
    <td class="codeline">        // Add the entry to the Result list.</td>
    <td class="lineNumber">1364</td>
    <td class="codeline">        // Add the entry to the Result list.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1365</td>
    <td class="codeline">        NonLocalDepResult Entry(Pred, MemDepResult::getUnknown(), PredPtrVal);</td>
    <td class="lineNumber">1365</td>
    <td class="codeline">        NonLocalDepResult Entry(Pred, MemDepResult::getUnknown(), PredPtrVal);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1366</td>
    <td class="codeline">        Result.push_back(Entry);</td>
    <td class="lineNumber">1366</td>
    <td class="codeline">        Result.push_back(Entry);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1367</td>
    <td class="codeline"></td>
    <td class="lineNumber">1367</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1368</td>
    <td class="codeline">        // Since we had a phi translation failure, the cache for CacheKey won't</td>
    <td class="lineNumber">1368</td>
    <td class="codeline">        // Since we had a phi translation failure, the cache for CacheKey won't</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1369</td>
    <td class="codeline">        // include all of the entries that we need to immediately satisfy future</td>
    <td class="lineNumber">1369</td>
    <td class="codeline">        // include all of the entries that we need to immediately satisfy future</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1370</td>
    <td class="codeline">        // queries.  Mark this in NonLocalPointerDeps by setting the</td>
    <td class="lineNumber">1370</td>
    <td class="codeline">        // queries.  Mark this in NonLocalPointerDeps by setting the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1371</td>
    <td class="codeline">        // BBSkipFirstBlockPair pointer to null.  This requires reuse of the</td>
    <td class="lineNumber">1371</td>
    <td class="codeline">        // BBSkipFirstBlockPair pointer to null.  This requires reuse of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1372</td>
    <td class="codeline">        // cached value to do more work but not miss the phi trans failure.</td>
    <td class="lineNumber">1372</td>
    <td class="codeline">        // cached value to do more work but not miss the phi trans failure.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1373</td>
    <td class="codeline">        NonLocalPointerInfo &NLPI = NonLocalPointerDeps[CacheKey];</td>
    <td class="lineNumber">1373</td>
    <td class="codeline">        NonLocalPointerInfo &NLPI = NonLocalPointerDeps[CacheKey];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1374</td>
    <td class="codeline">        NLPI.Pair = BBSkipFirstBlockPair();</td>
    <td class="lineNumber">1374</td>
    <td class="codeline">        NLPI.Pair = BBSkipFirstBlockPair();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1375</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">1375</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1376</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1376</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1377</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1377</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1378</td>
    <td class="codeline"></td>
    <td class="lineNumber">1378</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1379</td>
    <td class="codeline">    // Refresh the CacheInfo/Cache pointer so that it isn't invalidated.</td>
    <td class="lineNumber">1379</td>
    <td class="codeline">    // Refresh the CacheInfo/Cache pointer so that it isn't invalidated.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1380</td>
    <td class="codeline">    CacheInfo = &NonLocalPointerDeps[CacheKey];</td>
    <td class="lineNumber">1380</td>
    <td class="codeline">    CacheInfo = &NonLocalPointerDeps[CacheKey];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1381</td>
    <td class="codeline">    Cache = &CacheInfo->NonLocalDeps;</td>
    <td class="lineNumber">1381</td>
    <td class="codeline">    Cache = &CacheInfo->NonLocalDeps;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1382</td>
    <td class="codeline">    NumSortedEntries = Cache->size();</td>
    <td class="lineNumber">1382</td>
    <td class="codeline">    NumSortedEntries = Cache->size();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1383</td>
    <td class="codeline"></td>
    <td class="lineNumber">1383</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1384</td>
    <td class="codeline">    // Since we did phi translation, the "Cache" set won't contain all of the</td>
    <td class="lineNumber">1384</td>
    <td class="codeline">    // Since we did phi translation, the "Cache" set won't contain all of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1385</td>
    <td class="codeline">    // results for the query.  This is ok (we can still use it to accelerate</td>
    <td class="lineNumber">1385</td>
    <td class="codeline">    // results for the query.  This is ok (we can still use it to accelerate</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1386</td>
    <td class="codeline">    // specific block queries) but we can't do the fastpath "return all</td>
    <td class="lineNumber">1386</td>
    <td class="codeline">    // specific block queries) but we can't do the fastpath "return all</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1387</td>
    <td class="codeline">    // results from the set"  Clear out the indicator for this.</td>
    <td class="lineNumber">1387</td>
    <td class="codeline">    // results from the set"  Clear out the indicator for this.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1388</td>
    <td class="codeline">    CacheInfo->Pair = BBSkipFirstBlockPair();</td>
    <td class="lineNumber">1388</td>
    <td class="codeline">    CacheInfo->Pair = BBSkipFirstBlockPair();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1389</td>
    <td class="codeline">    SkipFirstBlock = false;</td>
    <td class="lineNumber">1389</td>
    <td class="codeline">    SkipFirstBlock = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1390</td>
    <td class="codeline">    continue;</td>
    <td class="lineNumber">1390</td>
    <td class="codeline">    continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1391</td>
    <td class="codeline"></td>
    <td class="lineNumber">1391</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1392</td>
    <td class="codeline">  PredTranslationFailure:</td>
    <td class="lineNumber">1392</td>
    <td class="codeline">  PredTranslationFailure:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1393</td>
    <td class="codeline">    // The following code is "failure"; we can't produce a sane translation</td>
    <td class="lineNumber">1393</td>
    <td class="codeline">    // The following code is "failure"; we can't produce a sane translation</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1394</td>
    <td class="codeline">    // for the given block.  It assumes that we haven't modified any of</td>
    <td class="lineNumber">1394</td>
    <td class="codeline">    // for the given block.  It assumes that we haven't modified any of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1395</td>
    <td class="codeline">    // our datastructures while processing the current block.</td>
    <td class="lineNumber">1395</td>
    <td class="codeline">    // our datastructures while processing the current block.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1396</td>
    <td class="codeline"></td>
    <td class="lineNumber">1396</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1397</td>
    <td class="codeline">    if (!Cache) {</td>
    <td class="lineNumber">1397</td>
    <td class="codeline">    if (!Cache) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1398</td>
    <td class="codeline">      // Refresh the CacheInfo/Cache pointer if it got invalidated.</td>
    <td class="lineNumber">1398</td>
    <td class="codeline">      // Refresh the CacheInfo/Cache pointer if it got invalidated.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1399</td>
    <td class="codeline">      CacheInfo = &NonLocalPointerDeps[CacheKey];</td>
    <td class="lineNumber">1399</td>
    <td class="codeline">      CacheInfo = &NonLocalPointerDeps[CacheKey];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1400</td>
    <td class="codeline">      Cache = &CacheInfo->NonLocalDeps;</td>
    <td class="lineNumber">1400</td>
    <td class="codeline">      Cache = &CacheInfo->NonLocalDeps;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1401</td>
    <td class="codeline">      NumSortedEntries = Cache->size();</td>
    <td class="lineNumber">1401</td>
    <td class="codeline">      NumSortedEntries = Cache->size();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1402</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1402</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1403</td>
    <td class="codeline"></td>
    <td class="lineNumber">1403</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1404</td>
    <td class="codeline">    // Since we failed phi translation, the "Cache" set won't contain all of the</td>
    <td class="lineNumber">1404</td>
    <td class="codeline">    // Since we failed phi translation, the "Cache" set won't contain all of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1405</td>
    <td class="codeline">    // results for the query.  This is ok (we can still use it to accelerate</td>
    <td class="lineNumber">1405</td>
    <td class="codeline">    // results for the query.  This is ok (we can still use it to accelerate</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1406</td>
    <td class="codeline">    // specific block queries) but we can't do the fastpath "return all</td>
    <td class="lineNumber">1406</td>
    <td class="codeline">    // specific block queries) but we can't do the fastpath "return all</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1407</td>
    <td class="codeline">    // results from the set".  Clear out the indicator for this.</td>
    <td class="lineNumber">1407</td>
    <td class="codeline">    // results from the set".  Clear out the indicator for this.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1408</td>
    <td class="codeline">    CacheInfo->Pair = BBSkipFirstBlockPair();</td>
    <td class="lineNumber">1408</td>
    <td class="codeline">    CacheInfo->Pair = BBSkipFirstBlockPair();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1409</td>
    <td class="codeline"></td>
    <td class="lineNumber">1409</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1410</td>
    <td class="codeline">    // If *nothing* works, mark the pointer as unknown.</td>
    <td class="lineNumber">1410</td>
    <td class="codeline">    // If *nothing* works, mark the pointer as unknown.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1411</td>
    <td class="codeline">    //</td>
    <td class="lineNumber">1411</td>
    <td class="codeline">    //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1412</td>
    <td class="codeline">    // If this is the magic first block, return this as a clobber of the whole</td>
    <td class="lineNumber">1412</td>
    <td class="codeline">    // If this is the magic first block, return this as a clobber of the whole</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1413</td>
    <td class="codeline">    // incoming value.  Since we can't phi translate to one of the predecessors,</td>
    <td class="lineNumber">1413</td>
    <td class="codeline">    // incoming value.  Since we can't phi translate to one of the predecessors,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1414</td>
    <td class="codeline">    // we have to bail out.</td>
    <td class="lineNumber">1414</td>
    <td class="codeline">    // we have to bail out.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1415</td>
    <td class="codeline">    if (SkipFirstBlock)</td>
    <td class="lineNumber">1415</td>
    <td class="codeline">    if (SkipFirstBlock)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1416</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">1416</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1417</td>
    <td class="codeline"></td>
    <td class="lineNumber">1417</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1418</td>
    <td class="codeline">    // Results of invariant loads are not cached thus no need to update cached</td>
    <td class="lineNumber">1418</td>
    <td class="codeline">    // Results of invariant loads are not cached thus no need to update cached</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1419</td>
    <td class="codeline">    // information.</td>
    <td class="lineNumber">1419</td>
    <td class="codeline">    // information.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1420</td>
    <td class="codeline">    if (!isInvariantLoad) {</td>
    <td class="lineNumber">1420</td>
    <td class="codeline">    if (!isInvariantLoad) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1421</td>
    <td class="codeline">      for (NonLocalDepEntry &I : llvm::reverse(*Cache)) {</td>
    <td class="lineNumber">1421</td>
    <td class="codeline">      for (NonLocalDepEntry &I : llvm::reverse(*Cache)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1422</td>
    <td class="codeline">        if (I.getBB() != BB)</td>
    <td class="lineNumber">1422</td>
    <td class="codeline">        if (I.getBB() != BB)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1423</td>
    <td class="codeline">          continue;</td>
    <td class="lineNumber">1423</td>
    <td class="codeline">          continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1424</td>
    <td class="codeline"></td>
    <td class="lineNumber">1424</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1425</td>
    <td class="codeline">        assert((GotWorklistLimit || I.getResult().isNonLocal() ||</td>
    <td class="lineNumber">1425</td>
    <td class="codeline">        assert((GotWorklistLimit || I.getResult().isNonLocal() ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1426</td>
    <td class="codeline">                !DT.isReachableFromEntry(BB)) &&</td>
    <td class="lineNumber">1426</td>
    <td class="codeline">                !DT.isReachableFromEntry(BB)) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1427</td>
    <td class="codeline">               "Should only be here with transparent block");</td>
    <td class="lineNumber">1427</td>
    <td class="codeline">               "Should only be here with transparent block");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1428</td>
    <td class="codeline"></td>
    <td class="lineNumber">1428</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1429</td>
    <td class="codeline">        I.setResult(MemDepResult::getUnknown());</td>
    <td class="lineNumber">1429</td>
    <td class="codeline">        I.setResult(MemDepResult::getUnknown());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1430</td>
    <td class="codeline"></td>
    <td class="lineNumber">1430</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1431</td>
    <td class="codeline"></td>
    <td class="lineNumber">1431</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1432</td>
    <td class="codeline">        break;</td>
    <td class="lineNumber">1432</td>
    <td class="codeline">        break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1433</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1433</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1434</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1434</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1435</td>
    <td class="codeline">    (void)GotWorklistLimit;</td>
    <td class="lineNumber">1435</td>
    <td class="codeline">    (void)GotWorklistLimit;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1436</td>
    <td class="codeline">    // Go ahead and report unknown dependence.</td>
    <td class="lineNumber">1436</td>
    <td class="codeline">    // Go ahead and report unknown dependence.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1437</td>
    <td class="codeline">    Result.push_back(</td>
    <td class="lineNumber">1437</td>
    <td class="codeline">    Result.push_back(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1438</td>
    <td class="codeline">        NonLocalDepResult(BB, MemDepResult::getUnknown(), Pointer.getAddr()));</td>
    <td class="lineNumber">1438</td>
    <td class="codeline">        NonLocalDepResult(BB, MemDepResult::getUnknown(), Pointer.getAddr()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1439</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1439</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1440</td>
    <td class="codeline"></td>
    <td class="lineNumber">1440</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1441</td>
    <td class="codeline">  // Okay, we're done now.  If we added new values to the cache, re-sort it.</td>
    <td class="lineNumber">1441</td>
    <td class="codeline">  // Okay, we're done now.  If we added new values to the cache, re-sort it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1442</td>
    <td class="codeline">  SortNonLocalDepInfoCache(*Cache, NumSortedEntries);</td>
    <td class="lineNumber">1442</td>
    <td class="codeline">  SortNonLocalDepInfoCache(*Cache, NumSortedEntries);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1443</td>
    <td class="codeline">  LLVM_DEBUG(AssertSorted(*Cache));</td>
    <td class="lineNumber">1443</td>
    <td class="codeline">  LLVM_DEBUG(AssertSorted(*Cache));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1444</td>
    <td class="codeline">  return true;</td>
    <td class="lineNumber">1444</td>
    <td class="codeline">  return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1445</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1445</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1446</td>
    <td class="codeline"></td>
    <td class="lineNumber">1446</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1447</td>
    <td class="codeline">/// If P exists in CachedNonLocalPointerInfo or NonLocalDefsCache, remove it.</td>
    <td class="lineNumber">1447</td>
    <td class="codeline">/// If P exists in CachedNonLocalPointerInfo or NonLocalDefsCache, remove it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1448</td>
    <td class="codeline">void MemoryDependenceResults::removeCachedNonLocalPointerDependencies(</td>
    <td class="lineNumber">1448</td>
    <td class="codeline">void MemoryDependenceResults::removeCachedNonLocalPointerDependencies(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1449</td>
    <td class="codeline">    ValueIsLoadPair P) {</td>
    <td class="lineNumber">1449</td>
    <td class="codeline">    ValueIsLoadPair P) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1450</td>
    <td class="codeline"></td>
    <td class="lineNumber">1450</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1451</td>
    <td class="codeline">  // Most of the time this cache is empty.</td>
    <td class="lineNumber">1451</td>
    <td class="codeline">  // Most of the time this cache is empty.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1452</td>
    <td class="codeline">  if (!NonLocalDefsCache.empty()) {</td>
    <td class="lineNumber">1452</td>
    <td class="codeline">  if (!NonLocalDefsCache.empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1453</td>
    <td class="codeline">    auto it = NonLocalDefsCache.find(P.getPointer());</td>
    <td class="lineNumber">1453</td>
    <td class="codeline">    auto it = NonLocalDefsCache.find(P.getPointer());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1454</td>
    <td class="codeline">    if (it != NonLocalDefsCache.end()) {</td>
    <td class="lineNumber">1454</td>
    <td class="codeline">    if (it != NonLocalDefsCache.end()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1455</td>
    <td class="codeline">      RemoveFromReverseMap(ReverseNonLocalDefsCache,</td>
    <td class="lineNumber">1455</td>
    <td class="codeline">      RemoveFromReverseMap(ReverseNonLocalDefsCache,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1456</td>
    <td class="codeline">                           it->second.getResult().getInst(), P.getPointer());</td>
    <td class="lineNumber">1456</td>
    <td class="codeline">                           it->second.getResult().getInst(), P.getPointer());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1457</td>
    <td class="codeline">      NonLocalDefsCache.erase(it);</td>
    <td class="lineNumber">1457</td>
    <td class="codeline">      NonLocalDefsCache.erase(it);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1458</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1458</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1459</td>
    <td class="codeline"></td>
    <td class="lineNumber">1459</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1460</td>
    <td class="codeline">    if (auto *I = dyn_cast<Instruction>(P.getPointer())) {</td>
    <td class="lineNumber">1460</td>
    <td class="codeline">    if (auto *I = dyn_cast<Instruction>(P.getPointer())) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1461</td>
    <td class="codeline">      auto toRemoveIt = ReverseNonLocalDefsCache.find(I);</td>
    <td class="lineNumber">1461</td>
    <td class="codeline">      auto toRemoveIt = ReverseNonLocalDefsCache.find(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1462</td>
    <td class="codeline">      if (toRemoveIt != ReverseNonLocalDefsCache.end()) {</td>
    <td class="lineNumber">1462</td>
    <td class="codeline">      if (toRemoveIt != ReverseNonLocalDefsCache.end()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1463</td>
    <td class="codeline">        for (const auto *entry : toRemoveIt->second)</td>
    <td class="lineNumber">1463</td>
    <td class="codeline">        for (const auto *entry : toRemoveIt->second)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1464</td>
    <td class="codeline">          NonLocalDefsCache.erase(entry);</td>
    <td class="lineNumber">1464</td>
    <td class="codeline">          NonLocalDefsCache.erase(entry);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1465</td>
    <td class="codeline">        ReverseNonLocalDefsCache.erase(toRemoveIt);</td>
    <td class="lineNumber">1465</td>
    <td class="codeline">        ReverseNonLocalDefsCache.erase(toRemoveIt);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1466</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1466</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1467</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1467</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1468</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1468</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1469</td>
    <td class="codeline"></td>
    <td class="lineNumber">1469</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1470</td>
    <td class="codeline">  CachedNonLocalPointerInfo::iterator It = NonLocalPointerDeps.find(P);</td>
    <td class="lineNumber">1470</td>
    <td class="codeline">  CachedNonLocalPointerInfo::iterator It = NonLocalPointerDeps.find(P);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1471</td>
    <td class="codeline">  if (It == NonLocalPointerDeps.end())</td>
    <td class="lineNumber">1471</td>
    <td class="codeline">  if (It == NonLocalPointerDeps.end())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1472</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">1472</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1473</td>
    <td class="codeline"></td>
    <td class="lineNumber">1473</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1474</td>
    <td class="codeline">  // Remove all of the entries in the BB->val map.  This involves removing</td>
    <td class="lineNumber">1474</td>
    <td class="codeline">  // Remove all of the entries in the BB->val map.  This involves removing</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1475</td>
    <td class="codeline">  // instructions from the reverse map.</td>
    <td class="lineNumber">1475</td>
    <td class="codeline">  // instructions from the reverse map.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1476</td>
    <td class="codeline">  NonLocalDepInfo &PInfo = It->second.NonLocalDeps;</td>
    <td class="lineNumber">1476</td>
    <td class="codeline">  NonLocalDepInfo &PInfo = It->second.NonLocalDeps;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1477</td>
    <td class="codeline"></td>
    <td class="lineNumber">1477</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1478</td>
    <td class="codeline">  for (const NonLocalDepEntry &DE : PInfo) {</td>
    <td class="lineNumber">1478</td>
    <td class="codeline">  for (const NonLocalDepEntry &DE : PInfo) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1479</td>
    <td class="codeline">    Instruction *Target = DE.getResult().getInst();</td>
    <td class="lineNumber">1479</td>
    <td class="codeline">    Instruction *Target = DE.getResult().getInst();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1480</td>
    <td class="codeline">    if (!Target)</td>
    <td class="lineNumber">1480</td>
    <td class="codeline">    if (!Target)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1481</td>
    <td class="codeline">      continue; // Ignore non-local dep results.</td>
    <td class="lineNumber">1481</td>
    <td class="codeline">      continue; // Ignore non-local dep results.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1482</td>
    <td class="codeline">    assert(Target->getParent() == DE.getBB());</td>
    <td class="lineNumber">1482</td>
    <td class="codeline">    assert(Target->getParent() == DE.getBB());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1483</td>
    <td class="codeline"></td>
    <td class="lineNumber">1483</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1484</td>
    <td class="codeline">    // Eliminating the dirty entry from 'Cache', so update the reverse info.</td>
    <td class="lineNumber">1484</td>
    <td class="codeline">    // Eliminating the dirty entry from 'Cache', so update the reverse info.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1485</td>
    <td class="codeline">    RemoveFromReverseMap(ReverseNonLocalPtrDeps, Target, P);</td>
    <td class="lineNumber">1485</td>
    <td class="codeline">    RemoveFromReverseMap(ReverseNonLocalPtrDeps, Target, P);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1486</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1486</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1487</td>
    <td class="codeline"></td>
    <td class="lineNumber">1487</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1488</td>
    <td class="codeline">  // Remove P from NonLocalPointerDeps (which deletes NonLocalDepInfo).</td>
    <td class="lineNumber">1488</td>
    <td class="codeline">  // Remove P from NonLocalPointerDeps (which deletes NonLocalDepInfo).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1489</td>
    <td class="codeline">  NonLocalPointerDeps.erase(It);</td>
    <td class="lineNumber">1489</td>
    <td class="codeline">  NonLocalPointerDeps.erase(It);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1490</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1490</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1491</td>
    <td class="codeline"></td>
    <td class="lineNumber">1491</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1492</td>
    <td class="codeline">void MemoryDependenceResults::invalidateCachedPointerInfo(Value *Ptr) {</td>
    <td class="lineNumber">1492</td>
    <td class="codeline">void MemoryDependenceResults::invalidateCachedPointerInfo(Value *Ptr) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1493</td>
    <td class="codeline">  // If Ptr isn't really a pointer, just ignore it.</td>
    <td class="lineNumber">1493</td>
    <td class="codeline">  // If Ptr isn't really a pointer, just ignore it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1494</td>
    <td class="codeline">  if (!Ptr->getType()->isPointerTy())</td>
    <td class="lineNumber">1494</td>
    <td class="codeline">  if (!Ptr->getType()->isPointerTy())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1495</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">1495</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1496</td>
    <td class="codeline">  // Flush store info for the pointer.</td>
    <td class="lineNumber">1496</td>
    <td class="codeline">  // Flush store info for the pointer.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1497</td>
    <td class="codeline">  removeCachedNonLocalPointerDependencies(ValueIsLoadPair(Ptr, false));</td>
    <td class="lineNumber">1497</td>
    <td class="codeline">  removeCachedNonLocalPointerDependencies(ValueIsLoadPair(Ptr, false));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1498</td>
    <td class="codeline">  // Flush load info for the pointer.</td>
    <td class="lineNumber">1498</td>
    <td class="codeline">  // Flush load info for the pointer.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1499</td>
    <td class="codeline">  removeCachedNonLocalPointerDependencies(ValueIsLoadPair(Ptr, true));</td>
    <td class="lineNumber">1499</td>
    <td class="codeline">  removeCachedNonLocalPointerDependencies(ValueIsLoadPair(Ptr, true));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1500</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1500</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1501</td>
    <td class="codeline"></td>
    <td class="lineNumber">1501</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1502</td>
    <td class="codeline">void MemoryDependenceResults::invalidateCachedPredecessors() {</td>
    <td class="lineNumber">1502</td>
    <td class="codeline">void MemoryDependenceResults::invalidateCachedPredecessors() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1503</td>
    <td class="codeline">  PredCache.clear();</td>
    <td class="lineNumber">1503</td>
    <td class="codeline">  PredCache.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1504</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1504</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1505</td>
    <td class="codeline"></td>
    <td class="lineNumber">1505</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1506</td>
    <td class="codeline">void MemoryDependenceResults::removeInstruction(Instruction *RemInst) {</td>
    <td class="lineNumber">1506</td>
    <td class="codeline">void MemoryDependenceResults::removeInstruction(Instruction *RemInst) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1507</td>
    <td class="codeline">  // Walk through the Non-local dependencies, removing this one as the value</td>
    <td class="lineNumber">1507</td>
    <td class="codeline">  // Walk through the Non-local dependencies, removing this one as the value</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1508</td>
    <td class="codeline">  // for any cached queries.</td>
    <td class="lineNumber">1508</td>
    <td class="codeline">  // for any cached queries.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1509</td>
    <td class="codeline">  NonLocalDepMapType::iterator NLDI = NonLocalDepsMap.find(RemInst);</td>
    <td class="lineNumber">1509</td>
    <td class="codeline">  NonLocalDepMapType::iterator NLDI = NonLocalDepsMap.find(RemInst);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1510</td>
    <td class="codeline">  if (NLDI != NonLocalDepsMap.end()) {</td>
    <td class="lineNumber">1510</td>
    <td class="codeline">  if (NLDI != NonLocalDepsMap.end()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1511</td>
    <td class="codeline">    NonLocalDepInfo &BlockMap = NLDI->second.first;</td>
    <td class="lineNumber">1511</td>
    <td class="codeline">    NonLocalDepInfo &BlockMap = NLDI->second.first;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1512</td>
    <td class="codeline">    for (auto &Entry : BlockMap)</td>
    <td class="lineNumber">1512</td>
    <td class="codeline">    for (auto &Entry : BlockMap)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1513</td>
    <td class="codeline">      if (Instruction *Inst = Entry.getResult().getInst())</td>
    <td class="lineNumber">1513</td>
    <td class="codeline">      if (Instruction *Inst = Entry.getResult().getInst())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1514</td>
    <td class="codeline">        RemoveFromReverseMap(ReverseNonLocalDeps, Inst, RemInst);</td>
    <td class="lineNumber">1514</td>
    <td class="codeline">        RemoveFromReverseMap(ReverseNonLocalDeps, Inst, RemInst);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1515</td>
    <td class="codeline">    NonLocalDepsMap.erase(NLDI);</td>
    <td class="lineNumber">1515</td>
    <td class="codeline">    NonLocalDepsMap.erase(NLDI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1516</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1516</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1517</td>
    <td class="codeline"></td>
    <td class="lineNumber">1517</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1518</td>
    <td class="codeline">  // If we have a cached local dependence query for this instruction, remove it.</td>
    <td class="lineNumber">1518</td>
    <td class="codeline">  // If we have a cached local dependence query for this instruction, remove it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1519</td>
    <td class="codeline">  LocalDepMapType::iterator LocalDepEntry = LocalDeps.find(RemInst);</td>
    <td class="lineNumber">1519</td>
    <td class="codeline">  LocalDepMapType::iterator LocalDepEntry = LocalDeps.find(RemInst);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1520</td>
    <td class="codeline">  if (LocalDepEntry != LocalDeps.end()) {</td>
    <td class="lineNumber">1520</td>
    <td class="codeline">  if (LocalDepEntry != LocalDeps.end()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1521</td>
    <td class="codeline">    // Remove us from DepInst's reverse set now that the local dep info is gone.</td>
    <td class="lineNumber">1521</td>
    <td class="codeline">    // Remove us from DepInst's reverse set now that the local dep info is gone.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1522</td>
    <td class="codeline">    if (Instruction *Inst = LocalDepEntry->second.getInst())</td>
    <td class="lineNumber">1522</td>
    <td class="codeline">    if (Instruction *Inst = LocalDepEntry->second.getInst())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1523</td>
    <td class="codeline">      RemoveFromReverseMap(ReverseLocalDeps, Inst, RemInst);</td>
    <td class="lineNumber">1523</td>
    <td class="codeline">      RemoveFromReverseMap(ReverseLocalDeps, Inst, RemInst);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1524</td>
    <td class="codeline"></td>
    <td class="lineNumber">1524</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1525</td>
    <td class="codeline">    // Remove this local dependency info.</td>
    <td class="lineNumber">1525</td>
    <td class="codeline">    // Remove this local dependency info.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1526</td>
    <td class="codeline">    LocalDeps.erase(LocalDepEntry);</td>
    <td class="lineNumber">1526</td>
    <td class="codeline">    LocalDeps.erase(LocalDepEntry);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1527</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1527</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1528</td>
    <td class="codeline"></td>
    <td class="lineNumber">1528</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1529</td>
    <td class="codeline">  // If we have any cached dependencies on this instruction, remove</td>
    <td class="lineNumber">1529</td>
    <td class="codeline">  // If we have any cached dependencies on this instruction, remove</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1530</td>
    <td class="codeline">  // them.</td>
    <td class="lineNumber">1530</td>
    <td class="codeline">  // them.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1531</td>
    <td class="codeline"></td>
    <td class="lineNumber">1531</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1532</td>
    <td class="codeline">  // If the instruction is a pointer, remove it from both the load info and the</td>
    <td class="lineNumber">1532</td>
    <td class="codeline">  // If the instruction is a pointer, remove it from both the load info and the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1533</td>
    <td class="codeline">  // store info.</td>
    <td class="lineNumber">1533</td>
    <td class="codeline">  // store info.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1534</td>
    <td class="codeline">  if (RemInst->getType()->isPointerTy()) {</td>
    <td class="lineNumber">1534</td>
    <td class="codeline">  if (RemInst->getType()->isPointerTy()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1535</td>
    <td class="codeline">    removeCachedNonLocalPointerDependencies(ValueIsLoadPair(RemInst, false));</td>
    <td class="lineNumber">1535</td>
    <td class="codeline">    removeCachedNonLocalPointerDependencies(ValueIsLoadPair(RemInst, false));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1536</td>
    <td class="codeline">    removeCachedNonLocalPointerDependencies(ValueIsLoadPair(RemInst, true));</td>
    <td class="lineNumber">1536</td>
    <td class="codeline">    removeCachedNonLocalPointerDependencies(ValueIsLoadPair(RemInst, true));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1537</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">1537</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1538</td>
    <td class="codeline">    // Otherwise, if the instructions is in the map directly, it must be a load.</td>
    <td class="lineNumber">1538</td>
    <td class="codeline">    // Otherwise, if the instructions is in the map directly, it must be a load.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1539</td>
    <td class="codeline">    // Remove it.</td>
    <td class="lineNumber">1539</td>
    <td class="codeline">    // Remove it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1540</td>
    <td class="codeline">    auto toRemoveIt = NonLocalDefsCache.find(RemInst);</td>
    <td class="lineNumber">1540</td>
    <td class="codeline">    auto toRemoveIt = NonLocalDefsCache.find(RemInst);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1541</td>
    <td class="codeline">    if (toRemoveIt != NonLocalDefsCache.end()) {</td>
    <td class="lineNumber">1541</td>
    <td class="codeline">    if (toRemoveIt != NonLocalDefsCache.end()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1542</td>
    <td class="codeline">      assert(isa<LoadInst>(RemInst) &&</td>
    <td class="lineNumber">1542</td>
    <td class="codeline">      assert(isa<LoadInst>(RemInst) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1543</td>
    <td class="codeline">             "only load instructions should be added directly");</td>
    <td class="lineNumber">1543</td>
    <td class="codeline">             "only load instructions should be added directly");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1544</td>
    <td class="codeline">      const Instruction *DepV = toRemoveIt->second.getResult().getInst();</td>
    <td class="lineNumber">1544</td>
    <td class="codeline">      const Instruction *DepV = toRemoveIt->second.getResult().getInst();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1545</td>
    <td class="codeline">      ReverseNonLocalDefsCache.find(DepV)->second.erase(RemInst);</td>
    <td class="lineNumber">1545</td>
    <td class="codeline">      ReverseNonLocalDefsCache.find(DepV)->second.erase(RemInst);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1546</td>
    <td class="codeline">      NonLocalDefsCache.erase(toRemoveIt);</td>
    <td class="lineNumber">1546</td>
    <td class="codeline">      NonLocalDefsCache.erase(toRemoveIt);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1547</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1547</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1548</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1548</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1549</td>
    <td class="codeline"></td>
    <td class="lineNumber">1549</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1550</td>
    <td class="codeline">  // Loop over all of the things that depend on the instruction we're removing.</td>
    <td class="lineNumber">1550</td>
    <td class="codeline">  // Loop over all of the things that depend on the instruction we're removing.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1551</td>
    <td class="codeline">  SmallVector<std::pair<Instruction *, Instruction *>, 8> ReverseDepsToAdd;</td>
    <td class="lineNumber">1551</td>
    <td class="codeline">  SmallVector<std::pair<Instruction *, Instruction *>, 8> ReverseDepsToAdd;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1552</td>
    <td class="codeline"></td>
    <td class="lineNumber">1552</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1553</td>
    <td class="codeline">  // If we find RemInst as a clobber or Def in any of the maps for other values,</td>
    <td class="lineNumber">1553</td>
    <td class="codeline">  // If we find RemInst as a clobber or Def in any of the maps for other values,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1554</td>
    <td class="codeline">  // we need to replace its entry with a dirty version of the instruction after</td>
    <td class="lineNumber">1554</td>
    <td class="codeline">  // we need to replace its entry with a dirty version of the instruction after</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1555</td>
    <td class="codeline">  // it.  If RemInst is a terminator, we use a null dirty value.</td>
    <td class="lineNumber">1555</td>
    <td class="codeline">  // it.  If RemInst is a terminator, we use a null dirty value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1556</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">1556</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1557</td>
    <td class="codeline">  // Using a dirty version of the instruction after RemInst saves having to scan</td>
    <td class="lineNumber">1557</td>
    <td class="codeline">  // Using a dirty version of the instruction after RemInst saves having to scan</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1558</td>
    <td class="codeline">  // the entire block to get to this point.</td>
    <td class="lineNumber">1558</td>
    <td class="codeline">  // the entire block to get to this point.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1559</td>
    <td class="codeline">  MemDepResult NewDirtyVal;</td>
    <td class="lineNumber">1559</td>
    <td class="codeline">  MemDepResult NewDirtyVal;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1560</td>
    <td class="codeline">  if (!RemInst->isTerminator())</td>
    <td class="lineNumber">1560</td>
    <td class="codeline">  if (!RemInst->isTerminator())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1561</td>
    <td class="codeline">    NewDirtyVal = MemDepResult::getDirty(&*++RemInst->getIterator());</td>
    <td class="lineNumber">1561</td>
    <td class="codeline">    NewDirtyVal = MemDepResult::getDirty(&*++RemInst->getIterator());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1562</td>
    <td class="codeline"></td>
    <td class="lineNumber">1562</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1563</td>
    <td class="codeline">  ReverseDepMapType::iterator ReverseDepIt = ReverseLocalDeps.find(RemInst);</td>
    <td class="lineNumber">1563</td>
    <td class="codeline">  ReverseDepMapType::iterator ReverseDepIt = ReverseLocalDeps.find(RemInst);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1564</td>
    <td class="codeline">  if (ReverseDepIt != ReverseLocalDeps.end()) {</td>
    <td class="lineNumber">1564</td>
    <td class="codeline">  if (ReverseDepIt != ReverseLocalDeps.end()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1565</td>
    <td class="codeline">    // RemInst can't be the terminator if it has local stuff depending on it.</td>
    <td class="lineNumber">1565</td>
    <td class="codeline">    // RemInst can't be the terminator if it has local stuff depending on it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1566</td>
    <td class="codeline">    assert(!ReverseDepIt->second.empty() && !RemInst->isTerminator() &&</td>
    <td class="lineNumber">1566</td>
    <td class="codeline">    assert(!ReverseDepIt->second.empty() && !RemInst->isTerminator() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1567</td>
    <td class="codeline">           "Nothing can locally depend on a terminator");</td>
    <td class="lineNumber">1567</td>
    <td class="codeline">           "Nothing can locally depend on a terminator");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1568</td>
    <td class="codeline"></td>
    <td class="lineNumber">1568</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1569</td>
    <td class="codeline">    for (Instruction *InstDependingOnRemInst : ReverseDepIt->second) {</td>
    <td class="lineNumber">1569</td>
    <td class="codeline">    for (Instruction *InstDependingOnRemInst : ReverseDepIt->second) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1570</td>
    <td class="codeline">      assert(InstDependingOnRemInst != RemInst &&</td>
    <td class="lineNumber">1570</td>
    <td class="codeline">      assert(InstDependingOnRemInst != RemInst &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1571</td>
    <td class="codeline">             "Already removed our local dep info");</td>
    <td class="lineNumber">1571</td>
    <td class="codeline">             "Already removed our local dep info");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1572</td>
    <td class="codeline"></td>
    <td class="lineNumber">1572</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1573</td>
    <td class="codeline">      LocalDeps[InstDependingOnRemInst] = NewDirtyVal;</td>
    <td class="lineNumber">1573</td>
    <td class="codeline">      LocalDeps[InstDependingOnRemInst] = NewDirtyVal;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1574</td>
    <td class="codeline"></td>
    <td class="lineNumber">1574</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1575</td>
    <td class="codeline">      // Make sure to remember that new things depend on NewDepInst.</td>
    <td class="lineNumber">1575</td>
    <td class="codeline">      // Make sure to remember that new things depend on NewDepInst.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1576</td>
    <td class="codeline">      assert(NewDirtyVal.getInst() &&</td>
    <td class="lineNumber">1576</td>
    <td class="codeline">      assert(NewDirtyVal.getInst() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1577</td>
    <td class="codeline">             "There is no way something else can have "</td>
    <td class="lineNumber">1577</td>
    <td class="codeline">             "There is no way something else can have "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1578</td>
    <td class="codeline">             "a local dep on this if it is a terminator!");</td>
    <td class="lineNumber">1578</td>
    <td class="codeline">             "a local dep on this if it is a terminator!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1579</td>
    <td class="codeline">      ReverseDepsToAdd.push_back(</td>
    <td class="lineNumber">1579</td>
    <td class="codeline">      ReverseDepsToAdd.push_back(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1580</td>
    <td class="codeline">          std::make_pair(NewDirtyVal.getInst(), InstDependingOnRemInst));</td>
    <td class="lineNumber">1580</td>
    <td class="codeline">          std::make_pair(NewDirtyVal.getInst(), InstDependingOnRemInst));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1581</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1581</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1582</td>
    <td class="codeline"></td>
    <td class="lineNumber">1582</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1583</td>
    <td class="codeline">    ReverseLocalDeps.erase(ReverseDepIt);</td>
    <td class="lineNumber">1583</td>
    <td class="codeline">    ReverseLocalDeps.erase(ReverseDepIt);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1584</td>
    <td class="codeline"></td>
    <td class="lineNumber">1584</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1585</td>
    <td class="codeline">    // Add new reverse deps after scanning the set, to avoid invalidating the</td>
    <td class="lineNumber">1585</td>
    <td class="codeline">    // Add new reverse deps after scanning the set, to avoid invalidating the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1586</td>
    <td class="codeline">    // 'ReverseDeps' reference.</td>
    <td class="lineNumber">1586</td>
    <td class="codeline">    // 'ReverseDeps' reference.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1587</td>
    <td class="codeline">    while (!ReverseDepsToAdd.empty()) {</td>
    <td class="lineNumber">1587</td>
    <td class="codeline">    while (!ReverseDepsToAdd.empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1588</td>
    <td class="codeline">      ReverseLocalDeps[ReverseDepsToAdd.back().first].insert(</td>
    <td class="lineNumber">1588</td>
    <td class="codeline">      ReverseLocalDeps[ReverseDepsToAdd.back().first].insert(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1589</td>
    <td class="codeline">          ReverseDepsToAdd.back().second);</td>
    <td class="lineNumber">1589</td>
    <td class="codeline">          ReverseDepsToAdd.back().second);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1590</td>
    <td class="codeline">      ReverseDepsToAdd.pop_back();</td>
    <td class="lineNumber">1590</td>
    <td class="codeline">      ReverseDepsToAdd.pop_back();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1591</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1591</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1592</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1592</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1593</td>
    <td class="codeline"></td>
    <td class="lineNumber">1593</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1594</td>
    <td class="codeline">  ReverseDepIt = ReverseNonLocalDeps.find(RemInst);</td>
    <td class="lineNumber">1594</td>
    <td class="codeline">  ReverseDepIt = ReverseNonLocalDeps.find(RemInst);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1595</td>
    <td class="codeline">  if (ReverseDepIt != ReverseNonLocalDeps.end()) {</td>
    <td class="lineNumber">1595</td>
    <td class="codeline">  if (ReverseDepIt != ReverseNonLocalDeps.end()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1596</td>
    <td class="codeline">    for (Instruction *I : ReverseDepIt->second) {</td>
    <td class="lineNumber">1596</td>
    <td class="codeline">    for (Instruction *I : ReverseDepIt->second) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1597</td>
    <td class="codeline">      assert(I != RemInst && "Already removed NonLocalDep info for RemInst");</td>
    <td class="lineNumber">1597</td>
    <td class="codeline">      assert(I != RemInst && "Already removed NonLocalDep info for RemInst");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1598</td>
    <td class="codeline"></td>
    <td class="lineNumber">1598</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1599</td>
    <td class="codeline">      PerInstNLInfo &INLD = NonLocalDepsMap[I];</td>
    <td class="lineNumber">1599</td>
    <td class="codeline">      PerInstNLInfo &INLD = NonLocalDepsMap[I];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1600</td>
    <td class="codeline">      // The information is now dirty!</td>
    <td class="lineNumber">1600</td>
    <td class="codeline">      // The information is now dirty!</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1601</td>
    <td class="codeline">      INLD.second = true;</td>
    <td class="lineNumber">1601</td>
    <td class="codeline">      INLD.second = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1602</td>
    <td class="codeline"></td>
    <td class="lineNumber">1602</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1603</td>
    <td class="codeline">      for (auto &Entry : INLD.first) {</td>
    <td class="lineNumber">1603</td>
    <td class="codeline">      for (auto &Entry : INLD.first) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1604</td>
    <td class="codeline">        if (Entry.getResult().getInst() != RemInst)</td>
    <td class="lineNumber">1604</td>
    <td class="codeline">        if (Entry.getResult().getInst() != RemInst)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1605</td>
    <td class="codeline">          continue;</td>
    <td class="lineNumber">1605</td>
    <td class="codeline">          continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1606</td>
    <td class="codeline"></td>
    <td class="lineNumber">1606</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1607</td>
    <td class="codeline">        // Convert to a dirty entry for the subsequent instruction.</td>
    <td class="lineNumber">1607</td>
    <td class="codeline">        // Convert to a dirty entry for the subsequent instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1608</td>
    <td class="codeline">        Entry.setResult(NewDirtyVal);</td>
    <td class="lineNumber">1608</td>
    <td class="codeline">        Entry.setResult(NewDirtyVal);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1609</td>
    <td class="codeline"></td>
    <td class="lineNumber">1609</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1610</td>
    <td class="codeline">        if (Instruction *NextI = NewDirtyVal.getInst())</td>
    <td class="lineNumber">1610</td>
    <td class="codeline">        if (Instruction *NextI = NewDirtyVal.getInst())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1611</td>
    <td class="codeline">          ReverseDepsToAdd.push_back(std::make_pair(NextI, I));</td>
    <td class="lineNumber">1611</td>
    <td class="codeline">          ReverseDepsToAdd.push_back(std::make_pair(NextI, I));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1612</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1612</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1613</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1613</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1614</td>
    <td class="codeline"></td>
    <td class="lineNumber">1614</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1615</td>
    <td class="codeline">    ReverseNonLocalDeps.erase(ReverseDepIt);</td>
    <td class="lineNumber">1615</td>
    <td class="codeline">    ReverseNonLocalDeps.erase(ReverseDepIt);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1616</td>
    <td class="codeline"></td>
    <td class="lineNumber">1616</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1617</td>
    <td class="codeline">    // Add new reverse deps after scanning the set, to avoid invalidating 'Set'</td>
    <td class="lineNumber">1617</td>
    <td class="codeline">    // Add new reverse deps after scanning the set, to avoid invalidating 'Set'</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1618</td>
    <td class="codeline">    while (!ReverseDepsToAdd.empty()) {</td>
    <td class="lineNumber">1618</td>
    <td class="codeline">    while (!ReverseDepsToAdd.empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1619</td>
    <td class="codeline">      ReverseNonLocalDeps[ReverseDepsToAdd.back().first].insert(</td>
    <td class="lineNumber">1619</td>
    <td class="codeline">      ReverseNonLocalDeps[ReverseDepsToAdd.back().first].insert(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1620</td>
    <td class="codeline">          ReverseDepsToAdd.back().second);</td>
    <td class="lineNumber">1620</td>
    <td class="codeline">          ReverseDepsToAdd.back().second);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1621</td>
    <td class="codeline">      ReverseDepsToAdd.pop_back();</td>
    <td class="lineNumber">1621</td>
    <td class="codeline">      ReverseDepsToAdd.pop_back();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1622</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1622</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1623</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1623</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1624</td>
    <td class="codeline"></td>
    <td class="lineNumber">1624</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1625</td>
    <td class="codeline">  // If the instruction is in ReverseNonLocalPtrDeps then it appears as a</td>
    <td class="lineNumber">1625</td>
    <td class="codeline">  // If the instruction is in ReverseNonLocalPtrDeps then it appears as a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1626</td>
    <td class="codeline">  // value in the NonLocalPointerDeps info.</td>
    <td class="lineNumber">1626</td>
    <td class="codeline">  // value in the NonLocalPointerDeps info.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1627</td>
    <td class="codeline">  ReverseNonLocalPtrDepTy::iterator ReversePtrDepIt =</td>
    <td class="lineNumber">1627</td>
    <td class="codeline">  ReverseNonLocalPtrDepTy::iterator ReversePtrDepIt =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1628</td>
    <td class="codeline">      ReverseNonLocalPtrDeps.find(RemInst);</td>
    <td class="lineNumber">1628</td>
    <td class="codeline">      ReverseNonLocalPtrDeps.find(RemInst);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1629</td>
    <td class="codeline">  if (ReversePtrDepIt != ReverseNonLocalPtrDeps.end()) {</td>
    <td class="lineNumber">1629</td>
    <td class="codeline">  if (ReversePtrDepIt != ReverseNonLocalPtrDeps.end()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1630</td>
    <td class="codeline">    SmallVector<std::pair<Instruction *, ValueIsLoadPair>, 8></td>
    <td class="lineNumber">1630</td>
    <td class="codeline">    SmallVector<std::pair<Instruction *, ValueIsLoadPair>, 8></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1631</td>
    <td class="codeline">        ReversePtrDepsToAdd;</td>
    <td class="lineNumber">1631</td>
    <td class="codeline">        ReversePtrDepsToAdd;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1632</td>
    <td class="codeline"></td>
    <td class="lineNumber">1632</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1633</td>
    <td class="codeline">    for (ValueIsLoadPair P : ReversePtrDepIt->second) {</td>
    <td class="lineNumber">1633</td>
    <td class="codeline">    for (ValueIsLoadPair P : ReversePtrDepIt->second) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1634</td>
    <td class="codeline">      assert(P.getPointer() != RemInst &&</td>
    <td class="lineNumber">1634</td>
    <td class="codeline">      assert(P.getPointer() != RemInst &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1635</td>
    <td class="codeline">             "Already removed NonLocalPointerDeps info for RemInst");</td>
    <td class="lineNumber">1635</td>
    <td class="codeline">             "Already removed NonLocalPointerDeps info for RemInst");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1636</td>
    <td class="codeline"></td>
    <td class="lineNumber">1636</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1637</td>
    <td class="codeline">      NonLocalDepInfo &NLPDI = NonLocalPointerDeps[P].NonLocalDeps;</td>
    <td class="lineNumber">1637</td>
    <td class="codeline">      NonLocalDepInfo &NLPDI = NonLocalPointerDeps[P].NonLocalDeps;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1638</td>
    <td class="codeline"></td>
    <td class="lineNumber">1638</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1639</td>
    <td class="codeline">      // The cache is not valid for any specific block anymore.</td>
    <td class="lineNumber">1639</td>
    <td class="codeline">      // The cache is not valid for any specific block anymore.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1640</td>
    <td class="codeline">      NonLocalPointerDeps[P].Pair = BBSkipFirstBlockPair();</td>
    <td class="lineNumber">1640</td>
    <td class="codeline">      NonLocalPointerDeps[P].Pair = BBSkipFirstBlockPair();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1641</td>
    <td class="codeline"></td>
    <td class="lineNumber">1641</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1642</td>
    <td class="codeline">      // Update any entries for RemInst to use the instruction after it.</td>
    <td class="lineNumber">1642</td>
    <td class="codeline">      // Update any entries for RemInst to use the instruction after it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1643</td>
    <td class="codeline">      for (auto &Entry : NLPDI) {</td>
    <td class="lineNumber">1643</td>
    <td class="codeline">      for (auto &Entry : NLPDI) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1644</td>
    <td class="codeline">        if (Entry.getResult().getInst() != RemInst)</td>
    <td class="lineNumber">1644</td>
    <td class="codeline">        if (Entry.getResult().getInst() != RemInst)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1645</td>
    <td class="codeline">          continue;</td>
    <td class="lineNumber">1645</td>
    <td class="codeline">          continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1646</td>
    <td class="codeline"></td>
    <td class="lineNumber">1646</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1647</td>
    <td class="codeline">        // Convert to a dirty entry for the subsequent instruction.</td>
    <td class="lineNumber">1647</td>
    <td class="codeline">        // Convert to a dirty entry for the subsequent instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1648</td>
    <td class="codeline">        Entry.setResult(NewDirtyVal);</td>
    <td class="lineNumber">1648</td>
    <td class="codeline">        Entry.setResult(NewDirtyVal);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1649</td>
    <td class="codeline"></td>
    <td class="lineNumber">1649</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1650</td>
    <td class="codeline">        if (Instruction *NewDirtyInst = NewDirtyVal.getInst())</td>
    <td class="lineNumber">1650</td>
    <td class="codeline">        if (Instruction *NewDirtyInst = NewDirtyVal.getInst())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1651</td>
    <td class="codeline">          ReversePtrDepsToAdd.push_back(std::make_pair(NewDirtyInst, P));</td>
    <td class="lineNumber">1651</td>
    <td class="codeline">          ReversePtrDepsToAdd.push_back(std::make_pair(NewDirtyInst, P));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1652</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1652</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1653</td>
    <td class="codeline"></td>
    <td class="lineNumber">1653</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1654</td>
    <td class="codeline">      // Re-sort the NonLocalDepInfo.  Changing the dirty entry to its</td>
    <td class="lineNumber">1654</td>
    <td class="codeline">      // Re-sort the NonLocalDepInfo.  Changing the dirty entry to its</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1655</td>
    <td class="codeline">      // subsequent value may invalidate the sortedness.</td>
    <td class="lineNumber">1655</td>
    <td class="codeline">      // subsequent value may invalidate the sortedness.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1656</td>
    <td class="codeline">      llvm::sort(NLPDI);</td>
    <td class="lineNumber">1656</td>
    <td class="codeline">      llvm::sort(NLPDI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1657</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1657</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1658</td>
    <td class="codeline"></td>
    <td class="lineNumber">1658</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1659</td>
    <td class="codeline">    ReverseNonLocalPtrDeps.erase(ReversePtrDepIt);</td>
    <td class="lineNumber">1659</td>
    <td class="codeline">    ReverseNonLocalPtrDeps.erase(ReversePtrDepIt);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1660</td>
    <td class="codeline"></td>
    <td class="lineNumber">1660</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1661</td>
    <td class="codeline">    while (!ReversePtrDepsToAdd.empty()) {</td>
    <td class="lineNumber">1661</td>
    <td class="codeline">    while (!ReversePtrDepsToAdd.empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1662</td>
    <td class="codeline">      ReverseNonLocalPtrDeps[ReversePtrDepsToAdd.back().first].insert(</td>
    <td class="lineNumber">1662</td>
    <td class="codeline">      ReverseNonLocalPtrDeps[ReversePtrDepsToAdd.back().first].insert(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1663</td>
    <td class="codeline">          ReversePtrDepsToAdd.back().second);</td>
    <td class="lineNumber">1663</td>
    <td class="codeline">          ReversePtrDepsToAdd.back().second);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1664</td>
    <td class="codeline">      ReversePtrDepsToAdd.pop_back();</td>
    <td class="lineNumber">1664</td>
    <td class="codeline">      ReversePtrDepsToAdd.pop_back();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1665</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1665</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1666</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1666</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1667</td>
    <td class="codeline"></td>
    <td class="lineNumber">1667</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1668</td>
    <td class="codeline">  assert(!NonLocalDepsMap.count(RemInst) && "RemInst got reinserted?");</td>
    <td class="lineNumber">1668</td>
    <td class="codeline">  assert(!NonLocalDepsMap.count(RemInst) && "RemInst got reinserted?");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1669</td>
    <td class="codeline">  LLVM_DEBUG(verifyRemoved(RemInst));</td>
    <td class="lineNumber">1669</td>
    <td class="codeline">  LLVM_DEBUG(verifyRemoved(RemInst));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1670</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1670</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1671</td>
    <td class="codeline"></td>
    <td class="lineNumber">1671</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1672</td>
    <td class="codeline">/// Verify that the specified instruction does not occur in our internal data</td>
    <td class="lineNumber">1672</td>
    <td class="codeline">/// Verify that the specified instruction does not occur in our internal data</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1673</td>
    <td class="codeline">/// structures.</td>
    <td class="lineNumber">1673</td>
    <td class="codeline">/// structures.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1674</td>
    <td class="codeline">///</td>
    <td class="lineNumber">1674</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1675</td>
    <td class="codeline">/// This function verifies by asserting in debug builds.</td>
    <td class="lineNumber">1675</td>
    <td class="codeline">/// This function verifies by asserting in debug builds.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1676</td>
    <td class="codeline">void MemoryDependenceResults::verifyRemoved(Instruction *D) const {</td>
    <td class="lineNumber">1676</td>
    <td class="codeline">void MemoryDependenceResults::verifyRemoved(Instruction *D) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1677</td>
    <td class="codeline">#ifndef NDEBUG</td>
    <td class="lineNumber">1677</td>
    <td class="codeline">#ifndef NDEBUG</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1678</td>
    <td class="codeline">  for (const auto &DepKV : LocalDeps) {</td>
    <td class="lineNumber">1678</td>
    <td class="codeline">  for (const auto &DepKV : LocalDeps) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1679</td>
    <td class="codeline">    assert(DepKV.first != D && "Inst occurs in data structures");</td>
    <td class="lineNumber">1679</td>
    <td class="codeline">    assert(DepKV.first != D && "Inst occurs in data structures");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1680</td>
    <td class="codeline">    assert(DepKV.second.getInst() != D && "Inst occurs in data structures");</td>
    <td class="lineNumber">1680</td>
    <td class="codeline">    assert(DepKV.second.getInst() != D && "Inst occurs in data structures");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1681</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1681</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1682</td>
    <td class="codeline"></td>
    <td class="lineNumber">1682</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1683</td>
    <td class="codeline">  for (const auto &DepKV : NonLocalPointerDeps) {</td>
    <td class="lineNumber">1683</td>
    <td class="codeline">  for (const auto &DepKV : NonLocalPointerDeps) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1684</td>
    <td class="codeline">    assert(DepKV.first.getPointer() != D && "Inst occurs in NLPD map key");</td>
    <td class="lineNumber">1684</td>
    <td class="codeline">    assert(DepKV.first.getPointer() != D && "Inst occurs in NLPD map key");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1685</td>
    <td class="codeline">    for (const auto &Entry : DepKV.second.NonLocalDeps)</td>
    <td class="lineNumber">1685</td>
    <td class="codeline">    for (const auto &Entry : DepKV.second.NonLocalDeps)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1686</td>
    <td class="codeline">      assert(Entry.getResult().getInst() != D && "Inst occurs as NLPD value");</td>
    <td class="lineNumber">1686</td>
    <td class="codeline">      assert(Entry.getResult().getInst() != D && "Inst occurs as NLPD value");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1687</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1687</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1688</td>
    <td class="codeline"></td>
    <td class="lineNumber">1688</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1689</td>
    <td class="codeline">  for (const auto &DepKV : NonLocalDepsMap) {</td>
    <td class="lineNumber">1689</td>
    <td class="codeline">  for (const auto &DepKV : NonLocalDepsMap) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1690</td>
    <td class="codeline">    assert(DepKV.first != D && "Inst occurs in data structures");</td>
    <td class="lineNumber">1690</td>
    <td class="codeline">    assert(DepKV.first != D && "Inst occurs in data structures");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1691</td>
    <td class="codeline">    const PerInstNLInfo &INLD = DepKV.second;</td>
    <td class="lineNumber">1691</td>
    <td class="codeline">    const PerInstNLInfo &INLD = DepKV.second;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1692</td>
    <td class="codeline">    for (const auto &Entry : INLD.first)</td>
    <td class="lineNumber">1692</td>
    <td class="codeline">    for (const auto &Entry : INLD.first)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1693</td>
    <td class="codeline">      assert(Entry.getResult().getInst() != D &&</td>
    <td class="lineNumber">1693</td>
    <td class="codeline">      assert(Entry.getResult().getInst() != D &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1694</td>
    <td class="codeline">             "Inst occurs in data structures");</td>
    <td class="lineNumber">1694</td>
    <td class="codeline">             "Inst occurs in data structures");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1695</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1695</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1696</td>
    <td class="codeline"></td>
    <td class="lineNumber">1696</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1697</td>
    <td class="codeline">  for (const auto &DepKV : ReverseLocalDeps) {</td>
    <td class="lineNumber">1697</td>
    <td class="codeline">  for (const auto &DepKV : ReverseLocalDeps) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1698</td>
    <td class="codeline">    assert(DepKV.first != D && "Inst occurs in data structures");</td>
    <td class="lineNumber">1698</td>
    <td class="codeline">    assert(DepKV.first != D && "Inst occurs in data structures");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1699</td>
    <td class="codeline">    for (Instruction *Inst : DepKV.second)</td>
    <td class="lineNumber">1699</td>
    <td class="codeline">    for (Instruction *Inst : DepKV.second)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1700</td>
    <td class="codeline">      assert(Inst != D && "Inst occurs in data structures");</td>
    <td class="lineNumber">1700</td>
    <td class="codeline">      assert(Inst != D && "Inst occurs in data structures");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1701</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1701</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1702</td>
    <td class="codeline"></td>
    <td class="lineNumber">1702</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1703</td>
    <td class="codeline">  for (const auto &DepKV : ReverseNonLocalDeps) {</td>
    <td class="lineNumber">1703</td>
    <td class="codeline">  for (const auto &DepKV : ReverseNonLocalDeps) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1704</td>
    <td class="codeline">    assert(DepKV.first != D && "Inst occurs in data structures");</td>
    <td class="lineNumber">1704</td>
    <td class="codeline">    assert(DepKV.first != D && "Inst occurs in data structures");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1705</td>
    <td class="codeline">    for (Instruction *Inst : DepKV.second)</td>
    <td class="lineNumber">1705</td>
    <td class="codeline">    for (Instruction *Inst : DepKV.second)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1706</td>
    <td class="codeline">      assert(Inst != D && "Inst occurs in data structures");</td>
    <td class="lineNumber">1706</td>
    <td class="codeline">      assert(Inst != D && "Inst occurs in data structures");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1707</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1707</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1708</td>
    <td class="codeline"></td>
    <td class="lineNumber">1708</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1709</td>
    <td class="codeline">  for (const auto &DepKV : ReverseNonLocalPtrDeps) {</td>
    <td class="lineNumber">1709</td>
    <td class="codeline">  for (const auto &DepKV : ReverseNonLocalPtrDeps) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1710</td>
    <td class="codeline">    assert(DepKV.first != D && "Inst occurs in rev NLPD map");</td>
    <td class="lineNumber">1710</td>
    <td class="codeline">    assert(DepKV.first != D && "Inst occurs in rev NLPD map");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1711</td>
    <td class="codeline"></td>
    <td class="lineNumber">1711</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1712</td>
    <td class="codeline">    for (ValueIsLoadPair P : DepKV.second)</td>
    <td class="lineNumber">1712</td>
    <td class="codeline">    for (ValueIsLoadPair P : DepKV.second)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1713</td>
    <td class="codeline">      assert(P != ValueIsLoadPair(D, false) && P != ValueIsLoadPair(D, true) &&</td>
    <td class="lineNumber">1713</td>
    <td class="codeline">      assert(P != ValueIsLoadPair(D, false) && P != ValueIsLoadPair(D, true) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1714</td>
    <td class="codeline">             "Inst occurs in ReverseNonLocalPtrDeps map");</td>
    <td class="lineNumber">1714</td>
    <td class="codeline">             "Inst occurs in ReverseNonLocalPtrDeps map");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1715</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1715</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1716</td>
    <td class="codeline">#endif</td>
    <td class="lineNumber">1716</td>
    <td class="codeline">#endif</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1717</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1717</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1718</td>
    <td class="codeline"></td>
    <td class="lineNumber">1718</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1719</td>
    <td class="codeline">AnalysisKey MemoryDependenceAnalysis::Key;</td>
    <td class="lineNumber">1719</td>
    <td class="codeline">AnalysisKey MemoryDependenceAnalysis::Key;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1720</td>
    <td class="codeline"></td>
    <td class="lineNumber">1720</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1721</td>
    <td class="codeline">MemoryDependenceAnalysis::MemoryDependenceAnalysis()</td>
    <td class="lineNumber">1721</td>
    <td class="codeline">MemoryDependenceAnalysis::MemoryDependenceAnalysis()</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1722</td>
    <td class="codeline">    : DefaultBlockScanLimit(BlockScanLimit) {}</td>
    <td class="lineNumber">1722</td>
    <td class="codeline">    : DefaultBlockScanLimit(BlockScanLimit) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1723</td>
    <td class="codeline"></td>
    <td class="lineNumber">1723</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1724</td>
    <td class="codeline">MemoryDependenceResults</td>
    <td class="lineNumber">1724</td>
    <td class="codeline">MemoryDependenceResults</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1725</td>
    <td class="codeline">MemoryDependenceAnalysis::run(Function &F, FunctionAnalysisManager &AM) {</td>
    <td class="lineNumber">1725</td>
    <td class="codeline">MemoryDependenceAnalysis::run(Function &F, FunctionAnalysisManager &AM) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1726</td>
    <td class="codeline">  auto &AA = AM.getResult<AAManager>(F);</td>
    <td class="lineNumber">1726</td>
    <td class="codeline">  auto &AA = AM.getResult<AAManager>(F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1727</td>
    <td class="codeline">  auto &AC = AM.getResult<AssumptionAnalysis>(F);</td>
    <td class="lineNumber">1727</td>
    <td class="codeline">  auto &AC = AM.getResult<AssumptionAnalysis>(F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1728</td>
    <td class="codeline">  auto &TLI = AM.getResult<TargetLibraryAnalysis>(F);</td>
    <td class="lineNumber">1728</td>
    <td class="codeline">  auto &TLI = AM.getResult<TargetLibraryAnalysis>(F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1729</td>
    <td class="codeline">  auto &DT = AM.getResult<DominatorTreeAnalysis>(F);</td>
    <td class="lineNumber">1729</td>
    <td class="codeline">  auto &DT = AM.getResult<DominatorTreeAnalysis>(F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1730</td>
    <td class="codeline">  return MemoryDependenceResults(AA, AC, TLI, DT, DefaultBlockScanLimit);</td>
    <td class="lineNumber">1730</td>
    <td class="codeline">  return MemoryDependenceResults(AA, AC, TLI, DT, DefaultBlockScanLimit);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1731</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1731</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1732</td>
    <td class="codeline"></td>
    <td class="lineNumber">1732</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1733</td>
    <td class="codeline">char MemoryDependenceWrapperPass::ID = 0;</td>
    <td class="lineNumber">1733</td>
    <td class="codeline">char MemoryDependenceWrapperPass::ID = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1734</td>
    <td class="codeline"></td>
    <td class="lineNumber">1734</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1735</td>
    <td class="codeline">INITIALIZE_PASS_BEGIN(MemoryDependenceWrapperPass, "memdep",</td>
    <td class="lineNumber">1735</td>
    <td class="codeline">INITIALIZE_PASS_BEGIN(MemoryDependenceWrapperPass, "memdep",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1736</td>
    <td class="codeline">                      "Memory Dependence Analysis", false, true)</td>
    <td class="lineNumber">1736</td>
    <td class="codeline">                      "Memory Dependence Analysis", false, true)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1737</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(AssumptionCacheTracker)</td>
    <td class="lineNumber">1737</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(AssumptionCacheTracker)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1738</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(AAResultsWrapperPass)</td>
    <td class="lineNumber">1738</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(AAResultsWrapperPass)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1739</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(DominatorTreeWrapperPass)</td>
    <td class="lineNumber">1739</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(DominatorTreeWrapperPass)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1740</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(TargetLibraryInfoWrapperPass)</td>
    <td class="lineNumber">1740</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(TargetLibraryInfoWrapperPass)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1741</td>
    <td class="codeline">INITIALIZE_PASS_END(MemoryDependenceWrapperPass, "memdep",</td>
    <td class="lineNumber">1741</td>
    <td class="codeline">INITIALIZE_PASS_END(MemoryDependenceWrapperPass, "memdep",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1742</td>
    <td class="codeline">                    "Memory Dependence Analysis", false, true)</td>
    <td class="lineNumber">1742</td>
    <td class="codeline">                    "Memory Dependence Analysis", false, true)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1743</td>
    <td class="codeline"></td>
    <td class="lineNumber">1743</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1744</td>
    <td class="codeline">MemoryDependenceWrapperPass::MemoryDependenceWrapperPass() : FunctionPass(ID) {</td>
    <td class="lineNumber">1744</td>
    <td class="codeline">MemoryDependenceWrapperPass::MemoryDependenceWrapperPass() : FunctionPass(ID) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1745</td>
    <td class="codeline">  initializeMemoryDependenceWrapperPassPass(*PassRegistry::getPassRegistry());</td>
    <td class="lineNumber">1745</td>
    <td class="codeline">  initializeMemoryDependenceWrapperPassPass(*PassRegistry::getPassRegistry());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1746</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1746</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1747</td>
    <td class="codeline"></td>
    <td class="lineNumber">1747</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1748</td>
    <td class="codeline">MemoryDependenceWrapperPass::~MemoryDependenceWrapperPass() = default;</td>
    <td class="lineNumber">1748</td>
    <td class="codeline">MemoryDependenceWrapperPass::~MemoryDependenceWrapperPass() = default;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1749</td>
    <td class="codeline"></td>
    <td class="lineNumber">1749</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1750</td>
    <td class="codeline">void MemoryDependenceWrapperPass::releaseMemory() {</td>
    <td class="lineNumber">1750</td>
    <td class="codeline">void MemoryDependenceWrapperPass::releaseMemory() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1751</td>
    <td class="codeline">  MemDep.reset();</td>
    <td class="lineNumber">1751</td>
    <td class="codeline">  MemDep.reset();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1752</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1752</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1753</td>
    <td class="codeline"></td>
    <td class="lineNumber">1753</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1754</td>
    <td class="codeline">void MemoryDependenceWrapperPass::getAnalysisUsage(AnalysisUsage &AU) const {</td>
    <td class="lineNumber">1754</td>
    <td class="codeline">void MemoryDependenceWrapperPass::getAnalysisUsage(AnalysisUsage &AU) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1755</td>
    <td class="codeline">  AU.setPreservesAll();</td>
    <td class="lineNumber">1755</td>
    <td class="codeline">  AU.setPreservesAll();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1756</td>
    <td class="codeline">  AU.addRequired<AssumptionCacheTracker>();</td>
    <td class="lineNumber">1756</td>
    <td class="codeline">  AU.addRequired<AssumptionCacheTracker>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1757</td>
    <td class="codeline">  AU.addRequired<DominatorTreeWrapperPass>();</td>
    <td class="lineNumber">1757</td>
    <td class="codeline">  AU.addRequired<DominatorTreeWrapperPass>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1758</td>
    <td class="codeline">  AU.addRequiredTransitive<AAResultsWrapperPass>();</td>
    <td class="lineNumber">1758</td>
    <td class="codeline">  AU.addRequiredTransitive<AAResultsWrapperPass>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1759</td>
    <td class="codeline">  AU.addRequiredTransitive<TargetLibraryInfoWrapperPass>();</td>
    <td class="lineNumber">1759</td>
    <td class="codeline">  AU.addRequiredTransitive<TargetLibraryInfoWrapperPass>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1760</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1760</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1761</td>
    <td class="codeline"></td>
    <td class="lineNumber">1761</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1762</td>
    <td class="codeline">bool MemoryDependenceResults::invalidate(Function &F, const PreservedAnalyses &PA,</td>
    <td class="lineNumber">1762</td>
    <td class="codeline">bool MemoryDependenceResults::invalidate(Function &F, const PreservedAnalyses &PA,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1763</td>
    <td class="codeline">                               FunctionAnalysisManager::Invalidator &Inv) {</td>
    <td class="lineNumber">1763</td>
    <td class="codeline">                               FunctionAnalysisManager::Invalidator &Inv) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1764</td>
    <td class="codeline">  // Check whether our analysis is preserved.</td>
    <td class="lineNumber">1764</td>
    <td class="codeline">  // Check whether our analysis is preserved.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1765</td>
    <td class="codeline">  auto PAC = PA.getChecker<MemoryDependenceAnalysis>();</td>
    <td class="lineNumber">1765</td>
    <td class="codeline">  auto PAC = PA.getChecker<MemoryDependenceAnalysis>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1766</td>
    <td class="codeline">  if (!PAC.preserved() && !PAC.preservedSet<AllAnalysesOn<Function>>())</td>
    <td class="lineNumber">1766</td>
    <td class="codeline">  if (!PAC.preserved() && !PAC.preservedSet<AllAnalysesOn<Function>>())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1767</td>
    <td class="codeline">    // If not, give up now.</td>
    <td class="lineNumber">1767</td>
    <td class="codeline">    // If not, give up now.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1768</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">1768</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1769</td>
    <td class="codeline"></td>
    <td class="lineNumber">1769</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1770</td>
    <td class="codeline">  // Check whether the analyses we depend on became invalid for any reason.</td>
    <td class="lineNumber">1770</td>
    <td class="codeline">  // Check whether the analyses we depend on became invalid for any reason.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1771</td>
    <td class="codeline">  if (Inv.invalidate<AAManager>(F, PA) ||</td>
    <td class="lineNumber">1771</td>
    <td class="codeline">  if (Inv.invalidate<AAManager>(F, PA) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1772</td>
    <td class="codeline">      Inv.invalidate<AssumptionAnalysis>(F, PA) ||</td>
    <td class="lineNumber">1772</td>
    <td class="codeline">      Inv.invalidate<AssumptionAnalysis>(F, PA) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1773</td>
    <td class="codeline">      Inv.invalidate<DominatorTreeAnalysis>(F, PA))</td>
    <td class="lineNumber">1773</td>
    <td class="codeline">      Inv.invalidate<DominatorTreeAnalysis>(F, PA))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1774</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">1774</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1775</td>
    <td class="codeline"></td>
    <td class="lineNumber">1775</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1776</td>
    <td class="codeline">  // Otherwise this analysis result remains valid.</td>
    <td class="lineNumber">1776</td>
    <td class="codeline">  // Otherwise this analysis result remains valid.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1777</td>
    <td class="codeline">  return false;</td>
    <td class="lineNumber">1777</td>
    <td class="codeline">  return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1778</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1778</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1779</td>
    <td class="codeline"></td>
    <td class="lineNumber">1779</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1780</td>
    <td class="codeline">unsigned MemoryDependenceResults::getDefaultBlockScanLimit() const {</td>
    <td class="lineNumber">1780</td>
    <td class="codeline">unsigned MemoryDependenceResults::getDefaultBlockScanLimit() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1781</td>
    <td class="codeline">  return DefaultBlockScanLimit;</td>
    <td class="lineNumber">1781</td>
    <td class="codeline">  return DefaultBlockScanLimit;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1782</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1782</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1783</td>
    <td class="codeline"></td>
    <td class="lineNumber">1783</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1784</td>
    <td class="codeline">bool MemoryDependenceWrapperPass::runOnFunction(Function &F) {</td>
    <td class="lineNumber">1784</td>
    <td class="codeline">bool MemoryDependenceWrapperPass::runOnFunction(Function &F) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1785</td>
    <td class="codeline">  auto &AA = getAnalysis<AAResultsWrapperPass>().getAAResults();</td>
    <td class="lineNumber">1785</td>
    <td class="codeline">  auto &AA = getAnalysis<AAResultsWrapperPass>().getAAResults();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1786</td>
    <td class="codeline">  auto &AC = getAnalysis<AssumptionCacheTracker>().getAssumptionCache(F);</td>
    <td class="lineNumber">1786</td>
    <td class="codeline">  auto &AC = getAnalysis<AssumptionCacheTracker>().getAssumptionCache(F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1787</td>
    <td class="codeline">  auto &TLI = getAnalysis<TargetLibraryInfoWrapperPass>().getTLI(F);</td>
    <td class="lineNumber">1787</td>
    <td class="codeline">  auto &TLI = getAnalysis<TargetLibraryInfoWrapperPass>().getTLI(F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1788</td>
    <td class="codeline">  auto &DT = getAnalysis<DominatorTreeWrapperPass>().getDomTree();</td>
    <td class="lineNumber">1788</td>
    <td class="codeline">  auto &DT = getAnalysis<DominatorTreeWrapperPass>().getDomTree();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1789</td>
    <td class="codeline">  MemDep.emplace(AA, AC, TLI, DT, BlockScanLimit);</td>
    <td class="lineNumber">1789</td>
    <td class="codeline">  MemDep.emplace(AA, AC, TLI, DT, BlockScanLimit);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1790</td>
    <td class="codeline">  return false;</td>
    <td class="lineNumber">1790</td>
    <td class="codeline">  return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1791</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1791</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1792</td>
    <td class="codeline"></td>
    <td class="lineNumber">1792</td>
    <td class="codeline"></td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Side By Side Comparison</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Side By Side Comparison</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </th>
    <th class="mainTh">Hit count</th>
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </th>
    <th class="mainTh">Hit count</th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="codeLine">//===- MemoryDependenceAnalysis.cpp - Mem Deps Implementation -------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1</td>
    <td class="codeLine">//===- MemoryDependenceAnalysis.cpp - Mem Deps Implementation -------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="codeLine">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3</td>
    <td class="codeLine">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="codeLine">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4</td>
    <td class="codeLine">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="codeLine">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5</td>
    <td class="codeLine">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">6</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">7</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">8</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="codeLine">// This file implements an analysis that determines, for a given memory</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">9</td>
    <td class="codeLine">// This file implements an analysis that determines, for a given memory</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="codeLine">// operation, what preceding memory operations it depends on.  It builds on</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">10</td>
    <td class="codeLine">// operation, what preceding memory operations it depends on.  It builds on</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="codeLine">// alias analysis information, and tries to provide a lazy, caching interface to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">11</td>
    <td class="codeLine">// alias analysis information, and tries to provide a lazy, caching interface to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="codeLine">// a common kind of alias information query.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">12</td>
    <td class="codeLine">// a common kind of alias information query.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">13</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">14</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">15</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="codeLine">#include "llvm/Analysis/MemoryDependenceAnalysis.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">16</td>
    <td class="codeLine">#include "llvm/Analysis/MemoryDependenceAnalysis.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="codeLine">#include "llvm/ADT/DenseMap.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">17</td>
    <td class="codeLine">#include "llvm/ADT/DenseMap.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="codeLine">#include "llvm/ADT/STLExtras.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">18</td>
    <td class="codeLine">#include "llvm/ADT/STLExtras.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="codeLine">#include "llvm/ADT/SmallPtrSet.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">19</td>
    <td class="codeLine">#include "llvm/ADT/SmallPtrSet.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="codeLine">#include "llvm/ADT/SmallVector.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">20</td>
    <td class="codeLine">#include "llvm/ADT/SmallVector.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="codeLine">#include "llvm/ADT/Statistic.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">21</td>
    <td class="codeLine">#include "llvm/ADT/Statistic.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="codeLine">#include "llvm/Analysis/AliasAnalysis.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">22</td>
    <td class="codeLine">#include "llvm/Analysis/AliasAnalysis.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="codeLine">#include "llvm/Analysis/AssumptionCache.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">23</td>
    <td class="codeLine">#include "llvm/Analysis/AssumptionCache.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="codeLine">#include "llvm/Analysis/MemoryBuiltins.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">24</td>
    <td class="codeLine">#include "llvm/Analysis/MemoryBuiltins.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="codeLine">#include "llvm/Analysis/MemoryLocation.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">25</td>
    <td class="codeLine">#include "llvm/Analysis/MemoryLocation.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="codeLine">#include "llvm/Analysis/PHITransAddr.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">26</td>
    <td class="codeLine">#include "llvm/Analysis/PHITransAddr.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="codeLine">#include "llvm/Analysis/TargetLibraryInfo.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">27</td>
    <td class="codeLine">#include "llvm/Analysis/TargetLibraryInfo.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="codeLine">#include "llvm/Analysis/ValueTracking.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">28</td>
    <td class="codeLine">#include "llvm/Analysis/ValueTracking.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="codeLine">#include "llvm/IR/BasicBlock.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">29</td>
    <td class="codeLine">#include "llvm/IR/BasicBlock.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="codeLine">#include "llvm/IR/Dominators.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">30</td>
    <td class="codeLine">#include "llvm/IR/Dominators.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="codeLine">#include "llvm/IR/Function.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">31</td>
    <td class="codeLine">#include "llvm/IR/Function.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="codeLine">#include "llvm/IR/InstrTypes.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">32</td>
    <td class="codeLine">#include "llvm/IR/InstrTypes.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="codeLine">#include "llvm/IR/Instruction.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">33</td>
    <td class="codeLine">#include "llvm/IR/Instruction.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="codeLine">#include "llvm/IR/Instructions.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">34</td>
    <td class="codeLine">#include "llvm/IR/Instructions.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="codeLine">#include "llvm/IR/IntrinsicInst.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">35</td>
    <td class="codeLine">#include "llvm/IR/IntrinsicInst.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="codeLine">#include "llvm/IR/LLVMContext.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">36</td>
    <td class="codeLine">#include "llvm/IR/LLVMContext.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="codeLine">#include "llvm/IR/Metadata.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">37</td>
    <td class="codeLine">#include "llvm/IR/Metadata.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="codeLine">#include "llvm/IR/Module.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">38</td>
    <td class="codeLine">#include "llvm/IR/Module.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="codeLine">#include "llvm/IR/PredIteratorCache.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">39</td>
    <td class="codeLine">#include "llvm/IR/PredIteratorCache.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="codeLine">#include "llvm/IR/Type.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">40</td>
    <td class="codeLine">#include "llvm/IR/Type.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="codeLine">#include "llvm/IR/Use.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">41</td>
    <td class="codeLine">#include "llvm/IR/Use.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="codeLine">#include "llvm/IR/Value.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">42</td>
    <td class="codeLine">#include "llvm/IR/Value.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="codeLine">#include "llvm/InitializePasses.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">43</td>
    <td class="codeLine">#include "llvm/InitializePasses.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="codeLine">#include "llvm/Pass.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">44</td>
    <td class="codeLine">#include "llvm/Pass.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="codeLine">#include "llvm/Support/AtomicOrdering.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">45</td>
    <td class="codeLine">#include "llvm/Support/AtomicOrdering.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="codeLine">#include "llvm/Support/Casting.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">46</td>
    <td class="codeLine">#include "llvm/Support/Casting.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="codeLine">#include "llvm/Support/CommandLine.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">47</td>
    <td class="codeLine">#include "llvm/Support/CommandLine.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="codeLine">#include "llvm/Support/Compiler.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">48</td>
    <td class="codeLine">#include "llvm/Support/Compiler.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="codeLine">#include "llvm/Support/Debug.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">49</td>
    <td class="codeLine">#include "llvm/Support/Debug.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="codeLine">#include <algorithm></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">50</td>
    <td class="codeLine">#include <algorithm></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="codeLine">#include <cassert></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">51</td>
    <td class="codeLine">#include <cassert></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="codeLine">#include <iterator></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">52</td>
    <td class="codeLine">#include <iterator></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="codeLine">#include <utility></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">53</td>
    <td class="codeLine">#include <utility></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">54</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="codeLine">using namespace llvm;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">55</td>
    <td class="codeLine">using namespace llvm;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">56</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="codeLine">#define DEBUG_TYPE "memdep"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">57</td>
    <td class="codeLine">#define DEBUG_TYPE "memdep"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">58</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="codeLine">STATISTIC(NumCacheNonLocal, "Number of fully cached non-local responses");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">59</td>
    <td class="codeLine">STATISTIC(NumCacheNonLocal, "Number of fully cached non-local responses");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="codeLine">STATISTIC(NumCacheDirtyNonLocal, "Number of dirty cached non-local responses");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">60</td>
    <td class="codeLine">STATISTIC(NumCacheDirtyNonLocal, "Number of dirty cached non-local responses");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="codeLine">STATISTIC(NumUncacheNonLocal, "Number of uncached non-local responses");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">61</td>
    <td class="codeLine">STATISTIC(NumUncacheNonLocal, "Number of uncached non-local responses");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">62</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="codeLine">STATISTIC(NumCacheNonLocalPtr,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">63</td>
    <td class="codeLine">STATISTIC(NumCacheNonLocalPtr,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="codeLine">          "Number of fully cached non-local ptr responses");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">64</td>
    <td class="codeLine">          "Number of fully cached non-local ptr responses");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="codeLine">STATISTIC(NumCacheDirtyNonLocalPtr,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">65</td>
    <td class="codeLine">STATISTIC(NumCacheDirtyNonLocalPtr,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="codeLine">          "Number of cached, but dirty, non-local ptr responses");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">66</td>
    <td class="codeLine">          "Number of cached, but dirty, non-local ptr responses");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="codeLine">STATISTIC(NumUncacheNonLocalPtr, "Number of uncached non-local ptr responses");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">67</td>
    <td class="codeLine">STATISTIC(NumUncacheNonLocalPtr, "Number of uncached non-local ptr responses");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="codeLine">STATISTIC(NumCacheCompleteNonLocalPtr,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">68</td>
    <td class="codeLine">STATISTIC(NumCacheCompleteNonLocalPtr,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="codeLine">          "Number of block queries that were completely cached");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">69</td>
    <td class="codeLine">          "Number of block queries that were completely cached");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">70</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="codeLine">// Limit for the number of instructions to scan in a block.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">71</td>
    <td class="codeLine">// Limit for the number of instructions to scan in a block.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">72</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="codeLine">static cl::opt<unsigned> BlockScanLimit(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">73</td>
    <td class="codeLine">static cl::opt<unsigned> BlockScanLimit(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="codeLine">    "memdep-block-scan-limit", cl::Hidden, cl::init(100),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">74</td>
    <td class="codeLine">    "memdep-block-scan-limit", cl::Hidden, cl::init(100),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="codeLine">    cl::desc("The number of instructions to scan in a block in memory "</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">75</td>
    <td class="codeLine">    cl::desc("The number of instructions to scan in a block in memory "</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="codeLine">             "dependency analysis (default = 100)"));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">76</td>
    <td class="codeLine">             "dependency analysis (default = 100)"));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">77</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="codeLine">static cl::opt<unsigned></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">78</td>
    <td class="codeLine">static cl::opt<unsigned></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="codeLine">    BlockNumberLimit("memdep-block-number-limit", cl::Hidden, cl::init(200),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">79</td>
    <td class="codeLine">    BlockNumberLimit("memdep-block-number-limit", cl::Hidden, cl::init(200),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="codeLine">                     cl::desc("The number of blocks to scan during memory "</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">80</td>
    <td class="codeLine">                     cl::desc("The number of blocks to scan during memory "</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="codeLine">                              "dependency analysis (default = 200)"));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">81</td>
    <td class="codeLine">                              "dependency analysis (default = 200)"));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">82</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="codeLine">// Limit on the number of memdep results to process.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">83</td>
    <td class="codeLine">// Limit on the number of memdep results to process.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="codeLine">static const unsigned int NumResultsLimit = 100;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">84</td>
    <td class="codeLine">static const unsigned int NumResultsLimit = 100;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">85</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="codeLine">/// This is a helper function that removes Val from 'Inst's set in ReverseMap.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">86</td>
    <td class="codeLine">/// This is a helper function that removes Val from 'Inst's set in ReverseMap.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">87</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="codeLine">/// If the set becomes empty, remove Inst's entry.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">88</td>
    <td class="codeLine">/// If the set becomes empty, remove Inst's entry.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="codeLine">template <typename KeyTy></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">89</td>
    <td class="codeLine">template <typename KeyTy></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="codeLine">static void</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">90</td>
    <td class="codeLine">static void</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="codeLine">RemoveFromReverseMap(DenseMap<Instruction *, SmallPtrSet<KeyTy, 4>> &ReverseMap,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">91</td>
    <td class="codeLine">RemoveFromReverseMap(DenseMap<Instruction *, SmallPtrSet<KeyTy, 4>> &ReverseMap,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="codeLine">                     Instruction *Inst, KeyTy Val) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">92</td>
    <td class="codeLine">                     Instruction *Inst, KeyTy Val) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="codeLine">  typename DenseMap<Instruction *, SmallPtrSet<KeyTy, 4>>::iterator InstIt =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">93</td>
    <td class="codeLine">  typename DenseMap<Instruction *, SmallPtrSet<KeyTy, 4>>::iterator InstIt =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="codeLine">      ReverseMap.find(Inst);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">94</td>
    <td class="codeLine">      ReverseMap.find(Inst);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="codeLine">  assert(InstIt != ReverseMap.end() && "Reverse map out of sync?");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">95</td>
    <td class="codeLine">  assert(InstIt != ReverseMap.end() && "Reverse map out of sync?");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="codeLine">  bool Found = InstIt->second.erase(Val);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">96</td>
    <td class="codeLine">  bool Found = InstIt->second.erase(Val);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="codeLine">  assert(Found && "Invalid reverse map!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">97</td>
    <td class="codeLine">  assert(Found && "Invalid reverse map!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="codeLine">  (void)Found;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">98</td>
    <td class="codeLine">  (void)Found;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="codeLine">  if (InstIt->second.empty())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">99</td>
    <td class="codeLine">  if (InstIt->second.empty())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="codeLine">    ReverseMap.erase(InstIt);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">100</td>
    <td class="codeLine">    ReverseMap.erase(InstIt);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">101</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">102</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="codeLine">/// If the given instruction references a specific memory location, fill in Loc</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">103</td>
    <td class="codeLine">/// If the given instruction references a specific memory location, fill in Loc</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="codeLine">/// with the details, otherwise set Loc.Ptr to null.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">104</td>
    <td class="codeLine">/// with the details, otherwise set Loc.Ptr to null.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">105</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="codeLine">/// Returns a ModRefInfo value describing the general behavior of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">106</td>
    <td class="codeLine">/// Returns a ModRefInfo value describing the general behavior of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="codeLine">/// instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">107</td>
    <td class="codeLine">/// instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="codeLine">static ModRefInfo GetLocation(const Instruction *Inst, MemoryLocation &Loc,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">108</td>
    <td class="codeLine">static ModRefInfo GetLocation(const Instruction *Inst, MemoryLocation &Loc,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="codeLine">                              const TargetLibraryInfo &TLI) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">109</td>
    <td class="codeLine">                              const TargetLibraryInfo &TLI) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="codeLine">  if (const LoadInst *LI = dyn_cast<LoadInst>(Inst)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">110</td>
    <td class="codeLine">  if (const LoadInst *LI = dyn_cast<LoadInst>(Inst)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="codeLine">    if (LI->isUnordered()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">111</td>
    <td class="codeLine">    if (LI->isUnordered()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="codeLine">      Loc = MemoryLocation::get(LI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">112</td>
    <td class="codeLine">      Loc = MemoryLocation::get(LI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="codeLine">      return ModRefInfo::Ref;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">113</td>
    <td class="codeLine">      return ModRefInfo::Ref;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">114</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="codeLine">    if (LI->getOrdering() == AtomicOrdering::Monotonic) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">115</td>
    <td class="codeLine">    if (LI->getOrdering() == AtomicOrdering::Monotonic) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="codeLine">      Loc = MemoryLocation::get(LI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">116</td>
    <td class="codeLine">      Loc = MemoryLocation::get(LI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="codeLine">      return ModRefInfo::ModRef;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">117</td>
    <td class="codeLine">      return ModRefInfo::ModRef;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">118</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="codeLine">    Loc = MemoryLocation();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">119</td>
    <td class="codeLine">    Loc = MemoryLocation();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="codeLine">    return ModRefInfo::ModRef;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">120</td>
    <td class="codeLine">    return ModRefInfo::ModRef;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">121</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">122</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="codeLine">  if (const StoreInst *SI = dyn_cast<StoreInst>(Inst)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">123</td>
    <td class="codeLine">  if (const StoreInst *SI = dyn_cast<StoreInst>(Inst)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="codeLine">    if (SI->isUnordered()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">124</td>
    <td class="codeLine">    if (SI->isUnordered()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="codeLine">      Loc = MemoryLocation::get(SI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">125</td>
    <td class="codeLine">      Loc = MemoryLocation::get(SI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="codeLine">      return ModRefInfo::Mod;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">126</td>
    <td class="codeLine">      return ModRefInfo::Mod;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">127</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="codeLine">    if (SI->getOrdering() == AtomicOrdering::Monotonic) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">128</td>
    <td class="codeLine">    if (SI->getOrdering() == AtomicOrdering::Monotonic) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="codeLine">      Loc = MemoryLocation::get(SI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">129</td>
    <td class="codeLine">      Loc = MemoryLocation::get(SI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="codeLine">      return ModRefInfo::ModRef;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">130</td>
    <td class="codeLine">      return ModRefInfo::ModRef;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">131</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="codeLine">    Loc = MemoryLocation();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">132</td>
    <td class="codeLine">    Loc = MemoryLocation();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="codeLine">    return ModRefInfo::ModRef;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">133</td>
    <td class="codeLine">    return ModRefInfo::ModRef;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">134</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">135</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="codeLine">  if (const VAArgInst *V = dyn_cast<VAArgInst>(Inst)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">136</td>
    <td class="codeLine">  if (const VAArgInst *V = dyn_cast<VAArgInst>(Inst)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="codeLine">    Loc = MemoryLocation::get(V);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">137</td>
    <td class="codeLine">    Loc = MemoryLocation::get(V);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="codeLine">    return ModRefInfo::ModRef;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">138</td>
    <td class="codeLine">    return ModRefInfo::ModRef;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">139</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">140</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="codeLine">  if (const CallBase *CB = dyn_cast<CallBase>(Inst)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">141</td>
    <td class="codeLine">  if (const CallBase *CB = dyn_cast<CallBase>(Inst)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="codeLine">    if (Value *FreedOp = getFreedOperand(CB, &TLI)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">142</td>
    <td class="codeLine">    if (Value *FreedOp = getFreedOperand(CB, &TLI)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="codeLine">      // calls to free() deallocate the entire structure</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">143</td>
    <td class="codeLine">      // calls to free() deallocate the entire structure</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="codeLine">      Loc = MemoryLocation::getAfter(FreedOp);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">144</td>
    <td class="codeLine">      Loc = MemoryLocation::getAfter(FreedOp);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="codeLine">      return ModRefInfo::Mod;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">145</td>
    <td class="codeLine">      return ModRefInfo::Mod;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">146</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">147</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">148</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="codeLine">  if (const IntrinsicInst *II = dyn_cast<IntrinsicInst>(Inst)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">149</td>
    <td class="codeLine">  if (const IntrinsicInst *II = dyn_cast<IntrinsicInst>(Inst)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="codeLine">    switch (II->getIntrinsicID()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">150</td>
    <td class="codeLine">    switch (II->getIntrinsicID()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="codeLine">    case Intrinsic::lifetime_start:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">151</td>
    <td class="codeLine">    case Intrinsic::lifetime_start:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="codeLine">    case Intrinsic::lifetime_end:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">152</td>
    <td class="codeLine">    case Intrinsic::lifetime_end:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="codeLine">    case Intrinsic::invariant_start:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">153</td>
    <td class="codeLine">    case Intrinsic::invariant_start:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="codeLine">      Loc = MemoryLocation::getForArgument(II, 1, TLI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">154</td>
    <td class="codeLine">      Loc = MemoryLocation::getForArgument(II, 1, TLI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="codeLine">      // These intrinsics don't really modify the memory, but returning Mod</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">155</td>
    <td class="codeLine">      // These intrinsics don't really modify the memory, but returning Mod</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="codeLine">      // will allow them to be handled conservatively.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">156</td>
    <td class="codeLine">      // will allow them to be handled conservatively.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="codeLine">      return ModRefInfo::Mod;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">157</td>
    <td class="codeLine">      return ModRefInfo::Mod;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="codeLine">    case Intrinsic::invariant_end:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">158</td>
    <td class="codeLine">    case Intrinsic::invariant_end:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="codeLine">      Loc = MemoryLocation::getForArgument(II, 2, TLI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">159</td>
    <td class="codeLine">      Loc = MemoryLocation::getForArgument(II, 2, TLI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="codeLine">      // These intrinsics don't really modify the memory, but returning Mod</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">160</td>
    <td class="codeLine">      // These intrinsics don't really modify the memory, but returning Mod</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="codeLine">      // will allow them to be handled conservatively.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">161</td>
    <td class="codeLine">      // will allow them to be handled conservatively.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="codeLine">      return ModRefInfo::Mod;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">162</td>
    <td class="codeLine">      return ModRefInfo::Mod;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="codeLine">    case Intrinsic::masked_load:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">163</td>
    <td class="codeLine">    case Intrinsic::masked_load:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="codeLine">      Loc = MemoryLocation::getForArgument(II, 0, TLI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">164</td>
    <td class="codeLine">      Loc = MemoryLocation::getForArgument(II, 0, TLI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="codeLine">      return ModRefInfo::Ref;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">165</td>
    <td class="codeLine">      return ModRefInfo::Ref;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="codeLine">    case Intrinsic::masked_store:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">166</td>
    <td class="codeLine">    case Intrinsic::masked_store:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="codeLine">      Loc = MemoryLocation::getForArgument(II, 1, TLI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">167</td>
    <td class="codeLine">      Loc = MemoryLocation::getForArgument(II, 1, TLI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="codeLine">      return ModRefInfo::Mod;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">168</td>
    <td class="codeLine">      return ModRefInfo::Mod;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="codeLine">    default:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">169</td>
    <td class="codeLine">    default:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">170</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">171</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">172</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">173</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="codeLine">  // Otherwise, just do the coarse-grained thing that always works.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">174</td>
    <td class="codeLine">  // Otherwise, just do the coarse-grained thing that always works.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="codeLine">  if (Inst->mayWriteToMemory())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">175</td>
    <td class="codeLine">  if (Inst->mayWriteToMemory())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="codeLine">    return ModRefInfo::ModRef;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">176</td>
    <td class="codeLine">    return ModRefInfo::ModRef;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="codeLine">  if (Inst->mayReadFromMemory())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">177</td>
    <td class="codeLine">  if (Inst->mayReadFromMemory())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="codeLine">    return ModRefInfo::Ref;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">178</td>
    <td class="codeLine">    return ModRefInfo::Ref;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="codeLine">  return ModRefInfo::NoModRef;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">179</td>
    <td class="codeLine">  return ModRefInfo::NoModRef;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">180</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">181</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="codeLine">/// Private helper for finding the local dependencies of a call site.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">182</td>
    <td class="codeLine">/// Private helper for finding the local dependencies of a call site.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="codeLine">MemDepResult MemoryDependenceResults::getCallDependencyFrom(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">183</td>
    <td class="codeLine">MemDepResult MemoryDependenceResults::getCallDependencyFrom(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="codeLine">    CallBase *Call, bool isReadOnlyCall, BasicBlock::iterator ScanIt,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">184</td>
    <td class="codeLine">    CallBase *Call, bool isReadOnlyCall, BasicBlock::iterator ScanIt,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="codeLine">    BasicBlock *BB) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">185</td>
    <td class="codeLine">    BasicBlock *BB) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="codeLine">  unsigned Limit = getDefaultBlockScanLimit();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">186</td>
    <td class="codeLine">  unsigned Limit = getDefaultBlockScanLimit();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">187</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="codeLine">  // Walk backwards through the block, looking for dependencies.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">188</td>
    <td class="codeLine">  // Walk backwards through the block, looking for dependencies.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="codeLine">  while (ScanIt != BB->begin()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">189</td>
    <td class="codeLine">  while (ScanIt != BB->begin()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="codeLine">    Instruction *Inst = &*--ScanIt;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">190</td>
    <td class="codeLine">    Instruction *Inst = &*--ScanIt;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="codeLine">    // Debug intrinsics don't cause dependences and should not affect Limit</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">191</td>
    <td class="codeLine">    // Debug intrinsics don't cause dependences and should not affect Limit</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="codeLine">    if (isa<DbgInfoIntrinsic>(Inst))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">192</td>
    <td class="codeLine">    if (isa<DbgInfoIntrinsic>(Inst))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">193</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">194</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="codeLine">    // Limit the amount of scanning we do so we don't end up with quadratic</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">195</td>
    <td class="codeLine">    // Limit the amount of scanning we do so we don't end up with quadratic</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="codeLine">    // running time on extreme testcases.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">196</td>
    <td class="codeLine">    // running time on extreme testcases.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="codeLine">    --Limit;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">197</td>
    <td class="codeLine">    --Limit;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="codeLine">    if (!Limit)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">198</td>
    <td class="codeLine">    if (!Limit)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="codeLine">      return MemDepResult::getUnknown();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">199</td>
    <td class="codeLine">      return MemDepResult::getUnknown();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">200</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="codeLine">    // If this inst is a memory op, get the pointer it accessed</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">201</td>
    <td class="codeLine">    // If this inst is a memory op, get the pointer it accessed</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="codeLine">    MemoryLocation Loc;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">202</td>
    <td class="codeLine">    MemoryLocation Loc;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="codeLine">    ModRefInfo MR = GetLocation(Inst, Loc, TLI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">203</td>
    <td class="codeLine">    ModRefInfo MR = GetLocation(Inst, Loc, TLI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="codeLine">    if (Loc.Ptr) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">204</td>
    <td class="codeLine">    if (Loc.Ptr) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="codeLine">      // A simple instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">205</td>
    <td class="codeLine">      // A simple instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="codeLine">      if (isModOrRefSet(AA.getModRefInfo(Call, Loc)))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">206</td>
    <td class="codeLine">      if (isModOrRefSet(AA.getModRefInfo(Call, Loc)))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="codeLine">        return MemDepResult::getClobber(Inst);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">207</td>
    <td class="codeLine">        return MemDepResult::getClobber(Inst);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">208</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">209</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">210</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="codeLine">    if (auto *CallB = dyn_cast<CallBase>(Inst)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">211</td>
    <td class="codeLine">    if (auto *CallB = dyn_cast<CallBase>(Inst)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="codeLine">      // If these two calls do not interfere, look past it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">212</td>
    <td class="codeLine">      // If these two calls do not interfere, look past it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="codeLine">      if (isNoModRef(AA.getModRefInfo(Call, CallB))) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">213</td>
    <td class="codeLine">      if (isNoModRef(AA.getModRefInfo(Call, CallB))) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="codeLine">        // If the two calls are the same, return Inst as a Def, so that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">214</td>
    <td class="codeLine">        // If the two calls are the same, return Inst as a Def, so that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="codeLine">        // Call can be found redundant and eliminated.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">215</td>
    <td class="codeLine">        // Call can be found redundant and eliminated.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="codeLine">        if (isReadOnlyCall && !isModSet(MR) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">216</td>
    <td class="codeLine">        if (isReadOnlyCall && !isModSet(MR) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="codeLine">            Call->isIdenticalToWhenDefined(CallB))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">217</td>
    <td class="codeLine">            Call->isIdenticalToWhenDefined(CallB))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="codeLine">          return MemDepResult::getDef(Inst);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">218</td>
    <td class="codeLine">          return MemDepResult::getDef(Inst);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">219</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="codeLine">        // Otherwise if the two calls don't interact (e.g. CallB is readnone)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">220</td>
    <td class="codeLine">        // Otherwise if the two calls don't interact (e.g. CallB is readnone)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="codeLine">        // keep scanning.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">221</td>
    <td class="codeLine">        // keep scanning.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">222</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="codeLine">      } else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">223</td>
    <td class="codeLine">      } else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="codeLine">        return MemDepResult::getClobber(Inst);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">224</td>
    <td class="codeLine">        return MemDepResult::getClobber(Inst);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">225</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">226</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="codeLine">    // If we could not obtain a pointer for the instruction and the instruction</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">227</td>
    <td class="codeLine">    // If we could not obtain a pointer for the instruction and the instruction</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="codeLine">    // touches memory then assume that this is a dependency.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">228</td>
    <td class="codeLine">    // touches memory then assume that this is a dependency.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="codeLine">    if (isModOrRefSet(MR))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">229</td>
    <td class="codeLine">    if (isModOrRefSet(MR))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="codeLine">      return MemDepResult::getClobber(Inst);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">230</td>
    <td class="codeLine">      return MemDepResult::getClobber(Inst);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">231</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">232</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="codeLine">  // No dependence found.  If this is the entry block of the function, it is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">233</td>
    <td class="codeLine">  // No dependence found.  If this is the entry block of the function, it is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="codeLine">  // unknown, otherwise it is non-local.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">234</td>
    <td class="codeLine">  // unknown, otherwise it is non-local.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="codeLine">  if (BB != &BB->getParent()->getEntryBlock())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">235</td>
    <td class="codeLine">  if (BB != &BB->getParent()->getEntryBlock())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="codeLine">    return MemDepResult::getNonLocal();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">236</td>
    <td class="codeLine">    return MemDepResult::getNonLocal();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="codeLine">  return MemDepResult::getNonFuncLocal();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">237</td>
    <td class="codeLine">  return MemDepResult::getNonFuncLocal();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">238</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">239</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="codeLine">MemDepResult MemoryDependenceResults::getPointerDependencyFrom(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">240</td>
    <td class="codeLine">MemDepResult MemoryDependenceResults::getPointerDependencyFrom(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="codeLine">    const MemoryLocation &MemLoc, bool isLoad, BasicBlock::iterator ScanIt,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">241</td>
    <td class="codeLine">    const MemoryLocation &MemLoc, bool isLoad, BasicBlock::iterator ScanIt,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="codeLine">    BasicBlock *BB, Instruction *QueryInst, unsigned *Limit,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">242</td>
    <td class="codeLine">    BasicBlock *BB, Instruction *QueryInst, unsigned *Limit,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="codeLine">    BatchAAResults &BatchAA) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">243</td>
    <td class="codeLine">    BatchAAResults &BatchAA) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="codeLine">  MemDepResult InvariantGroupDependency = MemDepResult::getUnknown();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">244</td>
    <td class="codeLine">  MemDepResult InvariantGroupDependency = MemDepResult::getUnknown();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="codeLine">  if (QueryInst != nullptr) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">245</td>
    <td class="codeLine">  if (QueryInst != nullptr) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="codeLine">    if (auto *LI = dyn_cast<LoadInst>(QueryInst)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">246</td>
    <td class="codeLine">    if (auto *LI = dyn_cast<LoadInst>(QueryInst)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="codeLine">      InvariantGroupDependency = getInvariantGroupPointerDependency(LI, BB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">247</td>
    <td class="codeLine">      InvariantGroupDependency = getInvariantGroupPointerDependency(LI, BB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">248</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="codeLine">      if (InvariantGroupDependency.isDef())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">249</td>
    <td class="codeLine">      if (InvariantGroupDependency.isDef())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="codeLine">        return InvariantGroupDependency;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">250</td>
    <td class="codeLine">        return InvariantGroupDependency;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">251</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">252</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="codeLine">  MemDepResult SimpleDep = getSimplePointerDependencyFrom(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">253</td>
    <td class="codeLine">  MemDepResult SimpleDep = getSimplePointerDependencyFrom(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="codeLine">      MemLoc, isLoad, ScanIt, BB, QueryInst, Limit, BatchAA);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">254</td>
    <td class="codeLine">      MemLoc, isLoad, ScanIt, BB, QueryInst, Limit, BatchAA);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="codeLine">  if (SimpleDep.isDef())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">255</td>
    <td class="codeLine">  if (SimpleDep.isDef())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="codeLine">    return SimpleDep;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">256</td>
    <td class="codeLine">    return SimpleDep;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="codeLine">  // Non-local invariant group dependency indicates there is non local Def</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">257</td>
    <td class="codeLine">  // Non-local invariant group dependency indicates there is non local Def</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="codeLine">  // (it only returns nonLocal if it finds nonLocal def), which is better than</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">258</td>
    <td class="codeLine">  // (it only returns nonLocal if it finds nonLocal def), which is better than</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="codeLine">  // local clobber and everything else.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">259</td>
    <td class="codeLine">  // local clobber and everything else.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="codeLine">  if (InvariantGroupDependency.isNonLocal())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">260</td>
    <td class="codeLine">  if (InvariantGroupDependency.isNonLocal())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="codeLine">    return InvariantGroupDependency;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">261</td>
    <td class="codeLine">    return InvariantGroupDependency;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">262</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="codeLine">  assert(InvariantGroupDependency.isUnknown() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">263</td>
    <td class="codeLine">  assert(InvariantGroupDependency.isUnknown() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="codeLine">         "InvariantGroupDependency should be only unknown at this point");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">264</td>
    <td class="codeLine">         "InvariantGroupDependency should be only unknown at this point");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="codeLine">  return SimpleDep;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">265</td>
    <td class="codeLine">  return SimpleDep;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">266</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">267</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="codeLine">MemDepResult MemoryDependenceResults::getPointerDependencyFrom(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">268</td>
    <td class="codeLine">MemDepResult MemoryDependenceResults::getPointerDependencyFrom(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="codeLine">    const MemoryLocation &MemLoc, bool isLoad, BasicBlock::iterator ScanIt,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">269</td>
    <td class="codeLine">    const MemoryLocation &MemLoc, bool isLoad, BasicBlock::iterator ScanIt,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="codeLine">    BasicBlock *BB, Instruction *QueryInst, unsigned *Limit) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">270</td>
    <td class="codeLine">    BasicBlock *BB, Instruction *QueryInst, unsigned *Limit) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="codeLine">  BatchAAResults BatchAA(AA);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">271</td>
    <td class="codeLine">  BatchAAResults BatchAA(AA);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="codeLine">  return getPointerDependencyFrom(MemLoc, isLoad, ScanIt, BB, QueryInst, Limit,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">272</td>
    <td class="codeLine">  return getPointerDependencyFrom(MemLoc, isLoad, ScanIt, BB, QueryInst, Limit,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="codeLine">                                  BatchAA);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">273</td>
    <td class="codeLine">                                  BatchAA);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">274</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">275</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="codeLine">MemDepResult</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">276</td>
    <td class="codeLine">MemDepResult</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="codeLine">MemoryDependenceResults::getInvariantGroupPointerDependency(LoadInst *LI,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">277</td>
    <td class="codeLine">MemoryDependenceResults::getInvariantGroupPointerDependency(LoadInst *LI,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="codeLine">                                                            BasicBlock *BB) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">278</td>
    <td class="codeLine">                                                            BasicBlock *BB) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">279</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="codeLine">  if (!LI->hasMetadata(LLVMContext::MD_invariant_group))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">280</td>
    <td class="codeLine">  if (!LI->hasMetadata(LLVMContext::MD_invariant_group))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="codeLine">    return MemDepResult::getUnknown();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">281</td>
    <td class="codeLine">    return MemDepResult::getUnknown();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">282</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="codeLine">  // Take the ptr operand after all casts and geps 0. This way we can search</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">283</td>
    <td class="codeLine">  // Take the ptr operand after all casts and geps 0. This way we can search</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="codeLine">  // cast graph down only.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">284</td>
    <td class="codeLine">  // cast graph down only.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="codeLine">  Value *LoadOperand = LI->getPointerOperand()->stripPointerCasts();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">285</td>
    <td class="codeLine">  Value *LoadOperand = LI->getPointerOperand()->stripPointerCasts();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">286</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="codeLine">  // It's is not safe to walk the use list of global value, because function</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">287</td>
    <td class="codeLine">  // It's is not safe to walk the use list of global value, because function</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="codeLine">  // passes aren't allowed to look outside their functions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">288</td>
    <td class="codeLine">  // passes aren't allowed to look outside their functions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="codeLine">  // FIXME: this could be fixed by filtering instructions from outside</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">289</td>
    <td class="codeLine">  // FIXME: this could be fixed by filtering instructions from outside</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="codeLine">  // of current function.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">290</td>
    <td class="codeLine">  // of current function.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="codeLine">  if (isa<GlobalValue>(LoadOperand))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">291</td>
    <td class="codeLine">  if (isa<GlobalValue>(LoadOperand))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="codeLine">    return MemDepResult::getUnknown();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">292</td>
    <td class="codeLine">    return MemDepResult::getUnknown();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">293</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="codeLine">  // Queue to process all pointers that are equivalent to load operand.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">294</td>
    <td class="codeLine">  // Queue to process all pointers that are equivalent to load operand.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="codeLine">  SmallVector<const Value *, 8> LoadOperandsQueue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">295</td>
    <td class="codeLine">  SmallVector<const Value *, 8> LoadOperandsQueue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="codeLine">  LoadOperandsQueue.push_back(LoadOperand);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">296</td>
    <td class="codeLine">  LoadOperandsQueue.push_back(LoadOperand);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">297</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="codeLine">  Instruction *ClosestDependency = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">298</td>
    <td class="codeLine">  Instruction *ClosestDependency = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="codeLine">  // Order of instructions in uses list is unpredictible. In order to always</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">299</td>
    <td class="codeLine">  // Order of instructions in uses list is unpredictible. In order to always</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="codeLine">  // get the same result, we will look for the closest dominance.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">300</td>
    <td class="codeLine">  // get the same result, we will look for the closest dominance.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="codeLine">  auto GetClosestDependency = [this](Instruction *Best, Instruction *Other) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">301</td>
    <td class="codeLine">  auto GetClosestDependency = [this](Instruction *Best, Instruction *Other) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="codeLine">    assert(Other && "Must call it with not null instruction");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">302</td>
    <td class="codeLine">    assert(Other && "Must call it with not null instruction");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="codeLine">    if (Best == nullptr || DT.dominates(Best, Other))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">303</td>
    <td class="codeLine">    if (Best == nullptr || DT.dominates(Best, Other))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="codeLine">      return Other;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">304</td>
    <td class="codeLine">      return Other;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="codeLine">    return Best;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">305</td>
    <td class="codeLine">    return Best;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">306</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">307</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="codeLine">  // FIXME: This loop is O(N^2) because dominates can be O(n) and in worst case</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">308</td>
    <td class="codeLine">  // FIXME: This loop is O(N^2) because dominates can be O(n) and in worst case</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="codeLine">  // we will see all the instructions. This should be fixed in MSSA.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">309</td>
    <td class="codeLine">  // we will see all the instructions. This should be fixed in MSSA.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="codeLine">  while (!LoadOperandsQueue.empty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">310</td>
    <td class="codeLine">  while (!LoadOperandsQueue.empty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="codeLine">    const Value *Ptr = LoadOperandsQueue.pop_back_val();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">311</td>
    <td class="codeLine">    const Value *Ptr = LoadOperandsQueue.pop_back_val();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="codeLine">    assert(Ptr && !isa<GlobalValue>(Ptr) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">312</td>
    <td class="codeLine">    assert(Ptr && !isa<GlobalValue>(Ptr) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="codeLine">           "Null or GlobalValue should not be inserted");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">313</td>
    <td class="codeLine">           "Null or GlobalValue should not be inserted");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">314</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="codeLine">    for (const Use &Us : Ptr->uses()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">315</td>
    <td class="codeLine">    for (const Use &Us : Ptr->uses()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="codeLine">      auto *U = dyn_cast<Instruction>(Us.getUser());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">316</td>
    <td class="codeLine">      auto *U = dyn_cast<Instruction>(Us.getUser());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="codeLine">      if (!U || U == LI || !DT.dominates(U, LI))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">317</td>
    <td class="codeLine">      if (!U || U == LI || !DT.dominates(U, LI))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">318</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">319</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="codeLine">      // Bitcast or gep with zeros are using Ptr. Add to queue to check it's</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">320</td>
    <td class="codeLine">      // Bitcast or gep with zeros are using Ptr. Add to queue to check it's</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="codeLine">      // users.      U = bitcast Ptr</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">321</td>
    <td class="codeLine">      // users.      U = bitcast Ptr</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="codeLine">      if (isa<BitCastInst>(U)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">322</td>
    <td class="codeLine">      if (isa<BitCastInst>(U)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="codeLine">        LoadOperandsQueue.push_back(U);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">323</td>
    <td class="codeLine">        LoadOperandsQueue.push_back(U);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">324</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">325</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="codeLine">      // Gep with zeros is equivalent to bitcast.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">326</td>
    <td class="codeLine">      // Gep with zeros is equivalent to bitcast.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="codeLine">      // FIXME: we are not sure if some bitcast should be canonicalized to gep 0</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">327</td>
    <td class="codeLine">      // FIXME: we are not sure if some bitcast should be canonicalized to gep 0</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="codeLine">      // or gep 0 to bitcast because of SROA, so there are 2 forms. When</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">328</td>
    <td class="codeLine">      // or gep 0 to bitcast because of SROA, so there are 2 forms. When</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="codeLine">      // typeless pointers will be ready then both cases will be gone</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">329</td>
    <td class="codeLine">      // typeless pointers will be ready then both cases will be gone</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="codeLine">      // (and this BFS also won't be needed).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">330</td>
    <td class="codeLine">      // (and this BFS also won't be needed).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="codeLine">      if (auto *GEP = dyn_cast<GetElementPtrInst>(U))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">331</td>
    <td class="codeLine">      if (auto *GEP = dyn_cast<GetElementPtrInst>(U))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="codeLine">        if (GEP->hasAllZeroIndices()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">332</td>
    <td class="codeLine">        if (GEP->hasAllZeroIndices()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="codeLine">          LoadOperandsQueue.push_back(U);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">333</td>
    <td class="codeLine">          LoadOperandsQueue.push_back(U);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">334</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">335</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">336</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="codeLine">      // If we hit load/store with the same invariant.group metadata (and the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">337</td>
    <td class="codeLine">      // If we hit load/store with the same invariant.group metadata (and the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="codeLine">      // same pointer operand) we can assume that value pointed by pointer</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">338</td>
    <td class="codeLine">      // same pointer operand) we can assume that value pointed by pointer</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="codeLine">      // operand didn't change.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">339</td>
    <td class="codeLine">      // operand didn't change.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="codeLine">      if ((isa<LoadInst>(U) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">340</td>
    <td class="codeLine">      if ((isa<LoadInst>(U) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="codeLine">           (isa<StoreInst>(U) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">341</td>
    <td class="codeLine">           (isa<StoreInst>(U) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="codeLine">            cast<StoreInst>(U)->getPointerOperand() == Ptr)) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">342</td>
    <td class="codeLine">            cast<StoreInst>(U)->getPointerOperand() == Ptr)) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="codeLine">          U->hasMetadata(LLVMContext::MD_invariant_group))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">343</td>
    <td class="codeLine">          U->hasMetadata(LLVMContext::MD_invariant_group))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="codeLine">        ClosestDependency = GetClosestDependency(ClosestDependency, U);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">344</td>
    <td class="codeLine">        ClosestDependency = GetClosestDependency(ClosestDependency, U);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">345</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">346</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">347</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="codeLine">  if (!ClosestDependency)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">348</td>
    <td class="codeLine">  if (!ClosestDependency)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="codeLine">    return MemDepResult::getUnknown();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">349</td>
    <td class="codeLine">    return MemDepResult::getUnknown();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="codeLine">  if (ClosestDependency->getParent() == BB)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">350</td>
    <td class="codeLine">  if (ClosestDependency->getParent() == BB)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="codeLine">    return MemDepResult::getDef(ClosestDependency);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">351</td>
    <td class="codeLine">    return MemDepResult::getDef(ClosestDependency);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="codeLine">  // Def(U) can't be returned here because it is non-local. If local</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">352</td>
    <td class="codeLine">  // Def(U) can't be returned here because it is non-local. If local</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="codeLine">  // dependency won't be found then return nonLocal counting that the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">353</td>
    <td class="codeLine">  // dependency won't be found then return nonLocal counting that the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="codeLine">  // user will call getNonLocalPointerDependency, which will return cached</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">354</td>
    <td class="codeLine">  // user will call getNonLocalPointerDependency, which will return cached</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="codeLine">  // result.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">355</td>
    <td class="codeLine">  // result.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="codeLine">  NonLocalDefsCache.try_emplace(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">356</td>
    <td class="codeLine">  NonLocalDefsCache.try_emplace(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="codeLine">      LI, NonLocalDepResult(ClosestDependency->getParent(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">357</td>
    <td class="codeLine">      LI, NonLocalDepResult(ClosestDependency->getParent(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="codeLine">                            MemDepResult::getDef(ClosestDependency), nullptr));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">358</td>
    <td class="codeLine">                            MemDepResult::getDef(ClosestDependency), nullptr));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="codeLine">  ReverseNonLocalDefsCache[ClosestDependency].insert(LI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">359</td>
    <td class="codeLine">  ReverseNonLocalDefsCache[ClosestDependency].insert(LI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="codeLine">  return MemDepResult::getNonLocal();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">360</td>
    <td class="codeLine">  return MemDepResult::getNonLocal();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">361</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">362</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="codeLine">MemDepResult MemoryDependenceResults::getSimplePointerDependencyFrom(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">363</td>
    <td class="codeLine">MemDepResult MemoryDependenceResults::getSimplePointerDependencyFrom(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="codeLine">    const MemoryLocation &MemLoc, bool isLoad, BasicBlock::iterator ScanIt,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">364</td>
    <td class="codeLine">    const MemoryLocation &MemLoc, bool isLoad, BasicBlock::iterator ScanIt,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="codeLine">    BasicBlock *BB, Instruction *QueryInst, unsigned *Limit,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">365</td>
    <td class="codeLine">    BasicBlock *BB, Instruction *QueryInst, unsigned *Limit,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="codeLine">    BatchAAResults &BatchAA) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">366</td>
    <td class="codeLine">    BatchAAResults &BatchAA) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="codeLine">  bool isInvariantLoad = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">367</td>
    <td class="codeLine">  bool isInvariantLoad = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">368</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="codeLine">  unsigned DefaultLimit = getDefaultBlockScanLimit();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">369</td>
    <td class="codeLine">  unsigned DefaultLimit = getDefaultBlockScanLimit();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="codeLine">  if (!Limit)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">370</td>
    <td class="codeLine">  if (!Limit)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="codeLine">    Limit = &DefaultLimit;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">371</td>
    <td class="codeLine">    Limit = &DefaultLimit;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">372</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="codeLine">  // We must be careful with atomic accesses, as they may allow another thread</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">373</td>
    <td class="codeLine">  // We must be careful with atomic accesses, as they may allow another thread</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="codeLine">  //   to touch this location, clobbering it. We are conservative: if the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">374</td>
    <td class="codeLine">  //   to touch this location, clobbering it. We are conservative: if the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="codeLine">  //   QueryInst is not a simple (non-atomic) memory access, we automatically</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">375</td>
    <td class="codeLine">  //   QueryInst is not a simple (non-atomic) memory access, we automatically</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="codeLine">  //   return getClobber.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">376</td>
    <td class="codeLine">  //   return getClobber.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="codeLine">  // If it is simple, we know based on the results of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">377</td>
    <td class="codeLine">  // If it is simple, we know based on the results of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="codeLine">  // "Compiler testing via a theory of sound optimisations in the C11/C++11</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">378</td>
    <td class="codeLine">  // "Compiler testing via a theory of sound optimisations in the C11/C++11</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="codeLine">  //   memory model" in PLDI 2013, that a non-atomic location can only be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">379</td>
    <td class="codeLine">  //   memory model" in PLDI 2013, that a non-atomic location can only be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="codeLine">  //   clobbered between a pair of a release and an acquire action, with no</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">380</td>
    <td class="codeLine">  //   clobbered between a pair of a release and an acquire action, with no</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="codeLine">  //   access to the location in between.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">381</td>
    <td class="codeLine">  //   access to the location in between.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="codeLine">  // Here is an example for giving the general intuition behind this rule.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">382</td>
    <td class="codeLine">  // Here is an example for giving the general intuition behind this rule.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="codeLine">  // In the following code:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">383</td>
    <td class="codeLine">  // In the following code:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="codeLine">  //   store x 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">384</td>
    <td class="codeLine">  //   store x 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="codeLine">  //   release action; [1]</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">385</td>
    <td class="codeLine">  //   release action; [1]</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="codeLine">  //   acquire action; [4]</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">386</td>
    <td class="codeLine">  //   acquire action; [4]</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="codeLine">  //   %val = load x;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">387</td>
    <td class="codeLine">  //   %val = load x;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="codeLine">  // It is unsafe to replace %val by 0 because another thread may be running:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">388</td>
    <td class="codeLine">  // It is unsafe to replace %val by 0 because another thread may be running:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="codeLine">  //   acquire action; [2]</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">389</td>
    <td class="codeLine">  //   acquire action; [2]</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="codeLine">  //   store x 42;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">390</td>
    <td class="codeLine">  //   store x 42;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="codeLine">  //   release action; [3]</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">391</td>
    <td class="codeLine">  //   release action; [3]</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="codeLine">  // with synchronization from 1 to 2 and from 3 to 4, resulting in %val</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">392</td>
    <td class="codeLine">  // with synchronization from 1 to 2 and from 3 to 4, resulting in %val</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="codeLine">  // being 42. A key property of this program however is that if either</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">393</td>
    <td class="codeLine">  // being 42. A key property of this program however is that if either</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="codeLine">  // 1 or 4 were missing, there would be a race between the store of 42</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">394</td>
    <td class="codeLine">  // 1 or 4 were missing, there would be a race between the store of 42</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="codeLine">  // either the store of 0 or the load (making the whole program racy).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">395</td>
    <td class="codeLine">  // either the store of 0 or the load (making the whole program racy).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="codeLine">  // The paper mentioned above shows that the same property is respected</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">396</td>
    <td class="codeLine">  // The paper mentioned above shows that the same property is respected</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="codeLine">  // by every program that can detect any optimization of that kind: either</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">397</td>
    <td class="codeLine">  // by every program that can detect any optimization of that kind: either</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="codeLine">  // it is racy (undefined) or there is a release followed by an acquire</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">398</td>
    <td class="codeLine">  // it is racy (undefined) or there is a release followed by an acquire</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="codeLine">  // between the pair of accesses under consideration.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">399</td>
    <td class="codeLine">  // between the pair of accesses under consideration.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">400</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="codeLine">  // If the load is invariant, we "know" that it doesn't alias *any* write. We</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">401</td>
    <td class="codeLine">  // If the load is invariant, we "know" that it doesn't alias *any* write. We</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="codeLine">  // do want to respect mustalias results since defs are useful for value</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">402</td>
    <td class="codeLine">  // do want to respect mustalias results since defs are useful for value</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="codeLine">  // forwarding, but any mayalias write can be assumed to be noalias.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">403</td>
    <td class="codeLine">  // forwarding, but any mayalias write can be assumed to be noalias.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="codeLine">  // Arguably, this logic should be pushed inside AliasAnalysis itself.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">404</td>
    <td class="codeLine">  // Arguably, this logic should be pushed inside AliasAnalysis itself.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="codeLine">  if (isLoad && QueryInst) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">405</td>
    <td class="codeLine">  if (isLoad && QueryInst) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="codeLine">    LoadInst *LI = dyn_cast<LoadInst>(QueryInst);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">406</td>
    <td class="codeLine">    LoadInst *LI = dyn_cast<LoadInst>(QueryInst);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="codeLine">    if (LI && LI->hasMetadata(LLVMContext::MD_invariant_load))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">407</td>
    <td class="codeLine">    if (LI && LI->hasMetadata(LLVMContext::MD_invariant_load))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="codeLine">      isInvariantLoad = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">408</td>
    <td class="codeLine">      isInvariantLoad = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">409</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">410</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="codeLine">  // True for volatile instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">411</td>
    <td class="codeLine">  // True for volatile instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="codeLine">  // For Load/Store return true if atomic ordering is stronger than AO,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">412</td>
    <td class="codeLine">  // For Load/Store return true if atomic ordering is stronger than AO,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="codeLine">  // for other instruction just true if it can read or write to memory.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">413</td>
    <td class="codeLine">  // for other instruction just true if it can read or write to memory.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="codeLine">  auto isComplexForReordering = [](Instruction * I, AtomicOrdering AO)->bool {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">414</td>
    <td class="codeLine">  auto isComplexForReordering = [](Instruction * I, AtomicOrdering AO)->bool {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="codeLine">    if (I->isVolatile())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">415</td>
    <td class="codeLine">    if (I->isVolatile())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">416</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="codeLine">    if (auto *LI = dyn_cast<LoadInst>(I))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">417</td>
    <td class="codeLine">    if (auto *LI = dyn_cast<LoadInst>(I))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="codeLine">      return isStrongerThan(LI->getOrdering(), AO);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">418</td>
    <td class="codeLine">      return isStrongerThan(LI->getOrdering(), AO);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="codeLine">    if (auto *SI = dyn_cast<StoreInst>(I))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">419</td>
    <td class="codeLine">    if (auto *SI = dyn_cast<StoreInst>(I))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="codeLine">      return isStrongerThan(SI->getOrdering(), AO);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">420</td>
    <td class="codeLine">      return isStrongerThan(SI->getOrdering(), AO);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="codeLine">    return I->mayReadOrWriteMemory();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">421</td>
    <td class="codeLine">    return I->mayReadOrWriteMemory();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">422</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">423</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="codeLine">  // Walk backwards through the basic block, looking for dependencies.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">424</td>
    <td class="codeLine">  // Walk backwards through the basic block, looking for dependencies.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="codeLine">  while (ScanIt != BB->begin()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">425</td>
    <td class="codeLine">  while (ScanIt != BB->begin()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="codeLine">    Instruction *Inst = &*--ScanIt;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">426</td>
    <td class="codeLine">    Instruction *Inst = &*--ScanIt;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">427</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="codeLine">    if (IntrinsicInst *II = dyn_cast<IntrinsicInst>(Inst))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">428</td>
    <td class="codeLine">    if (IntrinsicInst *II = dyn_cast<IntrinsicInst>(Inst))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="codeLine">      // Debug intrinsics don't (and can't) cause dependencies.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">429</td>
    <td class="codeLine">      // Debug intrinsics don't (and can't) cause dependencies.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="codeLine">      if (isa<DbgInfoIntrinsic>(II))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">430</td>
    <td class="codeLine">      if (isa<DbgInfoIntrinsic>(II))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">431</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">432</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="codeLine">    // Limit the amount of scanning we do so we don't end up with quadratic</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">433</td>
    <td class="codeLine">    // Limit the amount of scanning we do so we don't end up with quadratic</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="codeLine">    // running time on extreme testcases.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">434</td>
    <td class="codeLine">    // running time on extreme testcases.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="codeLine">    --*Limit;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">435</td>
    <td class="codeLine">    --*Limit;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="codeLine">    if (!*Limit)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">436</td>
    <td class="codeLine">    if (!*Limit)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="codeLine">      return MemDepResult::getUnknown();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">437</td>
    <td class="codeLine">      return MemDepResult::getUnknown();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">438</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="codeLine">    if (IntrinsicInst *II = dyn_cast<IntrinsicInst>(Inst)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">439</td>
    <td class="codeLine">    if (IntrinsicInst *II = dyn_cast<IntrinsicInst>(Inst)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="codeLine">      // If we reach a lifetime begin or end marker, then the query ends here</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">440</td>
    <td class="codeLine">      // If we reach a lifetime begin or end marker, then the query ends here</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="codeLine">      // because the value is undefined.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">441</td>
    <td class="codeLine">      // because the value is undefined.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="codeLine">      Intrinsic::ID ID = II->getIntrinsicID();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">442</td>
    <td class="codeLine">      Intrinsic::ID ID = II->getIntrinsicID();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="codeLine">      switch (ID) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">443</td>
    <td class="codeLine">      switch (ID) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="codeLine">      case Intrinsic::lifetime_start: {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">444</td>
    <td class="codeLine">      case Intrinsic::lifetime_start: {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="codeLine">        // FIXME: This only considers queries directly on the invariant-tagged</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">445</td>
    <td class="codeLine">        // FIXME: This only considers queries directly on the invariant-tagged</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="codeLine">        // pointer, not on query pointers that are indexed off of them.  It'd</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">446</td>
    <td class="codeLine">        // pointer, not on query pointers that are indexed off of them.  It'd</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="codeLine">        // be nice to handle that at some point (the right approach is to use</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">447</td>
    <td class="codeLine">        // be nice to handle that at some point (the right approach is to use</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="codeLine">        // GetPointerBaseWithConstantOffset).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">448</td>
    <td class="codeLine">        // GetPointerBaseWithConstantOffset).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="codeLine">        MemoryLocation ArgLoc = MemoryLocation::getAfter(II->getArgOperand(1));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">449</td>
    <td class="codeLine">        MemoryLocation ArgLoc = MemoryLocation::getAfter(II->getArgOperand(1));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="codeLine">        if (BatchAA.isMustAlias(ArgLoc, MemLoc))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">450</td>
    <td class="codeLine">        if (BatchAA.isMustAlias(ArgLoc, MemLoc))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="codeLine">          return MemDepResult::getDef(II);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">451</td>
    <td class="codeLine">          return MemDepResult::getDef(II);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">452</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">453</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="codeLine">      case Intrinsic::masked_load:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">454</td>
    <td class="codeLine">      case Intrinsic::masked_load:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="codeLine">      case Intrinsic::masked_store: {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">455</td>
    <td class="codeLine">      case Intrinsic::masked_store: {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="codeLine">        MemoryLocation Loc;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">456</td>
    <td class="codeLine">        MemoryLocation Loc;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="codeLine">        /*ModRefInfo MR =*/ GetLocation(II, Loc, TLI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">457</td>
    <td class="codeLine">        /*ModRefInfo MR =*/ GetLocation(II, Loc, TLI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="codeLine">        AliasResult R = BatchAA.alias(Loc, MemLoc);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">458</td>
    <td class="codeLine">        AliasResult R = BatchAA.alias(Loc, MemLoc);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="codeLine">        if (R == AliasResult::NoAlias)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">459</td>
    <td class="codeLine">        if (R == AliasResult::NoAlias)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">460</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="codeLine">        if (R == AliasResult::MustAlias)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">461</td>
    <td class="codeLine">        if (R == AliasResult::MustAlias)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="codeLine">          return MemDepResult::getDef(II);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">462</td>
    <td class="codeLine">          return MemDepResult::getDef(II);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="codeLine">        if (ID == Intrinsic::masked_load)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">463</td>
    <td class="codeLine">        if (ID == Intrinsic::masked_load)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">464</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="codeLine">        return MemDepResult::getClobber(II);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">465</td>
    <td class="codeLine">        return MemDepResult::getClobber(II);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">466</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">467</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">468</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">469</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="codeLine">    // Values depend on loads if the pointers are must aliased.  This means</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">470</td>
    <td class="codeLine">    // Values depend on loads if the pointers are must aliased.  This means</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="codeLine">    // that a load depends on another must aliased load from the same value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">471</td>
    <td class="codeLine">    // that a load depends on another must aliased load from the same value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="codeLine">    // One exception is atomic loads: a value can depend on an atomic load that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">472</td>
    <td class="codeLine">    // One exception is atomic loads: a value can depend on an atomic load that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="codeLine">    // it does not alias with when this atomic load indicates that another</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">473</td>
    <td class="codeLine">    // it does not alias with when this atomic load indicates that another</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="codeLine">    // thread may be accessing the location.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">474</td>
    <td class="codeLine">    // thread may be accessing the location.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="codeLine">    if (LoadInst *LI = dyn_cast<LoadInst>(Inst)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">475</td>
    <td class="codeLine">    if (LoadInst *LI = dyn_cast<LoadInst>(Inst)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="codeLine">      // While volatile access cannot be eliminated, they do not have to clobber</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">476</td>
    <td class="codeLine">      // While volatile access cannot be eliminated, they do not have to clobber</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="codeLine">      // non-aliasing locations, as normal accesses, for example, can be safely</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">477</td>
    <td class="codeLine">      // non-aliasing locations, as normal accesses, for example, can be safely</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="codeLine">      // reordered with volatile accesses.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">478</td>
    <td class="codeLine">      // reordered with volatile accesses.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="codeLine">      if (LI->isVolatile()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">479</td>
    <td class="codeLine">      if (LI->isVolatile()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="codeLine">        if (!QueryInst)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">480</td>
    <td class="codeLine">        if (!QueryInst)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="codeLine">          // Original QueryInst *may* be volatile</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">481</td>
    <td class="codeLine">          // Original QueryInst *may* be volatile</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="codeLine">          return MemDepResult::getClobber(LI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">482</td>
    <td class="codeLine">          return MemDepResult::getClobber(LI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="codeLine">        if (QueryInst->isVolatile())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">483</td>
    <td class="codeLine">        if (QueryInst->isVolatile())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="codeLine">          // Ordering required if QueryInst is itself volatile</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">484</td>
    <td class="codeLine">          // Ordering required if QueryInst is itself volatile</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="codeLine">          return MemDepResult::getClobber(LI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">485</td>
    <td class="codeLine">          return MemDepResult::getClobber(LI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="codeLine">        // Otherwise, volatile doesn't imply any special ordering</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">486</td>
    <td class="codeLine">        // Otherwise, volatile doesn't imply any special ordering</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">487</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">488</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="codeLine">      // Atomic loads have complications involved.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">489</td>
    <td class="codeLine">      // Atomic loads have complications involved.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="codeLine">      // A Monotonic (or higher) load is OK if the query inst is itself not</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">490</td>
    <td class="codeLine">      // A Monotonic (or higher) load is OK if the query inst is itself not</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="codeLine">      // atomic.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">491</td>
    <td class="codeLine">      // atomic.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="codeLine">      // FIXME: This is overly conservative.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">492</td>
    <td class="codeLine">      // FIXME: This is overly conservative.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="codeLine">      if (LI->isAtomic() && isStrongerThanUnordered(LI->getOrdering())) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">493</td>
    <td class="codeLine">      if (LI->isAtomic() && isStrongerThanUnordered(LI->getOrdering())) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="codeLine">        if (!QueryInst ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">494</td>
    <td class="codeLine">        if (!QueryInst ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="codeLine">            isComplexForReordering(QueryInst, AtomicOrdering::NotAtomic))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">495</td>
    <td class="codeLine">            isComplexForReordering(QueryInst, AtomicOrdering::NotAtomic))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="codeLine">          return MemDepResult::getClobber(LI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">496</td>
    <td class="codeLine">          return MemDepResult::getClobber(LI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="codeLine">        if (LI->getOrdering() != AtomicOrdering::Monotonic)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">497</td>
    <td class="codeLine">        if (LI->getOrdering() != AtomicOrdering::Monotonic)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="codeLine">          return MemDepResult::getClobber(LI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">498</td>
    <td class="codeLine">          return MemDepResult::getClobber(LI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">499</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">500</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="codeLine">      MemoryLocation LoadLoc = MemoryLocation::get(LI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">501</td>
    <td class="codeLine">      MemoryLocation LoadLoc = MemoryLocation::get(LI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">502</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="codeLine">      // If we found a pointer, check if it could be the same as our pointer.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">503</td>
    <td class="codeLine">      // If we found a pointer, check if it could be the same as our pointer.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class="codeLine">      AliasResult R = BatchAA.alias(LoadLoc, MemLoc);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">504</td>
    <td class="codeLine">      AliasResult R = BatchAA.alias(LoadLoc, MemLoc);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">505</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="codeLine">      if (R == AliasResult::NoAlias)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">506</td>
    <td class="codeLine">      if (R == AliasResult::NoAlias)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">507</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">508</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="codeLine">      if (isLoad) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">509</td>
    <td class="codeLine">      if (isLoad) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="codeLine">        // Must aliased loads are defs of each other.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">510</td>
    <td class="codeLine">        // Must aliased loads are defs of each other.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="codeLine">        if (R == AliasResult::MustAlias)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">511</td>
    <td class="codeLine">        if (R == AliasResult::MustAlias)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="codeLine">          return MemDepResult::getDef(Inst);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">512</td>
    <td class="codeLine">          return MemDepResult::getDef(Inst);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">513</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="codeLine">        // If we have a partial alias, then return this as a clobber for the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">514</td>
    <td class="codeLine">        // If we have a partial alias, then return this as a clobber for the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="codeLine">        // client to handle.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">515</td>
    <td class="codeLine">        // client to handle.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="codeLine">        if (R == AliasResult::PartialAlias && R.hasOffset()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">516</td>
    <td class="codeLine">        if (R == AliasResult::PartialAlias && R.hasOffset()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class="codeLine">          ClobberOffsets[LI] = R.getOffset();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">517</td>
    <td class="codeLine">          ClobberOffsets[LI] = R.getOffset();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="codeLine">          return MemDepResult::getClobber(Inst);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">518</td>
    <td class="codeLine">          return MemDepResult::getClobber(Inst);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">519</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">520</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="codeLine">        // Random may-alias loads don't depend on each other without a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">521</td>
    <td class="codeLine">        // Random may-alias loads don't depend on each other without a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="codeLine">        // dependence.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">522</td>
    <td class="codeLine">        // dependence.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">523</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">524</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">525</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class="codeLine">      // Stores don't alias loads from read-only memory.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">526</td>
    <td class="codeLine">      // Stores don't alias loads from read-only memory.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="codeLine">      if (!isModSet(BatchAA.getModRefInfoMask(LoadLoc)))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">527</td>
    <td class="codeLine">      if (!isModSet(BatchAA.getModRefInfoMask(LoadLoc)))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">528</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">529</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="codeLine">      // Stores depend on may/must aliased loads.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">530</td>
    <td class="codeLine">      // Stores depend on may/must aliased loads.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="codeLine">      return MemDepResult::getDef(Inst);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">531</td>
    <td class="codeLine">      return MemDepResult::getDef(Inst);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">532</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">533</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="codeLine">    if (StoreInst *SI = dyn_cast<StoreInst>(Inst)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">534</td>
    <td class="codeLine">    if (StoreInst *SI = dyn_cast<StoreInst>(Inst)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="codeLine">      // Atomic stores have complications involved.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">535</td>
    <td class="codeLine">      // Atomic stores have complications involved.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="codeLine">      // A Monotonic store is OK if the query inst is itself not atomic.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">536</td>
    <td class="codeLine">      // A Monotonic store is OK if the query inst is itself not atomic.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="codeLine">      // FIXME: This is overly conservative.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">537</td>
    <td class="codeLine">      // FIXME: This is overly conservative.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="codeLine">      if (!SI->isUnordered() && SI->isAtomic()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">538</td>
    <td class="codeLine">      if (!SI->isUnordered() && SI->isAtomic()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="codeLine">        if (!QueryInst ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">539</td>
    <td class="codeLine">        if (!QueryInst ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class="codeLine">            isComplexForReordering(QueryInst, AtomicOrdering::Unordered))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">540</td>
    <td class="codeLine">            isComplexForReordering(QueryInst, AtomicOrdering::Unordered))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="codeLine">          return MemDepResult::getClobber(SI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">541</td>
    <td class="codeLine">          return MemDepResult::getClobber(SI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="codeLine">        // Ok, if we are here the guard above guarantee us that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">542</td>
    <td class="codeLine">        // Ok, if we are here the guard above guarantee us that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="codeLine">        // QueryInst is a non-atomic or unordered load/store.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">543</td>
    <td class="codeLine">        // QueryInst is a non-atomic or unordered load/store.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="codeLine">        // SI is atomic with monotonic or release semantic (seq_cst for store</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">544</td>
    <td class="codeLine">        // SI is atomic with monotonic or release semantic (seq_cst for store</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="codeLine">        // is actually a release semantic plus total order over other seq_cst</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">545</td>
    <td class="codeLine">        // is actually a release semantic plus total order over other seq_cst</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="codeLine">        // instructions, as soon as QueryInst is not seq_cst we can consider it</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">546</td>
    <td class="codeLine">        // instructions, as soon as QueryInst is not seq_cst we can consider it</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="codeLine">        // as simple release semantic).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">547</td>
    <td class="codeLine">        // as simple release semantic).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="codeLine">        // Monotonic and Release semantic allows re-ordering before store</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">548</td>
    <td class="codeLine">        // Monotonic and Release semantic allows re-ordering before store</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="codeLine">        // so we are safe to go further and check the aliasing. It will prohibit</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">549</td>
    <td class="codeLine">        // so we are safe to go further and check the aliasing. It will prohibit</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="codeLine">        // re-ordering in case locations are may or must alias.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">550</td>
    <td class="codeLine">        // re-ordering in case locations are may or must alias.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">551</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">552</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="codeLine">      // While volatile access cannot be eliminated, they do not have to clobber</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">553</td>
    <td class="codeLine">      // While volatile access cannot be eliminated, they do not have to clobber</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="codeLine">      // non-aliasing locations, as normal accesses can for example be reordered</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">554</td>
    <td class="codeLine">      // non-aliasing locations, as normal accesses can for example be reordered</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="codeLine">      // with volatile accesses.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">555</td>
    <td class="codeLine">      // with volatile accesses.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="codeLine">      if (SI->isVolatile())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">556</td>
    <td class="codeLine">      if (SI->isVolatile())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="codeLine">        if (!QueryInst || QueryInst->isVolatile())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">557</td>
    <td class="codeLine">        if (!QueryInst || QueryInst->isVolatile())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="codeLine">          return MemDepResult::getClobber(SI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">558</td>
    <td class="codeLine">          return MemDepResult::getClobber(SI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">559</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="codeLine">      // If alias analysis can tell that this store is guaranteed to not modify</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">560</td>
    <td class="codeLine">      // If alias analysis can tell that this store is guaranteed to not modify</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="codeLine">      // the query pointer, ignore it.  Use getModRefInfo to handle cases where</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">561</td>
    <td class="codeLine">      // the query pointer, ignore it.  Use getModRefInfo to handle cases where</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="codeLine">      // the query pointer points to constant memory etc.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">562</td>
    <td class="codeLine">      // the query pointer points to constant memory etc.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="codeLine">      if (!isModOrRefSet(BatchAA.getModRefInfo(SI, MemLoc)))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">563</td>
    <td class="codeLine">      if (!isModOrRefSet(BatchAA.getModRefInfo(SI, MemLoc)))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">564</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">565</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="codeLine">      // Ok, this store might clobber the query pointer.  Check to see if it is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">566</td>
    <td class="codeLine">      // Ok, this store might clobber the query pointer.  Check to see if it is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="codeLine">      // a must alias: in this case, we want to return this as a def.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">567</td>
    <td class="codeLine">      // a must alias: in this case, we want to return this as a def.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="codeLine">      // FIXME: Use ModRefInfo::Must bit from getModRefInfo call above.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">568</td>
    <td class="codeLine">      // FIXME: Use ModRefInfo::Must bit from getModRefInfo call above.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="codeLine">      MemoryLocation StoreLoc = MemoryLocation::get(SI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">569</td>
    <td class="codeLine">      MemoryLocation StoreLoc = MemoryLocation::get(SI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">570</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="codeLine">      // If we found a pointer, check if it could be the same as our pointer.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">571</td>
    <td class="codeLine">      // If we found a pointer, check if it could be the same as our pointer.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="codeLine">      AliasResult R = BatchAA.alias(StoreLoc, MemLoc);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">572</td>
    <td class="codeLine">      AliasResult R = BatchAA.alias(StoreLoc, MemLoc);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">573</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="codeLine">      if (R == AliasResult::NoAlias)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">574</td>
    <td class="codeLine">      if (R == AliasResult::NoAlias)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">575</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="codeLine">      if (R == AliasResult::MustAlias)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">576</td>
    <td class="codeLine">      if (R == AliasResult::MustAlias)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="codeLine">        return MemDepResult::getDef(Inst);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">577</td>
    <td class="codeLine">        return MemDepResult::getDef(Inst);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="codeLine">      if (isInvariantLoad)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">578</td>
    <td class="codeLine">      if (isInvariantLoad)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">579</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="codeLine">      return MemDepResult::getClobber(Inst);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">580</td>
    <td class="codeLine">      return MemDepResult::getClobber(Inst);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">581</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">582</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="codeLine">    // If this is an allocation, and if we know that the accessed pointer is to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">583</td>
    <td class="codeLine">    // If this is an allocation, and if we know that the accessed pointer is to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="codeLine">    // the allocation, return Def.  This means that there is no dependence and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">584</td>
    <td class="codeLine">    // the allocation, return Def.  This means that there is no dependence and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="codeLine">    // the access can be optimized based on that.  For example, a load could</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">585</td>
    <td class="codeLine">    // the access can be optimized based on that.  For example, a load could</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="codeLine">    // turn into undef.  Note that we can bypass the allocation itself when</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">586</td>
    <td class="codeLine">    // turn into undef.  Note that we can bypass the allocation itself when</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class="codeLine">    // looking for a clobber in many cases; that's an alias property and is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">587</td>
    <td class="codeLine">    // looking for a clobber in many cases; that's an alias property and is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="codeLine">    // handled by BasicAA.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">588</td>
    <td class="codeLine">    // handled by BasicAA.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="codeLine">    if (isa<AllocaInst>(Inst) || isNoAliasCall(Inst)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">589</td>
    <td class="codeLine">    if (isa<AllocaInst>(Inst) || isNoAliasCall(Inst)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class="codeLine">      const Value *AccessPtr = getUnderlyingObject(MemLoc.Ptr);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">590</td>
    <td class="codeLine">      const Value *AccessPtr = getUnderlyingObject(MemLoc.Ptr);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="codeLine">      if (AccessPtr == Inst || BatchAA.isMustAlias(Inst, AccessPtr))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">591</td>
    <td class="codeLine">      if (AccessPtr == Inst || BatchAA.isMustAlias(Inst, AccessPtr))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="codeLine">        return MemDepResult::getDef(Inst);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">592</td>
    <td class="codeLine">        return MemDepResult::getDef(Inst);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">593</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">594</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="codeLine">    // If we found a select instruction for MemLoc pointer, return it as Def</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">595</td>
    <td class="codeLine">    // If we found a select instruction for MemLoc pointer, return it as Def</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="codeLine">    // dependency.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">596</td>
    <td class="codeLine">    // dependency.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class="codeLine">    if (isa<SelectInst>(Inst) && MemLoc.Ptr == Inst)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">597</td>
    <td class="codeLine">    if (isa<SelectInst>(Inst) && MemLoc.Ptr == Inst)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="codeLine">      return MemDepResult::getDef(Inst);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">598</td>
    <td class="codeLine">      return MemDepResult::getDef(Inst);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">599</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="codeLine">    if (isInvariantLoad)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">600</td>
    <td class="codeLine">    if (isInvariantLoad)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">601</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">602</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="codeLine">    // A release fence requires that all stores complete before it, but does</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">603</td>
    <td class="codeLine">    // A release fence requires that all stores complete before it, but does</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="codeLine">    // not prevent the reordering of following loads or stores 'before' the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">604</td>
    <td class="codeLine">    // not prevent the reordering of following loads or stores 'before' the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="codeLine">    // fence.  As a result, we look past it when finding a dependency for</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">605</td>
    <td class="codeLine">    // fence.  As a result, we look past it when finding a dependency for</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="codeLine">    // loads.  DSE uses this to find preceding stores to delete and thus we</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">606</td>
    <td class="codeLine">    // loads.  DSE uses this to find preceding stores to delete and thus we</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="codeLine">    // can't bypass the fence if the query instruction is a store.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">607</td>
    <td class="codeLine">    // can't bypass the fence if the query instruction is a store.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="codeLine">    if (FenceInst *FI = dyn_cast<FenceInst>(Inst))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">608</td>
    <td class="codeLine">    if (FenceInst *FI = dyn_cast<FenceInst>(Inst))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="codeLine">      if (isLoad && FI->getOrdering() == AtomicOrdering::Release)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">609</td>
    <td class="codeLine">      if (isLoad && FI->getOrdering() == AtomicOrdering::Release)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">610</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">611</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="codeLine">    // See if this instruction (e.g. a call or vaarg) mod/ref's the pointer.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">612</td>
    <td class="codeLine">    // See if this instruction (e.g. a call or vaarg) mod/ref's the pointer.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class="codeLine">    ModRefInfo MR = BatchAA.getModRefInfo(Inst, MemLoc);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">613</td>
    <td class="codeLine">    ModRefInfo MR = BatchAA.getModRefInfo(Inst, MemLoc);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class="codeLine">    // If necessary, perform additional analysis.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">614</td>
    <td class="codeLine">    // If necessary, perform additional analysis.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="codeLine">    if (isModAndRefSet(MR))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">615</td>
    <td class="codeLine">    if (isModAndRefSet(MR))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="codeLine">      MR = BatchAA.callCapturesBefore(Inst, MemLoc, &DT);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">616</td>
    <td class="codeLine">      MR = BatchAA.callCapturesBefore(Inst, MemLoc, &DT);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="codeLine">    switch (MR) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">617</td>
    <td class="codeLine">    switch (MR) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class="codeLine">    case ModRefInfo::NoModRef:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">618</td>
    <td class="codeLine">    case ModRefInfo::NoModRef:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="codeLine">      // If the call has no effect on the queried pointer, just ignore it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">619</td>
    <td class="codeLine">      // If the call has no effect on the queried pointer, just ignore it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">620</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class="codeLine">    case ModRefInfo::Mod:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">621</td>
    <td class="codeLine">    case ModRefInfo::Mod:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="codeLine">      return MemDepResult::getClobber(Inst);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">622</td>
    <td class="codeLine">      return MemDepResult::getClobber(Inst);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="codeLine">    case ModRefInfo::Ref:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">623</td>
    <td class="codeLine">    case ModRefInfo::Ref:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="codeLine">      // If the call is known to never store to the pointer, and if this is a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">624</td>
    <td class="codeLine">      // If the call is known to never store to the pointer, and if this is a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="codeLine">      // load query, we can safely ignore it (scan past it).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">625</td>
    <td class="codeLine">      // load query, we can safely ignore it (scan past it).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="codeLine">      if (isLoad)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">626</td>
    <td class="codeLine">      if (isLoad)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">627</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class="codeLine">      [[fallthrough]];</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">628</td>
    <td class="codeLine">      [[fallthrough]];</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="codeLine">    default:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">629</td>
    <td class="codeLine">    default:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class="codeLine">      // Otherwise, there is a potential dependence.  Return a clobber.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">630</td>
    <td class="codeLine">      // Otherwise, there is a potential dependence.  Return a clobber.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="codeLine">      return MemDepResult::getClobber(Inst);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">631</td>
    <td class="codeLine">      return MemDepResult::getClobber(Inst);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">632</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">633</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">634</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="codeLine">  // No dependence found.  If this is the entry block of the function, it is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">635</td>
    <td class="codeLine">  // No dependence found.  If this is the entry block of the function, it is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="codeLine">  // unknown, otherwise it is non-local.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">636</td>
    <td class="codeLine">  // unknown, otherwise it is non-local.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="codeLine">  if (BB != &BB->getParent()->getEntryBlock())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">637</td>
    <td class="codeLine">  if (BB != &BB->getParent()->getEntryBlock())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="codeLine">    return MemDepResult::getNonLocal();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">638</td>
    <td class="codeLine">    return MemDepResult::getNonLocal();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="codeLine">  return MemDepResult::getNonFuncLocal();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">639</td>
    <td class="codeLine">  return MemDepResult::getNonFuncLocal();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">640</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">641</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="codeLine">MemDepResult MemoryDependenceResults::getDependency(Instruction *QueryInst) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">642</td>
    <td class="codeLine">MemDepResult MemoryDependenceResults::getDependency(Instruction *QueryInst) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="codeLine">  ClobberOffsets.clear();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">643</td>
    <td class="codeLine">  ClobberOffsets.clear();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class="codeLine">  Instruction *ScanPos = QueryInst;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">644</td>
    <td class="codeLine">  Instruction *ScanPos = QueryInst;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">645</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="codeLine">  // Check for a cached result</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">646</td>
    <td class="codeLine">  // Check for a cached result</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="codeLine">  MemDepResult &LocalCache = LocalDeps[QueryInst];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">647</td>
    <td class="codeLine">  MemDepResult &LocalCache = LocalDeps[QueryInst];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">648</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="codeLine">  // If the cached entry is non-dirty, just return it.  Note that this depends</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">649</td>
    <td class="codeLine">  // If the cached entry is non-dirty, just return it.  Note that this depends</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="codeLine">  // on MemDepResult's default constructing to 'dirty'.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">650</td>
    <td class="codeLine">  // on MemDepResult's default constructing to 'dirty'.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="codeLine">  if (!LocalCache.isDirty())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">651</td>
    <td class="codeLine">  if (!LocalCache.isDirty())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="codeLine">    return LocalCache;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">652</td>
    <td class="codeLine">    return LocalCache;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">653</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="codeLine">  // Otherwise, if we have a dirty entry, we know we can start the scan at that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">654</td>
    <td class="codeLine">  // Otherwise, if we have a dirty entry, we know we can start the scan at that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="codeLine">  // instruction, which may save us some work.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">655</td>
    <td class="codeLine">  // instruction, which may save us some work.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="codeLine">  if (Instruction *Inst = LocalCache.getInst()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">656</td>
    <td class="codeLine">  if (Instruction *Inst = LocalCache.getInst()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class="codeLine">    ScanPos = Inst;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">657</td>
    <td class="codeLine">    ScanPos = Inst;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">658</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="codeLine">    RemoveFromReverseMap(ReverseLocalDeps, Inst, QueryInst);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">659</td>
    <td class="codeLine">    RemoveFromReverseMap(ReverseLocalDeps, Inst, QueryInst);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">660</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">661</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="codeLine">  BasicBlock *QueryParent = QueryInst->getParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">662</td>
    <td class="codeLine">  BasicBlock *QueryParent = QueryInst->getParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">663</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="codeLine">  // Do the scan.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">664</td>
    <td class="codeLine">  // Do the scan.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="codeLine">  if (BasicBlock::iterator(QueryInst) == QueryParent->begin()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">665</td>
    <td class="codeLine">  if (BasicBlock::iterator(QueryInst) == QueryParent->begin()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="codeLine">    // No dependence found. If this is the entry block of the function, it is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">666</td>
    <td class="codeLine">    // No dependence found. If this is the entry block of the function, it is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="codeLine">    // unknown, otherwise it is non-local.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">667</td>
    <td class="codeLine">    // unknown, otherwise it is non-local.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="codeLine">    if (QueryParent != &QueryParent->getParent()->getEntryBlock())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">668</td>
    <td class="codeLine">    if (QueryParent != &QueryParent->getParent()->getEntryBlock())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="codeLine">      LocalCache = MemDepResult::getNonLocal();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">669</td>
    <td class="codeLine">      LocalCache = MemDepResult::getNonLocal();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">670</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="codeLine">      LocalCache = MemDepResult::getNonFuncLocal();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">671</td>
    <td class="codeLine">      LocalCache = MemDepResult::getNonFuncLocal();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">672</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="codeLine">    MemoryLocation MemLoc;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">673</td>
    <td class="codeLine">    MemoryLocation MemLoc;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="codeLine">    ModRefInfo MR = GetLocation(QueryInst, MemLoc, TLI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">674</td>
    <td class="codeLine">    ModRefInfo MR = GetLocation(QueryInst, MemLoc, TLI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class="codeLine">    if (MemLoc.Ptr) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">675</td>
    <td class="codeLine">    if (MemLoc.Ptr) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class="codeLine">      // If we can do a pointer scan, make it happen.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">676</td>
    <td class="codeLine">      // If we can do a pointer scan, make it happen.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="codeLine">      bool isLoad = !isModSet(MR);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">677</td>
    <td class="codeLine">      bool isLoad = !isModSet(MR);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="codeLine">      if (auto *II = dyn_cast<IntrinsicInst>(QueryInst))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">678</td>
    <td class="codeLine">      if (auto *II = dyn_cast<IntrinsicInst>(QueryInst))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="codeLine">        isLoad |= II->getIntrinsicID() == Intrinsic::lifetime_start;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">679</td>
    <td class="codeLine">        isLoad |= II->getIntrinsicID() == Intrinsic::lifetime_start;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">680</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="codeLine">      LocalCache =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">681</td>
    <td class="codeLine">      LocalCache =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="codeLine">          getPointerDependencyFrom(MemLoc, isLoad, ScanPos->getIterator(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">682</td>
    <td class="codeLine">          getPointerDependencyFrom(MemLoc, isLoad, ScanPos->getIterator(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class="codeLine">                                   QueryParent, QueryInst, nullptr);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">683</td>
    <td class="codeLine">                                   QueryParent, QueryInst, nullptr);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="codeLine">    } else if (auto *QueryCall = dyn_cast<CallBase>(QueryInst)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">684</td>
    <td class="codeLine">    } else if (auto *QueryCall = dyn_cast<CallBase>(QueryInst)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class="codeLine">      bool isReadOnly = AA.onlyReadsMemory(QueryCall);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">685</td>
    <td class="codeLine">      bool isReadOnly = AA.onlyReadsMemory(QueryCall);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="codeLine">      LocalCache = getCallDependencyFrom(QueryCall, isReadOnly,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">686</td>
    <td class="codeLine">      LocalCache = getCallDependencyFrom(QueryCall, isReadOnly,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="codeLine">                                         ScanPos->getIterator(), QueryParent);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">687</td>
    <td class="codeLine">                                         ScanPos->getIterator(), QueryParent);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class="codeLine">    } else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">688</td>
    <td class="codeLine">    } else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class="codeLine">      // Non-memory instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">689</td>
    <td class="codeLine">      // Non-memory instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class="codeLine">      LocalCache = MemDepResult::getUnknown();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">690</td>
    <td class="codeLine">      LocalCache = MemDepResult::getUnknown();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">691</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">692</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class="codeLine">  // Remember the result!</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">693</td>
    <td class="codeLine">  // Remember the result!</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class="codeLine">  if (Instruction *I = LocalCache.getInst())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">694</td>
    <td class="codeLine">  if (Instruction *I = LocalCache.getInst())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="codeLine">    ReverseLocalDeps[I].insert(QueryInst);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">695</td>
    <td class="codeLine">    ReverseLocalDeps[I].insert(QueryInst);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">696</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class="codeLine">  return LocalCache;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">697</td>
    <td class="codeLine">  return LocalCache;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">698</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">699</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="codeLine">#ifndef NDEBUG</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">700</td>
    <td class="codeLine">#ifndef NDEBUG</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="codeLine">/// This method is used when -debug is specified to verify that cache arrays</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">701</td>
    <td class="codeLine">/// This method is used when -debug is specified to verify that cache arrays</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class="codeLine">/// are properly kept sorted.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">702</td>
    <td class="codeLine">/// are properly kept sorted.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="codeLine">static void AssertSorted(MemoryDependenceResults::NonLocalDepInfo &Cache,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">703</td>
    <td class="codeLine">static void AssertSorted(MemoryDependenceResults::NonLocalDepInfo &Cache,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class="codeLine">                         int Count = -1) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">704</td>
    <td class="codeLine">                         int Count = -1) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="codeLine">  if (Count == -1)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">705</td>
    <td class="codeLine">  if (Count == -1)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class="codeLine">    Count = Cache.size();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">706</td>
    <td class="codeLine">    Count = Cache.size();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class="codeLine">  assert(std::is_sorted(Cache.begin(), Cache.begin() + Count) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">707</td>
    <td class="codeLine">  assert(std::is_sorted(Cache.begin(), Cache.begin() + Count) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class="codeLine">         "Cache isn't sorted!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">708</td>
    <td class="codeLine">         "Cache isn't sorted!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">709</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">710</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">711</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class="codeLine">const MemoryDependenceResults::NonLocalDepInfo &</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">712</td>
    <td class="codeLine">const MemoryDependenceResults::NonLocalDepInfo &</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="codeLine">MemoryDependenceResults::getNonLocalCallDependency(CallBase *QueryCall) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">713</td>
    <td class="codeLine">MemoryDependenceResults::getNonLocalCallDependency(CallBase *QueryCall) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="codeLine">  assert(getDependency(QueryCall).isNonLocal() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">714</td>
    <td class="codeLine">  assert(getDependency(QueryCall).isNonLocal() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="codeLine">         "getNonLocalCallDependency should only be used on calls with "</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">715</td>
    <td class="codeLine">         "getNonLocalCallDependency should only be used on calls with "</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="codeLine">         "non-local deps!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">716</td>
    <td class="codeLine">         "non-local deps!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class="codeLine">  PerInstNLInfo &CacheP = NonLocalDepsMap[QueryCall];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">717</td>
    <td class="codeLine">  PerInstNLInfo &CacheP = NonLocalDepsMap[QueryCall];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class="codeLine">  NonLocalDepInfo &Cache = CacheP.first;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">718</td>
    <td class="codeLine">  NonLocalDepInfo &Cache = CacheP.first;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">719</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class="codeLine">  // This is the set of blocks that need to be recomputed.  In the cached case,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">720</td>
    <td class="codeLine">  // This is the set of blocks that need to be recomputed.  In the cached case,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="codeLine">  // this can happen due to instructions being deleted etc. In the uncached</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">721</td>
    <td class="codeLine">  // this can happen due to instructions being deleted etc. In the uncached</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class="codeLine">  // case, this starts out as the set of predecessors we care about.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">722</td>
    <td class="codeLine">  // case, this starts out as the set of predecessors we care about.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="codeLine">  SmallVector<BasicBlock *, 32> DirtyBlocks;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">723</td>
    <td class="codeLine">  SmallVector<BasicBlock *, 32> DirtyBlocks;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">724</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="codeLine">  if (!Cache.empty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">725</td>
    <td class="codeLine">  if (!Cache.empty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class="codeLine">    // Okay, we have a cache entry.  If we know it is not dirty, just return it</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">726</td>
    <td class="codeLine">    // Okay, we have a cache entry.  If we know it is not dirty, just return it</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class="codeLine">    // with no computation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">727</td>
    <td class="codeLine">    // with no computation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class="codeLine">    if (!CacheP.second) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">728</td>
    <td class="codeLine">    if (!CacheP.second) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="codeLine">      ++NumCacheNonLocal;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">729</td>
    <td class="codeLine">      ++NumCacheNonLocal;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class="codeLine">      return Cache;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">730</td>
    <td class="codeLine">      return Cache;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">731</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">732</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="codeLine">    // If we already have a partially computed set of results, scan them to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">733</td>
    <td class="codeLine">    // If we already have a partially computed set of results, scan them to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="codeLine">    // determine what is dirty, seeding our initial DirtyBlocks worklist.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">734</td>
    <td class="codeLine">    // determine what is dirty, seeding our initial DirtyBlocks worklist.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class="codeLine">    for (auto &Entry : Cache)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">735</td>
    <td class="codeLine">    for (auto &Entry : Cache)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class="codeLine">      if (Entry.getResult().isDirty())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">736</td>
    <td class="codeLine">      if (Entry.getResult().isDirty())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class="codeLine">        DirtyBlocks.push_back(Entry.getBB());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">737</td>
    <td class="codeLine">        DirtyBlocks.push_back(Entry.getBB());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">738</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class="codeLine">    // Sort the cache so that we can do fast binary search lookups below.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">739</td>
    <td class="codeLine">    // Sort the cache so that we can do fast binary search lookups below.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="codeLine">    llvm::sort(Cache);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">740</td>
    <td class="codeLine">    llvm::sort(Cache);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">741</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class="codeLine">    ++NumCacheDirtyNonLocal;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">742</td>
    <td class="codeLine">    ++NumCacheDirtyNonLocal;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">743</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="codeLine">    // Seed DirtyBlocks with each of the preds of QueryInst's block.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">744</td>
    <td class="codeLine">    // Seed DirtyBlocks with each of the preds of QueryInst's block.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="codeLine">    BasicBlock *QueryBB = QueryCall->getParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">745</td>
    <td class="codeLine">    BasicBlock *QueryBB = QueryCall->getParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class="codeLine">    append_range(DirtyBlocks, PredCache.get(QueryBB));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">746</td>
    <td class="codeLine">    append_range(DirtyBlocks, PredCache.get(QueryBB));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class="codeLine">    ++NumUncacheNonLocal;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">747</td>
    <td class="codeLine">    ++NumUncacheNonLocal;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">748</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">749</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="codeLine">  // isReadonlyCall - If this is a read-only call, we can be more aggressive.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">750</td>
    <td class="codeLine">  // isReadonlyCall - If this is a read-only call, we can be more aggressive.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class="codeLine">  bool isReadonlyCall = AA.onlyReadsMemory(QueryCall);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">751</td>
    <td class="codeLine">  bool isReadonlyCall = AA.onlyReadsMemory(QueryCall);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">752</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class="codeLine">  SmallPtrSet<BasicBlock *, 32> Visited;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">753</td>
    <td class="codeLine">  SmallPtrSet<BasicBlock *, 32> Visited;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">754</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class="codeLine">  unsigned NumSortedEntries = Cache.size();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">755</td>
    <td class="codeLine">  unsigned NumSortedEntries = Cache.size();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="codeLine">  LLVM_DEBUG(AssertSorted(Cache));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">756</td>
    <td class="codeLine">  LLVM_DEBUG(AssertSorted(Cache));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">757</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="codeLine">  // Iterate while we still have blocks to update.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">758</td>
    <td class="codeLine">  // Iterate while we still have blocks to update.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="codeLine">  while (!DirtyBlocks.empty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">759</td>
    <td class="codeLine">  while (!DirtyBlocks.empty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class="codeLine">    BasicBlock *DirtyBB = DirtyBlocks.pop_back_val();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">760</td>
    <td class="codeLine">    BasicBlock *DirtyBB = DirtyBlocks.pop_back_val();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">761</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class="codeLine">    // Already processed this block?</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">762</td>
    <td class="codeLine">    // Already processed this block?</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="codeLine">    if (!Visited.insert(DirtyBB).second)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">763</td>
    <td class="codeLine">    if (!Visited.insert(DirtyBB).second)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">764</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">765</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class="codeLine">    // Do a binary search to see if we already have an entry for this block in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">766</td>
    <td class="codeLine">    // Do a binary search to see if we already have an entry for this block in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="codeLine">    // the cache set.  If so, find it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">767</td>
    <td class="codeLine">    // the cache set.  If so, find it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class="codeLine">    LLVM_DEBUG(AssertSorted(Cache, NumSortedEntries));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">768</td>
    <td class="codeLine">    LLVM_DEBUG(AssertSorted(Cache, NumSortedEntries));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="codeLine">    NonLocalDepInfo::iterator Entry =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">769</td>
    <td class="codeLine">    NonLocalDepInfo::iterator Entry =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="codeLine">        std::upper_bound(Cache.begin(), Cache.begin() + NumSortedEntries,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">770</td>
    <td class="codeLine">        std::upper_bound(Cache.begin(), Cache.begin() + NumSortedEntries,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class="codeLine">                         NonLocalDepEntry(DirtyBB));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">771</td>
    <td class="codeLine">                         NonLocalDepEntry(DirtyBB));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="codeLine">    if (Entry != Cache.begin() && std::prev(Entry)->getBB() == DirtyBB)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">772</td>
    <td class="codeLine">    if (Entry != Cache.begin() && std::prev(Entry)->getBB() == DirtyBB)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class="codeLine">      --Entry;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">773</td>
    <td class="codeLine">      --Entry;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">774</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class="codeLine">    NonLocalDepEntry *ExistingResult = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">775</td>
    <td class="codeLine">    NonLocalDepEntry *ExistingResult = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class="codeLine">    if (Entry != Cache.begin() + NumSortedEntries &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">776</td>
    <td class="codeLine">    if (Entry != Cache.begin() + NumSortedEntries &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="codeLine">        Entry->getBB() == DirtyBB) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">777</td>
    <td class="codeLine">        Entry->getBB() == DirtyBB) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class="codeLine">      // If we already have an entry, and if it isn't already dirty, the block</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">778</td>
    <td class="codeLine">      // If we already have an entry, and if it isn't already dirty, the block</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="codeLine">      // is done.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">779</td>
    <td class="codeLine">      // is done.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class="codeLine">      if (!Entry->getResult().isDirty())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">780</td>
    <td class="codeLine">      if (!Entry->getResult().isDirty())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">781</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">782</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="codeLine">      // Otherwise, remember this slot so we can update the value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">783</td>
    <td class="codeLine">      // Otherwise, remember this slot so we can update the value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class="codeLine">      ExistingResult = &*Entry;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">784</td>
    <td class="codeLine">      ExistingResult = &*Entry;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">785</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">786</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class="codeLine">    // If the dirty entry has a pointer, start scanning from it so we don't have</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">787</td>
    <td class="codeLine">    // If the dirty entry has a pointer, start scanning from it so we don't have</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="codeLine">    // to rescan the entire block.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">788</td>
    <td class="codeLine">    // to rescan the entire block.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class="codeLine">    BasicBlock::iterator ScanPos = DirtyBB->end();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">789</td>
    <td class="codeLine">    BasicBlock::iterator ScanPos = DirtyBB->end();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class="codeLine">    if (ExistingResult) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">790</td>
    <td class="codeLine">    if (ExistingResult) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class="codeLine">      if (Instruction *Inst = ExistingResult->getResult().getInst()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">791</td>
    <td class="codeLine">      if (Instruction *Inst = ExistingResult->getResult().getInst()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class="codeLine">        ScanPos = Inst->getIterator();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">792</td>
    <td class="codeLine">        ScanPos = Inst->getIterator();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="codeLine">        // We're removing QueryInst's use of Inst.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">793</td>
    <td class="codeLine">        // We're removing QueryInst's use of Inst.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class="codeLine">        RemoveFromReverseMap<Instruction *>(ReverseNonLocalDeps, Inst,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">794</td>
    <td class="codeLine">        RemoveFromReverseMap<Instruction *>(ReverseNonLocalDeps, Inst,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="codeLine">                                            QueryCall);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">795</td>
    <td class="codeLine">                                            QueryCall);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">796</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">797</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">798</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class="codeLine">    // Find out if this block has a local dependency for QueryInst.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">799</td>
    <td class="codeLine">    // Find out if this block has a local dependency for QueryInst.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class="codeLine">    MemDepResult Dep;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">800</td>
    <td class="codeLine">    MemDepResult Dep;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">801</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class="codeLine">    if (ScanPos != DirtyBB->begin()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">802</td>
    <td class="codeLine">    if (ScanPos != DirtyBB->begin()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class="codeLine">      Dep = getCallDependencyFrom(QueryCall, isReadonlyCall, ScanPos, DirtyBB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">803</td>
    <td class="codeLine">      Dep = getCallDependencyFrom(QueryCall, isReadonlyCall, ScanPos, DirtyBB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class="codeLine">    } else if (DirtyBB != &DirtyBB->getParent()->getEntryBlock()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">804</td>
    <td class="codeLine">    } else if (DirtyBB != &DirtyBB->getParent()->getEntryBlock()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class="codeLine">      // No dependence found.  If this is the entry block of the function, it is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">805</td>
    <td class="codeLine">      // No dependence found.  If this is the entry block of the function, it is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class="codeLine">      // a clobber, otherwise it is unknown.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">806</td>
    <td class="codeLine">      // a clobber, otherwise it is unknown.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class="codeLine">      Dep = MemDepResult::getNonLocal();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">807</td>
    <td class="codeLine">      Dep = MemDepResult::getNonLocal();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">808</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class="codeLine">      Dep = MemDepResult::getNonFuncLocal();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">809</td>
    <td class="codeLine">      Dep = MemDepResult::getNonFuncLocal();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">810</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">811</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class="codeLine">    // If we had a dirty entry for the block, update it.  Otherwise, just add</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">812</td>
    <td class="codeLine">    // If we had a dirty entry for the block, update it.  Otherwise, just add</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class="codeLine">    // a new entry.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">813</td>
    <td class="codeLine">    // a new entry.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class="codeLine">    if (ExistingResult)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">814</td>
    <td class="codeLine">    if (ExistingResult)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class="codeLine">      ExistingResult->setResult(Dep);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">815</td>
    <td class="codeLine">      ExistingResult->setResult(Dep);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">816</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class="codeLine">      Cache.push_back(NonLocalDepEntry(DirtyBB, Dep));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">817</td>
    <td class="codeLine">      Cache.push_back(NonLocalDepEntry(DirtyBB, Dep));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">818</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class="codeLine">    // If the block has a dependency (i.e. it isn't completely transparent to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">819</td>
    <td class="codeLine">    // If the block has a dependency (i.e. it isn't completely transparent to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class="codeLine">    // the value), remember the association!</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">820</td>
    <td class="codeLine">    // the value), remember the association!</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class="codeLine">    if (!Dep.isNonLocal()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">821</td>
    <td class="codeLine">    if (!Dep.isNonLocal()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class="codeLine">      // Keep the ReverseNonLocalDeps map up to date so we can efficiently</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">822</td>
    <td class="codeLine">      // Keep the ReverseNonLocalDeps map up to date so we can efficiently</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class="codeLine">      // update this when we remove instructions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">823</td>
    <td class="codeLine">      // update this when we remove instructions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class="codeLine">      if (Instruction *Inst = Dep.getInst())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">824</td>
    <td class="codeLine">      if (Instruction *Inst = Dep.getInst())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class="codeLine">        ReverseNonLocalDeps[Inst].insert(QueryCall);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">825</td>
    <td class="codeLine">        ReverseNonLocalDeps[Inst].insert(QueryCall);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">826</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">827</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class="codeLine">      // If the block *is* completely transparent to the load, we need to check</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">828</td>
    <td class="codeLine">      // If the block *is* completely transparent to the load, we need to check</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class="codeLine">      // the predecessors of this block.  Add them to our worklist.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">829</td>
    <td class="codeLine">      // the predecessors of this block.  Add them to our worklist.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class="codeLine">      append_range(DirtyBlocks, PredCache.get(DirtyBB));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">830</td>
    <td class="codeLine">      append_range(DirtyBlocks, PredCache.get(DirtyBB));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">831</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">832</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">833</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class="codeLine">  return Cache;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">834</td>
    <td class="codeLine">  return Cache;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">835</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">836</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class="codeLine">void MemoryDependenceResults::getNonLocalPointerDependency(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">837</td>
    <td class="codeLine">void MemoryDependenceResults::getNonLocalPointerDependency(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class="codeLine">    Instruction *QueryInst, SmallVectorImpl<NonLocalDepResult> &Result) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">838</td>
    <td class="codeLine">    Instruction *QueryInst, SmallVectorImpl<NonLocalDepResult> &Result) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class="codeLine">  const MemoryLocation Loc = MemoryLocation::get(QueryInst);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">839</td>
    <td class="codeLine">  const MemoryLocation Loc = MemoryLocation::get(QueryInst);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class="codeLine">  bool isLoad = isa<LoadInst>(QueryInst);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">840</td>
    <td class="codeLine">  bool isLoad = isa<LoadInst>(QueryInst);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class="codeLine">  BasicBlock *FromBB = QueryInst->getParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">841</td>
    <td class="codeLine">  BasicBlock *FromBB = QueryInst->getParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class="codeLine">  assert(FromBB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">842</td>
    <td class="codeLine">  assert(FromBB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">843</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class="codeLine">  assert(Loc.Ptr->getType()->isPointerTy() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">844</td>
    <td class="codeLine">  assert(Loc.Ptr->getType()->isPointerTy() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class="codeLine">         "Can't get pointer deps of a non-pointer!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">845</td>
    <td class="codeLine">         "Can't get pointer deps of a non-pointer!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class="codeLine">  Result.clear();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">846</td>
    <td class="codeLine">  Result.clear();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class="codeLine">  {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">847</td>
    <td class="codeLine">  {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class="codeLine">    // Check if there is cached Def with invariant.group.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">848</td>
    <td class="codeLine">    // Check if there is cached Def with invariant.group.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class="codeLine">    auto NonLocalDefIt = NonLocalDefsCache.find(QueryInst);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">849</td>
    <td class="codeLine">    auto NonLocalDefIt = NonLocalDefsCache.find(QueryInst);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class="codeLine">    if (NonLocalDefIt != NonLocalDefsCache.end()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">850</td>
    <td class="codeLine">    if (NonLocalDefIt != NonLocalDefsCache.end()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class="codeLine">      Result.push_back(NonLocalDefIt->second);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">851</td>
    <td class="codeLine">      Result.push_back(NonLocalDefIt->second);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class="codeLine">      ReverseNonLocalDefsCache[NonLocalDefIt->second.getResult().getInst()]</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">852</td>
    <td class="codeLine">      ReverseNonLocalDefsCache[NonLocalDefIt->second.getResult().getInst()]</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class="codeLine">          .erase(QueryInst);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">853</td>
    <td class="codeLine">          .erase(QueryInst);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class="codeLine">      NonLocalDefsCache.erase(NonLocalDefIt);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">854</td>
    <td class="codeLine">      NonLocalDefsCache.erase(NonLocalDefIt);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class="codeLine">      return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">855</td>
    <td class="codeLine">      return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">856</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">857</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class="codeLine">  // This routine does not expect to deal with volatile instructions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">858</td>
    <td class="codeLine">  // This routine does not expect to deal with volatile instructions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class="codeLine">  // Doing so would require piping through the QueryInst all the way through.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">859</td>
    <td class="codeLine">  // Doing so would require piping through the QueryInst all the way through.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class="codeLine">  // TODO: volatiles can't be elided, but they can be reordered with other</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">860</td>
    <td class="codeLine">  // TODO: volatiles can't be elided, but they can be reordered with other</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class="codeLine">  // non-volatile accesses.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">861</td>
    <td class="codeLine">  // non-volatile accesses.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">862</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class="codeLine">  // We currently give up on any instruction which is ordered, but we do handle</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">863</td>
    <td class="codeLine">  // We currently give up on any instruction which is ordered, but we do handle</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class="codeLine">  // atomic instructions which are unordered.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">864</td>
    <td class="codeLine">  // atomic instructions which are unordered.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class="codeLine">  // TODO: Handle ordered instructions</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">865</td>
    <td class="codeLine">  // TODO: Handle ordered instructions</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class="codeLine">  auto isOrdered = [](Instruction *Inst) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">866</td>
    <td class="codeLine">  auto isOrdered = [](Instruction *Inst) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class="codeLine">    if (LoadInst *LI = dyn_cast<LoadInst>(Inst)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">867</td>
    <td class="codeLine">    if (LoadInst *LI = dyn_cast<LoadInst>(Inst)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class="codeLine">      return !LI->isUnordered();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">868</td>
    <td class="codeLine">      return !LI->isUnordered();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class="codeLine">    } else if (StoreInst *SI = dyn_cast<StoreInst>(Inst)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">869</td>
    <td class="codeLine">    } else if (StoreInst *SI = dyn_cast<StoreInst>(Inst)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="codeLine">      return !SI->isUnordered();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">870</td>
    <td class="codeLine">      return !SI->isUnordered();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">871</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">872</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">872</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">873</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">873</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">874</td>
    <td class="codeLine">  if (QueryInst->isVolatile() || isOrdered(QueryInst)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">874</td>
    <td class="codeLine">  if (QueryInst->isVolatile() || isOrdered(QueryInst)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">875</td>
    <td class="codeLine">    Result.push_back(NonLocalDepResult(FromBB, MemDepResult::getUnknown(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">875</td>
    <td class="codeLine">    Result.push_back(NonLocalDepResult(FromBB, MemDepResult::getUnknown(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">876</td>
    <td class="codeLine">                                       const_cast<Value *>(Loc.Ptr)));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">876</td>
    <td class="codeLine">                                       const_cast<Value *>(Loc.Ptr)));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">877</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">877</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">878</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">878</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">879</td>
    <td class="codeLine">  const DataLayout &DL = FromBB->getModule()->getDataLayout();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">879</td>
    <td class="codeLine">  const DataLayout &DL = FromBB->getModule()->getDataLayout();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">880</td>
    <td class="codeLine">  PHITransAddr Address(const_cast<Value *>(Loc.Ptr), DL, &AC);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">880</td>
    <td class="codeLine">  PHITransAddr Address(const_cast<Value *>(Loc.Ptr), DL, &AC);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">881</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">881</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">882</td>
    <td class="codeLine">  // This is the set of blocks we've inspected, and the pointer we consider in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">882</td>
    <td class="codeLine">  // This is the set of blocks we've inspected, and the pointer we consider in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">883</td>
    <td class="codeLine">  // each block.  Because of critical edges, we currently bail out if querying</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">883</td>
    <td class="codeLine">  // each block.  Because of critical edges, we currently bail out if querying</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">884</td>
    <td class="codeLine">  // a block with multiple different pointers.  This can happen during PHI</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">884</td>
    <td class="codeLine">  // a block with multiple different pointers.  This can happen during PHI</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">885</td>
    <td class="codeLine">  // translation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">885</td>
    <td class="codeLine">  // translation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">886</td>
    <td class="codeLine">  DenseMap<BasicBlock *, Value *> Visited;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">886</td>
    <td class="codeLine">  DenseMap<BasicBlock *, Value *> Visited;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">887</td>
    <td class="codeLine">  if (getNonLocalPointerDepFromBB(QueryInst, Address, Loc, isLoad, FromBB,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">887</td>
    <td class="codeLine">  if (getNonLocalPointerDepFromBB(QueryInst, Address, Loc, isLoad, FromBB,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">888</td>
    <td class="codeLine">                                   Result, Visited, true))</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">888</td>
    <td class="codeLine">                                   Result, Visited, true))</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">889</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">889</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">890</td>
    <td class="codeLine">  Result.clear();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">890</td>
    <td class="codeLine">  Result.clear();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">891</td>
    <td class="codeLine">  Result.push_back(NonLocalDepResult(FromBB, MemDepResult::getUnknown(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">891</td>
    <td class="codeLine">  Result.push_back(NonLocalDepResult(FromBB, MemDepResult::getUnknown(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">892</td>
    <td class="codeLine">                                     const_cast<Value *>(Loc.Ptr)));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">892</td>
    <td class="codeLine">                                     const_cast<Value *>(Loc.Ptr)));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">893</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">893</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">894</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">894</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">895</td>
    <td class="codeLine">/// Compute the memdep value for BB with Pointer/PointeeSize using either</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">895</td>
    <td class="codeLine">/// Compute the memdep value for BB with Pointer/PointeeSize using either</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">896</td>
    <td class="codeLine">/// cached information in Cache or by doing a lookup (which may use dirty cache</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">896</td>
    <td class="codeLine">/// cached information in Cache or by doing a lookup (which may use dirty cache</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">897</td>
    <td class="codeLine">/// info if available).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">897</td>
    <td class="codeLine">/// info if available).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">898</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">898</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">899</td>
    <td class="codeLine">/// If we do a lookup, add the result to the cache.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">899</td>
    <td class="codeLine">/// If we do a lookup, add the result to the cache.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">900</td>
    <td class="codeLine">MemDepResult MemoryDependenceResults::getNonLocalInfoForBlock(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">900</td>
    <td class="codeLine">MemDepResult MemoryDependenceResults::getNonLocalInfoForBlock(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">901</td>
    <td class="codeLine">    Instruction *QueryInst, const MemoryLocation &Loc, bool isLoad,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">901</td>
    <td class="codeLine">    Instruction *QueryInst, const MemoryLocation &Loc, bool isLoad,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">902</td>
    <td class="codeLine">    BasicBlock *BB, NonLocalDepInfo *Cache, unsigned NumSortedEntries,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">902</td>
    <td class="codeLine">    BasicBlock *BB, NonLocalDepInfo *Cache, unsigned NumSortedEntries,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">903</td>
    <td class="codeLine">    BatchAAResults &BatchAA) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">903</td>
    <td class="codeLine">    BatchAAResults &BatchAA) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">904</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">904</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">905</td>
    <td class="codeLine">  bool isInvariantLoad = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">905</td>
    <td class="codeLine">  bool isInvariantLoad = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">906</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">906</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">907</td>
    <td class="codeLine">  if (LoadInst *LI = dyn_cast_or_null<LoadInst>(QueryInst))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">907</td>
    <td class="codeLine">  if (LoadInst *LI = dyn_cast_or_null<LoadInst>(QueryInst))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">908</td>
    <td class="codeLine">    isInvariantLoad = LI->getMetadata(LLVMContext::MD_invariant_load);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">908</td>
    <td class="codeLine">    isInvariantLoad = LI->getMetadata(LLVMContext::MD_invariant_load);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">909</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">909</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">910</td>
    <td class="codeLine">  // Do a binary search to see if we already have an entry for this block in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">910</td>
    <td class="codeLine">  // Do a binary search to see if we already have an entry for this block in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">911</td>
    <td class="codeLine">  // the cache set.  If so, find it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">911</td>
    <td class="codeLine">  // the cache set.  If so, find it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">912</td>
    <td class="codeLine">  NonLocalDepInfo::iterator Entry = std::upper_bound(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">912</td>
    <td class="codeLine">  NonLocalDepInfo::iterator Entry = std::upper_bound(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">913</td>
    <td class="codeLine">      Cache->begin(), Cache->begin() + NumSortedEntries, NonLocalDepEntry(BB));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">913</td>
    <td class="codeLine">      Cache->begin(), Cache->begin() + NumSortedEntries, NonLocalDepEntry(BB));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">914</td>
    <td class="codeLine">  if (Entry != Cache->begin() && (Entry - 1)->getBB() == BB)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">914</td>
    <td class="codeLine">  if (Entry != Cache->begin() && (Entry - 1)->getBB() == BB)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">915</td>
    <td class="codeLine">    --Entry;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">915</td>
    <td class="codeLine">    --Entry;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">916</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">916</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">917</td>
    <td class="codeLine">  NonLocalDepEntry *ExistingResult = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">917</td>
    <td class="codeLine">  NonLocalDepEntry *ExistingResult = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">918</td>
    <td class="codeLine">  if (Entry != Cache->begin() + NumSortedEntries && Entry->getBB() == BB)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">918</td>
    <td class="codeLine">  if (Entry != Cache->begin() + NumSortedEntries && Entry->getBB() == BB)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">919</td>
    <td class="codeLine">    ExistingResult = &*Entry;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">919</td>
    <td class="codeLine">    ExistingResult = &*Entry;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">920</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">920</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">921</td>
    <td class="codeLine">  // Use cached result for invariant load only if there is no dependency for non</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">921</td>
    <td class="codeLine">  // Use cached result for invariant load only if there is no dependency for non</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">922</td>
    <td class="codeLine">  // invariant load. In this case invariant load can not have any dependency as</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">922</td>
    <td class="codeLine">  // invariant load. In this case invariant load can not have any dependency as</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">923</td>
    <td class="codeLine">  // well.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">923</td>
    <td class="codeLine">  // well.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">924</td>
    <td class="codeLine">  if (ExistingResult && isInvariantLoad &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">924</td>
    <td class="codeLine">  if (ExistingResult && isInvariantLoad &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">925</td>
    <td class="codeLine">      !ExistingResult->getResult().isNonFuncLocal())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">925</td>
    <td class="codeLine">      !ExistingResult->getResult().isNonFuncLocal())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">926</td>
    <td class="codeLine">    ExistingResult = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">926</td>
    <td class="codeLine">    ExistingResult = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">927</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">927</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">928</td>
    <td class="codeLine">  // If we have a cached entry, and it is non-dirty, use it as the value for</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">928</td>
    <td class="codeLine">  // If we have a cached entry, and it is non-dirty, use it as the value for</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">929</td>
    <td class="codeLine">  // this dependency.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">929</td>
    <td class="codeLine">  // this dependency.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">930</td>
    <td class="codeLine">  if (ExistingResult && !ExistingResult->getResult().isDirty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">930</td>
    <td class="codeLine">  if (ExistingResult && !ExistingResult->getResult().isDirty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">931</td>
    <td class="codeLine">    ++NumCacheNonLocalPtr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">931</td>
    <td class="codeLine">    ++NumCacheNonLocalPtr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">932</td>
    <td class="codeLine">    return ExistingResult->getResult();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">932</td>
    <td class="codeLine">    return ExistingResult->getResult();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">933</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">933</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">934</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">934</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">935</td>
    <td class="codeLine">  // Otherwise, we have to scan for the value.  If we have a dirty cache</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">935</td>
    <td class="codeLine">  // Otherwise, we have to scan for the value.  If we have a dirty cache</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">936</td>
    <td class="codeLine">  // entry, start scanning from its position, otherwise we scan from the end</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">936</td>
    <td class="codeLine">  // entry, start scanning from its position, otherwise we scan from the end</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">937</td>
    <td class="codeLine">  // of the block.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">937</td>
    <td class="codeLine">  // of the block.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">938</td>
    <td class="codeLine">  BasicBlock::iterator ScanPos = BB->end();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">938</td>
    <td class="codeLine">  BasicBlock::iterator ScanPos = BB->end();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">939</td>
    <td class="codeLine">  if (ExistingResult && ExistingResult->getResult().getInst()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">939</td>
    <td class="codeLine">  if (ExistingResult && ExistingResult->getResult().getInst()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">940</td>
    <td class="codeLine">    assert(ExistingResult->getResult().getInst()->getParent() == BB &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">940</td>
    <td class="codeLine">    assert(ExistingResult->getResult().getInst()->getParent() == BB &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">941</td>
    <td class="codeLine">           "Instruction invalidated?");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">941</td>
    <td class="codeLine">           "Instruction invalidated?");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">942</td>
    <td class="codeLine">    ++NumCacheDirtyNonLocalPtr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">942</td>
    <td class="codeLine">    ++NumCacheDirtyNonLocalPtr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">943</td>
    <td class="codeLine">    ScanPos = ExistingResult->getResult().getInst()->getIterator();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">943</td>
    <td class="codeLine">    ScanPos = ExistingResult->getResult().getInst()->getIterator();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">944</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">944</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">945</td>
    <td class="codeLine">    // Eliminating the dirty entry from 'Cache', so update the reverse info.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">945</td>
    <td class="codeLine">    // Eliminating the dirty entry from 'Cache', so update the reverse info.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">946</td>
    <td class="codeLine">    ValueIsLoadPair CacheKey(Loc.Ptr, isLoad);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">946</td>
    <td class="codeLine">    ValueIsLoadPair CacheKey(Loc.Ptr, isLoad);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">947</td>
    <td class="codeLine">    RemoveFromReverseMap(ReverseNonLocalPtrDeps, &*ScanPos, CacheKey);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">947</td>
    <td class="codeLine">    RemoveFromReverseMap(ReverseNonLocalPtrDeps, &*ScanPos, CacheKey);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">948</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">948</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">949</td>
    <td class="codeLine">    ++NumUncacheNonLocalPtr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">949</td>
    <td class="codeLine">    ++NumUncacheNonLocalPtr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">950</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">950</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">951</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">951</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">952</td>
    <td class="codeLine">  // Scan the block for the dependency.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">952</td>
    <td class="codeLine">  // Scan the block for the dependency.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">953</td>
    <td class="codeLine">  MemDepResult Dep = getPointerDependencyFrom(Loc, isLoad, ScanPos, BB,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">953</td>
    <td class="codeLine">  MemDepResult Dep = getPointerDependencyFrom(Loc, isLoad, ScanPos, BB,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">954</td>
    <td class="codeLine">                                              QueryInst, nullptr, BatchAA);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">954</td>
    <td class="codeLine">                                              QueryInst, nullptr, BatchAA);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">955</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">955</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">956</td>
    <td class="codeLine">  // Don't cache results for invariant load.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">956</td>
    <td class="codeLine">  // Don't cache results for invariant load.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">957</td>
    <td class="codeLine">  if (isInvariantLoad)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">957</td>
    <td class="codeLine">  if (isInvariantLoad)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">958</td>
    <td class="codeLine">    return Dep;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">958</td>
    <td class="codeLine">    return Dep;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">959</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">959</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">960</td>
    <td class="codeLine">  // If we had a dirty entry for the block, update it.  Otherwise, just add</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">960</td>
    <td class="codeLine">  // If we had a dirty entry for the block, update it.  Otherwise, just add</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">961</td>
    <td class="codeLine">  // a new entry.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">961</td>
    <td class="codeLine">  // a new entry.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">962</td>
    <td class="codeLine">  if (ExistingResult)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">962</td>
    <td class="codeLine">  if (ExistingResult)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">963</td>
    <td class="codeLine">    ExistingResult->setResult(Dep);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">963</td>
    <td class="codeLine">    ExistingResult->setResult(Dep);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">964</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">964</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">965</td>
    <td class="codeLine">    Cache->push_back(NonLocalDepEntry(BB, Dep));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">965</td>
    <td class="codeLine">    Cache->push_back(NonLocalDepEntry(BB, Dep));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">966</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">966</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">967</td>
    <td class="codeLine">  // If the block has a dependency (i.e. it isn't completely transparent to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">967</td>
    <td class="codeLine">  // If the block has a dependency (i.e. it isn't completely transparent to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">968</td>
    <td class="codeLine">  // the value), remember the reverse association because we just added it</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">968</td>
    <td class="codeLine">  // the value), remember the reverse association because we just added it</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">969</td>
    <td class="codeLine">  // to Cache!</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">969</td>
    <td class="codeLine">  // to Cache!</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">970</td>
    <td class="codeLine">  if (!Dep.isLocal())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">970</td>
    <td class="codeLine">  if (!Dep.isLocal())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">971</td>
    <td class="codeLine">    return Dep;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">971</td>
    <td class="codeLine">    return Dep;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">972</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">972</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">973</td>
    <td class="codeLine">  // Keep the ReverseNonLocalPtrDeps map up to date so we can efficiently</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">973</td>
    <td class="codeLine">  // Keep the ReverseNonLocalPtrDeps map up to date so we can efficiently</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">974</td>
    <td class="codeLine">  // update MemDep when we remove instructions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">974</td>
    <td class="codeLine">  // update MemDep when we remove instructions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">975</td>
    <td class="codeLine">  Instruction *Inst = Dep.getInst();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">975</td>
    <td class="codeLine">  Instruction *Inst = Dep.getInst();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">976</td>
    <td class="codeLine">  assert(Inst && "Didn't depend on anything?");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">976</td>
    <td class="codeLine">  assert(Inst && "Didn't depend on anything?");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">977</td>
    <td class="codeLine">  ValueIsLoadPair CacheKey(Loc.Ptr, isLoad);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">977</td>
    <td class="codeLine">  ValueIsLoadPair CacheKey(Loc.Ptr, isLoad);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">978</td>
    <td class="codeLine">  ReverseNonLocalPtrDeps[Inst].insert(CacheKey);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">978</td>
    <td class="codeLine">  ReverseNonLocalPtrDeps[Inst].insert(CacheKey);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">979</td>
    <td class="codeLine">  return Dep;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">979</td>
    <td class="codeLine">  return Dep;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">980</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">980</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">981</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">981</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">982</td>
    <td class="codeLine">/// Sort the NonLocalDepInfo cache, given a certain number of elements in the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">982</td>
    <td class="codeLine">/// Sort the NonLocalDepInfo cache, given a certain number of elements in the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">983</td>
    <td class="codeLine">/// array that are already properly ordered.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">983</td>
    <td class="codeLine">/// array that are already properly ordered.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">984</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">984</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">985</td>
    <td class="codeLine">/// This is optimized for the case when only a few entries are added.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">985</td>
    <td class="codeLine">/// This is optimized for the case when only a few entries are added.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">986</td>
    <td class="codeLine">static void</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">986</td>
    <td class="codeLine">static void</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">987</td>
    <td class="codeLine">SortNonLocalDepInfoCache(MemoryDependenceResults::NonLocalDepInfo &Cache,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">987</td>
    <td class="codeLine">SortNonLocalDepInfoCache(MemoryDependenceResults::NonLocalDepInfo &Cache,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">988</td>
    <td class="codeLine">                         unsigned NumSortedEntries) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">988</td>
    <td class="codeLine">                         unsigned NumSortedEntries) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">989</td>
    <td class="codeLine">  switch (Cache.size() - NumSortedEntries) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">989</td>
    <td class="codeLine">  switch (Cache.size() - NumSortedEntries) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">990</td>
    <td class="codeLine">  case 0:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">990</td>
    <td class="codeLine">  case 0:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">991</td>
    <td class="codeLine">    // done, no new entries.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">991</td>
    <td class="codeLine">    // done, no new entries.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">992</td>
    <td class="codeLine">    break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">992</td>
    <td class="codeLine">    break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">993</td>
    <td class="codeLine">  case 2: {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">993</td>
    <td class="codeLine">  case 2: {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">994</td>
    <td class="codeLine">    // Two new entries, insert the last one into place.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">994</td>
    <td class="codeLine">    // Two new entries, insert the last one into place.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">995</td>
    <td class="codeLine">    NonLocalDepEntry Val = Cache.back();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">995</td>
    <td class="codeLine">    NonLocalDepEntry Val = Cache.back();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">996</td>
    <td class="codeLine">    Cache.pop_back();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">996</td>
    <td class="codeLine">    Cache.pop_back();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">997</td>
    <td class="codeLine">    MemoryDependenceResults::NonLocalDepInfo::iterator Entry =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">997</td>
    <td class="codeLine">    MemoryDependenceResults::NonLocalDepInfo::iterator Entry =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">998</td>
    <td class="codeLine">        std::upper_bound(Cache.begin(), Cache.end() - 1, Val);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">998</td>
    <td class="codeLine">        std::upper_bound(Cache.begin(), Cache.end() - 1, Val);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">999</td>
    <td class="codeLine">    Cache.insert(Entry, Val);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">999</td>
    <td class="codeLine">    Cache.insert(Entry, Val);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1000</td>
    <td class="codeLine">    [[fallthrough]];</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1000</td>
    <td class="codeLine">    [[fallthrough]];</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1001</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1001</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1002</td>
    <td class="codeLine">  case 1:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1002</td>
    <td class="codeLine">  case 1:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1003</td>
    <td class="codeLine">    // One new entry, Just insert the new value at the appropriate position.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1003</td>
    <td class="codeLine">    // One new entry, Just insert the new value at the appropriate position.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1004</td>
    <td class="codeLine">    if (Cache.size() != 1) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1004</td>
    <td class="codeLine">    if (Cache.size() != 1) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1005</td>
    <td class="codeLine">      NonLocalDepEntry Val = Cache.back();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1005</td>
    <td class="codeLine">      NonLocalDepEntry Val = Cache.back();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1006</td>
    <td class="codeLine">      Cache.pop_back();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1006</td>
    <td class="codeLine">      Cache.pop_back();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1007</td>
    <td class="codeLine">      MemoryDependenceResults::NonLocalDepInfo::iterator Entry =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1007</td>
    <td class="codeLine">      MemoryDependenceResults::NonLocalDepInfo::iterator Entry =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1008</td>
    <td class="codeLine">          llvm::upper_bound(Cache, Val);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1008</td>
    <td class="codeLine">          llvm::upper_bound(Cache, Val);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1009</td>
    <td class="codeLine">      Cache.insert(Entry, Val);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1009</td>
    <td class="codeLine">      Cache.insert(Entry, Val);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1010</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1010</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1011</td>
    <td class="codeLine">    break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1011</td>
    <td class="codeLine">    break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1012</td>
    <td class="codeLine">  default:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1012</td>
    <td class="codeLine">  default:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1013</td>
    <td class="codeLine">    // Added many values, do a full scale sort.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1013</td>
    <td class="codeLine">    // Added many values, do a full scale sort.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1014</td>
    <td class="codeLine">    llvm::sort(Cache);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1014</td>
    <td class="codeLine">    llvm::sort(Cache);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1015</td>
    <td class="codeLine">    break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1015</td>
    <td class="codeLine">    break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1016</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1016</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1017</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1017</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1018</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1018</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1019</td>
    <td class="codeLine">/// Perform a dependency query based on pointer/pointeesize starting at the end</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1019</td>
    <td class="codeLine">/// Perform a dependency query based on pointer/pointeesize starting at the end</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1020</td>
    <td class="codeLine">/// of StartBB.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1020</td>
    <td class="codeLine">/// of StartBB.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1021</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1021</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1022</td>
    <td class="codeLine">/// Add any clobber/def results to the results vector and keep track of which</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1022</td>
    <td class="codeLine">/// Add any clobber/def results to the results vector and keep track of which</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1023</td>
    <td class="codeLine">/// blocks are visited in 'Visited'.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1023</td>
    <td class="codeLine">/// blocks are visited in 'Visited'.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1024</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1024</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1025</td>
    <td class="codeLine">/// This has special behavior for the first block queries (when SkipFirstBlock</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1025</td>
    <td class="codeLine">/// This has special behavior for the first block queries (when SkipFirstBlock</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1026</td>
    <td class="codeLine">/// is true).  In this special case, it ignores the contents of the specified</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1026</td>
    <td class="codeLine">/// is true).  In this special case, it ignores the contents of the specified</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1027</td>
    <td class="codeLine">/// block and starts returning dependence info for its predecessors.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1027</td>
    <td class="codeLine">/// block and starts returning dependence info for its predecessors.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1028</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1028</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1029</td>
    <td class="codeLine">/// This function returns true on success, or false to indicate that it could</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1029</td>
    <td class="codeLine">/// This function returns true on success, or false to indicate that it could</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1030</td>
    <td class="codeLine">/// not compute dependence information for some reason.  This should be treated</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1030</td>
    <td class="codeLine">/// not compute dependence information for some reason.  This should be treated</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1031</td>
    <td class="codeLine">/// as a clobber dependence on the first instruction in the predecessor block.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1031</td>
    <td class="codeLine">/// as a clobber dependence on the first instruction in the predecessor block.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1032</td>
    <td class="codeLine">bool MemoryDependenceResults::getNonLocalPointerDepFromBB(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1032</td>
    <td class="codeLine">bool MemoryDependenceResults::getNonLocalPointerDepFromBB(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1033</td>
    <td class="codeLine">    Instruction *QueryInst, const PHITransAddr &Pointer,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1033</td>
    <td class="codeLine">    Instruction *QueryInst, const PHITransAddr &Pointer,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1034</td>
    <td class="codeLine">    const MemoryLocation &Loc, bool isLoad, BasicBlock *StartBB,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1034</td>
    <td class="codeLine">    const MemoryLocation &Loc, bool isLoad, BasicBlock *StartBB,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1035</td>
    <td class="codeLine">    SmallVectorImpl<NonLocalDepResult> &Result,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1035</td>
    <td class="codeLine">    SmallVectorImpl<NonLocalDepResult> &Result,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1036</td>
    <td class="codeLine">    DenseMap<BasicBlock *, Value *> &Visited, bool SkipFirstBlock,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1036</td>
    <td class="codeLine">    DenseMap<BasicBlock *, Value *> &Visited, bool SkipFirstBlock,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1037</td>
    <td class="codeLine">    bool IsIncomplete) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1037</td>
    <td class="codeLine">    bool IsIncomplete) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1038</td>
    <td class="codeLine">  // Look up the cached info for Pointer.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1038</td>
    <td class="codeLine">  // Look up the cached info for Pointer.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1039</td>
    <td class="codeLine">  ValueIsLoadPair CacheKey(Pointer.getAddr(), isLoad);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1039</td>
    <td class="codeLine">  ValueIsLoadPair CacheKey(Pointer.getAddr(), isLoad);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1040</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1040</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1041</td>
    <td class="codeLine">  // Set up a temporary NLPI value. If the map doesn't yet have an entry for</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1041</td>
    <td class="codeLine">  // Set up a temporary NLPI value. If the map doesn't yet have an entry for</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1042</td>
    <td class="codeLine">  // CacheKey, this value will be inserted as the associated value. Otherwise,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1042</td>
    <td class="codeLine">  // CacheKey, this value will be inserted as the associated value. Otherwise,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1043</td>
    <td class="codeLine">  // it'll be ignored, and we'll have to check to see if the cached size and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1043</td>
    <td class="codeLine">  // it'll be ignored, and we'll have to check to see if the cached size and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1044</td>
    <td class="codeLine">  // aa tags are consistent with the current query.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1044</td>
    <td class="codeLine">  // aa tags are consistent with the current query.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1045</td>
    <td class="codeLine">  NonLocalPointerInfo InitialNLPI;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1045</td>
    <td class="codeLine">  NonLocalPointerInfo InitialNLPI;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1046</td>
    <td class="codeLine">  InitialNLPI.Size = Loc.Size;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1046</td>
    <td class="codeLine">  InitialNLPI.Size = Loc.Size;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1047</td>
    <td class="codeLine">  InitialNLPI.AATags = Loc.AATags;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1047</td>
    <td class="codeLine">  InitialNLPI.AATags = Loc.AATags;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1048</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1048</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1049</td>
    <td class="codeLine">  bool isInvariantLoad = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1049</td>
    <td class="codeLine">  bool isInvariantLoad = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1050</td>
    <td class="codeLine">  if (LoadInst *LI = dyn_cast_or_null<LoadInst>(QueryInst))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1050</td>
    <td class="codeLine">  if (LoadInst *LI = dyn_cast_or_null<LoadInst>(QueryInst))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1051</td>
    <td class="codeLine">    isInvariantLoad = LI->getMetadata(LLVMContext::MD_invariant_load);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1051</td>
    <td class="codeLine">    isInvariantLoad = LI->getMetadata(LLVMContext::MD_invariant_load);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1052</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1052</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1053</td>
    <td class="codeLine">  // Get the NLPI for CacheKey, inserting one into the map if it doesn't</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1053</td>
    <td class="codeLine">  // Get the NLPI for CacheKey, inserting one into the map if it doesn't</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1054</td>
    <td class="codeLine">  // already have one.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1054</td>
    <td class="codeLine">  // already have one.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1055</td>
    <td class="codeLine">  std::pair<CachedNonLocalPointerInfo::iterator, bool> Pair =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1055</td>
    <td class="codeLine">  std::pair<CachedNonLocalPointerInfo::iterator, bool> Pair =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1056</td>
    <td class="codeLine">      NonLocalPointerDeps.insert(std::make_pair(CacheKey, InitialNLPI));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1056</td>
    <td class="codeLine">      NonLocalPointerDeps.insert(std::make_pair(CacheKey, InitialNLPI));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1057</td>
    <td class="codeLine">  NonLocalPointerInfo *CacheInfo = &Pair.first->second;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1057</td>
    <td class="codeLine">  NonLocalPointerInfo *CacheInfo = &Pair.first->second;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1058</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1058</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1059</td>
    <td class="codeLine">  // If we already have a cache entry for this CacheKey, we may need to do some</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1059</td>
    <td class="codeLine">  // If we already have a cache entry for this CacheKey, we may need to do some</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1060</td>
    <td class="codeLine">  // work to reconcile the cache entry and the current query.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1060</td>
    <td class="codeLine">  // work to reconcile the cache entry and the current query.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1061</td>
    <td class="codeLine">  // Invariant loads don't participate in caching. Thus no need to reconcile.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1061</td>
    <td class="codeLine">  // Invariant loads don't participate in caching. Thus no need to reconcile.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1062</td>
    <td class="codeLine">  if (!isInvariantLoad && !Pair.second) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1062</td>
    <td class="codeLine">  if (!isInvariantLoad && !Pair.second) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1063</td>
    <td class="codeLine">    if (CacheInfo->Size != Loc.Size) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1063</td>
    <td class="codeLine">    if (CacheInfo->Size != Loc.Size) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1064</td>
    <td class="codeLine">      bool ThrowOutEverything;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1064</td>
    <td class="codeLine">      bool ThrowOutEverything;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1065</td>
    <td class="codeLine">      if (CacheInfo->Size.hasValue() && Loc.Size.hasValue()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1065</td>
    <td class="codeLine">      if (CacheInfo->Size.hasValue() && Loc.Size.hasValue()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1066</td>
    <td class="codeLine">        // FIXME: We may be able to do better in the face of results with mixed</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1066</td>
    <td class="codeLine">        // FIXME: We may be able to do better in the face of results with mixed</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1067</td>
    <td class="codeLine">        // precision. We don't appear to get them in practice, though, so just</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1067</td>
    <td class="codeLine">        // precision. We don't appear to get them in practice, though, so just</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1068</td>
    <td class="codeLine">        // be conservative.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1068</td>
    <td class="codeLine">        // be conservative.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1069</td>
    <td class="codeLine">        ThrowOutEverything =</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1069</td>
    <td class="codeLine">        ThrowOutEverything =</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1070</td>
    <td class="codeLine">            CacheInfo->Size.isPrecise() != Loc.Size.isPrecise() ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1070</td>
    <td class="codeLine">            CacheInfo->Size.isPrecise() != Loc.Size.isPrecise() ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1071</td>
    <td class="codeLine">            CacheInfo->Size.getValue() < Loc.Size.getValue();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1071</td>
    <td class="codeLine">            CacheInfo->Size.getValue() < Loc.Size.getValue();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1072</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1072</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1073</td>
    <td class="codeLine">        // For our purposes, unknown size > all others.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1073</td>
    <td class="codeLine">        // For our purposes, unknown size > all others.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1074</td>
    <td class="codeLine">        ThrowOutEverything = !Loc.Size.hasValue();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1074</td>
    <td class="codeLine">        ThrowOutEverything = !Loc.Size.hasValue();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1075</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1075</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1076</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1076</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1077</td>
    <td class="codeLine">      if (ThrowOutEverything) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1077</td>
    <td class="codeLine">      if (ThrowOutEverything) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1078</td>
    <td class="codeLine">        // The query's Size is greater than the cached one. Throw out the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1078</td>
    <td class="codeLine">        // The query's Size is greater than the cached one. Throw out the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1079</td>
    <td class="codeLine">        // cached data and proceed with the query at the greater size.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1079</td>
    <td class="codeLine">        // cached data and proceed with the query at the greater size.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1080</td>
    <td class="codeLine">        CacheInfo->Pair = BBSkipFirstBlockPair();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1080</td>
    <td class="codeLine">        CacheInfo->Pair = BBSkipFirstBlockPair();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1081</td>
    <td class="codeLine">        CacheInfo->Size = Loc.Size;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1081</td>
    <td class="codeLine">        CacheInfo->Size = Loc.Size;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1082</td>
    <td class="codeLine">        for (auto &Entry : CacheInfo->NonLocalDeps)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1082</td>
    <td class="codeLine">        for (auto &Entry : CacheInfo->NonLocalDeps)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1083</td>
    <td class="codeLine">          if (Instruction *Inst = Entry.getResult().getInst())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1083</td>
    <td class="codeLine">          if (Instruction *Inst = Entry.getResult().getInst())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1084</td>
    <td class="codeLine">            RemoveFromReverseMap(ReverseNonLocalPtrDeps, Inst, CacheKey);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1084</td>
    <td class="codeLine">            RemoveFromReverseMap(ReverseNonLocalPtrDeps, Inst, CacheKey);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1085</td>
    <td class="codeLine">        CacheInfo->NonLocalDeps.clear();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1085</td>
    <td class="codeLine">        CacheInfo->NonLocalDeps.clear();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1086</td>
    <td class="codeLine">        // The cache is cleared (in the above line) so we will have lost</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1086</td>
    <td class="codeLine">        // The cache is cleared (in the above line) so we will have lost</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1087</td>
    <td class="codeLine">        // information about blocks we have already visited. We therefore must</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1087</td>
    <td class="codeLine">        // information about blocks we have already visited. We therefore must</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1088</td>
    <td class="codeLine">        // assume that the cache information is incomplete.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1088</td>
    <td class="codeLine">        // assume that the cache information is incomplete.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1089</td>
    <td class="codeLine">        IsIncomplete = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1089</td>
    <td class="codeLine">        IsIncomplete = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1090</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1090</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1091</td>
    <td class="codeLine">        // This query's Size is less than the cached one. Conservatively restart</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1091</td>
    <td class="codeLine">        // This query's Size is less than the cached one. Conservatively restart</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1092</td>
    <td class="codeLine">        // the query using the greater size.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1092</td>
    <td class="codeLine">        // the query using the greater size.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1093</td>
    <td class="codeLine">        return getNonLocalPointerDepFromBB(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1093</td>
    <td class="codeLine">        return getNonLocalPointerDepFromBB(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1094</td>
    <td class="codeLine">            QueryInst, Pointer, Loc.getWithNewSize(CacheInfo->Size), isLoad,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1094</td>
    <td class="codeLine">            QueryInst, Pointer, Loc.getWithNewSize(CacheInfo->Size), isLoad,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1095</td>
    <td class="codeLine">            StartBB, Result, Visited, SkipFirstBlock, IsIncomplete);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1095</td>
    <td class="codeLine">            StartBB, Result, Visited, SkipFirstBlock, IsIncomplete);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1096</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1096</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1097</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1097</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1098</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1098</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1099</td>
    <td class="codeLine">    // If the query's AATags are inconsistent with the cached one,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1099</td>
    <td class="codeLine">    // If the query's AATags are inconsistent with the cached one,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1100</td>
    <td class="codeLine">    // conservatively throw out the cached data and restart the query with</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1100</td>
    <td class="codeLine">    // conservatively throw out the cached data and restart the query with</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1101</td>
    <td class="codeLine">    // no tag if needed.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1101</td>
    <td class="codeLine">    // no tag if needed.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1102</td>
    <td class="codeLine">    if (CacheInfo->AATags != Loc.AATags) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1102</td>
    <td class="codeLine">    if (CacheInfo->AATags != Loc.AATags) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1103</td>
    <td class="codeLine">      if (CacheInfo->AATags) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1103</td>
    <td class="codeLine">      if (CacheInfo->AATags) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1104</td>
    <td class="codeLine">        CacheInfo->Pair = BBSkipFirstBlockPair();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1104</td>
    <td class="codeLine">        CacheInfo->Pair = BBSkipFirstBlockPair();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1105</td>
    <td class="codeLine">        CacheInfo->AATags = AAMDNodes();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1105</td>
    <td class="codeLine">        CacheInfo->AATags = AAMDNodes();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1106</td>
    <td class="codeLine">        for (auto &Entry : CacheInfo->NonLocalDeps)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1106</td>
    <td class="codeLine">        for (auto &Entry : CacheInfo->NonLocalDeps)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1107</td>
    <td class="codeLine">          if (Instruction *Inst = Entry.getResult().getInst())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1107</td>
    <td class="codeLine">          if (Instruction *Inst = Entry.getResult().getInst())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1108</td>
    <td class="codeLine">            RemoveFromReverseMap(ReverseNonLocalPtrDeps, Inst, CacheKey);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1108</td>
    <td class="codeLine">            RemoveFromReverseMap(ReverseNonLocalPtrDeps, Inst, CacheKey);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1109</td>
    <td class="codeLine">        CacheInfo->NonLocalDeps.clear();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1109</td>
    <td class="codeLine">        CacheInfo->NonLocalDeps.clear();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1110</td>
    <td class="codeLine">        // The cache is cleared (in the above line) so we will have lost</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1110</td>
    <td class="codeLine">        // The cache is cleared (in the above line) so we will have lost</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1111</td>
    <td class="codeLine">        // information about blocks we have already visited. We therefore must</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1111</td>
    <td class="codeLine">        // information about blocks we have already visited. We therefore must</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1112</td>
    <td class="codeLine">        // assume that the cache information is incomplete.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1112</td>
    <td class="codeLine">        // assume that the cache information is incomplete.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1113</td>
    <td class="codeLine">        IsIncomplete = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1113</td>
    <td class="codeLine">        IsIncomplete = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1114</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1114</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1115</td>
    <td class="codeLine">      if (Loc.AATags)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1115</td>
    <td class="codeLine">      if (Loc.AATags)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1116</td>
    <td class="codeLine">        return getNonLocalPointerDepFromBB(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1116</td>
    <td class="codeLine">        return getNonLocalPointerDepFromBB(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1117</td>
    <td class="codeLine">            QueryInst, Pointer, Loc.getWithoutAATags(), isLoad, StartBB, Result,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1117</td>
    <td class="codeLine">            QueryInst, Pointer, Loc.getWithoutAATags(), isLoad, StartBB, Result,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1118</td>
    <td class="codeLine">            Visited, SkipFirstBlock, IsIncomplete);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1118</td>
    <td class="codeLine">            Visited, SkipFirstBlock, IsIncomplete);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1119</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1119</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1120</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1120</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1121</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1121</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1122</td>
    <td class="codeLine">  NonLocalDepInfo *Cache = &CacheInfo->NonLocalDeps;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1122</td>
    <td class="codeLine">  NonLocalDepInfo *Cache = &CacheInfo->NonLocalDeps;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1123</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1123</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1124</td>
    <td class="codeLine">  // If we have valid cached information for exactly the block we are</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1124</td>
    <td class="codeLine">  // If we have valid cached information for exactly the block we are</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1125</td>
    <td class="codeLine">  // investigating, just return it with no recomputation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1125</td>
    <td class="codeLine">  // investigating, just return it with no recomputation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1126</td>
    <td class="codeLine">  // Don't use cached information for invariant loads since it is valid for</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1126</td>
    <td class="codeLine">  // Don't use cached information for invariant loads since it is valid for</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1127</td>
    <td class="codeLine">  // non-invariant loads only.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1127</td>
    <td class="codeLine">  // non-invariant loads only.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1128</td>
    <td class="codeLine">  if (!IsIncomplete && !isInvariantLoad &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1128</td>
    <td class="codeLine">  if (!IsIncomplete && !isInvariantLoad &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1129</td>
    <td class="codeLine">      CacheInfo->Pair == BBSkipFirstBlockPair(StartBB, SkipFirstBlock)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1129</td>
    <td class="codeLine">      CacheInfo->Pair == BBSkipFirstBlockPair(StartBB, SkipFirstBlock)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1130</td>
    <td class="codeLine">    // We have a fully cached result for this query then we can just return the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1130</td>
    <td class="codeLine">    // We have a fully cached result for this query then we can just return the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1131</td>
    <td class="codeLine">    // cached results and populate the visited set.  However, we have to verify</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1131</td>
    <td class="codeLine">    // cached results and populate the visited set.  However, we have to verify</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1132</td>
    <td class="codeLine">    // that we don't already have conflicting results for these blocks.  Check</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1132</td>
    <td class="codeLine">    // that we don't already have conflicting results for these blocks.  Check</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1133</td>
    <td class="codeLine">    // to ensure that if a block in the results set is in the visited set that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1133</td>
    <td class="codeLine">    // to ensure that if a block in the results set is in the visited set that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1134</td>
    <td class="codeLine">    // it was for the same pointer query.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1134</td>
    <td class="codeLine">    // it was for the same pointer query.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1135</td>
    <td class="codeLine">    if (!Visited.empty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1135</td>
    <td class="codeLine">    if (!Visited.empty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1136</td>
    <td class="codeLine">      for (auto &Entry : *Cache) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1136</td>
    <td class="codeLine">      for (auto &Entry : *Cache) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1137</td>
    <td class="codeLine">        DenseMap<BasicBlock *, Value *>::iterator VI =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1137</td>
    <td class="codeLine">        DenseMap<BasicBlock *, Value *>::iterator VI =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1138</td>
    <td class="codeLine">            Visited.find(Entry.getBB());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1138</td>
    <td class="codeLine">            Visited.find(Entry.getBB());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1139</td>
    <td class="codeLine">        if (VI == Visited.end() || VI->second == Pointer.getAddr())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1139</td>
    <td class="codeLine">        if (VI == Visited.end() || VI->second == Pointer.getAddr())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1140</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1140</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1141</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1141</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1142</td>
    <td class="codeLine">        // We have a pointer mismatch in a block.  Just return false, saying</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1142</td>
    <td class="codeLine">        // We have a pointer mismatch in a block.  Just return false, saying</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1143</td>
    <td class="codeLine">        // that something was clobbered in this result.  We could also do a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1143</td>
    <td class="codeLine">        // that something was clobbered in this result.  We could also do a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1144</td>
    <td class="codeLine">        // non-fully cached query, but there is little point in doing this.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1144</td>
    <td class="codeLine">        // non-fully cached query, but there is little point in doing this.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1145</td>
    <td class="codeLine">        return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1145</td>
    <td class="codeLine">        return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1146</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1146</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1147</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1147</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1148</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1148</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1149</td>
    <td class="codeLine">    Value *Addr = Pointer.getAddr();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1149</td>
    <td class="codeLine">    Value *Addr = Pointer.getAddr();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1150</td>
    <td class="codeLine">    for (auto &Entry : *Cache) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1150</td>
    <td class="codeLine">    for (auto &Entry : *Cache) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1151</td>
    <td class="codeLine">      Visited.insert(std::make_pair(Entry.getBB(), Addr));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1151</td>
    <td class="codeLine">      Visited.insert(std::make_pair(Entry.getBB(), Addr));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1152</td>
    <td class="codeLine">      if (Entry.getResult().isNonLocal()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1152</td>
    <td class="codeLine">      if (Entry.getResult().isNonLocal()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1153</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1153</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1154</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1154</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1155</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1155</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1156</td>
    <td class="codeLine">      if (DT.isReachableFromEntry(Entry.getBB())) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1156</td>
    <td class="codeLine">      if (DT.isReachableFromEntry(Entry.getBB())) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1157</td>
    <td class="codeLine">        Result.push_back(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1157</td>
    <td class="codeLine">        Result.push_back(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1158</td>
    <td class="codeLine">            NonLocalDepResult(Entry.getBB(), Entry.getResult(), Addr));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1158</td>
    <td class="codeLine">            NonLocalDepResult(Entry.getBB(), Entry.getResult(), Addr));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1159</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1159</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1160</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1160</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1161</td>
    <td class="codeLine">    ++NumCacheCompleteNonLocalPtr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1161</td>
    <td class="codeLine">    ++NumCacheCompleteNonLocalPtr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1162</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1162</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1163</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1163</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1164</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1164</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1165</td>
    <td class="codeLine">  // Otherwise, either this is a new block, a block with an invalid cache</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1165</td>
    <td class="codeLine">  // Otherwise, either this is a new block, a block with an invalid cache</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1166</td>
    <td class="codeLine">  // pointer or one that we're about to invalidate by putting more info into</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1166</td>
    <td class="codeLine">  // pointer or one that we're about to invalidate by putting more info into</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1167</td>
    <td class="codeLine">  // it than its valid cache info.  If empty and not explicitly indicated as</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1167</td>
    <td class="codeLine">  // it than its valid cache info.  If empty and not explicitly indicated as</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1168</td>
    <td class="codeLine">  // incomplete, the result will be valid cache info, otherwise it isn't.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1168</td>
    <td class="codeLine">  // incomplete, the result will be valid cache info, otherwise it isn't.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1169</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1169</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1170</td>
    <td class="codeLine">  // Invariant loads don't affect cache in any way thus no need to update</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1170</td>
    <td class="codeLine">  // Invariant loads don't affect cache in any way thus no need to update</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1171</td>
    <td class="codeLine">  // CacheInfo as well.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1171</td>
    <td class="codeLine">  // CacheInfo as well.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1172</td>
    <td class="codeLine">  if (!isInvariantLoad) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1172</td>
    <td class="codeLine">  if (!isInvariantLoad) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1173</td>
    <td class="codeLine">    if (!IsIncomplete && Cache->empty())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1173</td>
    <td class="codeLine">    if (!IsIncomplete && Cache->empty())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1174</td>
    <td class="codeLine">      CacheInfo->Pair = BBSkipFirstBlockPair(StartBB, SkipFirstBlock);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1174</td>
    <td class="codeLine">      CacheInfo->Pair = BBSkipFirstBlockPair(StartBB, SkipFirstBlock);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1175</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1175</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1176</td>
    <td class="codeLine">      CacheInfo->Pair = BBSkipFirstBlockPair();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1176</td>
    <td class="codeLine">      CacheInfo->Pair = BBSkipFirstBlockPair();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1177</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1177</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1178</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1178</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1179</td>
    <td class="codeLine">  SmallVector<BasicBlock *, 32> Worklist;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1179</td>
    <td class="codeLine">  SmallVector<BasicBlock *, 32> Worklist;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1180</td>
    <td class="codeLine">  Worklist.push_back(StartBB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1180</td>
    <td class="codeLine">  Worklist.push_back(StartBB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1181</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1181</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1182</td>
    <td class="codeLine">  // PredList used inside loop.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1182</td>
    <td class="codeLine">  // PredList used inside loop.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1183</td>
    <td class="codeLine">  SmallVector<std::pair<BasicBlock *, PHITransAddr>, 16> PredList;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1183</td>
    <td class="codeLine">  SmallVector<std::pair<BasicBlock *, PHITransAddr>, 16> PredList;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1184</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1184</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1185</td>
    <td class="codeLine">  // Keep track of the entries that we know are sorted.  Previously cached</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1185</td>
    <td class="codeLine">  // Keep track of the entries that we know are sorted.  Previously cached</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1186</td>
    <td class="codeLine">  // entries will all be sorted.  The entries we add we only sort on demand (we</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1186</td>
    <td class="codeLine">  // entries will all be sorted.  The entries we add we only sort on demand (we</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1187</td>
    <td class="codeLine">  // don't insert every element into its sorted position).  We know that we</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1187</td>
    <td class="codeLine">  // don't insert every element into its sorted position).  We know that we</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1188</td>
    <td class="codeLine">  // won't get any reuse from currently inserted values, because we don't</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1188</td>
    <td class="codeLine">  // won't get any reuse from currently inserted values, because we don't</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1189</td>
    <td class="codeLine">  // revisit blocks after we insert info for them.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1189</td>
    <td class="codeLine">  // revisit blocks after we insert info for them.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1190</td>
    <td class="codeLine">  unsigned NumSortedEntries = Cache->size();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1190</td>
    <td class="codeLine">  unsigned NumSortedEntries = Cache->size();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1191</td>
    <td class="codeLine">  unsigned WorklistEntries = BlockNumberLimit;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1191</td>
    <td class="codeLine">  unsigned WorklistEntries = BlockNumberLimit;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1192</td>
    <td class="codeLine">  bool GotWorklistLimit = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1192</td>
    <td class="codeLine">  bool GotWorklistLimit = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1193</td>
    <td class="codeLine">  LLVM_DEBUG(AssertSorted(*Cache));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1193</td>
    <td class="codeLine">  LLVM_DEBUG(AssertSorted(*Cache));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1194</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1194</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1195</td>
    <td class="codeLine">  BatchAAResults BatchAA(AA);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1195</td>
    <td class="codeLine">  BatchAAResults BatchAA(AA);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1196</td>
    <td class="codeLine">  while (!Worklist.empty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1196</td>
    <td class="codeLine">  while (!Worklist.empty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1197</td>
    <td class="codeLine">    BasicBlock *BB = Worklist.pop_back_val();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1197</td>
    <td class="codeLine">    BasicBlock *BB = Worklist.pop_back_val();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1198</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1198</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1199</td>
    <td class="codeLine">    // If we do process a large number of blocks it becomes very expensive and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1199</td>
    <td class="codeLine">    // If we do process a large number of blocks it becomes very expensive and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1200</td>
    <td class="codeLine">    // likely it isn't worth worrying about</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1200</td>
    <td class="codeLine">    // likely it isn't worth worrying about</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1201</td>
    <td class="codeLine">    if (Result.size() > NumResultsLimit) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1201</td>
    <td class="codeLine">    if (Result.size() > NumResultsLimit) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1202</td>
    <td class="codeLine">      // Sort it now (if needed) so that recursive invocations of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1202</td>
    <td class="codeLine">      // Sort it now (if needed) so that recursive invocations of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1203</td>
    <td class="codeLine">      // getNonLocalPointerDepFromBB and other routines that could reuse the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1203</td>
    <td class="codeLine">      // getNonLocalPointerDepFromBB and other routines that could reuse the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1204</td>
    <td class="codeLine">      // cache value will only see properly sorted cache arrays.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1204</td>
    <td class="codeLine">      // cache value will only see properly sorted cache arrays.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1205</td>
    <td class="codeLine">      if (Cache && NumSortedEntries != Cache->size()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1205</td>
    <td class="codeLine">      if (Cache && NumSortedEntries != Cache->size()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1206</td>
    <td class="codeLine">        SortNonLocalDepInfoCache(*Cache, NumSortedEntries);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1206</td>
    <td class="codeLine">        SortNonLocalDepInfoCache(*Cache, NumSortedEntries);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1207</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1207</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1208</td>
    <td class="codeLine">      // Since we bail out, the "Cache" set won't contain all of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1208</td>
    <td class="codeLine">      // Since we bail out, the "Cache" set won't contain all of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1209</td>
    <td class="codeLine">      // results for the query.  This is ok (we can still use it to accelerate</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1209</td>
    <td class="codeLine">      // results for the query.  This is ok (we can still use it to accelerate</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1210</td>
    <td class="codeLine">      // specific block queries) but we can't do the fastpath "return all</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1210</td>
    <td class="codeLine">      // specific block queries) but we can't do the fastpath "return all</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1211</td>
    <td class="codeLine">      // results from the set".  Clear out the indicator for this.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1211</td>
    <td class="codeLine">      // results from the set".  Clear out the indicator for this.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1212</td>
    <td class="codeLine">      CacheInfo->Pair = BBSkipFirstBlockPair();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1212</td>
    <td class="codeLine">      CacheInfo->Pair = BBSkipFirstBlockPair();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1213</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1213</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1214</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1214</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1215</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1215</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1216</td>
    <td class="codeLine">    // Skip the first block if we have it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1216</td>
    <td class="codeLine">    // Skip the first block if we have it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1217</td>
    <td class="codeLine">    if (!SkipFirstBlock) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1217</td>
    <td class="codeLine">    if (!SkipFirstBlock) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1218</td>
    <td class="codeLine">      // Analyze the dependency of *Pointer in FromBB.  See if we already have</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1218</td>
    <td class="codeLine">      // Analyze the dependency of *Pointer in FromBB.  See if we already have</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1219</td>
    <td class="codeLine">      // been here.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1219</td>
    <td class="codeLine">      // been here.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1220</td>
    <td class="codeLine">      assert(Visited.count(BB) && "Should check 'visited' before adding to WL");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1220</td>
    <td class="codeLine">      assert(Visited.count(BB) && "Should check 'visited' before adding to WL");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1221</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1221</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1222</td>
    <td class="codeLine">      // Get the dependency info for Pointer in BB.  If we have cached</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1222</td>
    <td class="codeLine">      // Get the dependency info for Pointer in BB.  If we have cached</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1223</td>
    <td class="codeLine">      // information, we will use it, otherwise we compute it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1223</td>
    <td class="codeLine">      // information, we will use it, otherwise we compute it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1224</td>
    <td class="codeLine">      LLVM_DEBUG(AssertSorted(*Cache, NumSortedEntries));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1224</td>
    <td class="codeLine">      LLVM_DEBUG(AssertSorted(*Cache, NumSortedEntries));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1225</td>
    <td class="codeLine">      MemDepResult Dep = getNonLocalInfoForBlock(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1225</td>
    <td class="codeLine">      MemDepResult Dep = getNonLocalInfoForBlock(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1226</td>
    <td class="codeLine">          QueryInst, Loc, isLoad, BB, Cache, NumSortedEntries, BatchAA);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1226</td>
    <td class="codeLine">          QueryInst, Loc, isLoad, BB, Cache, NumSortedEntries, BatchAA);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1227</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1227</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1228</td>
    <td class="codeLine">      // If we got a Def or Clobber, add this to the list of results.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1228</td>
    <td class="codeLine">      // If we got a Def or Clobber, add this to the list of results.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1229</td>
    <td class="codeLine">      if (!Dep.isNonLocal()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1229</td>
    <td class="codeLine">      if (!Dep.isNonLocal()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1230</td>
    <td class="codeLine">        if (DT.isReachableFromEntry(BB)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1230</td>
    <td class="codeLine">        if (DT.isReachableFromEntry(BB)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1231</td>
    <td class="codeLine">          Result.push_back(NonLocalDepResult(BB, Dep, Pointer.getAddr()));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1231</td>
    <td class="codeLine">          Result.push_back(NonLocalDepResult(BB, Dep, Pointer.getAddr()));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1232</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1232</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1233</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1233</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1234</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1234</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1235</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1235</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1236</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1236</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1237</td>
    <td class="codeLine">    // If 'Pointer' is an instruction defined in this block, then we need to do</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1237</td>
    <td class="codeLine">    // If 'Pointer' is an instruction defined in this block, then we need to do</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1238</td>
    <td class="codeLine">    // phi translation to change it into a value live in the predecessor block.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1238</td>
    <td class="codeLine">    // phi translation to change it into a value live in the predecessor block.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1239</td>
    <td class="codeLine">    // If not, we just add the predecessors to the worklist and scan them with</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1239</td>
    <td class="codeLine">    // If not, we just add the predecessors to the worklist and scan them with</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1240</td>
    <td class="codeLine">    // the same Pointer.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1240</td>
    <td class="codeLine">    // the same Pointer.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1241</td>
    <td class="codeLine">    if (!Pointer.needsPHITranslationFromBlock(BB)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1241</td>
    <td class="codeLine">    if (!Pointer.needsPHITranslationFromBlock(BB)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1242</td>
    <td class="codeLine">      SkipFirstBlock = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1242</td>
    <td class="codeLine">      SkipFirstBlock = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1243</td>
    <td class="codeLine">      SmallVector<BasicBlock *, 16> NewBlocks;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1243</td>
    <td class="codeLine">      SmallVector<BasicBlock *, 16> NewBlocks;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1244</td>
    <td class="codeLine">      for (BasicBlock *Pred : PredCache.get(BB)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1244</td>
    <td class="codeLine">      for (BasicBlock *Pred : PredCache.get(BB)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1245</td>
    <td class="codeLine">        // Verify that we haven't looked at this block yet.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1245</td>
    <td class="codeLine">        // Verify that we haven't looked at this block yet.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1246</td>
    <td class="codeLine">        std::pair<DenseMap<BasicBlock *, Value *>::iterator, bool> InsertRes =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1246</td>
    <td class="codeLine">        std::pair<DenseMap<BasicBlock *, Value *>::iterator, bool> InsertRes =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1247</td>
    <td class="codeLine">            Visited.insert(std::make_pair(Pred, Pointer.getAddr()));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1247</td>
    <td class="codeLine">            Visited.insert(std::make_pair(Pred, Pointer.getAddr()));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1248</td>
    <td class="codeLine">        if (InsertRes.second) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1248</td>
    <td class="codeLine">        if (InsertRes.second) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1249</td>
    <td class="codeLine">          // First time we've looked at *PI.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1249</td>
    <td class="codeLine">          // First time we've looked at *PI.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1250</td>
    <td class="codeLine">          NewBlocks.push_back(Pred);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1250</td>
    <td class="codeLine">          NewBlocks.push_back(Pred);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1251</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1251</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1252</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1252</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1253</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1253</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1254</td>
    <td class="codeLine">        // If we have seen this block before, but it was with a different</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1254</td>
    <td class="codeLine">        // If we have seen this block before, but it was with a different</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1255</td>
    <td class="codeLine">        // pointer then we have a phi translation failure and we have to treat</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1255</td>
    <td class="codeLine">        // pointer then we have a phi translation failure and we have to treat</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1256</td>
    <td class="codeLine">        // this as a clobber.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1256</td>
    <td class="codeLine">        // this as a clobber.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1257</td>
    <td class="codeLine">        if (InsertRes.first->second != Pointer.getAddr()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1257</td>
    <td class="codeLine">        if (InsertRes.first->second != Pointer.getAddr()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1258</td>
    <td class="codeLine">          // Make sure to clean up the Visited map before continuing on to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1258</td>
    <td class="codeLine">          // Make sure to clean up the Visited map before continuing on to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1259</td>
    <td class="codeLine">          // PredTranslationFailure.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1259</td>
    <td class="codeLine">          // PredTranslationFailure.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1260</td>
    <td class="codeLine">          for (unsigned i = 0; i < NewBlocks.size(); i++)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1260</td>
    <td class="codeLine">          for (unsigned i = 0; i < NewBlocks.size(); i++)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1261</td>
    <td class="codeLine">            Visited.erase(NewBlocks[i]);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1261</td>
    <td class="codeLine">            Visited.erase(NewBlocks[i]);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1262</td>
    <td class="codeLine">          goto PredTranslationFailure;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1262</td>
    <td class="codeLine">          goto PredTranslationFailure;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1263</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1263</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1264</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1264</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1265</td>
    <td class="codeLine">      if (NewBlocks.size() > WorklistEntries) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1265</td>
    <td class="codeLine">      if (NewBlocks.size() > WorklistEntries) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1266</td>
    <td class="codeLine">        // Make sure to clean up the Visited map before continuing on to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1266</td>
    <td class="codeLine">        // Make sure to clean up the Visited map before continuing on to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1267</td>
    <td class="codeLine">        // PredTranslationFailure.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1267</td>
    <td class="codeLine">        // PredTranslationFailure.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1268</td>
    <td class="codeLine">        for (unsigned i = 0; i < NewBlocks.size(); i++)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1268</td>
    <td class="codeLine">        for (unsigned i = 0; i < NewBlocks.size(); i++)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1269</td>
    <td class="codeLine">          Visited.erase(NewBlocks[i]);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1269</td>
    <td class="codeLine">          Visited.erase(NewBlocks[i]);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1270</td>
    <td class="codeLine">        GotWorklistLimit = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1270</td>
    <td class="codeLine">        GotWorklistLimit = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1271</td>
    <td class="codeLine">        goto PredTranslationFailure;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1271</td>
    <td class="codeLine">        goto PredTranslationFailure;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1272</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1272</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1273</td>
    <td class="codeLine">      WorklistEntries -= NewBlocks.size();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1273</td>
    <td class="codeLine">      WorklistEntries -= NewBlocks.size();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1274</td>
    <td class="codeLine">      Worklist.append(NewBlocks.begin(), NewBlocks.end());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1274</td>
    <td class="codeLine">      Worklist.append(NewBlocks.begin(), NewBlocks.end());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1275</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1275</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1276</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1276</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1277</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1277</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1278</td>
    <td class="codeLine">    // We do need to do phi translation, if we know ahead of time we can't phi</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1278</td>
    <td class="codeLine">    // We do need to do phi translation, if we know ahead of time we can't phi</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1279</td>
    <td class="codeLine">    // translate this value, don't even try.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1279</td>
    <td class="codeLine">    // translate this value, don't even try.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1280</td>
    <td class="codeLine">    if (!Pointer.isPotentiallyPHITranslatable())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1280</td>
    <td class="codeLine">    if (!Pointer.isPotentiallyPHITranslatable())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1281</td>
    <td class="codeLine">      goto PredTranslationFailure;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1281</td>
    <td class="codeLine">      goto PredTranslationFailure;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1282</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1282</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1283</td>
    <td class="codeLine">    // We may have added values to the cache list before this PHI translation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1283</td>
    <td class="codeLine">    // We may have added values to the cache list before this PHI translation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1284</td>
    <td class="codeLine">    // If so, we haven't done anything to ensure that the cache remains sorted.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1284</td>
    <td class="codeLine">    // If so, we haven't done anything to ensure that the cache remains sorted.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1285</td>
    <td class="codeLine">    // Sort it now (if needed) so that recursive invocations of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1285</td>
    <td class="codeLine">    // Sort it now (if needed) so that recursive invocations of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1286</td>
    <td class="codeLine">    // getNonLocalPointerDepFromBB and other routines that could reuse the cache</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1286</td>
    <td class="codeLine">    // getNonLocalPointerDepFromBB and other routines that could reuse the cache</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1287</td>
    <td class="codeLine">    // value will only see properly sorted cache arrays.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1287</td>
    <td class="codeLine">    // value will only see properly sorted cache arrays.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1288</td>
    <td class="codeLine">    if (Cache && NumSortedEntries != Cache->size()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1288</td>
    <td class="codeLine">    if (Cache && NumSortedEntries != Cache->size()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1289</td>
    <td class="codeLine">      SortNonLocalDepInfoCache(*Cache, NumSortedEntries);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1289</td>
    <td class="codeLine">      SortNonLocalDepInfoCache(*Cache, NumSortedEntries);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1290</td>
    <td class="codeLine">      NumSortedEntries = Cache->size();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1290</td>
    <td class="codeLine">      NumSortedEntries = Cache->size();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1291</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1291</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1292</td>
    <td class="codeLine">    Cache = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1292</td>
    <td class="codeLine">    Cache = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1293</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1293</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1294</td>
    <td class="codeLine">    PredList.clear();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1294</td>
    <td class="codeLine">    PredList.clear();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1295</td>
    <td class="codeLine">    for (BasicBlock *Pred : PredCache.get(BB)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1295</td>
    <td class="codeLine">    for (BasicBlock *Pred : PredCache.get(BB)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1296</td>
    <td class="codeLine">      PredList.push_back(std::make_pair(Pred, Pointer));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1296</td>
    <td class="codeLine">      PredList.push_back(std::make_pair(Pred, Pointer));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1297</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1297</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1298</td>
    <td class="codeLine">      // Get the PHI translated pointer in this predecessor.  This can fail if</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1298</td>
    <td class="codeLine">      // Get the PHI translated pointer in this predecessor.  This can fail if</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1299</td>
    <td class="codeLine">      // not translatable, in which case the getAddr() returns null.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1299</td>
    <td class="codeLine">      // not translatable, in which case the getAddr() returns null.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1300</td>
    <td class="codeLine">      PHITransAddr &PredPointer = PredList.back().second;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1300</td>
    <td class="codeLine">      PHITransAddr &PredPointer = PredList.back().second;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1301</td>
    <td class="codeLine">      Value *PredPtrVal =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1301</td>
    <td class="codeLine">      Value *PredPtrVal =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1302</td>
    <td class="codeLine">          PredPointer.translateValue(BB, Pred, &DT, /*MustDominate=*/false);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1302</td>
    <td class="codeLine">          PredPointer.translateValue(BB, Pred, &DT, /*MustDominate=*/false);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1303</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1303</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1304</td>
    <td class="codeLine">      // Check to see if we have already visited this pred block with another</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1304</td>
    <td class="codeLine">      // Check to see if we have already visited this pred block with another</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1305</td>
    <td class="codeLine">      // pointer.  If so, we can't do this lookup.  This failure can occur</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1305</td>
    <td class="codeLine">      // pointer.  If so, we can't do this lookup.  This failure can occur</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1306</td>
    <td class="codeLine">      // with PHI translation when a critical edge exists and the PHI node in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1306</td>
    <td class="codeLine">      // with PHI translation when a critical edge exists and the PHI node in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1307</td>
    <td class="codeLine">      // the successor translates to a pointer value different than the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1307</td>
    <td class="codeLine">      // the successor translates to a pointer value different than the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1308</td>
    <td class="codeLine">      // pointer the block was first analyzed with.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1308</td>
    <td class="codeLine">      // pointer the block was first analyzed with.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1309</td>
    <td class="codeLine">      std::pair<DenseMap<BasicBlock *, Value *>::iterator, bool> InsertRes =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1309</td>
    <td class="codeLine">      std::pair<DenseMap<BasicBlock *, Value *>::iterator, bool> InsertRes =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1310</td>
    <td class="codeLine">          Visited.insert(std::make_pair(Pred, PredPtrVal));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1310</td>
    <td class="codeLine">          Visited.insert(std::make_pair(Pred, PredPtrVal));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1311</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1311</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1312</td>
    <td class="codeLine">      if (!InsertRes.second) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1312</td>
    <td class="codeLine">      if (!InsertRes.second) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1313</td>
    <td class="codeLine">        // We found the pred; take it off the list of preds to visit.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1313</td>
    <td class="codeLine">        // We found the pred; take it off the list of preds to visit.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1314</td>
    <td class="codeLine">        PredList.pop_back();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1314</td>
    <td class="codeLine">        PredList.pop_back();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1315</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1315</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1316</td>
    <td class="codeLine">        // If the predecessor was visited with PredPtr, then we already did</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1316</td>
    <td class="codeLine">        // If the predecessor was visited with PredPtr, then we already did</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1317</td>
    <td class="codeLine">        // the analysis and can ignore it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1317</td>
    <td class="codeLine">        // the analysis and can ignore it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1318</td>
    <td class="codeLine">        if (InsertRes.first->second == PredPtrVal)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1318</td>
    <td class="codeLine">        if (InsertRes.first->second == PredPtrVal)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1319</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1319</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1320</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1320</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1321</td>
    <td class="codeLine">        // Otherwise, the block was previously analyzed with a different</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1321</td>
    <td class="codeLine">        // Otherwise, the block was previously analyzed with a different</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1322</td>
    <td class="codeLine">        // pointer.  We can't represent the result of this case, so we just</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1322</td>
    <td class="codeLine">        // pointer.  We can't represent the result of this case, so we just</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1323</td>
    <td class="codeLine">        // treat this as a phi translation failure.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1323</td>
    <td class="codeLine">        // treat this as a phi translation failure.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1324</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1324</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1325</td>
    <td class="codeLine">        // Make sure to clean up the Visited map before continuing on to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1325</td>
    <td class="codeLine">        // Make sure to clean up the Visited map before continuing on to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1326</td>
    <td class="codeLine">        // PredTranslationFailure.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1326</td>
    <td class="codeLine">        // PredTranslationFailure.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1327</td>
    <td class="codeLine">        for (unsigned i = 0, n = PredList.size(); i < n; ++i)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1327</td>
    <td class="codeLine">        for (unsigned i = 0, n = PredList.size(); i < n; ++i)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1328</td>
    <td class="codeLine">          Visited.erase(PredList[i].first);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1328</td>
    <td class="codeLine">          Visited.erase(PredList[i].first);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1329</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1329</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1330</td>
    <td class="codeLine">        goto PredTranslationFailure;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1330</td>
    <td class="codeLine">        goto PredTranslationFailure;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1331</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1331</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1332</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1332</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1333</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1333</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1334</td>
    <td class="codeLine">    // Actually process results here; this need to be a separate loop to avoid</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1334</td>
    <td class="codeLine">    // Actually process results here; this need to be a separate loop to avoid</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1335</td>
    <td class="codeLine">    // calling getNonLocalPointerDepFromBB for blocks we don't want to return</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1335</td>
    <td class="codeLine">    // calling getNonLocalPointerDepFromBB for blocks we don't want to return</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1336</td>
    <td class="codeLine">    // any results for.  (getNonLocalPointerDepFromBB will modify our</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1336</td>
    <td class="codeLine">    // any results for.  (getNonLocalPointerDepFromBB will modify our</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1337</td>
    <td class="codeLine">    // datastructures in ways the code after the PredTranslationFailure label</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1337</td>
    <td class="codeLine">    // datastructures in ways the code after the PredTranslationFailure label</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1338</td>
    <td class="codeLine">    // doesn't expect.)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1338</td>
    <td class="codeLine">    // doesn't expect.)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1339</td>
    <td class="codeLine">    for (unsigned i = 0, n = PredList.size(); i < n; ++i) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1339</td>
    <td class="codeLine">    for (unsigned i = 0, n = PredList.size(); i < n; ++i) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1340</td>
    <td class="codeLine">      BasicBlock *Pred = PredList[i].first;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1340</td>
    <td class="codeLine">      BasicBlock *Pred = PredList[i].first;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1341</td>
    <td class="codeLine">      PHITransAddr &PredPointer = PredList[i].second;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1341</td>
    <td class="codeLine">      PHITransAddr &PredPointer = PredList[i].second;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1342</td>
    <td class="codeLine">      Value *PredPtrVal = PredPointer.getAddr();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1342</td>
    <td class="codeLine">      Value *PredPtrVal = PredPointer.getAddr();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1343</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1343</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1344</td>
    <td class="codeLine">      bool CanTranslate = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1344</td>
    <td class="codeLine">      bool CanTranslate = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1345</td>
    <td class="codeLine">      // If PHI translation was unable to find an available pointer in this</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1345</td>
    <td class="codeLine">      // If PHI translation was unable to find an available pointer in this</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1346</td>
    <td class="codeLine">      // predecessor, then we have to assume that the pointer is clobbered in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1346</td>
    <td class="codeLine">      // predecessor, then we have to assume that the pointer is clobbered in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1347</td>
    <td class="codeLine">      // that predecessor.  We can still do PRE of the load, which would insert</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1347</td>
    <td class="codeLine">      // that predecessor.  We can still do PRE of the load, which would insert</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1348</td>
    <td class="codeLine">      // a computation of the pointer in this predecessor.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1348</td>
    <td class="codeLine">      // a computation of the pointer in this predecessor.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1349</td>
    <td class="codeLine">      if (!PredPtrVal)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1349</td>
    <td class="codeLine">      if (!PredPtrVal)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1350</td>
    <td class="codeLine">        CanTranslate = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1350</td>
    <td class="codeLine">        CanTranslate = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1351</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1351</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1352</td>
    <td class="codeLine">      // FIXME: it is entirely possible that PHI translating will end up with</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1352</td>
    <td class="codeLine">      // FIXME: it is entirely possible that PHI translating will end up with</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1353</td>
    <td class="codeLine">      // the same value.  Consider PHI translating something like:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1353</td>
    <td class="codeLine">      // the same value.  Consider PHI translating something like:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1354</td>
    <td class="codeLine">      // X = phi [x, bb1], [y, bb2].  PHI translating for bb1 doesn't *need*</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1354</td>
    <td class="codeLine">      // X = phi [x, bb1], [y, bb2].  PHI translating for bb1 doesn't *need*</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1355</td>
    <td class="codeLine">      // to recurse here, pedantically speaking.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1355</td>
    <td class="codeLine">      // to recurse here, pedantically speaking.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1356</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1356</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1357</td>
    <td class="codeLine">      // If getNonLocalPointerDepFromBB fails here, that means the cached</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1357</td>
    <td class="codeLine">      // If getNonLocalPointerDepFromBB fails here, that means the cached</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1358</td>
    <td class="codeLine">      // result conflicted with the Visited list; we have to conservatively</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1358</td>
    <td class="codeLine">      // result conflicted with the Visited list; we have to conservatively</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1359</td>
    <td class="codeLine">      // assume it is unknown, but this also does not block PRE of the load.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1359</td>
    <td class="codeLine">      // assume it is unknown, but this also does not block PRE of the load.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1360</td>
    <td class="codeLine">      if (!CanTranslate ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1360</td>
    <td class="codeLine">      if (!CanTranslate ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1361</td>
    <td class="codeLine">          !getNonLocalPointerDepFromBB(QueryInst, PredPointer,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1361</td>
    <td class="codeLine">          !getNonLocalPointerDepFromBB(QueryInst, PredPointer,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1362</td>
    <td class="codeLine">                                      Loc.getWithNewPtr(PredPtrVal), isLoad,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1362</td>
    <td class="codeLine">                                      Loc.getWithNewPtr(PredPtrVal), isLoad,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1363</td>
    <td class="codeLine">                                      Pred, Result, Visited)) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1363</td>
    <td class="codeLine">                                      Pred, Result, Visited)) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1364</td>
    <td class="codeLine">        // Add the entry to the Result list.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1364</td>
    <td class="codeLine">        // Add the entry to the Result list.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1365</td>
    <td class="codeLine">        NonLocalDepResult Entry(Pred, MemDepResult::getUnknown(), PredPtrVal);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1365</td>
    <td class="codeLine">        NonLocalDepResult Entry(Pred, MemDepResult::getUnknown(), PredPtrVal);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1366</td>
    <td class="codeLine">        Result.push_back(Entry);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1366</td>
    <td class="codeLine">        Result.push_back(Entry);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1367</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1367</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1368</td>
    <td class="codeLine">        // Since we had a phi translation failure, the cache for CacheKey won't</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1368</td>
    <td class="codeLine">        // Since we had a phi translation failure, the cache for CacheKey won't</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1369</td>
    <td class="codeLine">        // include all of the entries that we need to immediately satisfy future</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1369</td>
    <td class="codeLine">        // include all of the entries that we need to immediately satisfy future</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1370</td>
    <td class="codeLine">        // queries.  Mark this in NonLocalPointerDeps by setting the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1370</td>
    <td class="codeLine">        // queries.  Mark this in NonLocalPointerDeps by setting the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1371</td>
    <td class="codeLine">        // BBSkipFirstBlockPair pointer to null.  This requires reuse of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1371</td>
    <td class="codeLine">        // BBSkipFirstBlockPair pointer to null.  This requires reuse of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1372</td>
    <td class="codeLine">        // cached value to do more work but not miss the phi trans failure.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1372</td>
    <td class="codeLine">        // cached value to do more work but not miss the phi trans failure.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1373</td>
    <td class="codeLine">        NonLocalPointerInfo &NLPI = NonLocalPointerDeps[CacheKey];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1373</td>
    <td class="codeLine">        NonLocalPointerInfo &NLPI = NonLocalPointerDeps[CacheKey];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1374</td>
    <td class="codeLine">        NLPI.Pair = BBSkipFirstBlockPair();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1374</td>
    <td class="codeLine">        NLPI.Pair = BBSkipFirstBlockPair();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1375</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1375</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1376</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1376</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1377</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1377</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1378</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1378</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1379</td>
    <td class="codeLine">    // Refresh the CacheInfo/Cache pointer so that it isn't invalidated.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1379</td>
    <td class="codeLine">    // Refresh the CacheInfo/Cache pointer so that it isn't invalidated.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1380</td>
    <td class="codeLine">    CacheInfo = &NonLocalPointerDeps[CacheKey];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1380</td>
    <td class="codeLine">    CacheInfo = &NonLocalPointerDeps[CacheKey];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1381</td>
    <td class="codeLine">    Cache = &CacheInfo->NonLocalDeps;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1381</td>
    <td class="codeLine">    Cache = &CacheInfo->NonLocalDeps;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1382</td>
    <td class="codeLine">    NumSortedEntries = Cache->size();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1382</td>
    <td class="codeLine">    NumSortedEntries = Cache->size();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1383</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1383</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1384</td>
    <td class="codeLine">    // Since we did phi translation, the "Cache" set won't contain all of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1384</td>
    <td class="codeLine">    // Since we did phi translation, the "Cache" set won't contain all of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1385</td>
    <td class="codeLine">    // results for the query.  This is ok (we can still use it to accelerate</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1385</td>
    <td class="codeLine">    // results for the query.  This is ok (we can still use it to accelerate</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1386</td>
    <td class="codeLine">    // specific block queries) but we can't do the fastpath "return all</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1386</td>
    <td class="codeLine">    // specific block queries) but we can't do the fastpath "return all</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1387</td>
    <td class="codeLine">    // results from the set"  Clear out the indicator for this.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1387</td>
    <td class="codeLine">    // results from the set"  Clear out the indicator for this.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1388</td>
    <td class="codeLine">    CacheInfo->Pair = BBSkipFirstBlockPair();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1388</td>
    <td class="codeLine">    CacheInfo->Pair = BBSkipFirstBlockPair();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1389</td>
    <td class="codeLine">    SkipFirstBlock = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1389</td>
    <td class="codeLine">    SkipFirstBlock = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1390</td>
    <td class="codeLine">    continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1390</td>
    <td class="codeLine">    continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1391</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1391</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1392</td>
    <td class="codeLine">  PredTranslationFailure:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1392</td>
    <td class="codeLine">  PredTranslationFailure:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1393</td>
    <td class="codeLine">    // The following code is "failure"; we can't produce a sane translation</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1393</td>
    <td class="codeLine">    // The following code is "failure"; we can't produce a sane translation</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1394</td>
    <td class="codeLine">    // for the given block.  It assumes that we haven't modified any of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1394</td>
    <td class="codeLine">    // for the given block.  It assumes that we haven't modified any of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1395</td>
    <td class="codeLine">    // our datastructures while processing the current block.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1395</td>
    <td class="codeLine">    // our datastructures while processing the current block.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1396</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1396</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1397</td>
    <td class="codeLine">    if (!Cache) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1397</td>
    <td class="codeLine">    if (!Cache) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1398</td>
    <td class="codeLine">      // Refresh the CacheInfo/Cache pointer if it got invalidated.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1398</td>
    <td class="codeLine">      // Refresh the CacheInfo/Cache pointer if it got invalidated.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1399</td>
    <td class="codeLine">      CacheInfo = &NonLocalPointerDeps[CacheKey];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1399</td>
    <td class="codeLine">      CacheInfo = &NonLocalPointerDeps[CacheKey];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1400</td>
    <td class="codeLine">      Cache = &CacheInfo->NonLocalDeps;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1400</td>
    <td class="codeLine">      Cache = &CacheInfo->NonLocalDeps;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1401</td>
    <td class="codeLine">      NumSortedEntries = Cache->size();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1401</td>
    <td class="codeLine">      NumSortedEntries = Cache->size();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1402</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1402</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1403</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1403</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1404</td>
    <td class="codeLine">    // Since we failed phi translation, the "Cache" set won't contain all of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1404</td>
    <td class="codeLine">    // Since we failed phi translation, the "Cache" set won't contain all of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1405</td>
    <td class="codeLine">    // results for the query.  This is ok (we can still use it to accelerate</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1405</td>
    <td class="codeLine">    // results for the query.  This is ok (we can still use it to accelerate</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1406</td>
    <td class="codeLine">    // specific block queries) but we can't do the fastpath "return all</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1406</td>
    <td class="codeLine">    // specific block queries) but we can't do the fastpath "return all</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1407</td>
    <td class="codeLine">    // results from the set".  Clear out the indicator for this.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1407</td>
    <td class="codeLine">    // results from the set".  Clear out the indicator for this.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1408</td>
    <td class="codeLine">    CacheInfo->Pair = BBSkipFirstBlockPair();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1408</td>
    <td class="codeLine">    CacheInfo->Pair = BBSkipFirstBlockPair();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1409</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1409</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1410</td>
    <td class="codeLine">    // If *nothing* works, mark the pointer as unknown.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1410</td>
    <td class="codeLine">    // If *nothing* works, mark the pointer as unknown.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1411</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1411</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1412</td>
    <td class="codeLine">    // If this is the magic first block, return this as a clobber of the whole</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1412</td>
    <td class="codeLine">    // If this is the magic first block, return this as a clobber of the whole</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1413</td>
    <td class="codeLine">    // incoming value.  Since we can't phi translate to one of the predecessors,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1413</td>
    <td class="codeLine">    // incoming value.  Since we can't phi translate to one of the predecessors,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1414</td>
    <td class="codeLine">    // we have to bail out.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1414</td>
    <td class="codeLine">    // we have to bail out.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1415</td>
    <td class="codeLine">    if (SkipFirstBlock)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1415</td>
    <td class="codeLine">    if (SkipFirstBlock)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1416</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1416</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1417</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1417</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1418</td>
    <td class="codeLine">    // Results of invariant loads are not cached thus no need to update cached</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1418</td>
    <td class="codeLine">    // Results of invariant loads are not cached thus no need to update cached</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1419</td>
    <td class="codeLine">    // information.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1419</td>
    <td class="codeLine">    // information.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1420</td>
    <td class="codeLine">    if (!isInvariantLoad) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1420</td>
    <td class="codeLine">    if (!isInvariantLoad) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1421</td>
    <td class="codeLine">      for (NonLocalDepEntry &I : llvm::reverse(*Cache)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1421</td>
    <td class="codeLine">      for (NonLocalDepEntry &I : llvm::reverse(*Cache)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1422</td>
    <td class="codeLine">        if (I.getBB() != BB)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1422</td>
    <td class="codeLine">        if (I.getBB() != BB)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1423</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1423</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1424</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1424</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1425</td>
    <td class="codeLine">        assert((GotWorklistLimit || I.getResult().isNonLocal() ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1425</td>
    <td class="codeLine">        assert((GotWorklistLimit || I.getResult().isNonLocal() ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1426</td>
    <td class="codeLine">                !DT.isReachableFromEntry(BB)) &&</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1426</td>
    <td class="codeLine">                !DT.isReachableFromEntry(BB)) &&</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1427</td>
    <td class="codeLine">               "Should only be here with transparent block");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1427</td>
    <td class="codeLine">               "Should only be here with transparent block");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1428</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1428</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1429</td>
    <td class="codeLine">        I.setResult(MemDepResult::getUnknown());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1429</td>
    <td class="codeLine">        I.setResult(MemDepResult::getUnknown());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1430</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1430</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1431</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1431</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1432</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1432</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1433</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1433</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1434</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1434</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1435</td>
    <td class="codeLine">    (void)GotWorklistLimit;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1435</td>
    <td class="codeLine">    (void)GotWorklistLimit;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1436</td>
    <td class="codeLine">    // Go ahead and report unknown dependence.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1436</td>
    <td class="codeLine">    // Go ahead and report unknown dependence.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1437</td>
    <td class="codeLine">    Result.push_back(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1437</td>
    <td class="codeLine">    Result.push_back(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1438</td>
    <td class="codeLine">        NonLocalDepResult(BB, MemDepResult::getUnknown(), Pointer.getAddr()));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1438</td>
    <td class="codeLine">        NonLocalDepResult(BB, MemDepResult::getUnknown(), Pointer.getAddr()));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1439</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1439</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1440</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1440</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1441</td>
    <td class="codeLine">  // Okay, we're done now.  If we added new values to the cache, re-sort it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1441</td>
    <td class="codeLine">  // Okay, we're done now.  If we added new values to the cache, re-sort it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1442</td>
    <td class="codeLine">  SortNonLocalDepInfoCache(*Cache, NumSortedEntries);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1442</td>
    <td class="codeLine">  SortNonLocalDepInfoCache(*Cache, NumSortedEntries);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1443</td>
    <td class="codeLine">  LLVM_DEBUG(AssertSorted(*Cache));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1443</td>
    <td class="codeLine">  LLVM_DEBUG(AssertSorted(*Cache));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1444</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1444</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1445</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1445</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1446</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1446</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1447</td>
    <td class="codeLine">/// If P exists in CachedNonLocalPointerInfo or NonLocalDefsCache, remove it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1447</td>
    <td class="codeLine">/// If P exists in CachedNonLocalPointerInfo or NonLocalDefsCache, remove it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1448</td>
    <td class="codeLine">void MemoryDependenceResults::removeCachedNonLocalPointerDependencies(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1448</td>
    <td class="codeLine">void MemoryDependenceResults::removeCachedNonLocalPointerDependencies(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1449</td>
    <td class="codeLine">    ValueIsLoadPair P) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1449</td>
    <td class="codeLine">    ValueIsLoadPair P) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1450</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1450</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1451</td>
    <td class="codeLine">  // Most of the time this cache is empty.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1451</td>
    <td class="codeLine">  // Most of the time this cache is empty.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1452</td>
    <td class="codeLine">  if (!NonLocalDefsCache.empty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1452</td>
    <td class="codeLine">  if (!NonLocalDefsCache.empty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1453</td>
    <td class="codeLine">    auto it = NonLocalDefsCache.find(P.getPointer());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1453</td>
    <td class="codeLine">    auto it = NonLocalDefsCache.find(P.getPointer());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1454</td>
    <td class="codeLine">    if (it != NonLocalDefsCache.end()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1454</td>
    <td class="codeLine">    if (it != NonLocalDefsCache.end()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1455</td>
    <td class="codeLine">      RemoveFromReverseMap(ReverseNonLocalDefsCache,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1455</td>
    <td class="codeLine">      RemoveFromReverseMap(ReverseNonLocalDefsCache,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1456</td>
    <td class="codeLine">                           it->second.getResult().getInst(), P.getPointer());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1456</td>
    <td class="codeLine">                           it->second.getResult().getInst(), P.getPointer());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1457</td>
    <td class="codeLine">      NonLocalDefsCache.erase(it);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1457</td>
    <td class="codeLine">      NonLocalDefsCache.erase(it);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1458</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1458</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1459</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1459</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1460</td>
    <td class="codeLine">    if (auto *I = dyn_cast<Instruction>(P.getPointer())) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1460</td>
    <td class="codeLine">    if (auto *I = dyn_cast<Instruction>(P.getPointer())) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1461</td>
    <td class="codeLine">      auto toRemoveIt = ReverseNonLocalDefsCache.find(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1461</td>
    <td class="codeLine">      auto toRemoveIt = ReverseNonLocalDefsCache.find(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1462</td>
    <td class="codeLine">      if (toRemoveIt != ReverseNonLocalDefsCache.end()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1462</td>
    <td class="codeLine">      if (toRemoveIt != ReverseNonLocalDefsCache.end()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1463</td>
    <td class="codeLine">        for (const auto *entry : toRemoveIt->second)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1463</td>
    <td class="codeLine">        for (const auto *entry : toRemoveIt->second)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1464</td>
    <td class="codeLine">          NonLocalDefsCache.erase(entry);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1464</td>
    <td class="codeLine">          NonLocalDefsCache.erase(entry);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1465</td>
    <td class="codeLine">        ReverseNonLocalDefsCache.erase(toRemoveIt);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1465</td>
    <td class="codeLine">        ReverseNonLocalDefsCache.erase(toRemoveIt);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1466</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1466</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1467</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1467</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1468</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1468</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1469</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1469</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1470</td>
    <td class="codeLine">  CachedNonLocalPointerInfo::iterator It = NonLocalPointerDeps.find(P);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1470</td>
    <td class="codeLine">  CachedNonLocalPointerInfo::iterator It = NonLocalPointerDeps.find(P);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1471</td>
    <td class="codeLine">  if (It == NonLocalPointerDeps.end())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1471</td>
    <td class="codeLine">  if (It == NonLocalPointerDeps.end())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1472</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1472</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1473</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1473</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1474</td>
    <td class="codeLine">  // Remove all of the entries in the BB->val map.  This involves removing</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1474</td>
    <td class="codeLine">  // Remove all of the entries in the BB->val map.  This involves removing</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1475</td>
    <td class="codeLine">  // instructions from the reverse map.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1475</td>
    <td class="codeLine">  // instructions from the reverse map.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1476</td>
    <td class="codeLine">  NonLocalDepInfo &PInfo = It->second.NonLocalDeps;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1476</td>
    <td class="codeLine">  NonLocalDepInfo &PInfo = It->second.NonLocalDeps;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1477</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1477</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1478</td>
    <td class="codeLine">  for (const NonLocalDepEntry &DE : PInfo) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1478</td>
    <td class="codeLine">  for (const NonLocalDepEntry &DE : PInfo) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1479</td>
    <td class="codeLine">    Instruction *Target = DE.getResult().getInst();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1479</td>
    <td class="codeLine">    Instruction *Target = DE.getResult().getInst();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1480</td>
    <td class="codeLine">    if (!Target)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1480</td>
    <td class="codeLine">    if (!Target)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1481</td>
    <td class="codeLine">      continue; // Ignore non-local dep results.</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1481</td>
    <td class="codeLine">      continue; // Ignore non-local dep results.</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1482</td>
    <td class="codeLine">    assert(Target->getParent() == DE.getBB());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1482</td>
    <td class="codeLine">    assert(Target->getParent() == DE.getBB());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1483</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1483</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1484</td>
    <td class="codeLine">    // Eliminating the dirty entry from 'Cache', so update the reverse info.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1484</td>
    <td class="codeLine">    // Eliminating the dirty entry from 'Cache', so update the reverse info.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1485</td>
    <td class="codeLine">    RemoveFromReverseMap(ReverseNonLocalPtrDeps, Target, P);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1485</td>
    <td class="codeLine">    RemoveFromReverseMap(ReverseNonLocalPtrDeps, Target, P);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1486</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1486</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1487</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1487</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1488</td>
    <td class="codeLine">  // Remove P from NonLocalPointerDeps (which deletes NonLocalDepInfo).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1488</td>
    <td class="codeLine">  // Remove P from NonLocalPointerDeps (which deletes NonLocalDepInfo).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1489</td>
    <td class="codeLine">  NonLocalPointerDeps.erase(It);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1489</td>
    <td class="codeLine">  NonLocalPointerDeps.erase(It);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1490</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1490</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1491</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1491</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1492</td>
    <td class="codeLine">void MemoryDependenceResults::invalidateCachedPointerInfo(Value *Ptr) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1492</td>
    <td class="codeLine">void MemoryDependenceResults::invalidateCachedPointerInfo(Value *Ptr) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1493</td>
    <td class="codeLine">  // If Ptr isn't really a pointer, just ignore it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1493</td>
    <td class="codeLine">  // If Ptr isn't really a pointer, just ignore it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1494</td>
    <td class="codeLine">  if (!Ptr->getType()->isPointerTy())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1494</td>
    <td class="codeLine">  if (!Ptr->getType()->isPointerTy())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1495</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1495</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1496</td>
    <td class="codeLine">  // Flush store info for the pointer.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1496</td>
    <td class="codeLine">  // Flush store info for the pointer.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1497</td>
    <td class="codeLine">  removeCachedNonLocalPointerDependencies(ValueIsLoadPair(Ptr, false));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1497</td>
    <td class="codeLine">  removeCachedNonLocalPointerDependencies(ValueIsLoadPair(Ptr, false));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1498</td>
    <td class="codeLine">  // Flush load info for the pointer.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1498</td>
    <td class="codeLine">  // Flush load info for the pointer.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1499</td>
    <td class="codeLine">  removeCachedNonLocalPointerDependencies(ValueIsLoadPair(Ptr, true));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1499</td>
    <td class="codeLine">  removeCachedNonLocalPointerDependencies(ValueIsLoadPair(Ptr, true));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1500</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1500</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1501</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1501</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1502</td>
    <td class="codeLine">void MemoryDependenceResults::invalidateCachedPredecessors() {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1502</td>
    <td class="codeLine">void MemoryDependenceResults::invalidateCachedPredecessors() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1503</td>
    <td class="codeLine">  PredCache.clear();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1503</td>
    <td class="codeLine">  PredCache.clear();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1504</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1504</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1505</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1505</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1506</td>
    <td class="codeLine">void MemoryDependenceResults::removeInstruction(Instruction *RemInst) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1506</td>
    <td class="codeLine">void MemoryDependenceResults::removeInstruction(Instruction *RemInst) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1507</td>
    <td class="codeLine">  // Walk through the Non-local dependencies, removing this one as the value</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1507</td>
    <td class="codeLine">  // Walk through the Non-local dependencies, removing this one as the value</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1508</td>
    <td class="codeLine">  // for any cached queries.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1508</td>
    <td class="codeLine">  // for any cached queries.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1509</td>
    <td class="codeLine">  NonLocalDepMapType::iterator NLDI = NonLocalDepsMap.find(RemInst);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1509</td>
    <td class="codeLine">  NonLocalDepMapType::iterator NLDI = NonLocalDepsMap.find(RemInst);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1510</td>
    <td class="codeLine">  if (NLDI != NonLocalDepsMap.end()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1510</td>
    <td class="codeLine">  if (NLDI != NonLocalDepsMap.end()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1511</td>
    <td class="codeLine">    NonLocalDepInfo &BlockMap = NLDI->second.first;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1511</td>
    <td class="codeLine">    NonLocalDepInfo &BlockMap = NLDI->second.first;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1512</td>
    <td class="codeLine">    for (auto &Entry : BlockMap)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1512</td>
    <td class="codeLine">    for (auto &Entry : BlockMap)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1513</td>
    <td class="codeLine">      if (Instruction *Inst = Entry.getResult().getInst())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1513</td>
    <td class="codeLine">      if (Instruction *Inst = Entry.getResult().getInst())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1514</td>
    <td class="codeLine">        RemoveFromReverseMap(ReverseNonLocalDeps, Inst, RemInst);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1514</td>
    <td class="codeLine">        RemoveFromReverseMap(ReverseNonLocalDeps, Inst, RemInst);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1515</td>
    <td class="codeLine">    NonLocalDepsMap.erase(NLDI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1515</td>
    <td class="codeLine">    NonLocalDepsMap.erase(NLDI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1516</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1516</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1517</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1517</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1518</td>
    <td class="codeLine">  // If we have a cached local dependence query for this instruction, remove it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1518</td>
    <td class="codeLine">  // If we have a cached local dependence query for this instruction, remove it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1519</td>
    <td class="codeLine">  LocalDepMapType::iterator LocalDepEntry = LocalDeps.find(RemInst);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1519</td>
    <td class="codeLine">  LocalDepMapType::iterator LocalDepEntry = LocalDeps.find(RemInst);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1520</td>
    <td class="codeLine">  if (LocalDepEntry != LocalDeps.end()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1520</td>
    <td class="codeLine">  if (LocalDepEntry != LocalDeps.end()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1521</td>
    <td class="codeLine">    // Remove us from DepInst's reverse set now that the local dep info is gone.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1521</td>
    <td class="codeLine">    // Remove us from DepInst's reverse set now that the local dep info is gone.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1522</td>
    <td class="codeLine">    if (Instruction *Inst = LocalDepEntry->second.getInst())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1522</td>
    <td class="codeLine">    if (Instruction *Inst = LocalDepEntry->second.getInst())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1523</td>
    <td class="codeLine">      RemoveFromReverseMap(ReverseLocalDeps, Inst, RemInst);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1523</td>
    <td class="codeLine">      RemoveFromReverseMap(ReverseLocalDeps, Inst, RemInst);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1524</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1524</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1525</td>
    <td class="codeLine">    // Remove this local dependency info.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1525</td>
    <td class="codeLine">    // Remove this local dependency info.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1526</td>
    <td class="codeLine">    LocalDeps.erase(LocalDepEntry);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1526</td>
    <td class="codeLine">    LocalDeps.erase(LocalDepEntry);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1527</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1527</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1528</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1528</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1529</td>
    <td class="codeLine">  // If we have any cached dependencies on this instruction, remove</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1529</td>
    <td class="codeLine">  // If we have any cached dependencies on this instruction, remove</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1530</td>
    <td class="codeLine">  // them.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1530</td>
    <td class="codeLine">  // them.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1531</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1531</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1532</td>
    <td class="codeLine">  // If the instruction is a pointer, remove it from both the load info and the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1532</td>
    <td class="codeLine">  // If the instruction is a pointer, remove it from both the load info and the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1533</td>
    <td class="codeLine">  // store info.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1533</td>
    <td class="codeLine">  // store info.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1534</td>
    <td class="codeLine">  if (RemInst->getType()->isPointerTy()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1534</td>
    <td class="codeLine">  if (RemInst->getType()->isPointerTy()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1535</td>
    <td class="codeLine">    removeCachedNonLocalPointerDependencies(ValueIsLoadPair(RemInst, false));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1535</td>
    <td class="codeLine">    removeCachedNonLocalPointerDependencies(ValueIsLoadPair(RemInst, false));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1536</td>
    <td class="codeLine">    removeCachedNonLocalPointerDependencies(ValueIsLoadPair(RemInst, true));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1536</td>
    <td class="codeLine">    removeCachedNonLocalPointerDependencies(ValueIsLoadPair(RemInst, true));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1537</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1537</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1538</td>
    <td class="codeLine">    // Otherwise, if the instructions is in the map directly, it must be a load.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1538</td>
    <td class="codeLine">    // Otherwise, if the instructions is in the map directly, it must be a load.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1539</td>
    <td class="codeLine">    // Remove it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1539</td>
    <td class="codeLine">    // Remove it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1540</td>
    <td class="codeLine">    auto toRemoveIt = NonLocalDefsCache.find(RemInst);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1540</td>
    <td class="codeLine">    auto toRemoveIt = NonLocalDefsCache.find(RemInst);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1541</td>
    <td class="codeLine">    if (toRemoveIt != NonLocalDefsCache.end()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1541</td>
    <td class="codeLine">    if (toRemoveIt != NonLocalDefsCache.end()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1542</td>
    <td class="codeLine">      assert(isa<LoadInst>(RemInst) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1542</td>
    <td class="codeLine">      assert(isa<LoadInst>(RemInst) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1543</td>
    <td class="codeLine">             "only load instructions should be added directly");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1543</td>
    <td class="codeLine">             "only load instructions should be added directly");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1544</td>
    <td class="codeLine">      const Instruction *DepV = toRemoveIt->second.getResult().getInst();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1544</td>
    <td class="codeLine">      const Instruction *DepV = toRemoveIt->second.getResult().getInst();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1545</td>
    <td class="codeLine">      ReverseNonLocalDefsCache.find(DepV)->second.erase(RemInst);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1545</td>
    <td class="codeLine">      ReverseNonLocalDefsCache.find(DepV)->second.erase(RemInst);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1546</td>
    <td class="codeLine">      NonLocalDefsCache.erase(toRemoveIt);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1546</td>
    <td class="codeLine">      NonLocalDefsCache.erase(toRemoveIt);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1547</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1547</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1548</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1548</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1549</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1549</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1550</td>
    <td class="codeLine">  // Loop over all of the things that depend on the instruction we're removing.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1550</td>
    <td class="codeLine">  // Loop over all of the things that depend on the instruction we're removing.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1551</td>
    <td class="codeLine">  SmallVector<std::pair<Instruction *, Instruction *>, 8> ReverseDepsToAdd;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1551</td>
    <td class="codeLine">  SmallVector<std::pair<Instruction *, Instruction *>, 8> ReverseDepsToAdd;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1552</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1552</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1553</td>
    <td class="codeLine">  // If we find RemInst as a clobber or Def in any of the maps for other values,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1553</td>
    <td class="codeLine">  // If we find RemInst as a clobber or Def in any of the maps for other values,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1554</td>
    <td class="codeLine">  // we need to replace its entry with a dirty version of the instruction after</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1554</td>
    <td class="codeLine">  // we need to replace its entry with a dirty version of the instruction after</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1555</td>
    <td class="codeLine">  // it.  If RemInst is a terminator, we use a null dirty value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1555</td>
    <td class="codeLine">  // it.  If RemInst is a terminator, we use a null dirty value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1556</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1556</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1557</td>
    <td class="codeLine">  // Using a dirty version of the instruction after RemInst saves having to scan</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1557</td>
    <td class="codeLine">  // Using a dirty version of the instruction after RemInst saves having to scan</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1558</td>
    <td class="codeLine">  // the entire block to get to this point.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1558</td>
    <td class="codeLine">  // the entire block to get to this point.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1559</td>
    <td class="codeLine">  MemDepResult NewDirtyVal;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1559</td>
    <td class="codeLine">  MemDepResult NewDirtyVal;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1560</td>
    <td class="codeLine">  if (!RemInst->isTerminator())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1560</td>
    <td class="codeLine">  if (!RemInst->isTerminator())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1561</td>
    <td class="codeLine">    NewDirtyVal = MemDepResult::getDirty(&*++RemInst->getIterator());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1561</td>
    <td class="codeLine">    NewDirtyVal = MemDepResult::getDirty(&*++RemInst->getIterator());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1562</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1562</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1563</td>
    <td class="codeLine">  ReverseDepMapType::iterator ReverseDepIt = ReverseLocalDeps.find(RemInst);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1563</td>
    <td class="codeLine">  ReverseDepMapType::iterator ReverseDepIt = ReverseLocalDeps.find(RemInst);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1564</td>
    <td class="codeLine">  if (ReverseDepIt != ReverseLocalDeps.end()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1564</td>
    <td class="codeLine">  if (ReverseDepIt != ReverseLocalDeps.end()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1565</td>
    <td class="codeLine">    // RemInst can't be the terminator if it has local stuff depending on it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1565</td>
    <td class="codeLine">    // RemInst can't be the terminator if it has local stuff depending on it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1566</td>
    <td class="codeLine">    assert(!ReverseDepIt->second.empty() && !RemInst->isTerminator() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1566</td>
    <td class="codeLine">    assert(!ReverseDepIt->second.empty() && !RemInst->isTerminator() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1567</td>
    <td class="codeLine">           "Nothing can locally depend on a terminator");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1567</td>
    <td class="codeLine">           "Nothing can locally depend on a terminator");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1568</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1568</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1569</td>
    <td class="codeLine">    for (Instruction *InstDependingOnRemInst : ReverseDepIt->second) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1569</td>
    <td class="codeLine">    for (Instruction *InstDependingOnRemInst : ReverseDepIt->second) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1570</td>
    <td class="codeLine">      assert(InstDependingOnRemInst != RemInst &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1570</td>
    <td class="codeLine">      assert(InstDependingOnRemInst != RemInst &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1571</td>
    <td class="codeLine">             "Already removed our local dep info");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1571</td>
    <td class="codeLine">             "Already removed our local dep info");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1572</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1572</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1573</td>
    <td class="codeLine">      LocalDeps[InstDependingOnRemInst] = NewDirtyVal;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1573</td>
    <td class="codeLine">      LocalDeps[InstDependingOnRemInst] = NewDirtyVal;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1574</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1574</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1575</td>
    <td class="codeLine">      // Make sure to remember that new things depend on NewDepInst.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1575</td>
    <td class="codeLine">      // Make sure to remember that new things depend on NewDepInst.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1576</td>
    <td class="codeLine">      assert(NewDirtyVal.getInst() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1576</td>
    <td class="codeLine">      assert(NewDirtyVal.getInst() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1577</td>
    <td class="codeLine">             "There is no way something else can have "</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1577</td>
    <td class="codeLine">             "There is no way something else can have "</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1578</td>
    <td class="codeLine">             "a local dep on this if it is a terminator!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1578</td>
    <td class="codeLine">             "a local dep on this if it is a terminator!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1579</td>
    <td class="codeLine">      ReverseDepsToAdd.push_back(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1579</td>
    <td class="codeLine">      ReverseDepsToAdd.push_back(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1580</td>
    <td class="codeLine">          std::make_pair(NewDirtyVal.getInst(), InstDependingOnRemInst));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1580</td>
    <td class="codeLine">          std::make_pair(NewDirtyVal.getInst(), InstDependingOnRemInst));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1581</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1581</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1582</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1582</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1583</td>
    <td class="codeLine">    ReverseLocalDeps.erase(ReverseDepIt);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1583</td>
    <td class="codeLine">    ReverseLocalDeps.erase(ReverseDepIt);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1584</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1584</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1585</td>
    <td class="codeLine">    // Add new reverse deps after scanning the set, to avoid invalidating the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1585</td>
    <td class="codeLine">    // Add new reverse deps after scanning the set, to avoid invalidating the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1586</td>
    <td class="codeLine">    // 'ReverseDeps' reference.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1586</td>
    <td class="codeLine">    // 'ReverseDeps' reference.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1587</td>
    <td class="codeLine">    while (!ReverseDepsToAdd.empty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1587</td>
    <td class="codeLine">    while (!ReverseDepsToAdd.empty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1588</td>
    <td class="codeLine">      ReverseLocalDeps[ReverseDepsToAdd.back().first].insert(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1588</td>
    <td class="codeLine">      ReverseLocalDeps[ReverseDepsToAdd.back().first].insert(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1589</td>
    <td class="codeLine">          ReverseDepsToAdd.back().second);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1589</td>
    <td class="codeLine">          ReverseDepsToAdd.back().second);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1590</td>
    <td class="codeLine">      ReverseDepsToAdd.pop_back();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1590</td>
    <td class="codeLine">      ReverseDepsToAdd.pop_back();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1591</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1591</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1592</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1592</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1593</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1593</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1594</td>
    <td class="codeLine">  ReverseDepIt = ReverseNonLocalDeps.find(RemInst);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1594</td>
    <td class="codeLine">  ReverseDepIt = ReverseNonLocalDeps.find(RemInst);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1595</td>
    <td class="codeLine">  if (ReverseDepIt != ReverseNonLocalDeps.end()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1595</td>
    <td class="codeLine">  if (ReverseDepIt != ReverseNonLocalDeps.end()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1596</td>
    <td class="codeLine">    for (Instruction *I : ReverseDepIt->second) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1596</td>
    <td class="codeLine">    for (Instruction *I : ReverseDepIt->second) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1597</td>
    <td class="codeLine">      assert(I != RemInst && "Already removed NonLocalDep info for RemInst");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1597</td>
    <td class="codeLine">      assert(I != RemInst && "Already removed NonLocalDep info for RemInst");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1598</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1598</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1599</td>
    <td class="codeLine">      PerInstNLInfo &INLD = NonLocalDepsMap[I];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1599</td>
    <td class="codeLine">      PerInstNLInfo &INLD = NonLocalDepsMap[I];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1600</td>
    <td class="codeLine">      // The information is now dirty!</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1600</td>
    <td class="codeLine">      // The information is now dirty!</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1601</td>
    <td class="codeLine">      INLD.second = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1601</td>
    <td class="codeLine">      INLD.second = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1602</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1602</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1603</td>
    <td class="codeLine">      for (auto &Entry : INLD.first) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1603</td>
    <td class="codeLine">      for (auto &Entry : INLD.first) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1604</td>
    <td class="codeLine">        if (Entry.getResult().getInst() != RemInst)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1604</td>
    <td class="codeLine">        if (Entry.getResult().getInst() != RemInst)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1605</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1605</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1606</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1606</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1607</td>
    <td class="codeLine">        // Convert to a dirty entry for the subsequent instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1607</td>
    <td class="codeLine">        // Convert to a dirty entry for the subsequent instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1608</td>
    <td class="codeLine">        Entry.setResult(NewDirtyVal);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1608</td>
    <td class="codeLine">        Entry.setResult(NewDirtyVal);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1609</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1609</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1610</td>
    <td class="codeLine">        if (Instruction *NextI = NewDirtyVal.getInst())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1610</td>
    <td class="codeLine">        if (Instruction *NextI = NewDirtyVal.getInst())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1611</td>
    <td class="codeLine">          ReverseDepsToAdd.push_back(std::make_pair(NextI, I));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1611</td>
    <td class="codeLine">          ReverseDepsToAdd.push_back(std::make_pair(NextI, I));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1612</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1612</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1613</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1613</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1614</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1614</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1615</td>
    <td class="codeLine">    ReverseNonLocalDeps.erase(ReverseDepIt);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1615</td>
    <td class="codeLine">    ReverseNonLocalDeps.erase(ReverseDepIt);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1616</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1616</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1617</td>
    <td class="codeLine">    // Add new reverse deps after scanning the set, to avoid invalidating 'Set'</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1617</td>
    <td class="codeLine">    // Add new reverse deps after scanning the set, to avoid invalidating 'Set'</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1618</td>
    <td class="codeLine">    while (!ReverseDepsToAdd.empty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1618</td>
    <td class="codeLine">    while (!ReverseDepsToAdd.empty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1619</td>
    <td class="codeLine">      ReverseNonLocalDeps[ReverseDepsToAdd.back().first].insert(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1619</td>
    <td class="codeLine">      ReverseNonLocalDeps[ReverseDepsToAdd.back().first].insert(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1620</td>
    <td class="codeLine">          ReverseDepsToAdd.back().second);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1620</td>
    <td class="codeLine">          ReverseDepsToAdd.back().second);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1621</td>
    <td class="codeLine">      ReverseDepsToAdd.pop_back();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1621</td>
    <td class="codeLine">      ReverseDepsToAdd.pop_back();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1622</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1622</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1623</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1623</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1624</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1624</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1625</td>
    <td class="codeLine">  // If the instruction is in ReverseNonLocalPtrDeps then it appears as a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1625</td>
    <td class="codeLine">  // If the instruction is in ReverseNonLocalPtrDeps then it appears as a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1626</td>
    <td class="codeLine">  // value in the NonLocalPointerDeps info.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1626</td>
    <td class="codeLine">  // value in the NonLocalPointerDeps info.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1627</td>
    <td class="codeLine">  ReverseNonLocalPtrDepTy::iterator ReversePtrDepIt =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1627</td>
    <td class="codeLine">  ReverseNonLocalPtrDepTy::iterator ReversePtrDepIt =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1628</td>
    <td class="codeLine">      ReverseNonLocalPtrDeps.find(RemInst);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1628</td>
    <td class="codeLine">      ReverseNonLocalPtrDeps.find(RemInst);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1629</td>
    <td class="codeLine">  if (ReversePtrDepIt != ReverseNonLocalPtrDeps.end()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1629</td>
    <td class="codeLine">  if (ReversePtrDepIt != ReverseNonLocalPtrDeps.end()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1630</td>
    <td class="codeLine">    SmallVector<std::pair<Instruction *, ValueIsLoadPair>, 8></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1630</td>
    <td class="codeLine">    SmallVector<std::pair<Instruction *, ValueIsLoadPair>, 8></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1631</td>
    <td class="codeLine">        ReversePtrDepsToAdd;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1631</td>
    <td class="codeLine">        ReversePtrDepsToAdd;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1632</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1632</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1633</td>
    <td class="codeLine">    for (ValueIsLoadPair P : ReversePtrDepIt->second) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1633</td>
    <td class="codeLine">    for (ValueIsLoadPair P : ReversePtrDepIt->second) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1634</td>
    <td class="codeLine">      assert(P.getPointer() != RemInst &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1634</td>
    <td class="codeLine">      assert(P.getPointer() != RemInst &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1635</td>
    <td class="codeLine">             "Already removed NonLocalPointerDeps info for RemInst");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1635</td>
    <td class="codeLine">             "Already removed NonLocalPointerDeps info for RemInst");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1636</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1636</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1637</td>
    <td class="codeLine">      NonLocalDepInfo &NLPDI = NonLocalPointerDeps[P].NonLocalDeps;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1637</td>
    <td class="codeLine">      NonLocalDepInfo &NLPDI = NonLocalPointerDeps[P].NonLocalDeps;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1638</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1638</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1639</td>
    <td class="codeLine">      // The cache is not valid for any specific block anymore.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1639</td>
    <td class="codeLine">      // The cache is not valid for any specific block anymore.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1640</td>
    <td class="codeLine">      NonLocalPointerDeps[P].Pair = BBSkipFirstBlockPair();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1640</td>
    <td class="codeLine">      NonLocalPointerDeps[P].Pair = BBSkipFirstBlockPair();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1641</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1641</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1642</td>
    <td class="codeLine">      // Update any entries for RemInst to use the instruction after it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1642</td>
    <td class="codeLine">      // Update any entries for RemInst to use the instruction after it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1643</td>
    <td class="codeLine">      for (auto &Entry : NLPDI) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1643</td>
    <td class="codeLine">      for (auto &Entry : NLPDI) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1644</td>
    <td class="codeLine">        if (Entry.getResult().getInst() != RemInst)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1644</td>
    <td class="codeLine">        if (Entry.getResult().getInst() != RemInst)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1645</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1645</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1646</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1646</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1647</td>
    <td class="codeLine">        // Convert to a dirty entry for the subsequent instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1647</td>
    <td class="codeLine">        // Convert to a dirty entry for the subsequent instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1648</td>
    <td class="codeLine">        Entry.setResult(NewDirtyVal);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1648</td>
    <td class="codeLine">        Entry.setResult(NewDirtyVal);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1649</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1649</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1650</td>
    <td class="codeLine">        if (Instruction *NewDirtyInst = NewDirtyVal.getInst())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1650</td>
    <td class="codeLine">        if (Instruction *NewDirtyInst = NewDirtyVal.getInst())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1651</td>
    <td class="codeLine">          ReversePtrDepsToAdd.push_back(std::make_pair(NewDirtyInst, P));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1651</td>
    <td class="codeLine">          ReversePtrDepsToAdd.push_back(std::make_pair(NewDirtyInst, P));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1652</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1652</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1653</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1653</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1654</td>
    <td class="codeLine">      // Re-sort the NonLocalDepInfo.  Changing the dirty entry to its</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1654</td>
    <td class="codeLine">      // Re-sort the NonLocalDepInfo.  Changing the dirty entry to its</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1655</td>
    <td class="codeLine">      // subsequent value may invalidate the sortedness.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1655</td>
    <td class="codeLine">      // subsequent value may invalidate the sortedness.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1656</td>
    <td class="codeLine">      llvm::sort(NLPDI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1656</td>
    <td class="codeLine">      llvm::sort(NLPDI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1657</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1657</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1658</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1658</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1659</td>
    <td class="codeLine">    ReverseNonLocalPtrDeps.erase(ReversePtrDepIt);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1659</td>
    <td class="codeLine">    ReverseNonLocalPtrDeps.erase(ReversePtrDepIt);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1660</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1660</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1661</td>
    <td class="codeLine">    while (!ReversePtrDepsToAdd.empty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1661</td>
    <td class="codeLine">    while (!ReversePtrDepsToAdd.empty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1662</td>
    <td class="codeLine">      ReverseNonLocalPtrDeps[ReversePtrDepsToAdd.back().first].insert(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1662</td>
    <td class="codeLine">      ReverseNonLocalPtrDeps[ReversePtrDepsToAdd.back().first].insert(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1663</td>
    <td class="codeLine">          ReversePtrDepsToAdd.back().second);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1663</td>
    <td class="codeLine">          ReversePtrDepsToAdd.back().second);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1664</td>
    <td class="codeLine">      ReversePtrDepsToAdd.pop_back();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1664</td>
    <td class="codeLine">      ReversePtrDepsToAdd.pop_back();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1665</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1665</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1666</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1666</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1667</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1667</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1668</td>
    <td class="codeLine">  assert(!NonLocalDepsMap.count(RemInst) && "RemInst got reinserted?");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1668</td>
    <td class="codeLine">  assert(!NonLocalDepsMap.count(RemInst) && "RemInst got reinserted?");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1669</td>
    <td class="codeLine">  LLVM_DEBUG(verifyRemoved(RemInst));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1669</td>
    <td class="codeLine">  LLVM_DEBUG(verifyRemoved(RemInst));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1670</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1670</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1671</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1671</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1672</td>
    <td class="codeLine">/// Verify that the specified instruction does not occur in our internal data</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1672</td>
    <td class="codeLine">/// Verify that the specified instruction does not occur in our internal data</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1673</td>
    <td class="codeLine">/// structures.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1673</td>
    <td class="codeLine">/// structures.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1674</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1674</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1675</td>
    <td class="codeLine">/// This function verifies by asserting in debug builds.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1675</td>
    <td class="codeLine">/// This function verifies by asserting in debug builds.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1676</td>
    <td class="codeLine">void MemoryDependenceResults::verifyRemoved(Instruction *D) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1676</td>
    <td class="codeLine">void MemoryDependenceResults::verifyRemoved(Instruction *D) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1677</td>
    <td class="codeLine">#ifndef NDEBUG</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1677</td>
    <td class="codeLine">#ifndef NDEBUG</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1678</td>
    <td class="codeLine">  for (const auto &DepKV : LocalDeps) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1678</td>
    <td class="codeLine">  for (const auto &DepKV : LocalDeps) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1679</td>
    <td class="codeLine">    assert(DepKV.first != D && "Inst occurs in data structures");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1679</td>
    <td class="codeLine">    assert(DepKV.first != D && "Inst occurs in data structures");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1680</td>
    <td class="codeLine">    assert(DepKV.second.getInst() != D && "Inst occurs in data structures");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1680</td>
    <td class="codeLine">    assert(DepKV.second.getInst() != D && "Inst occurs in data structures");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1681</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1681</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1682</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1682</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1683</td>
    <td class="codeLine">  for (const auto &DepKV : NonLocalPointerDeps) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1683</td>
    <td class="codeLine">  for (const auto &DepKV : NonLocalPointerDeps) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1684</td>
    <td class="codeLine">    assert(DepKV.first.getPointer() != D && "Inst occurs in NLPD map key");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1684</td>
    <td class="codeLine">    assert(DepKV.first.getPointer() != D && "Inst occurs in NLPD map key");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1685</td>
    <td class="codeLine">    for (const auto &Entry : DepKV.second.NonLocalDeps)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1685</td>
    <td class="codeLine">    for (const auto &Entry : DepKV.second.NonLocalDeps)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1686</td>
    <td class="codeLine">      assert(Entry.getResult().getInst() != D && "Inst occurs as NLPD value");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1686</td>
    <td class="codeLine">      assert(Entry.getResult().getInst() != D && "Inst occurs as NLPD value");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1687</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1687</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1688</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1688</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1689</td>
    <td class="codeLine">  for (const auto &DepKV : NonLocalDepsMap) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1689</td>
    <td class="codeLine">  for (const auto &DepKV : NonLocalDepsMap) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1690</td>
    <td class="codeLine">    assert(DepKV.first != D && "Inst occurs in data structures");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1690</td>
    <td class="codeLine">    assert(DepKV.first != D && "Inst occurs in data structures");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1691</td>
    <td class="codeLine">    const PerInstNLInfo &INLD = DepKV.second;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1691</td>
    <td class="codeLine">    const PerInstNLInfo &INLD = DepKV.second;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1692</td>
    <td class="codeLine">    for (const auto &Entry : INLD.first)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1692</td>
    <td class="codeLine">    for (const auto &Entry : INLD.first)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1693</td>
    <td class="codeLine">      assert(Entry.getResult().getInst() != D &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1693</td>
    <td class="codeLine">      assert(Entry.getResult().getInst() != D &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1694</td>
    <td class="codeLine">             "Inst occurs in data structures");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1694</td>
    <td class="codeLine">             "Inst occurs in data structures");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1695</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1695</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1696</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1696</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1697</td>
    <td class="codeLine">  for (const auto &DepKV : ReverseLocalDeps) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1697</td>
    <td class="codeLine">  for (const auto &DepKV : ReverseLocalDeps) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1698</td>
    <td class="codeLine">    assert(DepKV.first != D && "Inst occurs in data structures");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1698</td>
    <td class="codeLine">    assert(DepKV.first != D && "Inst occurs in data structures");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1699</td>
    <td class="codeLine">    for (Instruction *Inst : DepKV.second)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1699</td>
    <td class="codeLine">    for (Instruction *Inst : DepKV.second)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1700</td>
    <td class="codeLine">      assert(Inst != D && "Inst occurs in data structures");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1700</td>
    <td class="codeLine">      assert(Inst != D && "Inst occurs in data structures");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1701</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1701</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1702</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1702</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1703</td>
    <td class="codeLine">  for (const auto &DepKV : ReverseNonLocalDeps) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1703</td>
    <td class="codeLine">  for (const auto &DepKV : ReverseNonLocalDeps) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1704</td>
    <td class="codeLine">    assert(DepKV.first != D && "Inst occurs in data structures");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1704</td>
    <td class="codeLine">    assert(DepKV.first != D && "Inst occurs in data structures");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1705</td>
    <td class="codeLine">    for (Instruction *Inst : DepKV.second)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1705</td>
    <td class="codeLine">    for (Instruction *Inst : DepKV.second)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1706</td>
    <td class="codeLine">      assert(Inst != D && "Inst occurs in data structures");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1706</td>
    <td class="codeLine">      assert(Inst != D && "Inst occurs in data structures");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1707</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1707</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1708</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1708</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1709</td>
    <td class="codeLine">  for (const auto &DepKV : ReverseNonLocalPtrDeps) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1709</td>
    <td class="codeLine">  for (const auto &DepKV : ReverseNonLocalPtrDeps) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1710</td>
    <td class="codeLine">    assert(DepKV.first != D && "Inst occurs in rev NLPD map");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1710</td>
    <td class="codeLine">    assert(DepKV.first != D && "Inst occurs in rev NLPD map");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1711</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1711</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1712</td>
    <td class="codeLine">    for (ValueIsLoadPair P : DepKV.second)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1712</td>
    <td class="codeLine">    for (ValueIsLoadPair P : DepKV.second)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1713</td>
    <td class="codeLine">      assert(P != ValueIsLoadPair(D, false) && P != ValueIsLoadPair(D, true) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1713</td>
    <td class="codeLine">      assert(P != ValueIsLoadPair(D, false) && P != ValueIsLoadPair(D, true) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1714</td>
    <td class="codeLine">             "Inst occurs in ReverseNonLocalPtrDeps map");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1714</td>
    <td class="codeLine">             "Inst occurs in ReverseNonLocalPtrDeps map");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1715</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1715</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1716</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1716</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1717</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1717</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1718</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1718</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1719</td>
    <td class="codeLine">AnalysisKey MemoryDependenceAnalysis::Key;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1719</td>
    <td class="codeLine">AnalysisKey MemoryDependenceAnalysis::Key;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1720</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1720</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1721</td>
    <td class="codeLine">MemoryDependenceAnalysis::MemoryDependenceAnalysis()</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1721</td>
    <td class="codeLine">MemoryDependenceAnalysis::MemoryDependenceAnalysis()</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1722</td>
    <td class="codeLine">    : DefaultBlockScanLimit(BlockScanLimit) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1722</td>
    <td class="codeLine">    : DefaultBlockScanLimit(BlockScanLimit) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1723</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1723</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1724</td>
    <td class="codeLine">MemoryDependenceResults</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1724</td>
    <td class="codeLine">MemoryDependenceResults</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1725</td>
    <td class="codeLine">MemoryDependenceAnalysis::run(Function &F, FunctionAnalysisManager &AM) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1725</td>
    <td class="codeLine">MemoryDependenceAnalysis::run(Function &F, FunctionAnalysisManager &AM) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1726</td>
    <td class="codeLine">  auto &AA = AM.getResult<AAManager>(F);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1726</td>
    <td class="codeLine">  auto &AA = AM.getResult<AAManager>(F);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1727</td>
    <td class="codeLine">  auto &AC = AM.getResult<AssumptionAnalysis>(F);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1727</td>
    <td class="codeLine">  auto &AC = AM.getResult<AssumptionAnalysis>(F);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1728</td>
    <td class="codeLine">  auto &TLI = AM.getResult<TargetLibraryAnalysis>(F);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1728</td>
    <td class="codeLine">  auto &TLI = AM.getResult<TargetLibraryAnalysis>(F);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1729</td>
    <td class="codeLine">  auto &DT = AM.getResult<DominatorTreeAnalysis>(F);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1729</td>
    <td class="codeLine">  auto &DT = AM.getResult<DominatorTreeAnalysis>(F);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1730</td>
    <td class="codeLine">  return MemoryDependenceResults(AA, AC, TLI, DT, DefaultBlockScanLimit);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1730</td>
    <td class="codeLine">  return MemoryDependenceResults(AA, AC, TLI, DT, DefaultBlockScanLimit);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1731</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1731</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1732</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1732</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1733</td>
    <td class="codeLine">char MemoryDependenceWrapperPass::ID = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1733</td>
    <td class="codeLine">char MemoryDependenceWrapperPass::ID = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1734</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1734</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1735</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_BEGIN(MemoryDependenceWrapperPass, "memdep",</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">1735</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_BEGIN(MemoryDependenceWrapperPass, "memdep",</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1736</td>
    <td class="codeLine">                      "Memory Dependence Analysis", false, true)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1736</td>
    <td class="codeLine">                      "Memory Dependence Analysis", false, true)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1737</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(AssumptionCacheTracker)</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">1737</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(AssumptionCacheTracker)</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1738</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(AAResultsWrapperPass)</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">1738</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(AAResultsWrapperPass)</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1739</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(DominatorTreeWrapperPass)</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">1739</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(DominatorTreeWrapperPass)</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1740</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(TargetLibraryInfoWrapperPass)</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">1740</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(TargetLibraryInfoWrapperPass)</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1741</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_END(MemoryDependenceWrapperPass, "memdep",</td>
    <td class="lineNumber">3</td>
    <td class="lineNumber">1741</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_END(MemoryDependenceWrapperPass, "memdep",</td>
    <td class="lineNumber">3</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1742</td>
    <td class="codeLine">                    "Memory Dependence Analysis", false, true)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1742</td>
    <td class="codeLine">                    "Memory Dependence Analysis", false, true)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1743</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1743</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1744</td>
    <td class="codeLine">MemoryDependenceWrapperPass::MemoryDependenceWrapperPass() : FunctionPass(ID) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1744</td>
    <td class="codeLine">MemoryDependenceWrapperPass::MemoryDependenceWrapperPass() : FunctionPass(ID) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1745</td>
    <td class="codeLine">  initializeMemoryDependenceWrapperPassPass(*PassRegistry::getPassRegistry());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1745</td>
    <td class="codeLine">  initializeMemoryDependenceWrapperPassPass(*PassRegistry::getPassRegistry());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1746</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1746</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1747</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1747</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1748</td>
    <td class="codeLine">MemoryDependenceWrapperPass::~MemoryDependenceWrapperPass() = default;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1748</td>
    <td class="codeLine">MemoryDependenceWrapperPass::~MemoryDependenceWrapperPass() = default;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1749</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1749</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1750</td>
    <td class="codeLine">void MemoryDependenceWrapperPass::releaseMemory() {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1750</td>
    <td class="codeLine">void MemoryDependenceWrapperPass::releaseMemory() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1751</td>
    <td class="codeLine">  MemDep.reset();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1751</td>
    <td class="codeLine">  MemDep.reset();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1752</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1752</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1753</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1753</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1754</td>
    <td class="codeLine">void MemoryDependenceWrapperPass::getAnalysisUsage(AnalysisUsage &AU) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1754</td>
    <td class="codeLine">void MemoryDependenceWrapperPass::getAnalysisUsage(AnalysisUsage &AU) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1755</td>
    <td class="codeLine">  AU.setPreservesAll();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1755</td>
    <td class="codeLine">  AU.setPreservesAll();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1756</td>
    <td class="codeLine">  AU.addRequired<AssumptionCacheTracker>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1756</td>
    <td class="codeLine">  AU.addRequired<AssumptionCacheTracker>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1757</td>
    <td class="codeLine">  AU.addRequired<DominatorTreeWrapperPass>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1757</td>
    <td class="codeLine">  AU.addRequired<DominatorTreeWrapperPass>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1758</td>
    <td class="codeLine">  AU.addRequiredTransitive<AAResultsWrapperPass>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1758</td>
    <td class="codeLine">  AU.addRequiredTransitive<AAResultsWrapperPass>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1759</td>
    <td class="codeLine">  AU.addRequiredTransitive<TargetLibraryInfoWrapperPass>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1759</td>
    <td class="codeLine">  AU.addRequiredTransitive<TargetLibraryInfoWrapperPass>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1760</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1760</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1761</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1761</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1762</td>
    <td class="codeLine">bool MemoryDependenceResults::invalidate(Function &F, const PreservedAnalyses &PA,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1762</td>
    <td class="codeLine">bool MemoryDependenceResults::invalidate(Function &F, const PreservedAnalyses &PA,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1763</td>
    <td class="codeLine">                               FunctionAnalysisManager::Invalidator &Inv) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1763</td>
    <td class="codeLine">                               FunctionAnalysisManager::Invalidator &Inv) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1764</td>
    <td class="codeLine">  // Check whether our analysis is preserved.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1764</td>
    <td class="codeLine">  // Check whether our analysis is preserved.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1765</td>
    <td class="codeLine">  auto PAC = PA.getChecker<MemoryDependenceAnalysis>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1765</td>
    <td class="codeLine">  auto PAC = PA.getChecker<MemoryDependenceAnalysis>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1766</td>
    <td class="codeLine">  if (!PAC.preserved() && !PAC.preservedSet<AllAnalysesOn<Function>>())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1766</td>
    <td class="codeLine">  if (!PAC.preserved() && !PAC.preservedSet<AllAnalysesOn<Function>>())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1767</td>
    <td class="codeLine">    // If not, give up now.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1767</td>
    <td class="codeLine">    // If not, give up now.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1768</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1768</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1769</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1769</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1770</td>
    <td class="codeLine">  // Check whether the analyses we depend on became invalid for any reason.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1770</td>
    <td class="codeLine">  // Check whether the analyses we depend on became invalid for any reason.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1771</td>
    <td class="codeLine">  if (Inv.invalidate<AAManager>(F, PA) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1771</td>
    <td class="codeLine">  if (Inv.invalidate<AAManager>(F, PA) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1772</td>
    <td class="codeLine">      Inv.invalidate<AssumptionAnalysis>(F, PA) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1772</td>
    <td class="codeLine">      Inv.invalidate<AssumptionAnalysis>(F, PA) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1773</td>
    <td class="codeLine">      Inv.invalidate<DominatorTreeAnalysis>(F, PA))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1773</td>
    <td class="codeLine">      Inv.invalidate<DominatorTreeAnalysis>(F, PA))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1774</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1774</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1775</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1775</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1776</td>
    <td class="codeLine">  // Otherwise this analysis result remains valid.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1776</td>
    <td class="codeLine">  // Otherwise this analysis result remains valid.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1777</td>
    <td class="codeLine">  return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1777</td>
    <td class="codeLine">  return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1778</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1778</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1779</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1779</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1780</td>
    <td class="codeLine">unsigned MemoryDependenceResults::getDefaultBlockScanLimit() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1780</td>
    <td class="codeLine">unsigned MemoryDependenceResults::getDefaultBlockScanLimit() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1781</td>
    <td class="codeLine">  return DefaultBlockScanLimit;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1781</td>
    <td class="codeLine">  return DefaultBlockScanLimit;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1782</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1782</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1783</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1783</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1784</td>
    <td class="codeLine">bool MemoryDependenceWrapperPass::runOnFunction(Function &F) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1784</td>
    <td class="codeLine">bool MemoryDependenceWrapperPass::runOnFunction(Function &F) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1785</td>
    <td class="codeLine">  auto &AA = getAnalysis<AAResultsWrapperPass>().getAAResults();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1785</td>
    <td class="codeLine">  auto &AA = getAnalysis<AAResultsWrapperPass>().getAAResults();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1786</td>
    <td class="codeLine">  auto &AC = getAnalysis<AssumptionCacheTracker>().getAssumptionCache(F);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1786</td>
    <td class="codeLine">  auto &AC = getAnalysis<AssumptionCacheTracker>().getAssumptionCache(F);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1787</td>
    <td class="codeLine">  auto &TLI = getAnalysis<TargetLibraryInfoWrapperPass>().getTLI(F);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1787</td>
    <td class="codeLine">  auto &TLI = getAnalysis<TargetLibraryInfoWrapperPass>().getTLI(F);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1788</td>
    <td class="codeLine">  auto &DT = getAnalysis<DominatorTreeWrapperPass>().getDomTree();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1788</td>
    <td class="codeLine">  auto &DT = getAnalysis<DominatorTreeWrapperPass>().getDomTree();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1789</td>
    <td class="codeLine">  MemDep.emplace(AA, AC, TLI, DT, BlockScanLimit);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1789</td>
    <td class="codeLine">  MemDep.emplace(AA, AC, TLI, DT, BlockScanLimit);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1790</td>
    <td class="codeLine">  return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1790</td>
    <td class="codeLine">  return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1791</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1791</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1792</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1792</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
</table>
    </div>
    <button id="myBtn" onclick="topFunction()" title="Go to top" type="button">Top</button>
    <script src="../Javascript/drop_down.js"></script>
    <script src="../Javascript/top_button.js"></script>
  </body>
</html>