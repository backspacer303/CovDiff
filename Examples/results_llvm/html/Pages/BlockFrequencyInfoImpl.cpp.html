<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>BlockFrequencyInfoImpl.cpp</title>
    <link rel="stylesheet" href="../Style/style.css" />
  </head>
  <body>
    <div class="headerDiv">
      <h1>
        Code Coverage
      </h1>
      <p>
        Source file: /home/nikola/Desktop/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp
      </p>
    </div>
    <button class="collapsible" type="button">Open Summary Report</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Summary Report</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line number</th>
    <th class="mainTh">Line</th>
    <th class="mainTh">Number of hits</th>
    <th class="mainTh">Tests that cover line</th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="">//===- BlockFrequencyImplInfo.cpp - Block Frequency Info Implementation ---===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="">// Loops should be simplified before this analysis.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="">#include "llvm/Analysis/BlockFrequencyInfoImpl.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="">#include "llvm/ADT/APInt.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="">#include "llvm/ADT/DenseMap.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="">#include "llvm/ADT/SCCIterator.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="">#include "llvm/ADT/SmallString.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="">#include "llvm/Config/llvm-config.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="">#include "llvm/IR/Function.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="">#include "llvm/Support/BlockFrequency.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="">#include "llvm/Support/BranchProbability.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="">#include "llvm/Support/Compiler.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="">#include "llvm/Support/Debug.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="">#include "llvm/Support/MathExtras.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="">#include "llvm/Support/ScaledNumber.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="">#include "llvm/Support/raw_ostream.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="">#include <algorithm></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="">#include <cassert></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="">#include <cstddef></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="">#include <cstdint></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="">#include <iterator></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="">#include <list></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="">#include <numeric></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="">#include <optional></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="">#include <utility></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="">#include <vector></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="">using namespace llvm;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="">using namespace llvm::bfi_detail;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="">#define DEBUG_TYPE "block-freq"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="">namespace llvm {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="">cl::opt<bool> CheckBFIUnknownBlockQueries(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="">    "check-bfi-unknown-block-queries",</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="">    cl::init(false), cl::Hidden,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="">    cl::desc("Check if block frequency is queried for an unknown block "</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="">             "for debugging missed BFI updates"));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="">cl::opt<bool> UseIterativeBFIInference(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="">    "use-iterative-bfi-inference", cl::Hidden,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="">    cl::desc("Apply an iterative post-processing to infer correct BFI counts"));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="">cl::opt<unsigned> IterativeBFIMaxIterationsPerBlock(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="">    "iterative-bfi-max-iterations-per-block", cl::init(1000), cl::Hidden,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="">    cl::desc("Iterative inference: maximum number of update iterations "</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="">             "per block"));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="">cl::opt<double> IterativeBFIPrecision(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="">    "iterative-bfi-precision", cl::init(1e-12), cl::Hidden,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="">    cl::desc("Iterative inference: delta convergence precision; smaller values "</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="">             "typically lead to better results at the cost of worsen runtime"));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="">} // namespace llvm</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="coveredLine">ScaledNumber<uint64_t> BlockMass::toScaled() const {</td>
    <td>48</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="coveredLine">  if (isFull())</td>
    <td>48</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="coveredLine">    return ScaledNumber<uint64_t>(1, 0);</td>
    <td>24</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="coveredLine">  return ScaledNumber<uint64_t>(getMass() + 1, -64);</td>
    <td>24</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="">#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="uncoveredLine">LLVM_DUMP_METHOD void BlockMass::dump() const { print(dbgs()); }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="">#endif</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="uncoveredLine">static char getHexDigit(int N) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="uncoveredLine">  assert(N < 16);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="uncoveredLine">  if (N < 10)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="uncoveredLine">    return '0' + N;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="uncoveredLine">  return 'a' + N - 10;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="uncoveredLine">raw_ostream &BlockMass::print(raw_ostream &OS) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="uncoveredLine">  for (int Digits = 0; Digits < 16; ++Digits)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="uncoveredLine">    OS << getHexDigit(Mass >> (60 - Digits * 4) & 0xf);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="uncoveredLine">  return OS;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="">namespace {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="">using BlockNode = BlockFrequencyInfoImplBase::BlockNode;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="">using Distribution = BlockFrequencyInfoImplBase::Distribution;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="">using WeightList = BlockFrequencyInfoImplBase::Distribution::WeightList;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="">using Scaled64 = BlockFrequencyInfoImplBase::Scaled64;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="">using LoopData = BlockFrequencyInfoImplBase::LoopData;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="">using Weight = BlockFrequencyInfoImplBase::Weight;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="">using FrequencyData = BlockFrequencyInfoImplBase::FrequencyData;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="">/// Dithering mass distributer.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="">/// This class splits up a single mass into portions by weight, dithering to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="">/// spread out error.  No mass is lost.  The dithering precision depends on the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="">/// precision of the product of \a BlockMass and \a BranchProbability.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="">/// The distribution algorithm follows.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="">///  1. Initialize by saving the sum of the weights in \a RemWeight and the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="">///     mass to distribute in \a RemMass.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="">///  2. For each portion:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="">///      1. Construct a branch probability, P, as the portion's weight divided</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="">///         by the current value of \a RemWeight.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="">///      2. Calculate the portion's mass as \a RemMass times P.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="">///      3. Update \a RemWeight and \a RemMass at each portion by subtracting</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="">///         the current portion's weight and mass.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="">struct DitheringDistributer {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="">  uint32_t RemWeight;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="">  BlockMass RemMass;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="">  DitheringDistributer(Distribution &Dist, const BlockMass &Mass);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="">  BlockMass takeMass(uint32_t Weight);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="">} // end anonymous namespace</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="coveredLine">DitheringDistributer::DitheringDistributer(Distribution &Dist,</td>
    <td>48</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="coveredLine">                                           const BlockMass &Mass) {</td>
    <td>48</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="coveredLine">  Dist.normalize();</td>
    <td>48</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="coveredLine">  RemWeight = Dist.Total;</td>
    <td>48</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="coveredLine">  RemMass = Mass;</td>
    <td>48</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="coveredLine">}</td>
    <td>48</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="coveredLine">BlockMass DitheringDistributer::takeMass(uint32_t Weight) {</td>
    <td>48</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="coveredLine">  assert(Weight && "invalid weight");</td>
    <td>48</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="coveredLine">  assert(Weight <= RemWeight);</td>
    <td>48</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="coveredLine">  BlockMass Mass = RemMass * BranchProbability(Weight, RemWeight);</td>
    <td>48</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="">  // Decrement totals (dither).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="coveredLine">  RemWeight -= Weight;</td>
    <td>48</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="coveredLine">  RemMass -= Mass;</td>
    <td>48</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="coveredLine">  return Mass;</td>
    <td>48</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="coveredLine">void Distribution::add(const BlockNode &Node, uint64_t Amount,</td>
    <td>48</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="">                       Weight::DistType Type) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="coveredLine">  assert(Amount && "invalid weight of 0");</td>
    <td>48</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="coveredLine">  uint64_t NewTotal = Total + Amount;</td>
    <td>48</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="">  // Check for overflow.  It should be impossible to overflow twice.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="coveredLine">  bool IsOverflow = NewTotal < Total;</td>
    <td>48</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="coveredLine">  assert(!(DidOverflow && IsOverflow) && "unexpected repeated overflow");</td>
    <td>48</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="coveredLine">  DidOverflow |= IsOverflow;</td>
    <td>48</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="">  // Update the total.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="coveredLine">  Total = NewTotal;</td>
    <td>48</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="">  // Save the weight.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="coveredLine">  Weights.push_back(Weight(Type, Node, Amount));</td>
    <td>48</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="coveredLine">}</td>
    <td>48</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="uncoveredLine">static void combineWeight(Weight &W, const Weight &OtherW) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="uncoveredLine">  assert(OtherW.TargetNode.isValid());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="uncoveredLine">  if (!W.Amount) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="uncoveredLine">    W = OtherW;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="uncoveredLine">  assert(W.Type == OtherW.Type);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="uncoveredLine">  assert(W.TargetNode == OtherW.TargetNode);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="uncoveredLine">  assert(OtherW.Amount && "Expected non-zero weight");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="uncoveredLine">  if (W.Amount > W.Amount + OtherW.Amount)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="">    // Saturate on overflow.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="uncoveredLine">    W.Amount = UINT64_MAX;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="">  else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="uncoveredLine">    W.Amount += OtherW.Amount;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="coveredLine">static void combineWeightsBySorting(WeightList &Weights) {</td>
    <td>12</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="">  // Sort so edges to the same node are adjacent.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="coveredLine">  llvm::sort(Weights, [](const Weight &L, const Weight &R) {</td>
    <td>12</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="coveredLine">    return L.TargetNode < R.TargetNode;</td>
    <td>12</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="">  });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="">  // Combine adjacent edges.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="coveredLine">  WeightList::iterator O = Weights.begin();</td>
    <td>12</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="coveredLine">  for (WeightList::const_iterator I = O, L = O, E = Weights.end(); I != E;</td>
    <td>36</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="coveredLine">       ++O, (I = L)) {</td>
    <td>24</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="coveredLine">    *O = *I;</td>
    <td>24</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="">    // Find the adjacent weights to the same node.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="coveredLine">    for (++L; L != E && I->TargetNode == L->TargetNode; ++L)</td>
    <td>24</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="uncoveredLine">      combineWeight(*O, *L);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="">  // Erase extra entries.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="coveredLine">  Weights.erase(O, Weights.end());</td>
    <td>12</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="coveredLine">}</td>
    <td>12</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="uncoveredLine">static void combineWeightsByHashing(WeightList &Weights) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="">  // Collect weights into a DenseMap.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="">  using HashTable = DenseMap<BlockNode::IndexType, Weight>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="uncoveredLine">  HashTable Combined(NextPowerOf2(2 * Weights.size()));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="uncoveredLine">  for (const Weight &W : Weights)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="uncoveredLine">    combineWeight(Combined[W.TargetNode.Index], W);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="">  // Check whether anything changed.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="uncoveredLine">  if (Weights.size() == Combined.size())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="">  // Fill in the new weights.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="uncoveredLine">  Weights.clear();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="uncoveredLine">  Weights.reserve(Combined.size());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="uncoveredLine">  for (const auto &I : Combined)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="uncoveredLine">    Weights.push_back(I.second);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="coveredLine">static void combineWeights(WeightList &Weights) {</td>
    <td>12</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="">  // Use a hash table for many successors to keep this linear.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="coveredLine">  if (Weights.size() > 128) {</td>
    <td>12</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="uncoveredLine">    combineWeightsByHashing(Weights);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="coveredLine">  combineWeightsBySorting(Weights);</td>
    <td>12</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="uncoveredLine">static uint64_t shiftRightAndRound(uint64_t N, int Shift) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="uncoveredLine">  assert(Shift >= 0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="uncoveredLine">  assert(Shift < 64);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="uncoveredLine">  if (!Shift)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="uncoveredLine">    return N;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="uncoveredLine">  return (N >> Shift) + (UINT64_C(1) & N >> (Shift - 1));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="coveredLine">void Distribution::normalize() {</td>
    <td>48</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="">  // Early exit for termination nodes.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="coveredLine">  if (Weights.empty())</td>
    <td>48</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="coveredLine">    return;</td>
    <td>12</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="">  // Only bother if there are multiple successors.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="coveredLine">  if (Weights.size() > 1)</td>
    <td>36</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="coveredLine">    combineWeights(Weights);</td>
    <td>12</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="">  // Early exit when combined into a single successor.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="coveredLine">  if (Weights.size() == 1) {</td>
    <td>36</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="coveredLine">    Total = 1;</td>
    <td>24</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="coveredLine">    Weights.front().Amount = 1;</td>
    <td>24</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="coveredLine">    return;</td>
    <td>24</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="">  // Determine how much to shift right so that the total fits into 32-bits.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="">  // If we shift at all, shift by 1 extra.  Otherwise, the lower limit of 1</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="">  // for each weight can cause a 32-bit overflow.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="coveredLine">  int Shift = 0;</td>
    <td>12</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="coveredLine">  if (DidOverflow)</td>
    <td>12</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="uncoveredLine">    Shift = 33;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="coveredLine">  else if (Total > UINT32_MAX)</td>
    <td>12</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="uncoveredLine">    Shift = 33 - llvm::countl_zero(Total);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="">  // Early exit if nothing needs to be scaled.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="coveredLine">  if (!Shift) {</td>
    <td>12</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="">    // If we didn't overflow then combineWeights() shouldn't have changed the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="">    // sum of the weights, but let's double-check.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="coveredLine">    assert(Total == std::accumulate(Weights.begin(), Weights.end(), UINT64_C(0),</td>
    <td>36</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="">                                    [](uint64_t Sum, const Weight &W) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="">                      return Sum + W.Amount;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="">                    }) &&</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="">           "Expected total to be correct");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="coveredLine">    return;</td>
    <td>12</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="">  // Recompute the total through accumulation (rather than shifting it) so that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="">  // it's accurate after shifting and any changes combineWeights() made above.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="uncoveredLine">  Total = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="">  // Sum the weights to each node and shift right if necessary.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="uncoveredLine">  for (Weight &W : Weights) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="">    // Scale down below UINT32_MAX.  Since Shift is larger than necessary, we</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="">    // can round here without concern about overflow.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="uncoveredLine">    assert(W.TargetNode.isValid());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="uncoveredLine">    W.Amount = std::max(UINT64_C(1), shiftRightAndRound(W.Amount, Shift));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="uncoveredLine">    assert(W.Amount <= UINT32_MAX);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="">    // Update the total.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="uncoveredLine">    Total += W.Amount;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="uncoveredLine">  assert(Total <= UINT32_MAX);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="coveredLine">void BlockFrequencyInfoImplBase::clear() {</td>
    <td>24</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="">  // Swap with a default-constructed std::vector, since std::vector<>::clear()</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="">  // does not actually clear heap storage.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="coveredLine">  std::vector<FrequencyData>().swap(Freqs);</td>
    <td>24</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="coveredLine">  IsIrrLoopHeader.clear();</td>
    <td>24</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="coveredLine">  std::vector<WorkingData>().swap(Working);</td>
    <td>24</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="coveredLine">  Loops.clear();</td>
    <td>24</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="coveredLine">}</td>
    <td>24</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="">/// Clear all memory not needed downstream.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="">/// Releases all memory not used downstream.  In particular, saves Freqs.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="coveredLine">static void cleanup(BlockFrequencyInfoImplBase &BFI) {</td>
    <td>12</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="coveredLine">  std::vector<FrequencyData> SavedFreqs(std::move(BFI.Freqs));</td>
    <td>12</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="coveredLine">  SparseBitVector<> SavedIsIrrLoopHeader(std::move(BFI.IsIrrLoopHeader));</td>
    <td>12</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="coveredLine">  BFI.clear();</td>
    <td>12</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="coveredLine">  BFI.Freqs = std::move(SavedFreqs);</td>
    <td>12</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="coveredLine">  BFI.IsIrrLoopHeader = std::move(SavedIsIrrLoopHeader);</td>
    <td>12</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="coveredLine">}</td>
    <td>12</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="coveredLine">bool BlockFrequencyInfoImplBase::addToDist(Distribution &Dist,</td>
    <td>48</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="">                                           const LoopData *OuterLoop,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="">                                           const BlockNode &Pred,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="">                                           const BlockNode &Succ,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="">                                           uint64_t Weight) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="coveredLine">  if (!Weight)</td>
    <td>48</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="uncoveredLine">    Weight = 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="coveredLine">  auto isLoopHeader = [&OuterLoop](const BlockNode &Node) {</td>
    <td>48</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="coveredLine">    return OuterLoop && OuterLoop->isHeader(Node);</td>
    <td>48</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="coveredLine">  };</td>
    <td>48</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="coveredLine">  BlockNode Resolved = Working[Succ.Index].getResolvedNode();</td>
    <td>48</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="">#ifndef NDEBUG</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="uncoveredLine">  auto debugSuccessor = [&](const char *Type) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="uncoveredLine">    dbgs() << "  =>"</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="uncoveredLine">           << " [" << Type << "] weight = " << Weight;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="uncoveredLine">    if (!isLoopHeader(Resolved))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="uncoveredLine">      dbgs() << ", succ = " << getBlockName(Succ);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="uncoveredLine">    if (Resolved != Succ)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="uncoveredLine">      dbgs() << ", resolved = " << getBlockName(Resolved);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="uncoveredLine">    dbgs() << "\n";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="coveredLine">  };</td>
    <td>48</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="">  (void)debugSuccessor;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="">#endif</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="coveredLine">  if (isLoopHeader(Resolved)) {</td>
    <td>48</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="uncoveredLine">    LLVM_DEBUG(debugSuccessor("backedge"));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="uncoveredLine">    Dist.addBackedge(Resolved, Weight);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="coveredLine">  if (Working[Resolved.Index].getContainingLoop() != OuterLoop) {</td>
    <td>48</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="uncoveredLine">    LLVM_DEBUG(debugSuccessor("  exit  "));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="uncoveredLine">    Dist.addExit(Resolved, Weight);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="coveredLine">  if (Resolved < Pred) {</td>
    <td>48</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="uncoveredLine">    if (!isLoopHeader(Pred)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="">      // If OuterLoop is an irreducible loop, we can't actually handle this.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="uncoveredLine">      assert((!OuterLoop || !OuterLoop->isIrreducible()) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="">             "unhandled irreducible control flow");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="">      // Irreducible backedge.  Abort.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="uncoveredLine">      LLVM_DEBUG(debugSuccessor("abort!!!"));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="">    // If "Pred" is a loop header, then this isn't really a backedge; rather,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="">    // OuterLoop must be irreducible.  These false backedges can come only from</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="">    // secondary loop headers.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="uncoveredLine">    assert(OuterLoop && OuterLoop->isIrreducible() && !isLoopHeader(Resolved) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="">           "unhandled irreducible control flow");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="coveredLine">  LLVM_DEBUG(debugSuccessor(" local  "));</td>
    <td>48</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="coveredLine">  Dist.addLocal(Resolved, Weight);</td>
    <td>48</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="coveredLine">  return true;</td>
    <td>48</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="uncoveredLine">bool BlockFrequencyInfoImplBase::addLoopSuccessorsToDist(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="">    const LoopData *OuterLoop, LoopData &Loop, Distribution &Dist) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="">  // Copy the exit map into Dist.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="uncoveredLine">  for (const auto &I : Loop.Exits)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="uncoveredLine">    if (!addToDist(Dist, OuterLoop, Loop.getHeader(), I.first,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="">                   I.second.getMass()))</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="">      // Irreducible backedge.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="uncoveredLine">  return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="">/// Compute the loop scale for a loop.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="uncoveredLine">void BlockFrequencyInfoImplBase::computeLoopScale(LoopData &Loop) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="">  // Compute loop scale.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << "compute-loop-scale: " << getLoopName(Loop) << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="">  // Infinite loops need special handling. If we give the back edge an infinite</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="">  // mass, they may saturate all the other scales in the function down to 1,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="">  // making all the other region temperatures look exactly the same. Choose an</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="">  // arbitrary scale to avoid these issues.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="">  // FIXME: An alternate way would be to select a symbolic scale which is later</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="">  // replaced to be the maximum of all computed scales plus 1. This would</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="">  // appropriately describe the loop as having a large scale, without skewing</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="">  // the final frequency computation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="uncoveredLine">  const Scaled64 InfiniteLoopScale(1, 12);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="">  // LoopScale == 1 / ExitMass</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="">  // ExitMass == HeadMass - BackedgeMass</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="uncoveredLine">  BlockMass TotalBackedgeMass;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="uncoveredLine">  for (auto &Mass : Loop.BackedgeMass)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="uncoveredLine">    TotalBackedgeMass += Mass;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="uncoveredLine">  BlockMass ExitMass = BlockMass::getFull() - TotalBackedgeMass;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="">  // Block scale stores the inverse of the scale. If this is an infinite loop,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="">  // its exit mass will be zero. In this case, use an arbitrary scale for the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="">  // loop scale.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="uncoveredLine">  Loop.Scale =</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="uncoveredLine">      ExitMass.isEmpty() ? InfiniteLoopScale : ExitMass.toScaled().inverse();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << " - exit-mass = " << ExitMass << " ("</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="">                    << BlockMass::getFull() << " - " << TotalBackedgeMass</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="">                    << ")\n"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="">                    << " - scale = " << Loop.Scale << "\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="">/// Package up a loop.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="uncoveredLine">void BlockFrequencyInfoImplBase::packageLoop(LoopData &Loop) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << "packaging-loop: " << getLoopName(Loop) << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="">  // Clear the subloop exits to prevent quadratic memory usage.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="uncoveredLine">  for (const BlockNode &M : Loop.Nodes) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="uncoveredLine">    if (auto *Loop = Working[M.Index].getPackagedLoop())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="uncoveredLine">      Loop->Exits.clear();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << " - node: " << getBlockName(M.Index) << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="uncoveredLine">  Loop.IsPackaged = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="">#ifndef NDEBUG</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="uncoveredLine">static void debugAssign(const BlockFrequencyInfoImplBase &BFI,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="">                        const DitheringDistributer &D, const BlockNode &T,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="">                        const BlockMass &M, const char *Desc) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="uncoveredLine">  dbgs() << "  => assign " << M << " (" << D.RemMass << ")";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="uncoveredLine">  if (Desc)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="uncoveredLine">    dbgs() << " [" << Desc << "]";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="uncoveredLine">  if (T.isValid())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="uncoveredLine">    dbgs() << " to " << BFI.getBlockName(T);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="uncoveredLine">  dbgs() << "\n";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="">#endif</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="coveredLine">void BlockFrequencyInfoImplBase::distributeMass(const BlockNode &Source,</td>
    <td>48</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="">                                                LoopData *OuterLoop,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="">                                                Distribution &Dist) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="coveredLine">  BlockMass Mass = Working[Source.Index].getMass();</td>
    <td>48</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="coveredLine">  LLVM_DEBUG(dbgs() << "  => mass:  " << Mass << "\n");</td>
    <td>48</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="">  // Distribute mass to successors as laid out in Dist.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="coveredLine">  DitheringDistributer D(Dist, Mass);</td>
    <td>48</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="coveredLine">  for (const Weight &W : Dist.Weights) {</td>
    <td>96</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="">    // Check for a local edge (non-backedge and non-exit).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="coveredLine">    BlockMass Taken = D.takeMass(W.Amount);</td>
    <td>48</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="coveredLine">    if (W.Type == Weight::Local) {</td>
    <td>48</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="coveredLine">      Working[W.TargetNode.Index].getMass() += Taken;</td>
    <td>48</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="coveredLine">      LLVM_DEBUG(debugAssign(*this, D, W.TargetNode, Taken, nullptr));</td>
    <td>48</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="coveredLine">      continue;</td>
    <td>48</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="">    // Backedges and exits only make sense if we're processing a loop.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="uncoveredLine">    assert(OuterLoop && "backedge or exit outside of loop");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="">    // Check for a backedge.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="uncoveredLine">    if (W.Type == Weight::Backedge) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="uncoveredLine">      OuterLoop->BackedgeMass[OuterLoop->getHeaderIndex(W.TargetNode)] += Taken;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="uncoveredLine">      LLVM_DEBUG(debugAssign(*this, D, W.TargetNode, Taken, "back"));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="">    // This must be an exit.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="uncoveredLine">    assert(W.Type == Weight::Exit);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="uncoveredLine">    OuterLoop->Exits.push_back(std::make_pair(W.TargetNode, Taken));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="uncoveredLine">    LLVM_DEBUG(debugAssign(*this, D, W.TargetNode, Taken, "exit"));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="coveredLine">}</td>
    <td>48</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="coveredLine">static void convertFloatingToInteger(BlockFrequencyInfoImplBase &BFI,</td>
    <td>12</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="">                                     const Scaled64 &Min, const Scaled64 &Max) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="">  // Scale the Factor to a size that creates integers.  Ideally, integers would</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="">  // be scaled so that Max == UINT64_MAX so that they can be best</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="">  // differentiated.  However, in the presence of large frequency values, small</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="">  // frequencies are scaled down to 1, making it impossible to differentiate</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="">  // small, unequal numbers. When the spread between Min and Max frequencies</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="">  // fits well within MaxBits, we make the scale be at least 8.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="coveredLine">  const unsigned MaxBits = 64;</td>
    <td>12</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="coveredLine">  const unsigned SpreadBits = (Max / Min).lg();</td>
    <td>12</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="coveredLine">  Scaled64 ScalingFactor;</td>
    <td>12</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="coveredLine">  if (SpreadBits <= MaxBits - 3) {</td>
    <td>12</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="">    // If the values are small enough, make the scaling factor at least 8 to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="">    // allow distinguishing small values.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="coveredLine">    ScalingFactor = Min.inverse();</td>
    <td>12</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="coveredLine">    ScalingFactor <<= 3;</td>
    <td>12</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="">  } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="">    // If the values need more than MaxBits to be represented, saturate small</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="">    // frequency values down to 1 by using a scaling factor that benefits large</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="">    // frequency values.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="uncoveredLine">    ScalingFactor = Scaled64(1, MaxBits) / Max;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="">  // Translate the floats to integers.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="coveredLine">  LLVM_DEBUG(dbgs() << "float-to-int: min = " << Min << ", max = " << Max</td>
    <td>12</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="">                    << ", factor = " << ScalingFactor << "\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="coveredLine">  for (size_t Index = 0; Index < BFI.Freqs.size(); ++Index) {</td>
    <td>60</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="coveredLine">    Scaled64 Scaled = BFI.Freqs[Index].Scaled * ScalingFactor;</td>
    <td>48</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="coveredLine">    BFI.Freqs[Index].Integer = std::max(UINT64_C(1), Scaled.toInt<uint64_t>());</td>
    <td>48</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="coveredLine">    LLVM_DEBUG(dbgs() << " - " << BFI.getBlockName(Index) << ": float = "</td>
    <td>48</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="">                      << BFI.Freqs[Index].Scaled << ", scaled = " << Scaled</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class="">                      << ", int = " << BFI.Freqs[Index].Integer << "\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="coveredLine">}</td>
    <td>12</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class="">/// Unwrap a loop package.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="">/// Visits all the members of a loop, adjusting their BlockData according to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class="">/// the loop's pseudo-node.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="uncoveredLine">static void unwrapLoop(BlockFrequencyInfoImplBase &BFI, LoopData &Loop) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << "unwrap-loop-package: " << BFI.getLoopName(Loop)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="">                    << ": mass = " << Loop.Mass << ", scale = " << Loop.Scale</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="">                    << "\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="uncoveredLine">  Loop.Scale *= Loop.Mass.toScaled();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class="uncoveredLine">  Loop.IsPackaged = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << "  => combined-scale = " << Loop.Scale << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="">  // Propagate the head scale through the loop.  Since members are visited in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="">  // RPO, the head scale will be updated by the loop scale first, and then the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="">  // final head scale will be used for updated the rest of the members.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="uncoveredLine">  for (const BlockNode &N : Loop.Nodes) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class="uncoveredLine">    const auto &Working = BFI.Working[N.Index];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="uncoveredLine">    Scaled64 &F = Working.isAPackage() ? Working.getPackagedLoop()->Scale</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="uncoveredLine">                                       : BFI.Freqs[N.Index].Scaled;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="uncoveredLine">    Scaled64 New = Loop.Scale * F;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << " - " << BFI.getBlockName(N) << ": " << F << " => "</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="">                      << New << "\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="uncoveredLine">    F = New;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="coveredLine">void BlockFrequencyInfoImplBase::unwrapLoops() {</td>
    <td>12</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="">  // Set initial frequencies from loop-local masses.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="coveredLine">  for (size_t Index = 0; Index < Working.size(); ++Index)</td>
    <td>60</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="coveredLine">    Freqs[Index].Scaled = Working[Index].Mass.toScaled();</td>
    <td>48</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="coveredLine">  for (LoopData &Loop : Loops)</td>
    <td>12</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="uncoveredLine">    unwrapLoop(*this, Loop);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="coveredLine">}</td>
    <td>12</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="coveredLine">void BlockFrequencyInfoImplBase::finalizeMetrics() {</td>
    <td>12</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="">  // Unwrap loop packages in reverse post-order, tracking min and max</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="">  // frequencies.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="coveredLine">  auto Min = Scaled64::getLargest();</td>
    <td>12</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="coveredLine">  auto Max = Scaled64::getZero();</td>
    <td>12</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="coveredLine">  for (size_t Index = 0; Index < Working.size(); ++Index) {</td>
    <td>60</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="">    // Update min/max scale.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="coveredLine">    Min = std::min(Min, Freqs[Index].Scaled);</td>
    <td>48</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="coveredLine">    Max = std::max(Max, Freqs[Index].Scaled);</td>
    <td>48</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="">  // Convert to integers.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="coveredLine">  convertFloatingToInteger(*this, Min, Max);</td>
    <td>12</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="">  // Clean up data structures.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="coveredLine">  cleanup(*this);</td>
    <td>12</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="">  // Print out the final stats.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="coveredLine">  LLVM_DEBUG(dump());</td>
    <td>12</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="coveredLine">}</td>
    <td>12</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="">BlockFrequency</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="coveredLine">BlockFrequencyInfoImplBase::getBlockFreq(const BlockNode &Node) const {</td>
    <td>40</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="coveredLine">  if (!Node.isValid()) {</td>
    <td>40</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="">#ifndef NDEBUG</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="uncoveredLine">    if (CheckBFIUnknownBlockQueries) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="uncoveredLine">      SmallString<256> Msg;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class="uncoveredLine">      raw_svector_ostream OS(Msg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="uncoveredLine">      OS << "*** Detected BFI query for unknown block " << getBlockName(Node);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="uncoveredLine">      report_fatal_error(OS.str());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="">#endif</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="uncoveredLine">    return 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="coveredLine">  return Freqs[Node.Index].Integer;</td>
    <td>40</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="">std::optional<uint64_t></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class="uncoveredLine">BlockFrequencyInfoImplBase::getBlockProfileCount(const Function &F,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="">                                                 const BlockNode &Node,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="">                                                 bool AllowSynthetic) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="uncoveredLine">  return getProfileCountFromFreq(F, getBlockFreq(Node).getFrequency(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="uncoveredLine">                                 AllowSynthetic);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class="">std::optional<uint64_t></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="uncoveredLine">BlockFrequencyInfoImplBase::getProfileCountFromFreq(const Function &F,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="">                                                    uint64_t Freq,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="">                                                    bool AllowSynthetic) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="uncoveredLine">  auto EntryCount = F.getEntryCount(AllowSynthetic);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="uncoveredLine">  if (!EntryCount)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="uncoveredLine">    return std::nullopt;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="">  // Use 128 bit APInt to do the arithmetic to avoid overflow.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="uncoveredLine">  APInt BlockCount(128, EntryCount->getCount());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="uncoveredLine">  APInt BlockFreq(128, Freq);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="uncoveredLine">  APInt EntryFreq(128, getEntryFreq());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="uncoveredLine">  BlockCount *= BlockFreq;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="">  // Rounded division of BlockCount by EntryFreq. Since EntryFreq is unsigned</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="">  // lshr by 1 gives EntryFreq/2.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="uncoveredLine">  BlockCount = (BlockCount + EntryFreq.lshr(1)).udiv(EntryFreq);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="uncoveredLine">  return BlockCount.getLimitedValue();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="">bool</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="uncoveredLine">BlockFrequencyInfoImplBase::isIrrLoopHeader(const BlockNode &Node) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="uncoveredLine">  if (!Node.isValid())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="uncoveredLine">  return IsIrrLoopHeader.test(Node.Index);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="">Scaled64</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="uncoveredLine">BlockFrequencyInfoImplBase::getFloatingBlockFreq(const BlockNode &Node) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="uncoveredLine">  if (!Node.isValid())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="uncoveredLine">    return Scaled64::getZero();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="uncoveredLine">  return Freqs[Node.Index].Scaled;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="uncoveredLine">void BlockFrequencyInfoImplBase::setBlockFreq(const BlockNode &Node,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class="">                                              uint64_t Freq) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="uncoveredLine">  assert(Node.isValid() && "Expected valid node");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="uncoveredLine">  assert(Node.Index < Freqs.size() && "Expected legal index");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="uncoveredLine">  Freqs[Node.Index].Integer = Freq;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="">std::string</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="uncoveredLine">BlockFrequencyInfoImplBase::getBlockName(const BlockNode &Node) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="uncoveredLine">  return {};</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="">std::string</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="uncoveredLine">BlockFrequencyInfoImplBase::getLoopName(const LoopData &Loop) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="uncoveredLine">  return getBlockName(Loop.getHeader()) + (Loop.isIrreducible() ? "**" : "*");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="">raw_ostream &</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="uncoveredLine">BlockFrequencyInfoImplBase::printBlockFreq(raw_ostream &OS,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="">                                           const BlockNode &Node) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="uncoveredLine">  return OS << getFloatingBlockFreq(Node);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="">raw_ostream &</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="uncoveredLine">BlockFrequencyInfoImplBase::printBlockFreq(raw_ostream &OS,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="">                                           const BlockFrequency &Freq) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="uncoveredLine">  Scaled64 Block(Freq.getFrequency(), 0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="uncoveredLine">  Scaled64 Entry(getEntryFreq(), 0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="uncoveredLine">  return OS << Block / Entry;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="uncoveredLine">void IrreducibleGraph::addNodesInLoop(const BFIBase::LoopData &OuterLoop) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="uncoveredLine">  Start = OuterLoop.getHeader();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="uncoveredLine">  Nodes.reserve(OuterLoop.Nodes.size());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="uncoveredLine">  for (auto N : OuterLoop.Nodes)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="uncoveredLine">    addNode(N);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="uncoveredLine">  indexNodes();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="uncoveredLine">void IrreducibleGraph::addNodesInFunction() {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="uncoveredLine">  Start = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="uncoveredLine">  for (uint32_t Index = 0; Index < BFI.Working.size(); ++Index)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class="uncoveredLine">    if (!BFI.Working[Index].isPackaged())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="uncoveredLine">      addNode(Index);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="uncoveredLine">  indexNodes();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="uncoveredLine">void IrreducibleGraph::indexNodes() {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="uncoveredLine">  for (auto &I : Nodes)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="uncoveredLine">    Lookup[I.Node.Index] = &I;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="uncoveredLine">void IrreducibleGraph::addEdge(IrrNode &Irr, const BlockNode &Succ,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class="">                               const BFIBase::LoopData *OuterLoop) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="uncoveredLine">  if (OuterLoop && OuterLoop->isHeader(Succ))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="uncoveredLine">  auto L = Lookup.find(Succ.Index);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="uncoveredLine">  if (L == Lookup.end())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class="uncoveredLine">  IrrNode &SuccIrr = *L->second;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class="uncoveredLine">  Irr.Edges.push_back(&SuccIrr);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class="uncoveredLine">  SuccIrr.Edges.push_front(&Irr);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="uncoveredLine">  ++SuccIrr.NumIn;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="">namespace llvm {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class="">template <> struct GraphTraits<IrreducibleGraph> {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class="">  using GraphT = bfi_detail::IrreducibleGraph;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class="">  using NodeRef = const GraphT::IrrNode *;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="">  using ChildIteratorType = GraphT::IrrNode::iterator;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class="uncoveredLine">  static NodeRef getEntryNode(const GraphT &G) { return G.StartIrr; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="uncoveredLine">  static ChildIteratorType child_begin(NodeRef N) { return N->succ_begin(); }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class="uncoveredLine">  static ChildIteratorType child_end(NodeRef N) { return N->succ_end(); }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class="">} // end namespace llvm</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class="">/// Find extra irreducible headers.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class="">/// Find entry blocks and other blocks with backedges, which exist when \c G</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class="">/// contains irreducible sub-SCCs.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="uncoveredLine">static void findIrreducibleHeaders(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="">    const BlockFrequencyInfoImplBase &BFI,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="">    const IrreducibleGraph &G,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="">    const std::vector<const IrreducibleGraph::IrrNode *> &SCC,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class="">    LoopData::NodeList &Headers, LoopData::NodeList &Others) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class="">  // Map from nodes in the SCC to whether it's an entry block.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class="uncoveredLine">  SmallDenseMap<const IrreducibleGraph::IrrNode *, bool, 8> InSCC;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="">  // InSCC also acts the set of nodes in the graph.  Seed it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class="uncoveredLine">  for (const auto *I : SCC)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="uncoveredLine">    InSCC[I] = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="uncoveredLine">  for (auto I = InSCC.begin(), E = InSCC.end(); I != E; ++I) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class="uncoveredLine">    auto &Irr = *I->first;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class="uncoveredLine">    for (const auto *P : make_range(Irr.pred_begin(), Irr.pred_end())) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class="uncoveredLine">      if (InSCC.count(P))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class="">      // This is an entry block.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class="uncoveredLine">      I->second = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="uncoveredLine">      Headers.push_back(Irr.Node);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="uncoveredLine">      LLVM_DEBUG(dbgs() << "  => entry = " << BFI.getBlockName(Irr.Node)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class="">                        << "\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class="uncoveredLine">  assert(Headers.size() >= 2 &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="">         "Expected irreducible CFG; -loop-info is likely invalid");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class="uncoveredLine">  if (Headers.size() == InSCC.size()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class="">    // Every block is a header.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class="uncoveredLine">    llvm::sort(Headers);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class="">  // Look for extra headers from irreducible sub-SCCs.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="uncoveredLine">  for (const auto &I : InSCC) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="">    // Entry blocks are already headers.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="uncoveredLine">    if (I.second)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class="uncoveredLine">    auto &Irr = *I.first;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class="uncoveredLine">    for (const auto *P : make_range(Irr.pred_begin(), Irr.pred_end())) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class="">      // Skip forward edges.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="uncoveredLine">      if (P->Node < Irr.Node)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="">      // Skip predecessors from entry blocks.  These can have inverted</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class="">      // ordering.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class="uncoveredLine">      if (InSCC.lookup(P))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class="">      // Store the extra header.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class="uncoveredLine">      Headers.push_back(Irr.Node);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class="uncoveredLine">      LLVM_DEBUG(dbgs() << "  => extra = " << BFI.getBlockName(Irr.Node)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="">                        << "\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="uncoveredLine">    if (Headers.back() == Irr.Node)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class="">      // Added this as a header.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="">    // This is not a header.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class="uncoveredLine">    Others.push_back(Irr.Node);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "  => other = " << BFI.getBlockName(Irr.Node) << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class="uncoveredLine">  llvm::sort(Headers);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="uncoveredLine">  llvm::sort(Others);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="uncoveredLine">static void createIrreducibleLoop(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="">    BlockFrequencyInfoImplBase &BFI, const IrreducibleGraph &G,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class="">    LoopData *OuterLoop, std::list<LoopData>::iterator Insert,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class="">    const std::vector<const IrreducibleGraph::IrrNode *> &SCC) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class="">  // Translate the SCC into RPO.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << " - found-scc\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class="uncoveredLine">  LoopData::NodeList Headers;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class="uncoveredLine">  LoopData::NodeList Others;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class="uncoveredLine">  findIrreducibleHeaders(BFI, G, SCC, Headers, Others);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="uncoveredLine">  auto Loop = BFI.Loops.emplace(Insert, OuterLoop, Headers.begin(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class="uncoveredLine">                                Headers.end(), Others.begin(), Others.end());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class="">  // Update loop hierarchy.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class="uncoveredLine">  for (const auto &N : Loop->Nodes)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class="uncoveredLine">    if (BFI.Working[N.Index].isLoopHeader())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class="uncoveredLine">      BFI.Working[N.Index].Loop->Parent = &*Loop;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class="">    else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class="uncoveredLine">      BFI.Working[N.Index].Loop = &*Loop;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class="">iterator_range<std::list<LoopData>::iterator></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class="uncoveredLine">BlockFrequencyInfoImplBase::analyzeIrreducible(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class="">    const IrreducibleGraph &G, LoopData *OuterLoop,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class="">    std::list<LoopData>::iterator Insert) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class="uncoveredLine">  assert((OuterLoop == nullptr) == (Insert == Loops.begin()));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class="uncoveredLine">  auto Prev = OuterLoop ? std::prev(Insert) : Loops.end();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class="uncoveredLine">  for (auto I = scc_begin(G); !I.isAtEnd(); ++I) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class="uncoveredLine">    if (I->size() < 2)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class="">    // Translate the SCC into RPO.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class="uncoveredLine">    createIrreducibleLoop(*this, G, OuterLoop, Insert, *I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class="uncoveredLine">  if (OuterLoop)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class="uncoveredLine">    return make_range(std::next(Prev), Insert);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class="uncoveredLine">  return make_range(Loops.begin(), Insert);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class="">void</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class="uncoveredLine">BlockFrequencyInfoImplBase::updateLoopWithIrreducible(LoopData &OuterLoop) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class="uncoveredLine">  OuterLoop.Exits.clear();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class="uncoveredLine">  for (auto &Mass : OuterLoop.BackedgeMass)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class="uncoveredLine">    Mass = BlockMass::getEmpty();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class="uncoveredLine">  auto O = OuterLoop.Nodes.begin() + 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class="uncoveredLine">  for (auto I = O, E = OuterLoop.Nodes.end(); I != E; ++I)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class="uncoveredLine">    if (!Working[I->Index].isPackaged())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class="uncoveredLine">      *O++ = *I;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class="uncoveredLine">  OuterLoop.Nodes.erase(O, OuterLoop.Nodes.end());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class="uncoveredLine">void BlockFrequencyInfoImplBase::adjustLoopHeaderMass(LoopData &Loop) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class="uncoveredLine">  assert(Loop.isIrreducible() && "this only makes sense on irreducible loops");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class="">  // Since the loop has more than one header block, the mass flowing back into</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class="">  // each header will be different. Adjust the mass in each header loop to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class="">  // reflect the masses flowing through back edges.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class="">  // To do this, we distribute the initial mass using the backedge masses</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class="">  // as weights for the distribution.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class="uncoveredLine">  BlockMass LoopMass = BlockMass::getFull();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class="uncoveredLine">  Distribution Dist;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << "adjust-loop-header-mass:\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class="uncoveredLine">  for (uint32_t H = 0; H < Loop.NumHeaders; ++H) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class="uncoveredLine">    auto &HeaderNode = Loop.Nodes[H];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class="uncoveredLine">    auto &BackedgeMass = Loop.BackedgeMass[Loop.getHeaderIndex(HeaderNode)];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << " - Add back edge mass for node "</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class="">                      << getBlockName(HeaderNode) << ": " << BackedgeMass</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class="">                      << "\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class="uncoveredLine">    if (BackedgeMass.getMass() > 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class="uncoveredLine">      Dist.addLocal(HeaderNode, BackedgeMass.getMass());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class="">    else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class="uncoveredLine">      LLVM_DEBUG(dbgs() << "   Nothing added. Back edge mass is zero\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class="uncoveredLine">  DitheringDistributer D(Dist, LoopMass);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << " Distribute loop mass " << LoopMass</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class="">                    << " to headers using above weights\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class="uncoveredLine">  for (const Weight &W : Dist.Weights) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class="uncoveredLine">    BlockMass Taken = D.takeMass(W.Amount);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class="uncoveredLine">    assert(W.Type == Weight::Local && "all weights should be local");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class="uncoveredLine">    Working[W.TargetNode.Index].getMass() = Taken;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class="uncoveredLine">    LLVM_DEBUG(debugAssign(*this, D, W.TargetNode, Taken, nullptr));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">872</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">873</td>
    <td class="uncoveredLine">void BlockFrequencyInfoImplBase::distributeIrrLoopHeaderMass(Distribution &Dist) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">874</td>
    <td class="uncoveredLine">  BlockMass LoopMass = BlockMass::getFull();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">875</td>
    <td class="uncoveredLine">  DitheringDistributer D(Dist, LoopMass);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">876</td>
    <td class="uncoveredLine">  for (const Weight &W : Dist.Weights) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">877</td>
    <td class="uncoveredLine">    BlockMass Taken = D.takeMass(W.Amount);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">878</td>
    <td class="uncoveredLine">    assert(W.Type == Weight::Local && "all weights should be local");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">879</td>
    <td class="uncoveredLine">    Working[W.TargetNode.Index].getMass() = Taken;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">880</td>
    <td class="uncoveredLine">    LLVM_DEBUG(debugAssign(*this, D, W.TargetNode, Taken, nullptr));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">881</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">882</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">883</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Functions Report</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Functions Report</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Function name</th>
    <th class="mainTh">Number of hits</th>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm10bfi_detail9BlockMass8toScaledEv</td>
    <td class="numberOfCalls">48</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm10bfi_detail9BlockMass4dumpEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL11getHexDigiti</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm10bfi_detail9BlockMass5printERNS_11raw_ostreamE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_120DitheringDistributerC2ERN4llvm26BlockFrequencyInfoImplBase12DistributionERKNS1_10bfi_detail9BlockMassE</td>
    <td class="numberOfCalls">48</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_120DitheringDistributer8takeMassEj</td>
    <td class="numberOfCalls">48</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm26BlockFrequencyInfoImplBase12Distribution3addERKNS0_9BlockNodeEmNS0_6Weight8DistTypeE</td>
    <td class="numberOfCalls">48</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL13combineWeightRN4llvm26BlockFrequencyInfoImplBase6WeightERKS1_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL23combineWeightsBySortingRN4llvm11SmallVectorINS_26BlockFrequencyInfoImplBase6WeightELj4EEE</td>
    <td class="numberOfCalls">12</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZL23combineWeightsBySortingRN4llvm11SmallVectorINS_26BlockFrequencyInfoImplBase6WeightELj4EEEENKUlRKS2_S6_E_clES6_S6_</td>
    <td class="numberOfCalls">12</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL23combineWeightsByHashingRN4llvm11SmallVectorINS_26BlockFrequencyInfoImplBase6WeightELj4EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL14combineWeightsRN4llvm11SmallVectorINS_26BlockFrequencyInfoImplBase6WeightELj4EEE</td>
    <td class="numberOfCalls">12</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL18shiftRightAndRoundmi</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm26BlockFrequencyInfoImplBase12Distribution9normalizeEv</td>
    <td class="numberOfCalls">48</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN4llvm26BlockFrequencyInfoImplBase12Distribution9normalizeEvENKUlmRKNS0_6WeightEE_clEmS4_</td>
    <td class="numberOfCalls">24</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm26BlockFrequencyInfoImplBase5clearEv</td>
    <td class="numberOfCalls">24</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL7cleanupRN4llvm26BlockFrequencyInfoImplBaseE</td>
    <td class="numberOfCalls">12</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm26BlockFrequencyInfoImplBase9addToDistERNS0_12DistributionEPKNS0_8LoopDataERKNS0_9BlockNodeES8_m</td>
    <td class="numberOfCalls">48</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN4llvm26BlockFrequencyInfoImplBase9addToDistERNS0_12DistributionEPKNS0_8LoopDataERKNS0_9BlockNodeES8_mENKUlS8_E_clES8_</td>
    <td class="numberOfCalls">48</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN4llvm26BlockFrequencyInfoImplBase9addToDistERNS0_12DistributionEPKNS0_8LoopDataERKNS0_9BlockNodeES8_mENKUlPKcE0_clESA_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm26BlockFrequencyInfoImplBase23addLoopSuccessorsToDistEPKNS0_8LoopDataERS1_RNS0_12DistributionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm26BlockFrequencyInfoImplBase16computeLoopScaleERNS0_8LoopDataE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm26BlockFrequencyInfoImplBase11packageLoopERNS0_8LoopDataE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL11debugAssignRKN4llvm26BlockFrequencyInfoImplBaseERKN12_GLOBAL__N_120DitheringDistributerERKNS0_9BlockNodeERKNS_10bfi_detail9BlockMassEPKc</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm26BlockFrequencyInfoImplBase14distributeMassERKNS0_9BlockNodeEPNS0_8LoopDataERNS0_12DistributionE</td>
    <td class="numberOfCalls">48</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL24convertFloatingToIntegerRN4llvm26BlockFrequencyInfoImplBaseERKNS_12ScaledNumberImEES5_</td>
    <td class="numberOfCalls">12</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL10unwrapLoopRN4llvm26BlockFrequencyInfoImplBaseERNS0_8LoopDataE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm26BlockFrequencyInfoImplBase11unwrapLoopsEv</td>
    <td class="numberOfCalls">12</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm26BlockFrequencyInfoImplBase15finalizeMetricsEv</td>
    <td class="numberOfCalls">12</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm26BlockFrequencyInfoImplBase12getBlockFreqERKNS0_9BlockNodeE</td>
    <td class="numberOfCalls">40</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm26BlockFrequencyInfoImplBase20getBlockProfileCountERKNS_8FunctionERKNS0_9BlockNodeEb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm26BlockFrequencyInfoImplBase23getProfileCountFromFreqERKNS_8FunctionEmb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm26BlockFrequencyInfoImplBase15isIrrLoopHeaderERKNS0_9BlockNodeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm26BlockFrequencyInfoImplBase20getFloatingBlockFreqERKNS0_9BlockNodeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm26BlockFrequencyInfoImplBase12setBlockFreqERKNS0_9BlockNodeEm</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm26BlockFrequencyInfoImplBase12getBlockNameB5cxx11ERKNS0_9BlockNodeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm26BlockFrequencyInfoImplBase11getLoopNameB5cxx11ERKNS0_8LoopDataE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm26BlockFrequencyInfoImplBase14printBlockFreqERNS_11raw_ostreamERKNS0_9BlockNodeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm26BlockFrequencyInfoImplBase14printBlockFreqERNS_11raw_ostreamERKNS_14BlockFrequencyE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm10bfi_detail16IrreducibleGraph14addNodesInLoopERKNS_26BlockFrequencyInfoImplBase8LoopDataE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm10bfi_detail16IrreducibleGraph18addNodesInFunctionEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm10bfi_detail16IrreducibleGraph10indexNodesEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm10bfi_detail16IrreducibleGraph7addEdgeERNS1_7IrrNodeERKNS_26BlockFrequencyInfoImplBase9BlockNodeEPKNS4_8LoopDataE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm11GraphTraitsINS_10bfi_detail16IrreducibleGraphEE12getEntryNodeERKS2_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm11GraphTraitsINS_10bfi_detail16IrreducibleGraphEE11child_beginEPKNS2_7IrrNodeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm11GraphTraitsINS_10bfi_detail16IrreducibleGraphEE9child_endEPKNS2_7IrrNodeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL22findIrreducibleHeadersRKN4llvm26BlockFrequencyInfoImplBaseERKNS_10bfi_detail16IrreducibleGraphERKSt6vectorIPKNS4_7IrrNodeESaISA_EERNS_11SmallVectorINS0_9BlockNodeELj4EEESI_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL21createIrreducibleLoopRN4llvm26BlockFrequencyInfoImplBaseERKNS_10bfi_detail16IrreducibleGraphEPNS0_8LoopDataESt14_List_iteratorIS6_ERKSt6vectorIPKNS3_7IrrNodeESaISD_EE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm26BlockFrequencyInfoImplBase18analyzeIrreducibleERKNS_10bfi_detail16IrreducibleGraphEPNS0_8LoopDataESt14_List_iteratorIS5_E</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm26BlockFrequencyInfoImplBase25updateLoopWithIrreducibleERNS0_8LoopDataE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm26BlockFrequencyInfoImplBase20adjustLoopHeaderMassERNS0_8LoopDataE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm26BlockFrequencyInfoImplBase27distributeIrrLoopHeaderMassERNS0_12DistributionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Coverage Diff</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Coverage Diff</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span> BUT NOT </span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </th>
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
      <span> BUT NOT </span>
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="codeline">//===- BlockFrequencyImplInfo.cpp - Block Frequency Info Implementation ---===//</td>
    <td class="lineNumber">1</td>
    <td class="codeline">//===- BlockFrequencyImplInfo.cpp - Block Frequency Info Implementation ---===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="codeline">//</td>
    <td class="lineNumber">2</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="codeline">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">3</td>
    <td class="codeline">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="codeline">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">4</td>
    <td class="codeline">// See https://llvm.org/LICENSE.txt for license information.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="codeline">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">5</td>
    <td class="codeline">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="codeline">//</td>
    <td class="lineNumber">6</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">7</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="codeline">//</td>
    <td class="lineNumber">8</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="codeline">// Loops should be simplified before this analysis.</td>
    <td class="lineNumber">9</td>
    <td class="codeline">// Loops should be simplified before this analysis.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="codeline">//</td>
    <td class="lineNumber">10</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">11</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="codeline"></td>
    <td class="lineNumber">12</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="codeline">#include "llvm/Analysis/BlockFrequencyInfoImpl.h"</td>
    <td class="lineNumber">13</td>
    <td class="codeline">#include "llvm/Analysis/BlockFrequencyInfoImpl.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="codeline">#include "llvm/ADT/APInt.h"</td>
    <td class="lineNumber">14</td>
    <td class="codeline">#include "llvm/ADT/APInt.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="codeline">#include "llvm/ADT/DenseMap.h"</td>
    <td class="lineNumber">15</td>
    <td class="codeline">#include "llvm/ADT/DenseMap.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="codeline">#include "llvm/ADT/SCCIterator.h"</td>
    <td class="lineNumber">16</td>
    <td class="codeline">#include "llvm/ADT/SCCIterator.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="codeline">#include "llvm/ADT/SmallString.h"</td>
    <td class="lineNumber">17</td>
    <td class="codeline">#include "llvm/ADT/SmallString.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="codeline">#include "llvm/Config/llvm-config.h"</td>
    <td class="lineNumber">18</td>
    <td class="codeline">#include "llvm/Config/llvm-config.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="codeline">#include "llvm/IR/Function.h"</td>
    <td class="lineNumber">19</td>
    <td class="codeline">#include "llvm/IR/Function.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="codeline">#include "llvm/Support/BlockFrequency.h"</td>
    <td class="lineNumber">20</td>
    <td class="codeline">#include "llvm/Support/BlockFrequency.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="codeline">#include "llvm/Support/BranchProbability.h"</td>
    <td class="lineNumber">21</td>
    <td class="codeline">#include "llvm/Support/BranchProbability.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="codeline">#include "llvm/Support/Compiler.h"</td>
    <td class="lineNumber">22</td>
    <td class="codeline">#include "llvm/Support/Compiler.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="codeline">#include "llvm/Support/Debug.h"</td>
    <td class="lineNumber">23</td>
    <td class="codeline">#include "llvm/Support/Debug.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="codeline">#include "llvm/Support/MathExtras.h"</td>
    <td class="lineNumber">24</td>
    <td class="codeline">#include "llvm/Support/MathExtras.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="codeline">#include "llvm/Support/ScaledNumber.h"</td>
    <td class="lineNumber">25</td>
    <td class="codeline">#include "llvm/Support/ScaledNumber.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="codeline">#include "llvm/Support/raw_ostream.h"</td>
    <td class="lineNumber">26</td>
    <td class="codeline">#include "llvm/Support/raw_ostream.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="codeline">#include <algorithm></td>
    <td class="lineNumber">27</td>
    <td class="codeline">#include <algorithm></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="codeline">#include <cassert></td>
    <td class="lineNumber">28</td>
    <td class="codeline">#include <cassert></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="codeline">#include <cstddef></td>
    <td class="lineNumber">29</td>
    <td class="codeline">#include <cstddef></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="codeline">#include <cstdint></td>
    <td class="lineNumber">30</td>
    <td class="codeline">#include <cstdint></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="codeline">#include <iterator></td>
    <td class="lineNumber">31</td>
    <td class="codeline">#include <iterator></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="codeline">#include <list></td>
    <td class="lineNumber">32</td>
    <td class="codeline">#include <list></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="codeline">#include <numeric></td>
    <td class="lineNumber">33</td>
    <td class="codeline">#include <numeric></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="codeline">#include <optional></td>
    <td class="lineNumber">34</td>
    <td class="codeline">#include <optional></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="codeline">#include <utility></td>
    <td class="lineNumber">35</td>
    <td class="codeline">#include <utility></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="codeline">#include <vector></td>
    <td class="lineNumber">36</td>
    <td class="codeline">#include <vector></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="codeline"></td>
    <td class="lineNumber">37</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="codeline">using namespace llvm;</td>
    <td class="lineNumber">38</td>
    <td class="codeline">using namespace llvm;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="codeline">using namespace llvm::bfi_detail;</td>
    <td class="lineNumber">39</td>
    <td class="codeline">using namespace llvm::bfi_detail;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="codeline"></td>
    <td class="lineNumber">40</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="codeline">#define DEBUG_TYPE "block-freq"</td>
    <td class="lineNumber">41</td>
    <td class="codeline">#define DEBUG_TYPE "block-freq"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="codeline"></td>
    <td class="lineNumber">42</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="codeline">namespace llvm {</td>
    <td class="lineNumber">43</td>
    <td class="codeline">namespace llvm {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="codeline">cl::opt<bool> CheckBFIUnknownBlockQueries(</td>
    <td class="lineNumber">44</td>
    <td class="codeline">cl::opt<bool> CheckBFIUnknownBlockQueries(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="codeline">    "check-bfi-unknown-block-queries",</td>
    <td class="lineNumber">45</td>
    <td class="codeline">    "check-bfi-unknown-block-queries",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="codeline">    cl::init(false), cl::Hidden,</td>
    <td class="lineNumber">46</td>
    <td class="codeline">    cl::init(false), cl::Hidden,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="codeline">    cl::desc("Check if block frequency is queried for an unknown block "</td>
    <td class="lineNumber">47</td>
    <td class="codeline">    cl::desc("Check if block frequency is queried for an unknown block "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="codeline">             "for debugging missed BFI updates"));</td>
    <td class="lineNumber">48</td>
    <td class="codeline">             "for debugging missed BFI updates"));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="codeline"></td>
    <td class="lineNumber">49</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="codeline">cl::opt<bool> UseIterativeBFIInference(</td>
    <td class="lineNumber">50</td>
    <td class="codeline">cl::opt<bool> UseIterativeBFIInference(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="codeline">    "use-iterative-bfi-inference", cl::Hidden,</td>
    <td class="lineNumber">51</td>
    <td class="codeline">    "use-iterative-bfi-inference", cl::Hidden,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="codeline">    cl::desc("Apply an iterative post-processing to infer correct BFI counts"));</td>
    <td class="lineNumber">52</td>
    <td class="codeline">    cl::desc("Apply an iterative post-processing to infer correct BFI counts"));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="codeline"></td>
    <td class="lineNumber">53</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="codeline">cl::opt<unsigned> IterativeBFIMaxIterationsPerBlock(</td>
    <td class="lineNumber">54</td>
    <td class="codeline">cl::opt<unsigned> IterativeBFIMaxIterationsPerBlock(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="codeline">    "iterative-bfi-max-iterations-per-block", cl::init(1000), cl::Hidden,</td>
    <td class="lineNumber">55</td>
    <td class="codeline">    "iterative-bfi-max-iterations-per-block", cl::init(1000), cl::Hidden,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="codeline">    cl::desc("Iterative inference: maximum number of update iterations "</td>
    <td class="lineNumber">56</td>
    <td class="codeline">    cl::desc("Iterative inference: maximum number of update iterations "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="codeline">             "per block"));</td>
    <td class="lineNumber">57</td>
    <td class="codeline">             "per block"));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="codeline"></td>
    <td class="lineNumber">58</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="codeline">cl::opt<double> IterativeBFIPrecision(</td>
    <td class="lineNumber">59</td>
    <td class="codeline">cl::opt<double> IterativeBFIPrecision(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="codeline">    "iterative-bfi-precision", cl::init(1e-12), cl::Hidden,</td>
    <td class="lineNumber">60</td>
    <td class="codeline">    "iterative-bfi-precision", cl::init(1e-12), cl::Hidden,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="codeline">    cl::desc("Iterative inference: delta convergence precision; smaller values "</td>
    <td class="lineNumber">61</td>
    <td class="codeline">    cl::desc("Iterative inference: delta convergence precision; smaller values "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="codeline">             "typically lead to better results at the cost of worsen runtime"));</td>
    <td class="lineNumber">62</td>
    <td class="codeline">             "typically lead to better results at the cost of worsen runtime"));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="codeline">} // namespace llvm</td>
    <td class="lineNumber">63</td>
    <td class="codeline">} // namespace llvm</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="codeline"></td>
    <td class="lineNumber">64</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="codeline">ScaledNumber<uint64_t> BlockMass::toScaled() const {</td>
    <td class="lineNumber">65</td>
    <td class="codeline">ScaledNumber<uint64_t> BlockMass::toScaled() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="codeline">  if (isFull())</td>
    <td class="lineNumber">66</td>
    <td class="codeline">  if (isFull())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="codeline">    return ScaledNumber<uint64_t>(1, 0);</td>
    <td class="lineNumber">67</td>
    <td class="codeline">    return ScaledNumber<uint64_t>(1, 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="codeline">  return ScaledNumber<uint64_t>(getMass() + 1, -64);</td>
    <td class="lineNumber">68</td>
    <td class="codeline">  return ScaledNumber<uint64_t>(getMass() + 1, -64);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="codeline">}</td>
    <td class="lineNumber">69</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="codeline"></td>
    <td class="lineNumber">70</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="codeline">#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)</td>
    <td class="lineNumber">71</td>
    <td class="codeline">#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="codeline">LLVM_DUMP_METHOD void BlockMass::dump() const { print(dbgs()); }</td>
    <td class="lineNumber">72</td>
    <td class="codeline">LLVM_DUMP_METHOD void BlockMass::dump() const { print(dbgs()); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="codeline">#endif</td>
    <td class="lineNumber">73</td>
    <td class="codeline">#endif</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="codeline"></td>
    <td class="lineNumber">74</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="codeline">static char getHexDigit(int N) {</td>
    <td class="lineNumber">75</td>
    <td class="codeline">static char getHexDigit(int N) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="codeline">  assert(N < 16);</td>
    <td class="lineNumber">76</td>
    <td class="codeline">  assert(N < 16);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="codeline">  if (N < 10)</td>
    <td class="lineNumber">77</td>
    <td class="codeline">  if (N < 10)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="codeline">    return '0' + N;</td>
    <td class="lineNumber">78</td>
    <td class="codeline">    return '0' + N;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="codeline">  return 'a' + N - 10;</td>
    <td class="lineNumber">79</td>
    <td class="codeline">  return 'a' + N - 10;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="codeline">}</td>
    <td class="lineNumber">80</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="codeline"></td>
    <td class="lineNumber">81</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="codeline">raw_ostream &BlockMass::print(raw_ostream &OS) const {</td>
    <td class="lineNumber">82</td>
    <td class="codeline">raw_ostream &BlockMass::print(raw_ostream &OS) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="codeline">  for (int Digits = 0; Digits < 16; ++Digits)</td>
    <td class="lineNumber">83</td>
    <td class="codeline">  for (int Digits = 0; Digits < 16; ++Digits)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="codeline">    OS << getHexDigit(Mass >> (60 - Digits * 4) & 0xf);</td>
    <td class="lineNumber">84</td>
    <td class="codeline">    OS << getHexDigit(Mass >> (60 - Digits * 4) & 0xf);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="codeline">  return OS;</td>
    <td class="lineNumber">85</td>
    <td class="codeline">  return OS;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="codeline">}</td>
    <td class="lineNumber">86</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="codeline"></td>
    <td class="lineNumber">87</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="codeline">namespace {</td>
    <td class="lineNumber">88</td>
    <td class="codeline">namespace {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="codeline"></td>
    <td class="lineNumber">89</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="codeline">using BlockNode = BlockFrequencyInfoImplBase::BlockNode;</td>
    <td class="lineNumber">90</td>
    <td class="codeline">using BlockNode = BlockFrequencyInfoImplBase::BlockNode;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="codeline">using Distribution = BlockFrequencyInfoImplBase::Distribution;</td>
    <td class="lineNumber">91</td>
    <td class="codeline">using Distribution = BlockFrequencyInfoImplBase::Distribution;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="codeline">using WeightList = BlockFrequencyInfoImplBase::Distribution::WeightList;</td>
    <td class="lineNumber">92</td>
    <td class="codeline">using WeightList = BlockFrequencyInfoImplBase::Distribution::WeightList;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="codeline">using Scaled64 = BlockFrequencyInfoImplBase::Scaled64;</td>
    <td class="lineNumber">93</td>
    <td class="codeline">using Scaled64 = BlockFrequencyInfoImplBase::Scaled64;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="codeline">using LoopData = BlockFrequencyInfoImplBase::LoopData;</td>
    <td class="lineNumber">94</td>
    <td class="codeline">using LoopData = BlockFrequencyInfoImplBase::LoopData;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="codeline">using Weight = BlockFrequencyInfoImplBase::Weight;</td>
    <td class="lineNumber">95</td>
    <td class="codeline">using Weight = BlockFrequencyInfoImplBase::Weight;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="codeline">using FrequencyData = BlockFrequencyInfoImplBase::FrequencyData;</td>
    <td class="lineNumber">96</td>
    <td class="codeline">using FrequencyData = BlockFrequencyInfoImplBase::FrequencyData;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="codeline"></td>
    <td class="lineNumber">97</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="codeline">/// Dithering mass distributer.</td>
    <td class="lineNumber">98</td>
    <td class="codeline">/// Dithering mass distributer.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="codeline">///</td>
    <td class="lineNumber">99</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="codeline">/// This class splits up a single mass into portions by weight, dithering to</td>
    <td class="lineNumber">100</td>
    <td class="codeline">/// This class splits up a single mass into portions by weight, dithering to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="codeline">/// spread out error.  No mass is lost.  The dithering precision depends on the</td>
    <td class="lineNumber">101</td>
    <td class="codeline">/// spread out error.  No mass is lost.  The dithering precision depends on the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="codeline">/// precision of the product of \a BlockMass and \a BranchProbability.</td>
    <td class="lineNumber">102</td>
    <td class="codeline">/// precision of the product of \a BlockMass and \a BranchProbability.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="codeline">///</td>
    <td class="lineNumber">103</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="codeline">/// The distribution algorithm follows.</td>
    <td class="lineNumber">104</td>
    <td class="codeline">/// The distribution algorithm follows.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="codeline">///</td>
    <td class="lineNumber">105</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="codeline">///  1. Initialize by saving the sum of the weights in \a RemWeight and the</td>
    <td class="lineNumber">106</td>
    <td class="codeline">///  1. Initialize by saving the sum of the weights in \a RemWeight and the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="codeline">///     mass to distribute in \a RemMass.</td>
    <td class="lineNumber">107</td>
    <td class="codeline">///     mass to distribute in \a RemMass.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="codeline">///</td>
    <td class="lineNumber">108</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="codeline">///  2. For each portion:</td>
    <td class="lineNumber">109</td>
    <td class="codeline">///  2. For each portion:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="codeline">///</td>
    <td class="lineNumber">110</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="codeline">///      1. Construct a branch probability, P, as the portion's weight divided</td>
    <td class="lineNumber">111</td>
    <td class="codeline">///      1. Construct a branch probability, P, as the portion's weight divided</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="codeline">///         by the current value of \a RemWeight.</td>
    <td class="lineNumber">112</td>
    <td class="codeline">///         by the current value of \a RemWeight.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="codeline">///      2. Calculate the portion's mass as \a RemMass times P.</td>
    <td class="lineNumber">113</td>
    <td class="codeline">///      2. Calculate the portion's mass as \a RemMass times P.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="codeline">///      3. Update \a RemWeight and \a RemMass at each portion by subtracting</td>
    <td class="lineNumber">114</td>
    <td class="codeline">///      3. Update \a RemWeight and \a RemMass at each portion by subtracting</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="codeline">///         the current portion's weight and mass.</td>
    <td class="lineNumber">115</td>
    <td class="codeline">///         the current portion's weight and mass.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="codeline">struct DitheringDistributer {</td>
    <td class="lineNumber">116</td>
    <td class="codeline">struct DitheringDistributer {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="codeline">  uint32_t RemWeight;</td>
    <td class="lineNumber">117</td>
    <td class="codeline">  uint32_t RemWeight;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="codeline">  BlockMass RemMass;</td>
    <td class="lineNumber">118</td>
    <td class="codeline">  BlockMass RemMass;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="codeline"></td>
    <td class="lineNumber">119</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="codeline">  DitheringDistributer(Distribution &Dist, const BlockMass &Mass);</td>
    <td class="lineNumber">120</td>
    <td class="codeline">  DitheringDistributer(Distribution &Dist, const BlockMass &Mass);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="codeline"></td>
    <td class="lineNumber">121</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="codeline">  BlockMass takeMass(uint32_t Weight);</td>
    <td class="lineNumber">122</td>
    <td class="codeline">  BlockMass takeMass(uint32_t Weight);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="codeline">};</td>
    <td class="lineNumber">123</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="codeline"></td>
    <td class="lineNumber">124</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="codeline">} // end anonymous namespace</td>
    <td class="lineNumber">125</td>
    <td class="codeline">} // end anonymous namespace</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="codeline"></td>
    <td class="lineNumber">126</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="codeline">DitheringDistributer::DitheringDistributer(Distribution &Dist,</td>
    <td class="lineNumber">127</td>
    <td class="codeline">DitheringDistributer::DitheringDistributer(Distribution &Dist,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="codeline">                                           const BlockMass &Mass) {</td>
    <td class="lineNumber">128</td>
    <td class="codeline">                                           const BlockMass &Mass) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="codeline">  Dist.normalize();</td>
    <td class="lineNumber">129</td>
    <td class="codeline">  Dist.normalize();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="codeline">  RemWeight = Dist.Total;</td>
    <td class="lineNumber">130</td>
    <td class="codeline">  RemWeight = Dist.Total;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="codeline">  RemMass = Mass;</td>
    <td class="lineNumber">131</td>
    <td class="codeline">  RemMass = Mass;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="codeline">}</td>
    <td class="lineNumber">132</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="codeline"></td>
    <td class="lineNumber">133</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="codeline">BlockMass DitheringDistributer::takeMass(uint32_t Weight) {</td>
    <td class="lineNumber">134</td>
    <td class="codeline">BlockMass DitheringDistributer::takeMass(uint32_t Weight) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="codeline">  assert(Weight && "invalid weight");</td>
    <td class="lineNumber">135</td>
    <td class="codeline">  assert(Weight && "invalid weight");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="codeline">  assert(Weight <= RemWeight);</td>
    <td class="lineNumber">136</td>
    <td class="codeline">  assert(Weight <= RemWeight);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="codeline">  BlockMass Mass = RemMass * BranchProbability(Weight, RemWeight);</td>
    <td class="lineNumber">137</td>
    <td class="codeline">  BlockMass Mass = RemMass * BranchProbability(Weight, RemWeight);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="codeline"></td>
    <td class="lineNumber">138</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="codeline">  // Decrement totals (dither).</td>
    <td class="lineNumber">139</td>
    <td class="codeline">  // Decrement totals (dither).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="codeline">  RemWeight -= Weight;</td>
    <td class="lineNumber">140</td>
    <td class="codeline">  RemWeight -= Weight;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="codeline">  RemMass -= Mass;</td>
    <td class="lineNumber">141</td>
    <td class="codeline">  RemMass -= Mass;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="codeline">  return Mass;</td>
    <td class="lineNumber">142</td>
    <td class="codeline">  return Mass;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="codeline">}</td>
    <td class="lineNumber">143</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="codeline"></td>
    <td class="lineNumber">144</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="codeline">void Distribution::add(const BlockNode &Node, uint64_t Amount,</td>
    <td class="lineNumber">145</td>
    <td class="codeline">void Distribution::add(const BlockNode &Node, uint64_t Amount,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="codeline">                       Weight::DistType Type) {</td>
    <td class="lineNumber">146</td>
    <td class="codeline">                       Weight::DistType Type) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="codeline">  assert(Amount && "invalid weight of 0");</td>
    <td class="lineNumber">147</td>
    <td class="codeline">  assert(Amount && "invalid weight of 0");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="codeline">  uint64_t NewTotal = Total + Amount;</td>
    <td class="lineNumber">148</td>
    <td class="codeline">  uint64_t NewTotal = Total + Amount;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="codeline"></td>
    <td class="lineNumber">149</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="codeline">  // Check for overflow.  It should be impossible to overflow twice.</td>
    <td class="lineNumber">150</td>
    <td class="codeline">  // Check for overflow.  It should be impossible to overflow twice.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="codeline">  bool IsOverflow = NewTotal < Total;</td>
    <td class="lineNumber">151</td>
    <td class="codeline">  bool IsOverflow = NewTotal < Total;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="codeline">  assert(!(DidOverflow && IsOverflow) && "unexpected repeated overflow");</td>
    <td class="lineNumber">152</td>
    <td class="codeline">  assert(!(DidOverflow && IsOverflow) && "unexpected repeated overflow");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="codeline">  DidOverflow |= IsOverflow;</td>
    <td class="lineNumber">153</td>
    <td class="codeline">  DidOverflow |= IsOverflow;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="codeline"></td>
    <td class="lineNumber">154</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="codeline">  // Update the total.</td>
    <td class="lineNumber">155</td>
    <td class="codeline">  // Update the total.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="codeline">  Total = NewTotal;</td>
    <td class="lineNumber">156</td>
    <td class="codeline">  Total = NewTotal;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="codeline"></td>
    <td class="lineNumber">157</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="codeline">  // Save the weight.</td>
    <td class="lineNumber">158</td>
    <td class="codeline">  // Save the weight.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="codeline">  Weights.push_back(Weight(Type, Node, Amount));</td>
    <td class="lineNumber">159</td>
    <td class="codeline">  Weights.push_back(Weight(Type, Node, Amount));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="codeline">}</td>
    <td class="lineNumber">160</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="codeline"></td>
    <td class="lineNumber">161</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="codeline">static void combineWeight(Weight &W, const Weight &OtherW) {</td>
    <td class="lineNumber">162</td>
    <td class="codeline">static void combineWeight(Weight &W, const Weight &OtherW) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="codeline">  assert(OtherW.TargetNode.isValid());</td>
    <td class="lineNumber">163</td>
    <td class="codeline">  assert(OtherW.TargetNode.isValid());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="codeline">  if (!W.Amount) {</td>
    <td class="lineNumber">164</td>
    <td class="codeline">  if (!W.Amount) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="codeline">    W = OtherW;</td>
    <td class="lineNumber">165</td>
    <td class="codeline">    W = OtherW;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">166</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">167</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="codeline">  assert(W.Type == OtherW.Type);</td>
    <td class="lineNumber">168</td>
    <td class="codeline">  assert(W.Type == OtherW.Type);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="codeline">  assert(W.TargetNode == OtherW.TargetNode);</td>
    <td class="lineNumber">169</td>
    <td class="codeline">  assert(W.TargetNode == OtherW.TargetNode);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="codeline">  assert(OtherW.Amount && "Expected non-zero weight");</td>
    <td class="lineNumber">170</td>
    <td class="codeline">  assert(OtherW.Amount && "Expected non-zero weight");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="codeline">  if (W.Amount > W.Amount + OtherW.Amount)</td>
    <td class="lineNumber">171</td>
    <td class="codeline">  if (W.Amount > W.Amount + OtherW.Amount)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="codeline">    // Saturate on overflow.</td>
    <td class="lineNumber">172</td>
    <td class="codeline">    // Saturate on overflow.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="codeline">    W.Amount = UINT64_MAX;</td>
    <td class="lineNumber">173</td>
    <td class="codeline">    W.Amount = UINT64_MAX;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="codeline">  else</td>
    <td class="lineNumber">174</td>
    <td class="codeline">  else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="codeline">    W.Amount += OtherW.Amount;</td>
    <td class="lineNumber">175</td>
    <td class="codeline">    W.Amount += OtherW.Amount;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="codeline">}</td>
    <td class="lineNumber">176</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="codeline"></td>
    <td class="lineNumber">177</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="codeline">static void combineWeightsBySorting(WeightList &Weights) {</td>
    <td class="lineNumber">178</td>
    <td class="codeline">static void combineWeightsBySorting(WeightList &Weights) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="codeline">  // Sort so edges to the same node are adjacent.</td>
    <td class="lineNumber">179</td>
    <td class="codeline">  // Sort so edges to the same node are adjacent.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="codeline">  llvm::sort(Weights, [](const Weight &L, const Weight &R) {</td>
    <td class="lineNumber">180</td>
    <td class="codeline">  llvm::sort(Weights, [](const Weight &L, const Weight &R) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="codeline">    return L.TargetNode < R.TargetNode;</td>
    <td class="lineNumber">181</td>
    <td class="codeline">    return L.TargetNode < R.TargetNode;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="codeline">  });</td>
    <td class="lineNumber">182</td>
    <td class="codeline">  });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="codeline"></td>
    <td class="lineNumber">183</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="codeline">  // Combine adjacent edges.</td>
    <td class="lineNumber">184</td>
    <td class="codeline">  // Combine adjacent edges.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="codeline">  WeightList::iterator O = Weights.begin();</td>
    <td class="lineNumber">185</td>
    <td class="codeline">  WeightList::iterator O = Weights.begin();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="codeline">  for (WeightList::const_iterator I = O, L = O, E = Weights.end(); I != E;</td>
    <td class="lineNumber">186</td>
    <td class="codeline">  for (WeightList::const_iterator I = O, L = O, E = Weights.end(); I != E;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="codeline">       ++O, (I = L)) {</td>
    <td class="lineNumber">187</td>
    <td class="codeline">       ++O, (I = L)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="codeline">    *O = *I;</td>
    <td class="lineNumber">188</td>
    <td class="codeline">    *O = *I;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="codeline"></td>
    <td class="lineNumber">189</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="codeline">    // Find the adjacent weights to the same node.</td>
    <td class="lineNumber">190</td>
    <td class="codeline">    // Find the adjacent weights to the same node.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="codeline">    for (++L; L != E && I->TargetNode == L->TargetNode; ++L)</td>
    <td class="lineNumber">191</td>
    <td class="codeline">    for (++L; L != E && I->TargetNode == L->TargetNode; ++L)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="codeline">      combineWeight(*O, *L);</td>
    <td class="lineNumber">192</td>
    <td class="codeline">      combineWeight(*O, *L);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">193</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="codeline"></td>
    <td class="lineNumber">194</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="codeline">  // Erase extra entries.</td>
    <td class="lineNumber">195</td>
    <td class="codeline">  // Erase extra entries.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="codeline">  Weights.erase(O, Weights.end());</td>
    <td class="lineNumber">196</td>
    <td class="codeline">  Weights.erase(O, Weights.end());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="codeline">}</td>
    <td class="lineNumber">197</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="codeline"></td>
    <td class="lineNumber">198</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="codeline">static void combineWeightsByHashing(WeightList &Weights) {</td>
    <td class="lineNumber">199</td>
    <td class="codeline">static void combineWeightsByHashing(WeightList &Weights) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="codeline">  // Collect weights into a DenseMap.</td>
    <td class="lineNumber">200</td>
    <td class="codeline">  // Collect weights into a DenseMap.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="codeline">  using HashTable = DenseMap<BlockNode::IndexType, Weight>;</td>
    <td class="lineNumber">201</td>
    <td class="codeline">  using HashTable = DenseMap<BlockNode::IndexType, Weight>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="codeline"></td>
    <td class="lineNumber">202</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="codeline">  HashTable Combined(NextPowerOf2(2 * Weights.size()));</td>
    <td class="lineNumber">203</td>
    <td class="codeline">  HashTable Combined(NextPowerOf2(2 * Weights.size()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="codeline">  for (const Weight &W : Weights)</td>
    <td class="lineNumber">204</td>
    <td class="codeline">  for (const Weight &W : Weights)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="codeline">    combineWeight(Combined[W.TargetNode.Index], W);</td>
    <td class="lineNumber">205</td>
    <td class="codeline">    combineWeight(Combined[W.TargetNode.Index], W);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="codeline"></td>
    <td class="lineNumber">206</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="codeline">  // Check whether anything changed.</td>
    <td class="lineNumber">207</td>
    <td class="codeline">  // Check whether anything changed.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="codeline">  if (Weights.size() == Combined.size())</td>
    <td class="lineNumber">208</td>
    <td class="codeline">  if (Weights.size() == Combined.size())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">209</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="codeline"></td>
    <td class="lineNumber">210</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="codeline">  // Fill in the new weights.</td>
    <td class="lineNumber">211</td>
    <td class="codeline">  // Fill in the new weights.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="codeline">  Weights.clear();</td>
    <td class="lineNumber">212</td>
    <td class="codeline">  Weights.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="codeline">  Weights.reserve(Combined.size());</td>
    <td class="lineNumber">213</td>
    <td class="codeline">  Weights.reserve(Combined.size());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="codeline">  for (const auto &I : Combined)</td>
    <td class="lineNumber">214</td>
    <td class="codeline">  for (const auto &I : Combined)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="codeline">    Weights.push_back(I.second);</td>
    <td class="lineNumber">215</td>
    <td class="codeline">    Weights.push_back(I.second);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="codeline">}</td>
    <td class="lineNumber">216</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="codeline"></td>
    <td class="lineNumber">217</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="codeline">static void combineWeights(WeightList &Weights) {</td>
    <td class="lineNumber">218</td>
    <td class="codeline">static void combineWeights(WeightList &Weights) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="codeline">  // Use a hash table for many successors to keep this linear.</td>
    <td class="lineNumber">219</td>
    <td class="codeline">  // Use a hash table for many successors to keep this linear.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="codeline">  if (Weights.size() > 128) {</td>
    <td class="lineNumber">220</td>
    <td class="codeline">  if (Weights.size() > 128) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="codeline">    combineWeightsByHashing(Weights);</td>
    <td class="lineNumber">221</td>
    <td class="codeline">    combineWeightsByHashing(Weights);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">222</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">223</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="codeline"></td>
    <td class="lineNumber">224</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="codeline">  combineWeightsBySorting(Weights);</td>
    <td class="lineNumber">225</td>
    <td class="codeline">  combineWeightsBySorting(Weights);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="codeline">}</td>
    <td class="lineNumber">226</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="codeline"></td>
    <td class="lineNumber">227</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="codeline">static uint64_t shiftRightAndRound(uint64_t N, int Shift) {</td>
    <td class="lineNumber">228</td>
    <td class="codeline">static uint64_t shiftRightAndRound(uint64_t N, int Shift) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="codeline">  assert(Shift >= 0);</td>
    <td class="lineNumber">229</td>
    <td class="codeline">  assert(Shift >= 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="codeline">  assert(Shift < 64);</td>
    <td class="lineNumber">230</td>
    <td class="codeline">  assert(Shift < 64);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="codeline">  if (!Shift)</td>
    <td class="lineNumber">231</td>
    <td class="codeline">  if (!Shift)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="codeline">    return N;</td>
    <td class="lineNumber">232</td>
    <td class="codeline">    return N;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="codeline">  return (N >> Shift) + (UINT64_C(1) & N >> (Shift - 1));</td>
    <td class="lineNumber">233</td>
    <td class="codeline">  return (N >> Shift) + (UINT64_C(1) & N >> (Shift - 1));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="codeline">}</td>
    <td class="lineNumber">234</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="codeline"></td>
    <td class="lineNumber">235</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="codeline">void Distribution::normalize() {</td>
    <td class="lineNumber">236</td>
    <td class="codeline">void Distribution::normalize() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="codeline">  // Early exit for termination nodes.</td>
    <td class="lineNumber">237</td>
    <td class="codeline">  // Early exit for termination nodes.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="codeline">  if (Weights.empty())</td>
    <td class="lineNumber">238</td>
    <td class="codeline">  if (Weights.empty())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">239</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="codeline"></td>
    <td class="lineNumber">240</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="codeline">  // Only bother if there are multiple successors.</td>
    <td class="lineNumber">241</td>
    <td class="codeline">  // Only bother if there are multiple successors.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="codeline">  if (Weights.size() > 1)</td>
    <td class="lineNumber">242</td>
    <td class="codeline">  if (Weights.size() > 1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="codeline">    combineWeights(Weights);</td>
    <td class="lineNumber">243</td>
    <td class="codeline">    combineWeights(Weights);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="codeline"></td>
    <td class="lineNumber">244</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="codeline">  // Early exit when combined into a single successor.</td>
    <td class="lineNumber">245</td>
    <td class="codeline">  // Early exit when combined into a single successor.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="codeline">  if (Weights.size() == 1) {</td>
    <td class="lineNumber">246</td>
    <td class="codeline">  if (Weights.size() == 1) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="codeline">    Total = 1;</td>
    <td class="lineNumber">247</td>
    <td class="codeline">    Total = 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="codeline">    Weights.front().Amount = 1;</td>
    <td class="lineNumber">248</td>
    <td class="codeline">    Weights.front().Amount = 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">249</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">250</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="codeline"></td>
    <td class="lineNumber">251</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="codeline">  // Determine how much to shift right so that the total fits into 32-bits.</td>
    <td class="lineNumber">252</td>
    <td class="codeline">  // Determine how much to shift right so that the total fits into 32-bits.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">253</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="codeline">  // If we shift at all, shift by 1 extra.  Otherwise, the lower limit of 1</td>
    <td class="lineNumber">254</td>
    <td class="codeline">  // If we shift at all, shift by 1 extra.  Otherwise, the lower limit of 1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="codeline">  // for each weight can cause a 32-bit overflow.</td>
    <td class="lineNumber">255</td>
    <td class="codeline">  // for each weight can cause a 32-bit overflow.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="codeline">  int Shift = 0;</td>
    <td class="lineNumber">256</td>
    <td class="codeline">  int Shift = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="codeline">  if (DidOverflow)</td>
    <td class="lineNumber">257</td>
    <td class="codeline">  if (DidOverflow)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="codeline">    Shift = 33;</td>
    <td class="lineNumber">258</td>
    <td class="codeline">    Shift = 33;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="codeline">  else if (Total > UINT32_MAX)</td>
    <td class="lineNumber">259</td>
    <td class="codeline">  else if (Total > UINT32_MAX)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="codeline">    Shift = 33 - llvm::countl_zero(Total);</td>
    <td class="lineNumber">260</td>
    <td class="codeline">    Shift = 33 - llvm::countl_zero(Total);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="codeline"></td>
    <td class="lineNumber">261</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="codeline">  // Early exit if nothing needs to be scaled.</td>
    <td class="lineNumber">262</td>
    <td class="codeline">  // Early exit if nothing needs to be scaled.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="codeline">  if (!Shift) {</td>
    <td class="lineNumber">263</td>
    <td class="codeline">  if (!Shift) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="codeline">    // If we didn't overflow then combineWeights() shouldn't have changed the</td>
    <td class="lineNumber">264</td>
    <td class="codeline">    // If we didn't overflow then combineWeights() shouldn't have changed the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="codeline">    // sum of the weights, but let's double-check.</td>
    <td class="lineNumber">265</td>
    <td class="codeline">    // sum of the weights, but let's double-check.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="codeline">    assert(Total == std::accumulate(Weights.begin(), Weights.end(), UINT64_C(0),</td>
    <td class="lineNumber">266</td>
    <td class="codeline">    assert(Total == std::accumulate(Weights.begin(), Weights.end(), UINT64_C(0),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="codeline">                                    [](uint64_t Sum, const Weight &W) {</td>
    <td class="lineNumber">267</td>
    <td class="codeline">                                    [](uint64_t Sum, const Weight &W) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="codeline">                      return Sum + W.Amount;</td>
    <td class="lineNumber">268</td>
    <td class="codeline">                      return Sum + W.Amount;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="codeline">                    }) &&</td>
    <td class="lineNumber">269</td>
    <td class="codeline">                    }) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="codeline">           "Expected total to be correct");</td>
    <td class="lineNumber">270</td>
    <td class="codeline">           "Expected total to be correct");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">271</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">272</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="codeline"></td>
    <td class="lineNumber">273</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="codeline">  // Recompute the total through accumulation (rather than shifting it) so that</td>
    <td class="lineNumber">274</td>
    <td class="codeline">  // Recompute the total through accumulation (rather than shifting it) so that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="codeline">  // it's accurate after shifting and any changes combineWeights() made above.</td>
    <td class="lineNumber">275</td>
    <td class="codeline">  // it's accurate after shifting and any changes combineWeights() made above.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="codeline">  Total = 0;</td>
    <td class="lineNumber">276</td>
    <td class="codeline">  Total = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="codeline"></td>
    <td class="lineNumber">277</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="codeline">  // Sum the weights to each node and shift right if necessary.</td>
    <td class="lineNumber">278</td>
    <td class="codeline">  // Sum the weights to each node and shift right if necessary.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="codeline">  for (Weight &W : Weights) {</td>
    <td class="lineNumber">279</td>
    <td class="codeline">  for (Weight &W : Weights) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="codeline">    // Scale down below UINT32_MAX.  Since Shift is larger than necessary, we</td>
    <td class="lineNumber">280</td>
    <td class="codeline">    // Scale down below UINT32_MAX.  Since Shift is larger than necessary, we</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="codeline">    // can round here without concern about overflow.</td>
    <td class="lineNumber">281</td>
    <td class="codeline">    // can round here without concern about overflow.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="codeline">    assert(W.TargetNode.isValid());</td>
    <td class="lineNumber">282</td>
    <td class="codeline">    assert(W.TargetNode.isValid());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="codeline">    W.Amount = std::max(UINT64_C(1), shiftRightAndRound(W.Amount, Shift));</td>
    <td class="lineNumber">283</td>
    <td class="codeline">    W.Amount = std::max(UINT64_C(1), shiftRightAndRound(W.Amount, Shift));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="codeline">    assert(W.Amount <= UINT32_MAX);</td>
    <td class="lineNumber">284</td>
    <td class="codeline">    assert(W.Amount <= UINT32_MAX);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="codeline"></td>
    <td class="lineNumber">285</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="codeline">    // Update the total.</td>
    <td class="lineNumber">286</td>
    <td class="codeline">    // Update the total.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="codeline">    Total += W.Amount;</td>
    <td class="lineNumber">287</td>
    <td class="codeline">    Total += W.Amount;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">288</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="codeline">  assert(Total <= UINT32_MAX);</td>
    <td class="lineNumber">289</td>
    <td class="codeline">  assert(Total <= UINT32_MAX);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="codeline">}</td>
    <td class="lineNumber">290</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="codeline"></td>
    <td class="lineNumber">291</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="codeline">void BlockFrequencyInfoImplBase::clear() {</td>
    <td class="lineNumber">292</td>
    <td class="codeline">void BlockFrequencyInfoImplBase::clear() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="codeline">  // Swap with a default-constructed std::vector, since std::vector<>::clear()</td>
    <td class="lineNumber">293</td>
    <td class="codeline">  // Swap with a default-constructed std::vector, since std::vector<>::clear()</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="codeline">  // does not actually clear heap storage.</td>
    <td class="lineNumber">294</td>
    <td class="codeline">  // does not actually clear heap storage.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="codeline">  std::vector<FrequencyData>().swap(Freqs);</td>
    <td class="lineNumber">295</td>
    <td class="codeline">  std::vector<FrequencyData>().swap(Freqs);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="codeline">  IsIrrLoopHeader.clear();</td>
    <td class="lineNumber">296</td>
    <td class="codeline">  IsIrrLoopHeader.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="codeline">  std::vector<WorkingData>().swap(Working);</td>
    <td class="lineNumber">297</td>
    <td class="codeline">  std::vector<WorkingData>().swap(Working);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="codeline">  Loops.clear();</td>
    <td class="lineNumber">298</td>
    <td class="codeline">  Loops.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="codeline">}</td>
    <td class="lineNumber">299</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="codeline"></td>
    <td class="lineNumber">300</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="codeline">/// Clear all memory not needed downstream.</td>
    <td class="lineNumber">301</td>
    <td class="codeline">/// Clear all memory not needed downstream.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="codeline">///</td>
    <td class="lineNumber">302</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="codeline">/// Releases all memory not used downstream.  In particular, saves Freqs.</td>
    <td class="lineNumber">303</td>
    <td class="codeline">/// Releases all memory not used downstream.  In particular, saves Freqs.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="codeline">static void cleanup(BlockFrequencyInfoImplBase &BFI) {</td>
    <td class="lineNumber">304</td>
    <td class="codeline">static void cleanup(BlockFrequencyInfoImplBase &BFI) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="codeline">  std::vector<FrequencyData> SavedFreqs(std::move(BFI.Freqs));</td>
    <td class="lineNumber">305</td>
    <td class="codeline">  std::vector<FrequencyData> SavedFreqs(std::move(BFI.Freqs));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="codeline">  SparseBitVector<> SavedIsIrrLoopHeader(std::move(BFI.IsIrrLoopHeader));</td>
    <td class="lineNumber">306</td>
    <td class="codeline">  SparseBitVector<> SavedIsIrrLoopHeader(std::move(BFI.IsIrrLoopHeader));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="codeline">  BFI.clear();</td>
    <td class="lineNumber">307</td>
    <td class="codeline">  BFI.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="codeline">  BFI.Freqs = std::move(SavedFreqs);</td>
    <td class="lineNumber">308</td>
    <td class="codeline">  BFI.Freqs = std::move(SavedFreqs);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="codeline">  BFI.IsIrrLoopHeader = std::move(SavedIsIrrLoopHeader);</td>
    <td class="lineNumber">309</td>
    <td class="codeline">  BFI.IsIrrLoopHeader = std::move(SavedIsIrrLoopHeader);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="codeline">}</td>
    <td class="lineNumber">310</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="codeline"></td>
    <td class="lineNumber">311</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="codeline">bool BlockFrequencyInfoImplBase::addToDist(Distribution &Dist,</td>
    <td class="lineNumber">312</td>
    <td class="codeline">bool BlockFrequencyInfoImplBase::addToDist(Distribution &Dist,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="codeline">                                           const LoopData *OuterLoop,</td>
    <td class="lineNumber">313</td>
    <td class="codeline">                                           const LoopData *OuterLoop,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="codeline">                                           const BlockNode &Pred,</td>
    <td class="lineNumber">314</td>
    <td class="codeline">                                           const BlockNode &Pred,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="codeline">                                           const BlockNode &Succ,</td>
    <td class="lineNumber">315</td>
    <td class="codeline">                                           const BlockNode &Succ,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="codeline">                                           uint64_t Weight) {</td>
    <td class="lineNumber">316</td>
    <td class="codeline">                                           uint64_t Weight) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="codeline">  if (!Weight)</td>
    <td class="lineNumber">317</td>
    <td class="codeline">  if (!Weight)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="codeline">    Weight = 1;</td>
    <td class="lineNumber">318</td>
    <td class="codeline">    Weight = 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="codeline"></td>
    <td class="lineNumber">319</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="codeline">  auto isLoopHeader = [&OuterLoop](const BlockNode &Node) {</td>
    <td class="lineNumber">320</td>
    <td class="codeline">  auto isLoopHeader = [&OuterLoop](const BlockNode &Node) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="codeline">    return OuterLoop && OuterLoop->isHeader(Node);</td>
    <td class="lineNumber">321</td>
    <td class="codeline">    return OuterLoop && OuterLoop->isHeader(Node);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">322</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="codeline"></td>
    <td class="lineNumber">323</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="codeline">  BlockNode Resolved = Working[Succ.Index].getResolvedNode();</td>
    <td class="lineNumber">324</td>
    <td class="codeline">  BlockNode Resolved = Working[Succ.Index].getResolvedNode();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="codeline"></td>
    <td class="lineNumber">325</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="codeline">#ifndef NDEBUG</td>
    <td class="lineNumber">326</td>
    <td class="codeline">#ifndef NDEBUG</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="codeline">  auto debugSuccessor = [&](const char *Type) {</td>
    <td class="lineNumber">327</td>
    <td class="codeline">  auto debugSuccessor = [&](const char *Type) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="codeline">    dbgs() << "  =>"</td>
    <td class="lineNumber">328</td>
    <td class="codeline">    dbgs() << "  =>"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="codeline">           << " [" << Type << "] weight = " << Weight;</td>
    <td class="lineNumber">329</td>
    <td class="codeline">           << " [" << Type << "] weight = " << Weight;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="codeline">    if (!isLoopHeader(Resolved))</td>
    <td class="lineNumber">330</td>
    <td class="codeline">    if (!isLoopHeader(Resolved))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="codeline">      dbgs() << ", succ = " << getBlockName(Succ);</td>
    <td class="lineNumber">331</td>
    <td class="codeline">      dbgs() << ", succ = " << getBlockName(Succ);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="codeline">    if (Resolved != Succ)</td>
    <td class="lineNumber">332</td>
    <td class="codeline">    if (Resolved != Succ)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="codeline">      dbgs() << ", resolved = " << getBlockName(Resolved);</td>
    <td class="lineNumber">333</td>
    <td class="codeline">      dbgs() << ", resolved = " << getBlockName(Resolved);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="codeline">    dbgs() << "\n";</td>
    <td class="lineNumber">334</td>
    <td class="codeline">    dbgs() << "\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">335</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="codeline">  (void)debugSuccessor;</td>
    <td class="lineNumber">336</td>
    <td class="codeline">  (void)debugSuccessor;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="codeline">#endif</td>
    <td class="lineNumber">337</td>
    <td class="codeline">#endif</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="codeline"></td>
    <td class="lineNumber">338</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="codeline">  if (isLoopHeader(Resolved)) {</td>
    <td class="lineNumber">339</td>
    <td class="codeline">  if (isLoopHeader(Resolved)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="codeline">    LLVM_DEBUG(debugSuccessor("backedge"));</td>
    <td class="lineNumber">340</td>
    <td class="codeline">    LLVM_DEBUG(debugSuccessor("backedge"));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="codeline">    Dist.addBackedge(Resolved, Weight);</td>
    <td class="lineNumber">341</td>
    <td class="codeline">    Dist.addBackedge(Resolved, Weight);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">342</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">343</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="codeline"></td>
    <td class="lineNumber">344</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="codeline">  if (Working[Resolved.Index].getContainingLoop() != OuterLoop) {</td>
    <td class="lineNumber">345</td>
    <td class="codeline">  if (Working[Resolved.Index].getContainingLoop() != OuterLoop) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="codeline">    LLVM_DEBUG(debugSuccessor("  exit  "));</td>
    <td class="lineNumber">346</td>
    <td class="codeline">    LLVM_DEBUG(debugSuccessor("  exit  "));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="codeline">    Dist.addExit(Resolved, Weight);</td>
    <td class="lineNumber">347</td>
    <td class="codeline">    Dist.addExit(Resolved, Weight);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">348</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">349</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="codeline"></td>
    <td class="lineNumber">350</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="codeline">  if (Resolved < Pred) {</td>
    <td class="lineNumber">351</td>
    <td class="codeline">  if (Resolved < Pred) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="codeline">    if (!isLoopHeader(Pred)) {</td>
    <td class="lineNumber">352</td>
    <td class="codeline">    if (!isLoopHeader(Pred)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="codeline">      // If OuterLoop is an irreducible loop, we can't actually handle this.</td>
    <td class="lineNumber">353</td>
    <td class="codeline">      // If OuterLoop is an irreducible loop, we can't actually handle this.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="codeline">      assert((!OuterLoop || !OuterLoop->isIrreducible()) &&</td>
    <td class="lineNumber">354</td>
    <td class="codeline">      assert((!OuterLoop || !OuterLoop->isIrreducible()) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="codeline">             "unhandled irreducible control flow");</td>
    <td class="lineNumber">355</td>
    <td class="codeline">             "unhandled irreducible control flow");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="codeline"></td>
    <td class="lineNumber">356</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="codeline">      // Irreducible backedge.  Abort.</td>
    <td class="lineNumber">357</td>
    <td class="codeline">      // Irreducible backedge.  Abort.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="codeline">      LLVM_DEBUG(debugSuccessor("abort!!!"));</td>
    <td class="lineNumber">358</td>
    <td class="codeline">      LLVM_DEBUG(debugSuccessor("abort!!!"));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">359</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">360</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="codeline"></td>
    <td class="lineNumber">361</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="codeline">    // If "Pred" is a loop header, then this isn't really a backedge; rather,</td>
    <td class="lineNumber">362</td>
    <td class="codeline">    // If "Pred" is a loop header, then this isn't really a backedge; rather,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="codeline">    // OuterLoop must be irreducible.  These false backedges can come only from</td>
    <td class="lineNumber">363</td>
    <td class="codeline">    // OuterLoop must be irreducible.  These false backedges can come only from</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="codeline">    // secondary loop headers.</td>
    <td class="lineNumber">364</td>
    <td class="codeline">    // secondary loop headers.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="codeline">    assert(OuterLoop && OuterLoop->isIrreducible() && !isLoopHeader(Resolved) &&</td>
    <td class="lineNumber">365</td>
    <td class="codeline">    assert(OuterLoop && OuterLoop->isIrreducible() && !isLoopHeader(Resolved) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="codeline">           "unhandled irreducible control flow");</td>
    <td class="lineNumber">366</td>
    <td class="codeline">           "unhandled irreducible control flow");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">367</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="codeline"></td>
    <td class="lineNumber">368</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="codeline">  LLVM_DEBUG(debugSuccessor(" local  "));</td>
    <td class="lineNumber">369</td>
    <td class="codeline">  LLVM_DEBUG(debugSuccessor(" local  "));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="codeline">  Dist.addLocal(Resolved, Weight);</td>
    <td class="lineNumber">370</td>
    <td class="codeline">  Dist.addLocal(Resolved, Weight);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="codeline">  return true;</td>
    <td class="lineNumber">371</td>
    <td class="codeline">  return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="codeline">}</td>
    <td class="lineNumber">372</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="codeline"></td>
    <td class="lineNumber">373</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="codeline">bool BlockFrequencyInfoImplBase::addLoopSuccessorsToDist(</td>
    <td class="lineNumber">374</td>
    <td class="codeline">bool BlockFrequencyInfoImplBase::addLoopSuccessorsToDist(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="codeline">    const LoopData *OuterLoop, LoopData &Loop, Distribution &Dist) {</td>
    <td class="lineNumber">375</td>
    <td class="codeline">    const LoopData *OuterLoop, LoopData &Loop, Distribution &Dist) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="codeline">  // Copy the exit map into Dist.</td>
    <td class="lineNumber">376</td>
    <td class="codeline">  // Copy the exit map into Dist.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="codeline">  for (const auto &I : Loop.Exits)</td>
    <td class="lineNumber">377</td>
    <td class="codeline">  for (const auto &I : Loop.Exits)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="codeline">    if (!addToDist(Dist, OuterLoop, Loop.getHeader(), I.first,</td>
    <td class="lineNumber">378</td>
    <td class="codeline">    if (!addToDist(Dist, OuterLoop, Loop.getHeader(), I.first,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="codeline">                   I.second.getMass()))</td>
    <td class="lineNumber">379</td>
    <td class="codeline">                   I.second.getMass()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="codeline">      // Irreducible backedge.</td>
    <td class="lineNumber">380</td>
    <td class="codeline">      // Irreducible backedge.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">381</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="codeline"></td>
    <td class="lineNumber">382</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="codeline">  return true;</td>
    <td class="lineNumber">383</td>
    <td class="codeline">  return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="codeline">}</td>
    <td class="lineNumber">384</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="codeline"></td>
    <td class="lineNumber">385</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="codeline">/// Compute the loop scale for a loop.</td>
    <td class="lineNumber">386</td>
    <td class="codeline">/// Compute the loop scale for a loop.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="codeline">void BlockFrequencyInfoImplBase::computeLoopScale(LoopData &Loop) {</td>
    <td class="lineNumber">387</td>
    <td class="codeline">void BlockFrequencyInfoImplBase::computeLoopScale(LoopData &Loop) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="codeline">  // Compute loop scale.</td>
    <td class="lineNumber">388</td>
    <td class="codeline">  // Compute loop scale.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "compute-loop-scale: " << getLoopName(Loop) << "\n");</td>
    <td class="lineNumber">389</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "compute-loop-scale: " << getLoopName(Loop) << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="codeline"></td>
    <td class="lineNumber">390</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="codeline">  // Infinite loops need special handling. If we give the back edge an infinite</td>
    <td class="lineNumber">391</td>
    <td class="codeline">  // Infinite loops need special handling. If we give the back edge an infinite</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="codeline">  // mass, they may saturate all the other scales in the function down to 1,</td>
    <td class="lineNumber">392</td>
    <td class="codeline">  // mass, they may saturate all the other scales in the function down to 1,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="codeline">  // making all the other region temperatures look exactly the same. Choose an</td>
    <td class="lineNumber">393</td>
    <td class="codeline">  // making all the other region temperatures look exactly the same. Choose an</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="codeline">  // arbitrary scale to avoid these issues.</td>
    <td class="lineNumber">394</td>
    <td class="codeline">  // arbitrary scale to avoid these issues.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">395</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="codeline">  // FIXME: An alternate way would be to select a symbolic scale which is later</td>
    <td class="lineNumber">396</td>
    <td class="codeline">  // FIXME: An alternate way would be to select a symbolic scale which is later</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="codeline">  // replaced to be the maximum of all computed scales plus 1. This would</td>
    <td class="lineNumber">397</td>
    <td class="codeline">  // replaced to be the maximum of all computed scales plus 1. This would</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="codeline">  // appropriately describe the loop as having a large scale, without skewing</td>
    <td class="lineNumber">398</td>
    <td class="codeline">  // appropriately describe the loop as having a large scale, without skewing</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="codeline">  // the final frequency computation.</td>
    <td class="lineNumber">399</td>
    <td class="codeline">  // the final frequency computation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="codeline">  const Scaled64 InfiniteLoopScale(1, 12);</td>
    <td class="lineNumber">400</td>
    <td class="codeline">  const Scaled64 InfiniteLoopScale(1, 12);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="codeline"></td>
    <td class="lineNumber">401</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="codeline">  // LoopScale == 1 / ExitMass</td>
    <td class="lineNumber">402</td>
    <td class="codeline">  // LoopScale == 1 / ExitMass</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="codeline">  // ExitMass == HeadMass - BackedgeMass</td>
    <td class="lineNumber">403</td>
    <td class="codeline">  // ExitMass == HeadMass - BackedgeMass</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="codeline">  BlockMass TotalBackedgeMass;</td>
    <td class="lineNumber">404</td>
    <td class="codeline">  BlockMass TotalBackedgeMass;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="codeline">  for (auto &Mass : Loop.BackedgeMass)</td>
    <td class="lineNumber">405</td>
    <td class="codeline">  for (auto &Mass : Loop.BackedgeMass)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="codeline">    TotalBackedgeMass += Mass;</td>
    <td class="lineNumber">406</td>
    <td class="codeline">    TotalBackedgeMass += Mass;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="codeline">  BlockMass ExitMass = BlockMass::getFull() - TotalBackedgeMass;</td>
    <td class="lineNumber">407</td>
    <td class="codeline">  BlockMass ExitMass = BlockMass::getFull() - TotalBackedgeMass;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="codeline"></td>
    <td class="lineNumber">408</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="codeline">  // Block scale stores the inverse of the scale. If this is an infinite loop,</td>
    <td class="lineNumber">409</td>
    <td class="codeline">  // Block scale stores the inverse of the scale. If this is an infinite loop,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="codeline">  // its exit mass will be zero. In this case, use an arbitrary scale for the</td>
    <td class="lineNumber">410</td>
    <td class="codeline">  // its exit mass will be zero. In this case, use an arbitrary scale for the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="codeline">  // loop scale.</td>
    <td class="lineNumber">411</td>
    <td class="codeline">  // loop scale.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="codeline">  Loop.Scale =</td>
    <td class="lineNumber">412</td>
    <td class="codeline">  Loop.Scale =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="codeline">      ExitMass.isEmpty() ? InfiniteLoopScale : ExitMass.toScaled().inverse();</td>
    <td class="lineNumber">413</td>
    <td class="codeline">      ExitMass.isEmpty() ? InfiniteLoopScale : ExitMass.toScaled().inverse();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="codeline"></td>
    <td class="lineNumber">414</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << " - exit-mass = " << ExitMass << " ("</td>
    <td class="lineNumber">415</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << " - exit-mass = " << ExitMass << " ("</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="codeline">                    << BlockMass::getFull() << " - " << TotalBackedgeMass</td>
    <td class="lineNumber">416</td>
    <td class="codeline">                    << BlockMass::getFull() << " - " << TotalBackedgeMass</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="codeline">                    << ")\n"</td>
    <td class="lineNumber">417</td>
    <td class="codeline">                    << ")\n"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="codeline">                    << " - scale = " << Loop.Scale << "\n");</td>
    <td class="lineNumber">418</td>
    <td class="codeline">                    << " - scale = " << Loop.Scale << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="codeline">}</td>
    <td class="lineNumber">419</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="codeline"></td>
    <td class="lineNumber">420</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="codeline">/// Package up a loop.</td>
    <td class="lineNumber">421</td>
    <td class="codeline">/// Package up a loop.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="codeline">void BlockFrequencyInfoImplBase::packageLoop(LoopData &Loop) {</td>
    <td class="lineNumber">422</td>
    <td class="codeline">void BlockFrequencyInfoImplBase::packageLoop(LoopData &Loop) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "packaging-loop: " << getLoopName(Loop) << "\n");</td>
    <td class="lineNumber">423</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "packaging-loop: " << getLoopName(Loop) << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="codeline"></td>
    <td class="lineNumber">424</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="codeline">  // Clear the subloop exits to prevent quadratic memory usage.</td>
    <td class="lineNumber">425</td>
    <td class="codeline">  // Clear the subloop exits to prevent quadratic memory usage.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="codeline">  for (const BlockNode &M : Loop.Nodes) {</td>
    <td class="lineNumber">426</td>
    <td class="codeline">  for (const BlockNode &M : Loop.Nodes) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="codeline">    if (auto *Loop = Working[M.Index].getPackagedLoop())</td>
    <td class="lineNumber">427</td>
    <td class="codeline">    if (auto *Loop = Working[M.Index].getPackagedLoop())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="codeline">      Loop->Exits.clear();</td>
    <td class="lineNumber">428</td>
    <td class="codeline">      Loop->Exits.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << " - node: " << getBlockName(M.Index) << "\n");</td>
    <td class="lineNumber">429</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << " - node: " << getBlockName(M.Index) << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">430</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="codeline">  Loop.IsPackaged = true;</td>
    <td class="lineNumber">431</td>
    <td class="codeline">  Loop.IsPackaged = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="codeline">}</td>
    <td class="lineNumber">432</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="codeline"></td>
    <td class="lineNumber">433</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="codeline">#ifndef NDEBUG</td>
    <td class="lineNumber">434</td>
    <td class="codeline">#ifndef NDEBUG</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="codeline">static void debugAssign(const BlockFrequencyInfoImplBase &BFI,</td>
    <td class="lineNumber">435</td>
    <td class="codeline">static void debugAssign(const BlockFrequencyInfoImplBase &BFI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="codeline">                        const DitheringDistributer &D, const BlockNode &T,</td>
    <td class="lineNumber">436</td>
    <td class="codeline">                        const DitheringDistributer &D, const BlockNode &T,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="codeline">                        const BlockMass &M, const char *Desc) {</td>
    <td class="lineNumber">437</td>
    <td class="codeline">                        const BlockMass &M, const char *Desc) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="codeline">  dbgs() << "  => assign " << M << " (" << D.RemMass << ")";</td>
    <td class="lineNumber">438</td>
    <td class="codeline">  dbgs() << "  => assign " << M << " (" << D.RemMass << ")";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="codeline">  if (Desc)</td>
    <td class="lineNumber">439</td>
    <td class="codeline">  if (Desc)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="codeline">    dbgs() << " [" << Desc << "]";</td>
    <td class="lineNumber">440</td>
    <td class="codeline">    dbgs() << " [" << Desc << "]";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="codeline">  if (T.isValid())</td>
    <td class="lineNumber">441</td>
    <td class="codeline">  if (T.isValid())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="codeline">    dbgs() << " to " << BFI.getBlockName(T);</td>
    <td class="lineNumber">442</td>
    <td class="codeline">    dbgs() << " to " << BFI.getBlockName(T);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="codeline">  dbgs() << "\n";</td>
    <td class="lineNumber">443</td>
    <td class="codeline">  dbgs() << "\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="codeline">}</td>
    <td class="lineNumber">444</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="codeline">#endif</td>
    <td class="lineNumber">445</td>
    <td class="codeline">#endif</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="codeline"></td>
    <td class="lineNumber">446</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="codeline">void BlockFrequencyInfoImplBase::distributeMass(const BlockNode &Source,</td>
    <td class="lineNumber">447</td>
    <td class="codeline">void BlockFrequencyInfoImplBase::distributeMass(const BlockNode &Source,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="codeline">                                                LoopData *OuterLoop,</td>
    <td class="lineNumber">448</td>
    <td class="codeline">                                                LoopData *OuterLoop,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="codeline">                                                Distribution &Dist) {</td>
    <td class="lineNumber">449</td>
    <td class="codeline">                                                Distribution &Dist) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="codeline">  BlockMass Mass = Working[Source.Index].getMass();</td>
    <td class="lineNumber">450</td>
    <td class="codeline">  BlockMass Mass = Working[Source.Index].getMass();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "  => mass:  " << Mass << "\n");</td>
    <td class="lineNumber">451</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "  => mass:  " << Mass << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="codeline"></td>
    <td class="lineNumber">452</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="codeline">  // Distribute mass to successors as laid out in Dist.</td>
    <td class="lineNumber">453</td>
    <td class="codeline">  // Distribute mass to successors as laid out in Dist.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="codeline">  DitheringDistributer D(Dist, Mass);</td>
    <td class="lineNumber">454</td>
    <td class="codeline">  DitheringDistributer D(Dist, Mass);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="codeline"></td>
    <td class="lineNumber">455</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="codeline">  for (const Weight &W : Dist.Weights) {</td>
    <td class="lineNumber">456</td>
    <td class="codeline">  for (const Weight &W : Dist.Weights) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="codeline">    // Check for a local edge (non-backedge and non-exit).</td>
    <td class="lineNumber">457</td>
    <td class="codeline">    // Check for a local edge (non-backedge and non-exit).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="codeline">    BlockMass Taken = D.takeMass(W.Amount);</td>
    <td class="lineNumber">458</td>
    <td class="codeline">    BlockMass Taken = D.takeMass(W.Amount);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="codeline">    if (W.Type == Weight::Local) {</td>
    <td class="lineNumber">459</td>
    <td class="codeline">    if (W.Type == Weight::Local) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="codeline">      Working[W.TargetNode.Index].getMass() += Taken;</td>
    <td class="lineNumber">460</td>
    <td class="codeline">      Working[W.TargetNode.Index].getMass() += Taken;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="codeline">      LLVM_DEBUG(debugAssign(*this, D, W.TargetNode, Taken, nullptr));</td>
    <td class="lineNumber">461</td>
    <td class="codeline">      LLVM_DEBUG(debugAssign(*this, D, W.TargetNode, Taken, nullptr));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">462</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">463</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="codeline"></td>
    <td class="lineNumber">464</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="codeline">    // Backedges and exits only make sense if we're processing a loop.</td>
    <td class="lineNumber">465</td>
    <td class="codeline">    // Backedges and exits only make sense if we're processing a loop.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="codeline">    assert(OuterLoop && "backedge or exit outside of loop");</td>
    <td class="lineNumber">466</td>
    <td class="codeline">    assert(OuterLoop && "backedge or exit outside of loop");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="codeline"></td>
    <td class="lineNumber">467</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="codeline">    // Check for a backedge.</td>
    <td class="lineNumber">468</td>
    <td class="codeline">    // Check for a backedge.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="codeline">    if (W.Type == Weight::Backedge) {</td>
    <td class="lineNumber">469</td>
    <td class="codeline">    if (W.Type == Weight::Backedge) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="codeline">      OuterLoop->BackedgeMass[OuterLoop->getHeaderIndex(W.TargetNode)] += Taken;</td>
    <td class="lineNumber">470</td>
    <td class="codeline">      OuterLoop->BackedgeMass[OuterLoop->getHeaderIndex(W.TargetNode)] += Taken;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="codeline">      LLVM_DEBUG(debugAssign(*this, D, W.TargetNode, Taken, "back"));</td>
    <td class="lineNumber">471</td>
    <td class="codeline">      LLVM_DEBUG(debugAssign(*this, D, W.TargetNode, Taken, "back"));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">472</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">473</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="codeline"></td>
    <td class="lineNumber">474</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="codeline">    // This must be an exit.</td>
    <td class="lineNumber">475</td>
    <td class="codeline">    // This must be an exit.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="codeline">    assert(W.Type == Weight::Exit);</td>
    <td class="lineNumber">476</td>
    <td class="codeline">    assert(W.Type == Weight::Exit);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="codeline">    OuterLoop->Exits.push_back(std::make_pair(W.TargetNode, Taken));</td>
    <td class="lineNumber">477</td>
    <td class="codeline">    OuterLoop->Exits.push_back(std::make_pair(W.TargetNode, Taken));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="codeline">    LLVM_DEBUG(debugAssign(*this, D, W.TargetNode, Taken, "exit"));</td>
    <td class="lineNumber">478</td>
    <td class="codeline">    LLVM_DEBUG(debugAssign(*this, D, W.TargetNode, Taken, "exit"));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">479</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="codeline">}</td>
    <td class="lineNumber">480</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="codeline"></td>
    <td class="lineNumber">481</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="codeline">static void convertFloatingToInteger(BlockFrequencyInfoImplBase &BFI,</td>
    <td class="lineNumber">482</td>
    <td class="codeline">static void convertFloatingToInteger(BlockFrequencyInfoImplBase &BFI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="codeline">                                     const Scaled64 &Min, const Scaled64 &Max) {</td>
    <td class="lineNumber">483</td>
    <td class="codeline">                                     const Scaled64 &Min, const Scaled64 &Max) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="codeline">  // Scale the Factor to a size that creates integers.  Ideally, integers would</td>
    <td class="lineNumber">484</td>
    <td class="codeline">  // Scale the Factor to a size that creates integers.  Ideally, integers would</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="codeline">  // be scaled so that Max == UINT64_MAX so that they can be best</td>
    <td class="lineNumber">485</td>
    <td class="codeline">  // be scaled so that Max == UINT64_MAX so that they can be best</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="codeline">  // differentiated.  However, in the presence of large frequency values, small</td>
    <td class="lineNumber">486</td>
    <td class="codeline">  // differentiated.  However, in the presence of large frequency values, small</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="codeline">  // frequencies are scaled down to 1, making it impossible to differentiate</td>
    <td class="lineNumber">487</td>
    <td class="codeline">  // frequencies are scaled down to 1, making it impossible to differentiate</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="codeline">  // small, unequal numbers. When the spread between Min and Max frequencies</td>
    <td class="lineNumber">488</td>
    <td class="codeline">  // small, unequal numbers. When the spread between Min and Max frequencies</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="codeline">  // fits well within MaxBits, we make the scale be at least 8.</td>
    <td class="lineNumber">489</td>
    <td class="codeline">  // fits well within MaxBits, we make the scale be at least 8.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="codeline">  const unsigned MaxBits = 64;</td>
    <td class="lineNumber">490</td>
    <td class="codeline">  const unsigned MaxBits = 64;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="codeline">  const unsigned SpreadBits = (Max / Min).lg();</td>
    <td class="lineNumber">491</td>
    <td class="codeline">  const unsigned SpreadBits = (Max / Min).lg();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="codeline">  Scaled64 ScalingFactor;</td>
    <td class="lineNumber">492</td>
    <td class="codeline">  Scaled64 ScalingFactor;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="codeline">  if (SpreadBits <= MaxBits - 3) {</td>
    <td class="lineNumber">493</td>
    <td class="codeline">  if (SpreadBits <= MaxBits - 3) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="codeline">    // If the values are small enough, make the scaling factor at least 8 to</td>
    <td class="lineNumber">494</td>
    <td class="codeline">    // If the values are small enough, make the scaling factor at least 8 to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="codeline">    // allow distinguishing small values.</td>
    <td class="lineNumber">495</td>
    <td class="codeline">    // allow distinguishing small values.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="codeline">    ScalingFactor = Min.inverse();</td>
    <td class="lineNumber">496</td>
    <td class="codeline">    ScalingFactor = Min.inverse();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="codeline">    ScalingFactor <<= 3;</td>
    <td class="lineNumber">497</td>
    <td class="codeline">    ScalingFactor <<= 3;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">498</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="codeline">    // If the values need more than MaxBits to be represented, saturate small</td>
    <td class="lineNumber">499</td>
    <td class="codeline">    // If the values need more than MaxBits to be represented, saturate small</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="codeline">    // frequency values down to 1 by using a scaling factor that benefits large</td>
    <td class="lineNumber">500</td>
    <td class="codeline">    // frequency values down to 1 by using a scaling factor that benefits large</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="codeline">    // frequency values.</td>
    <td class="lineNumber">501</td>
    <td class="codeline">    // frequency values.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="codeline">    ScalingFactor = Scaled64(1, MaxBits) / Max;</td>
    <td class="lineNumber">502</td>
    <td class="codeline">    ScalingFactor = Scaled64(1, MaxBits) / Max;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">503</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class="codeline"></td>
    <td class="lineNumber">504</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="codeline">  // Translate the floats to integers.</td>
    <td class="lineNumber">505</td>
    <td class="codeline">  // Translate the floats to integers.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "float-to-int: min = " << Min << ", max = " << Max</td>
    <td class="lineNumber">506</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "float-to-int: min = " << Min << ", max = " << Max</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="codeline">                    << ", factor = " << ScalingFactor << "\n");</td>
    <td class="lineNumber">507</td>
    <td class="codeline">                    << ", factor = " << ScalingFactor << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="codeline">  for (size_t Index = 0; Index < BFI.Freqs.size(); ++Index) {</td>
    <td class="lineNumber">508</td>
    <td class="codeline">  for (size_t Index = 0; Index < BFI.Freqs.size(); ++Index) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="codeline">    Scaled64 Scaled = BFI.Freqs[Index].Scaled * ScalingFactor;</td>
    <td class="lineNumber">509</td>
    <td class="codeline">    Scaled64 Scaled = BFI.Freqs[Index].Scaled * ScalingFactor;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="codeline">    BFI.Freqs[Index].Integer = std::max(UINT64_C(1), Scaled.toInt<uint64_t>());</td>
    <td class="lineNumber">510</td>
    <td class="codeline">    BFI.Freqs[Index].Integer = std::max(UINT64_C(1), Scaled.toInt<uint64_t>());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << " - " << BFI.getBlockName(Index) << ": float = "</td>
    <td class="lineNumber">511</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << " - " << BFI.getBlockName(Index) << ": float = "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="codeline">                      << BFI.Freqs[Index].Scaled << ", scaled = " << Scaled</td>
    <td class="lineNumber">512</td>
    <td class="codeline">                      << BFI.Freqs[Index].Scaled << ", scaled = " << Scaled</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class="codeline">                      << ", int = " << BFI.Freqs[Index].Integer << "\n");</td>
    <td class="lineNumber">513</td>
    <td class="codeline">                      << ", int = " << BFI.Freqs[Index].Integer << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">514</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="codeline">}</td>
    <td class="lineNumber">515</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="codeline"></td>
    <td class="lineNumber">516</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class="codeline">/// Unwrap a loop package.</td>
    <td class="lineNumber">517</td>
    <td class="codeline">/// Unwrap a loop package.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="codeline">///</td>
    <td class="lineNumber">518</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="codeline">/// Visits all the members of a loop, adjusting their BlockData according to</td>
    <td class="lineNumber">519</td>
    <td class="codeline">/// Visits all the members of a loop, adjusting their BlockData according to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class="codeline">/// the loop's pseudo-node.</td>
    <td class="lineNumber">520</td>
    <td class="codeline">/// the loop's pseudo-node.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="codeline">static void unwrapLoop(BlockFrequencyInfoImplBase &BFI, LoopData &Loop) {</td>
    <td class="lineNumber">521</td>
    <td class="codeline">static void unwrapLoop(BlockFrequencyInfoImplBase &BFI, LoopData &Loop) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "unwrap-loop-package: " << BFI.getLoopName(Loop)</td>
    <td class="lineNumber">522</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "unwrap-loop-package: " << BFI.getLoopName(Loop)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="codeline">                    << ": mass = " << Loop.Mass << ", scale = " << Loop.Scale</td>
    <td class="lineNumber">523</td>
    <td class="codeline">                    << ": mass = " << Loop.Mass << ", scale = " << Loop.Scale</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="codeline">                    << "\n");</td>
    <td class="lineNumber">524</td>
    <td class="codeline">                    << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="codeline">  Loop.Scale *= Loop.Mass.toScaled();</td>
    <td class="lineNumber">525</td>
    <td class="codeline">  Loop.Scale *= Loop.Mass.toScaled();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class="codeline">  Loop.IsPackaged = false;</td>
    <td class="lineNumber">526</td>
    <td class="codeline">  Loop.IsPackaged = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "  => combined-scale = " << Loop.Scale << "\n");</td>
    <td class="lineNumber">527</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "  => combined-scale = " << Loop.Scale << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="codeline"></td>
    <td class="lineNumber">528</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="codeline">  // Propagate the head scale through the loop.  Since members are visited in</td>
    <td class="lineNumber">529</td>
    <td class="codeline">  // Propagate the head scale through the loop.  Since members are visited in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="codeline">  // RPO, the head scale will be updated by the loop scale first, and then the</td>
    <td class="lineNumber">530</td>
    <td class="codeline">  // RPO, the head scale will be updated by the loop scale first, and then the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="codeline">  // final head scale will be used for updated the rest of the members.</td>
    <td class="lineNumber">531</td>
    <td class="codeline">  // final head scale will be used for updated the rest of the members.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="codeline">  for (const BlockNode &N : Loop.Nodes) {</td>
    <td class="lineNumber">532</td>
    <td class="codeline">  for (const BlockNode &N : Loop.Nodes) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class="codeline">    const auto &Working = BFI.Working[N.Index];</td>
    <td class="lineNumber">533</td>
    <td class="codeline">    const auto &Working = BFI.Working[N.Index];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="codeline">    Scaled64 &F = Working.isAPackage() ? Working.getPackagedLoop()->Scale</td>
    <td class="lineNumber">534</td>
    <td class="codeline">    Scaled64 &F = Working.isAPackage() ? Working.getPackagedLoop()->Scale</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="codeline">                                       : BFI.Freqs[N.Index].Scaled;</td>
    <td class="lineNumber">535</td>
    <td class="codeline">                                       : BFI.Freqs[N.Index].Scaled;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="codeline">    Scaled64 New = Loop.Scale * F;</td>
    <td class="lineNumber">536</td>
    <td class="codeline">    Scaled64 New = Loop.Scale * F;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << " - " << BFI.getBlockName(N) << ": " << F << " => "</td>
    <td class="lineNumber">537</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << " - " << BFI.getBlockName(N) << ": " << F << " => "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="codeline">                      << New << "\n");</td>
    <td class="lineNumber">538</td>
    <td class="codeline">                      << New << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="codeline">    F = New;</td>
    <td class="lineNumber">539</td>
    <td class="codeline">    F = New;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">540</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="codeline">}</td>
    <td class="lineNumber">541</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="codeline"></td>
    <td class="lineNumber">542</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="codeline">void BlockFrequencyInfoImplBase::unwrapLoops() {</td>
    <td class="lineNumber">543</td>
    <td class="codeline">void BlockFrequencyInfoImplBase::unwrapLoops() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="codeline">  // Set initial frequencies from loop-local masses.</td>
    <td class="lineNumber">544</td>
    <td class="codeline">  // Set initial frequencies from loop-local masses.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="codeline">  for (size_t Index = 0; Index < Working.size(); ++Index)</td>
    <td class="lineNumber">545</td>
    <td class="codeline">  for (size_t Index = 0; Index < Working.size(); ++Index)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="codeline">    Freqs[Index].Scaled = Working[Index].Mass.toScaled();</td>
    <td class="lineNumber">546</td>
    <td class="codeline">    Freqs[Index].Scaled = Working[Index].Mass.toScaled();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="codeline"></td>
    <td class="lineNumber">547</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="codeline">  for (LoopData &Loop : Loops)</td>
    <td class="lineNumber">548</td>
    <td class="codeline">  for (LoopData &Loop : Loops)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="codeline">    unwrapLoop(*this, Loop);</td>
    <td class="lineNumber">549</td>
    <td class="codeline">    unwrapLoop(*this, Loop);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="codeline">}</td>
    <td class="lineNumber">550</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="codeline"></td>
    <td class="lineNumber">551</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="codeline">void BlockFrequencyInfoImplBase::finalizeMetrics() {</td>
    <td class="lineNumber">552</td>
    <td class="codeline">void BlockFrequencyInfoImplBase::finalizeMetrics() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="codeline">  // Unwrap loop packages in reverse post-order, tracking min and max</td>
    <td class="lineNumber">553</td>
    <td class="codeline">  // Unwrap loop packages in reverse post-order, tracking min and max</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="codeline">  // frequencies.</td>
    <td class="lineNumber">554</td>
    <td class="codeline">  // frequencies.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="codeline">  auto Min = Scaled64::getLargest();</td>
    <td class="lineNumber">555</td>
    <td class="codeline">  auto Min = Scaled64::getLargest();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="codeline">  auto Max = Scaled64::getZero();</td>
    <td class="lineNumber">556</td>
    <td class="codeline">  auto Max = Scaled64::getZero();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="codeline">  for (size_t Index = 0; Index < Working.size(); ++Index) {</td>
    <td class="lineNumber">557</td>
    <td class="codeline">  for (size_t Index = 0; Index < Working.size(); ++Index) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="codeline">    // Update min/max scale.</td>
    <td class="lineNumber">558</td>
    <td class="codeline">    // Update min/max scale.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="codeline">    Min = std::min(Min, Freqs[Index].Scaled);</td>
    <td class="lineNumber">559</td>
    <td class="codeline">    Min = std::min(Min, Freqs[Index].Scaled);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="codeline">    Max = std::max(Max, Freqs[Index].Scaled);</td>
    <td class="lineNumber">560</td>
    <td class="codeline">    Max = std::max(Max, Freqs[Index].Scaled);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">561</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="codeline"></td>
    <td class="lineNumber">562</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="codeline">  // Convert to integers.</td>
    <td class="lineNumber">563</td>
    <td class="codeline">  // Convert to integers.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="codeline">  convertFloatingToInteger(*this, Min, Max);</td>
    <td class="lineNumber">564</td>
    <td class="codeline">  convertFloatingToInteger(*this, Min, Max);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class="codeline"></td>
    <td class="lineNumber">565</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="codeline">  // Clean up data structures.</td>
    <td class="lineNumber">566</td>
    <td class="codeline">  // Clean up data structures.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="codeline">  cleanup(*this);</td>
    <td class="lineNumber">567</td>
    <td class="codeline">  cleanup(*this);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="codeline"></td>
    <td class="lineNumber">568</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="codeline">  // Print out the final stats.</td>
    <td class="lineNumber">569</td>
    <td class="codeline">  // Print out the final stats.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="codeline">  LLVM_DEBUG(dump());</td>
    <td class="lineNumber">570</td>
    <td class="codeline">  LLVM_DEBUG(dump());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="codeline">}</td>
    <td class="lineNumber">571</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="codeline"></td>
    <td class="lineNumber">572</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="codeline">BlockFrequency</td>
    <td class="lineNumber">573</td>
    <td class="codeline">BlockFrequency</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="codeline">BlockFrequencyInfoImplBase::getBlockFreq(const BlockNode &Node) const {</td>
    <td class="lineNumber">574</td>
    <td class="codeline">BlockFrequencyInfoImplBase::getBlockFreq(const BlockNode &Node) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="codeline">  if (!Node.isValid()) {</td>
    <td class="lineNumber">575</td>
    <td class="codeline">  if (!Node.isValid()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="codeline">#ifndef NDEBUG</td>
    <td class="lineNumber">576</td>
    <td class="codeline">#ifndef NDEBUG</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="codeline">    if (CheckBFIUnknownBlockQueries) {</td>
    <td class="lineNumber">577</td>
    <td class="codeline">    if (CheckBFIUnknownBlockQueries) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="codeline">      SmallString<256> Msg;</td>
    <td class="lineNumber">578</td>
    <td class="codeline">      SmallString<256> Msg;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class="codeline">      raw_svector_ostream OS(Msg);</td>
    <td class="lineNumber">579</td>
    <td class="codeline">      raw_svector_ostream OS(Msg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="codeline">      OS << "*** Detected BFI query for unknown block " << getBlockName(Node);</td>
    <td class="lineNumber">580</td>
    <td class="codeline">      OS << "*** Detected BFI query for unknown block " << getBlockName(Node);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="codeline">      report_fatal_error(OS.str());</td>
    <td class="lineNumber">581</td>
    <td class="codeline">      report_fatal_error(OS.str());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">582</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="codeline">#endif</td>
    <td class="lineNumber">583</td>
    <td class="codeline">#endif</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="codeline">    return 0;</td>
    <td class="lineNumber">584</td>
    <td class="codeline">    return 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">585</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="codeline">  return Freqs[Node.Index].Integer;</td>
    <td class="lineNumber">586</td>
    <td class="codeline">  return Freqs[Node.Index].Integer;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class="codeline">}</td>
    <td class="lineNumber">587</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="codeline"></td>
    <td class="lineNumber">588</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="codeline">std::optional<uint64_t></td>
    <td class="lineNumber">589</td>
    <td class="codeline">std::optional<uint64_t></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class="codeline">BlockFrequencyInfoImplBase::getBlockProfileCount(const Function &F,</td>
    <td class="lineNumber">590</td>
    <td class="codeline">BlockFrequencyInfoImplBase::getBlockProfileCount(const Function &F,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="codeline">                                                 const BlockNode &Node,</td>
    <td class="lineNumber">591</td>
    <td class="codeline">                                                 const BlockNode &Node,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="codeline">                                                 bool AllowSynthetic) const {</td>
    <td class="lineNumber">592</td>
    <td class="codeline">                                                 bool AllowSynthetic) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="codeline">  return getProfileCountFromFreq(F, getBlockFreq(Node).getFrequency(),</td>
    <td class="lineNumber">593</td>
    <td class="codeline">  return getProfileCountFromFreq(F, getBlockFreq(Node).getFrequency(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="codeline">                                 AllowSynthetic);</td>
    <td class="lineNumber">594</td>
    <td class="codeline">                                 AllowSynthetic);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="codeline">}</td>
    <td class="lineNumber">595</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="codeline"></td>
    <td class="lineNumber">596</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class="codeline">std::optional<uint64_t></td>
    <td class="lineNumber">597</td>
    <td class="codeline">std::optional<uint64_t></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="codeline">BlockFrequencyInfoImplBase::getProfileCountFromFreq(const Function &F,</td>
    <td class="lineNumber">598</td>
    <td class="codeline">BlockFrequencyInfoImplBase::getProfileCountFromFreq(const Function &F,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="codeline">                                                    uint64_t Freq,</td>
    <td class="lineNumber">599</td>
    <td class="codeline">                                                    uint64_t Freq,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="codeline">                                                    bool AllowSynthetic) const {</td>
    <td class="lineNumber">600</td>
    <td class="codeline">                                                    bool AllowSynthetic) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="codeline">  auto EntryCount = F.getEntryCount(AllowSynthetic);</td>
    <td class="lineNumber">601</td>
    <td class="codeline">  auto EntryCount = F.getEntryCount(AllowSynthetic);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="codeline">  if (!EntryCount)</td>
    <td class="lineNumber">602</td>
    <td class="codeline">  if (!EntryCount)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="codeline">    return std::nullopt;</td>
    <td class="lineNumber">603</td>
    <td class="codeline">    return std::nullopt;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="codeline">  // Use 128 bit APInt to do the arithmetic to avoid overflow.</td>
    <td class="lineNumber">604</td>
    <td class="codeline">  // Use 128 bit APInt to do the arithmetic to avoid overflow.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="codeline">  APInt BlockCount(128, EntryCount->getCount());</td>
    <td class="lineNumber">605</td>
    <td class="codeline">  APInt BlockCount(128, EntryCount->getCount());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="codeline">  APInt BlockFreq(128, Freq);</td>
    <td class="lineNumber">606</td>
    <td class="codeline">  APInt BlockFreq(128, Freq);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="codeline">  APInt EntryFreq(128, getEntryFreq());</td>
    <td class="lineNumber">607</td>
    <td class="codeline">  APInt EntryFreq(128, getEntryFreq());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="codeline">  BlockCount *= BlockFreq;</td>
    <td class="lineNumber">608</td>
    <td class="codeline">  BlockCount *= BlockFreq;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="codeline">  // Rounded division of BlockCount by EntryFreq. Since EntryFreq is unsigned</td>
    <td class="lineNumber">609</td>
    <td class="codeline">  // Rounded division of BlockCount by EntryFreq. Since EntryFreq is unsigned</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="codeline">  // lshr by 1 gives EntryFreq/2.</td>
    <td class="lineNumber">610</td>
    <td class="codeline">  // lshr by 1 gives EntryFreq/2.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="codeline">  BlockCount = (BlockCount + EntryFreq.lshr(1)).udiv(EntryFreq);</td>
    <td class="lineNumber">611</td>
    <td class="codeline">  BlockCount = (BlockCount + EntryFreq.lshr(1)).udiv(EntryFreq);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="codeline">  return BlockCount.getLimitedValue();</td>
    <td class="lineNumber">612</td>
    <td class="codeline">  return BlockCount.getLimitedValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class="codeline">}</td>
    <td class="lineNumber">613</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class="codeline"></td>
    <td class="lineNumber">614</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="codeline">bool</td>
    <td class="lineNumber">615</td>
    <td class="codeline">bool</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="codeline">BlockFrequencyInfoImplBase::isIrrLoopHeader(const BlockNode &Node) {</td>
    <td class="lineNumber">616</td>
    <td class="codeline">BlockFrequencyInfoImplBase::isIrrLoopHeader(const BlockNode &Node) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="codeline">  if (!Node.isValid())</td>
    <td class="lineNumber">617</td>
    <td class="codeline">  if (!Node.isValid())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">618</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="codeline">  return IsIrrLoopHeader.test(Node.Index);</td>
    <td class="lineNumber">619</td>
    <td class="codeline">  return IsIrrLoopHeader.test(Node.Index);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="codeline">}</td>
    <td class="lineNumber">620</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class="codeline"></td>
    <td class="lineNumber">621</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="codeline">Scaled64</td>
    <td class="lineNumber">622</td>
    <td class="codeline">Scaled64</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="codeline">BlockFrequencyInfoImplBase::getFloatingBlockFreq(const BlockNode &Node) const {</td>
    <td class="lineNumber">623</td>
    <td class="codeline">BlockFrequencyInfoImplBase::getFloatingBlockFreq(const BlockNode &Node) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="codeline">  if (!Node.isValid())</td>
    <td class="lineNumber">624</td>
    <td class="codeline">  if (!Node.isValid())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="codeline">    return Scaled64::getZero();</td>
    <td class="lineNumber">625</td>
    <td class="codeline">    return Scaled64::getZero();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="codeline">  return Freqs[Node.Index].Scaled;</td>
    <td class="lineNumber">626</td>
    <td class="codeline">  return Freqs[Node.Index].Scaled;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="codeline">}</td>
    <td class="lineNumber">627</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class="codeline"></td>
    <td class="lineNumber">628</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="codeline">void BlockFrequencyInfoImplBase::setBlockFreq(const BlockNode &Node,</td>
    <td class="lineNumber">629</td>
    <td class="codeline">void BlockFrequencyInfoImplBase::setBlockFreq(const BlockNode &Node,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class="codeline">                                              uint64_t Freq) {</td>
    <td class="lineNumber">630</td>
    <td class="codeline">                                              uint64_t Freq) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="codeline">  assert(Node.isValid() && "Expected valid node");</td>
    <td class="lineNumber">631</td>
    <td class="codeline">  assert(Node.isValid() && "Expected valid node");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="codeline">  assert(Node.Index < Freqs.size() && "Expected legal index");</td>
    <td class="lineNumber">632</td>
    <td class="codeline">  assert(Node.Index < Freqs.size() && "Expected legal index");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="codeline">  Freqs[Node.Index].Integer = Freq;</td>
    <td class="lineNumber">633</td>
    <td class="codeline">  Freqs[Node.Index].Integer = Freq;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="codeline">}</td>
    <td class="lineNumber">634</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="codeline"></td>
    <td class="lineNumber">635</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="codeline">std::string</td>
    <td class="lineNumber">636</td>
    <td class="codeline">std::string</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="codeline">BlockFrequencyInfoImplBase::getBlockName(const BlockNode &Node) const {</td>
    <td class="lineNumber">637</td>
    <td class="codeline">BlockFrequencyInfoImplBase::getBlockName(const BlockNode &Node) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="codeline">  return {};</td>
    <td class="lineNumber">638</td>
    <td class="codeline">  return {};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="codeline">}</td>
    <td class="lineNumber">639</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="codeline"></td>
    <td class="lineNumber">640</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="codeline">std::string</td>
    <td class="lineNumber">641</td>
    <td class="codeline">std::string</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="codeline">BlockFrequencyInfoImplBase::getLoopName(const LoopData &Loop) const {</td>
    <td class="lineNumber">642</td>
    <td class="codeline">BlockFrequencyInfoImplBase::getLoopName(const LoopData &Loop) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="codeline">  return getBlockName(Loop.getHeader()) + (Loop.isIrreducible() ? "**" : "*");</td>
    <td class="lineNumber">643</td>
    <td class="codeline">  return getBlockName(Loop.getHeader()) + (Loop.isIrreducible() ? "**" : "*");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class="codeline">}</td>
    <td class="lineNumber">644</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="codeline"></td>
    <td class="lineNumber">645</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="codeline">raw_ostream &</td>
    <td class="lineNumber">646</td>
    <td class="codeline">raw_ostream &</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="codeline">BlockFrequencyInfoImplBase::printBlockFreq(raw_ostream &OS,</td>
    <td class="lineNumber">647</td>
    <td class="codeline">BlockFrequencyInfoImplBase::printBlockFreq(raw_ostream &OS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="codeline">                                           const BlockNode &Node) const {</td>
    <td class="lineNumber">648</td>
    <td class="codeline">                                           const BlockNode &Node) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="codeline">  return OS << getFloatingBlockFreq(Node);</td>
    <td class="lineNumber">649</td>
    <td class="codeline">  return OS << getFloatingBlockFreq(Node);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="codeline">}</td>
    <td class="lineNumber">650</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="codeline"></td>
    <td class="lineNumber">651</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="codeline">raw_ostream &</td>
    <td class="lineNumber">652</td>
    <td class="codeline">raw_ostream &</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="codeline">BlockFrequencyInfoImplBase::printBlockFreq(raw_ostream &OS,</td>
    <td class="lineNumber">653</td>
    <td class="codeline">BlockFrequencyInfoImplBase::printBlockFreq(raw_ostream &OS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="codeline">                                           const BlockFrequency &Freq) const {</td>
    <td class="lineNumber">654</td>
    <td class="codeline">                                           const BlockFrequency &Freq) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="codeline">  Scaled64 Block(Freq.getFrequency(), 0);</td>
    <td class="lineNumber">655</td>
    <td class="codeline">  Scaled64 Block(Freq.getFrequency(), 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="codeline">  Scaled64 Entry(getEntryFreq(), 0);</td>
    <td class="lineNumber">656</td>
    <td class="codeline">  Scaled64 Entry(getEntryFreq(), 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class="codeline"></td>
    <td class="lineNumber">657</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="codeline">  return OS << Block / Entry;</td>
    <td class="lineNumber">658</td>
    <td class="codeline">  return OS << Block / Entry;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="codeline">}</td>
    <td class="lineNumber">659</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="codeline"></td>
    <td class="lineNumber">660</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="codeline">void IrreducibleGraph::addNodesInLoop(const BFIBase::LoopData &OuterLoop) {</td>
    <td class="lineNumber">661</td>
    <td class="codeline">void IrreducibleGraph::addNodesInLoop(const BFIBase::LoopData &OuterLoop) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="codeline">  Start = OuterLoop.getHeader();</td>
    <td class="lineNumber">662</td>
    <td class="codeline">  Start = OuterLoop.getHeader();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="codeline">  Nodes.reserve(OuterLoop.Nodes.size());</td>
    <td class="lineNumber">663</td>
    <td class="codeline">  Nodes.reserve(OuterLoop.Nodes.size());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="codeline">  for (auto N : OuterLoop.Nodes)</td>
    <td class="lineNumber">664</td>
    <td class="codeline">  for (auto N : OuterLoop.Nodes)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="codeline">    addNode(N);</td>
    <td class="lineNumber">665</td>
    <td class="codeline">    addNode(N);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="codeline">  indexNodes();</td>
    <td class="lineNumber">666</td>
    <td class="codeline">  indexNodes();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="codeline">}</td>
    <td class="lineNumber">667</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="codeline"></td>
    <td class="lineNumber">668</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="codeline">void IrreducibleGraph::addNodesInFunction() {</td>
    <td class="lineNumber">669</td>
    <td class="codeline">void IrreducibleGraph::addNodesInFunction() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="codeline">  Start = 0;</td>
    <td class="lineNumber">670</td>
    <td class="codeline">  Start = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="codeline">  for (uint32_t Index = 0; Index < BFI.Working.size(); ++Index)</td>
    <td class="lineNumber">671</td>
    <td class="codeline">  for (uint32_t Index = 0; Index < BFI.Working.size(); ++Index)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class="codeline">    if (!BFI.Working[Index].isPackaged())</td>
    <td class="lineNumber">672</td>
    <td class="codeline">    if (!BFI.Working[Index].isPackaged())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="codeline">      addNode(Index);</td>
    <td class="lineNumber">673</td>
    <td class="codeline">      addNode(Index);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="codeline">  indexNodes();</td>
    <td class="lineNumber">674</td>
    <td class="codeline">  indexNodes();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class="codeline">}</td>
    <td class="lineNumber">675</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class="codeline"></td>
    <td class="lineNumber">676</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="codeline">void IrreducibleGraph::indexNodes() {</td>
    <td class="lineNumber">677</td>
    <td class="codeline">void IrreducibleGraph::indexNodes() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="codeline">  for (auto &I : Nodes)</td>
    <td class="lineNumber">678</td>
    <td class="codeline">  for (auto &I : Nodes)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="codeline">    Lookup[I.Node.Index] = &I;</td>
    <td class="lineNumber">679</td>
    <td class="codeline">    Lookup[I.Node.Index] = &I;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="codeline">}</td>
    <td class="lineNumber">680</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="codeline"></td>
    <td class="lineNumber">681</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="codeline">void IrreducibleGraph::addEdge(IrrNode &Irr, const BlockNode &Succ,</td>
    <td class="lineNumber">682</td>
    <td class="codeline">void IrreducibleGraph::addEdge(IrrNode &Irr, const BlockNode &Succ,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class="codeline">                               const BFIBase::LoopData *OuterLoop) {</td>
    <td class="lineNumber">683</td>
    <td class="codeline">                               const BFIBase::LoopData *OuterLoop) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="codeline">  if (OuterLoop && OuterLoop->isHeader(Succ))</td>
    <td class="lineNumber">684</td>
    <td class="codeline">  if (OuterLoop && OuterLoop->isHeader(Succ))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">685</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="codeline">  auto L = Lookup.find(Succ.Index);</td>
    <td class="lineNumber">686</td>
    <td class="codeline">  auto L = Lookup.find(Succ.Index);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="codeline">  if (L == Lookup.end())</td>
    <td class="lineNumber">687</td>
    <td class="codeline">  if (L == Lookup.end())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">688</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class="codeline">  IrrNode &SuccIrr = *L->second;</td>
    <td class="lineNumber">689</td>
    <td class="codeline">  IrrNode &SuccIrr = *L->second;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class="codeline">  Irr.Edges.push_back(&SuccIrr);</td>
    <td class="lineNumber">690</td>
    <td class="codeline">  Irr.Edges.push_back(&SuccIrr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class="codeline">  SuccIrr.Edges.push_front(&Irr);</td>
    <td class="lineNumber">691</td>
    <td class="codeline">  SuccIrr.Edges.push_front(&Irr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="codeline">  ++SuccIrr.NumIn;</td>
    <td class="lineNumber">692</td>
    <td class="codeline">  ++SuccIrr.NumIn;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class="codeline">}</td>
    <td class="lineNumber">693</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class="codeline"></td>
    <td class="lineNumber">694</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="codeline">namespace llvm {</td>
    <td class="lineNumber">695</td>
    <td class="codeline">namespace llvm {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="codeline"></td>
    <td class="lineNumber">696</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class="codeline">template <> struct GraphTraits<IrreducibleGraph> {</td>
    <td class="lineNumber">697</td>
    <td class="codeline">template <> struct GraphTraits<IrreducibleGraph> {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class="codeline">  using GraphT = bfi_detail::IrreducibleGraph;</td>
    <td class="lineNumber">698</td>
    <td class="codeline">  using GraphT = bfi_detail::IrreducibleGraph;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class="codeline">  using NodeRef = const GraphT::IrrNode *;</td>
    <td class="lineNumber">699</td>
    <td class="codeline">  using NodeRef = const GraphT::IrrNode *;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="codeline">  using ChildIteratorType = GraphT::IrrNode::iterator;</td>
    <td class="lineNumber">700</td>
    <td class="codeline">  using ChildIteratorType = GraphT::IrrNode::iterator;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="codeline"></td>
    <td class="lineNumber">701</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class="codeline">  static NodeRef getEntryNode(const GraphT &G) { return G.StartIrr; }</td>
    <td class="lineNumber">702</td>
    <td class="codeline">  static NodeRef getEntryNode(const GraphT &G) { return G.StartIrr; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="codeline">  static ChildIteratorType child_begin(NodeRef N) { return N->succ_begin(); }</td>
    <td class="lineNumber">703</td>
    <td class="codeline">  static ChildIteratorType child_begin(NodeRef N) { return N->succ_begin(); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class="codeline">  static ChildIteratorType child_end(NodeRef N) { return N->succ_end(); }</td>
    <td class="lineNumber">704</td>
    <td class="codeline">  static ChildIteratorType child_end(NodeRef N) { return N->succ_end(); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="codeline">};</td>
    <td class="lineNumber">705</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class="codeline"></td>
    <td class="lineNumber">706</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class="codeline">} // end namespace llvm</td>
    <td class="lineNumber">707</td>
    <td class="codeline">} // end namespace llvm</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class="codeline"></td>
    <td class="lineNumber">708</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class="codeline">/// Find extra irreducible headers.</td>
    <td class="lineNumber">709</td>
    <td class="codeline">/// Find extra irreducible headers.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="codeline">///</td>
    <td class="lineNumber">710</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class="codeline">/// Find entry blocks and other blocks with backedges, which exist when \c G</td>
    <td class="lineNumber">711</td>
    <td class="codeline">/// Find entry blocks and other blocks with backedges, which exist when \c G</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class="codeline">/// contains irreducible sub-SCCs.</td>
    <td class="lineNumber">712</td>
    <td class="codeline">/// contains irreducible sub-SCCs.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="codeline">static void findIrreducibleHeaders(</td>
    <td class="lineNumber">713</td>
    <td class="codeline">static void findIrreducibleHeaders(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="codeline">    const BlockFrequencyInfoImplBase &BFI,</td>
    <td class="lineNumber">714</td>
    <td class="codeline">    const BlockFrequencyInfoImplBase &BFI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="codeline">    const IrreducibleGraph &G,</td>
    <td class="lineNumber">715</td>
    <td class="codeline">    const IrreducibleGraph &G,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="codeline">    const std::vector<const IrreducibleGraph::IrrNode *> &SCC,</td>
    <td class="lineNumber">716</td>
    <td class="codeline">    const std::vector<const IrreducibleGraph::IrrNode *> &SCC,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class="codeline">    LoopData::NodeList &Headers, LoopData::NodeList &Others) {</td>
    <td class="lineNumber">717</td>
    <td class="codeline">    LoopData::NodeList &Headers, LoopData::NodeList &Others) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class="codeline">  // Map from nodes in the SCC to whether it's an entry block.</td>
    <td class="lineNumber">718</td>
    <td class="codeline">  // Map from nodes in the SCC to whether it's an entry block.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class="codeline">  SmallDenseMap<const IrreducibleGraph::IrrNode *, bool, 8> InSCC;</td>
    <td class="lineNumber">719</td>
    <td class="codeline">  SmallDenseMap<const IrreducibleGraph::IrrNode *, bool, 8> InSCC;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class="codeline"></td>
    <td class="lineNumber">720</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="codeline">  // InSCC also acts the set of nodes in the graph.  Seed it.</td>
    <td class="lineNumber">721</td>
    <td class="codeline">  // InSCC also acts the set of nodes in the graph.  Seed it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class="codeline">  for (const auto *I : SCC)</td>
    <td class="lineNumber">722</td>
    <td class="codeline">  for (const auto *I : SCC)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="codeline">    InSCC[I] = false;</td>
    <td class="lineNumber">723</td>
    <td class="codeline">    InSCC[I] = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class="codeline"></td>
    <td class="lineNumber">724</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="codeline">  for (auto I = InSCC.begin(), E = InSCC.end(); I != E; ++I) {</td>
    <td class="lineNumber">725</td>
    <td class="codeline">  for (auto I = InSCC.begin(), E = InSCC.end(); I != E; ++I) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class="codeline">    auto &Irr = *I->first;</td>
    <td class="lineNumber">726</td>
    <td class="codeline">    auto &Irr = *I->first;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class="codeline">    for (const auto *P : make_range(Irr.pred_begin(), Irr.pred_end())) {</td>
    <td class="lineNumber">727</td>
    <td class="codeline">    for (const auto *P : make_range(Irr.pred_begin(), Irr.pred_end())) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class="codeline">      if (InSCC.count(P))</td>
    <td class="lineNumber">728</td>
    <td class="codeline">      if (InSCC.count(P))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">729</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class="codeline"></td>
    <td class="lineNumber">730</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class="codeline">      // This is an entry block.</td>
    <td class="lineNumber">731</td>
    <td class="codeline">      // This is an entry block.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class="codeline">      I->second = true;</td>
    <td class="lineNumber">732</td>
    <td class="codeline">      I->second = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="codeline">      Headers.push_back(Irr.Node);</td>
    <td class="lineNumber">733</td>
    <td class="codeline">      Headers.push_back(Irr.Node);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "  => entry = " << BFI.getBlockName(Irr.Node)</td>
    <td class="lineNumber">734</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "  => entry = " << BFI.getBlockName(Irr.Node)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class="codeline">                        << "\n");</td>
    <td class="lineNumber">735</td>
    <td class="codeline">                        << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">736</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">737</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">738</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class="codeline">  assert(Headers.size() >= 2 &&</td>
    <td class="lineNumber">739</td>
    <td class="codeline">  assert(Headers.size() >= 2 &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="codeline">         "Expected irreducible CFG; -loop-info is likely invalid");</td>
    <td class="lineNumber">740</td>
    <td class="codeline">         "Expected irreducible CFG; -loop-info is likely invalid");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class="codeline">  if (Headers.size() == InSCC.size()) {</td>
    <td class="lineNumber">741</td>
    <td class="codeline">  if (Headers.size() == InSCC.size()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class="codeline">    // Every block is a header.</td>
    <td class="lineNumber">742</td>
    <td class="codeline">    // Every block is a header.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class="codeline">    llvm::sort(Headers);</td>
    <td class="lineNumber">743</td>
    <td class="codeline">    llvm::sort(Headers);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">744</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">745</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class="codeline"></td>
    <td class="lineNumber">746</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class="codeline">  // Look for extra headers from irreducible sub-SCCs.</td>
    <td class="lineNumber">747</td>
    <td class="codeline">  // Look for extra headers from irreducible sub-SCCs.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="codeline">  for (const auto &I : InSCC) {</td>
    <td class="lineNumber">748</td>
    <td class="codeline">  for (const auto &I : InSCC) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="codeline">    // Entry blocks are already headers.</td>
    <td class="lineNumber">749</td>
    <td class="codeline">    // Entry blocks are already headers.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="codeline">    if (I.second)</td>
    <td class="lineNumber">750</td>
    <td class="codeline">    if (I.second)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">751</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class="codeline"></td>
    <td class="lineNumber">752</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class="codeline">    auto &Irr = *I.first;</td>
    <td class="lineNumber">753</td>
    <td class="codeline">    auto &Irr = *I.first;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class="codeline">    for (const auto *P : make_range(Irr.pred_begin(), Irr.pred_end())) {</td>
    <td class="lineNumber">754</td>
    <td class="codeline">    for (const auto *P : make_range(Irr.pred_begin(), Irr.pred_end())) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class="codeline">      // Skip forward edges.</td>
    <td class="lineNumber">755</td>
    <td class="codeline">      // Skip forward edges.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="codeline">      if (P->Node < Irr.Node)</td>
    <td class="lineNumber">756</td>
    <td class="codeline">      if (P->Node < Irr.Node)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">757</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="codeline"></td>
    <td class="lineNumber">758</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="codeline">      // Skip predecessors from entry blocks.  These can have inverted</td>
    <td class="lineNumber">759</td>
    <td class="codeline">      // Skip predecessors from entry blocks.  These can have inverted</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class="codeline">      // ordering.</td>
    <td class="lineNumber">760</td>
    <td class="codeline">      // ordering.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class="codeline">      if (InSCC.lookup(P))</td>
    <td class="lineNumber">761</td>
    <td class="codeline">      if (InSCC.lookup(P))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">762</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="codeline"></td>
    <td class="lineNumber">763</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class="codeline">      // Store the extra header.</td>
    <td class="lineNumber">764</td>
    <td class="codeline">      // Store the extra header.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class="codeline">      Headers.push_back(Irr.Node);</td>
    <td class="lineNumber">765</td>
    <td class="codeline">      Headers.push_back(Irr.Node);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "  => extra = " << BFI.getBlockName(Irr.Node)</td>
    <td class="lineNumber">766</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "  => extra = " << BFI.getBlockName(Irr.Node)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="codeline">                        << "\n");</td>
    <td class="lineNumber">767</td>
    <td class="codeline">                        << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">768</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">769</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="codeline">    if (Headers.back() == Irr.Node)</td>
    <td class="lineNumber">770</td>
    <td class="codeline">    if (Headers.back() == Irr.Node)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class="codeline">      // Added this as a header.</td>
    <td class="lineNumber">771</td>
    <td class="codeline">      // Added this as a header.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">772</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class="codeline"></td>
    <td class="lineNumber">773</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="codeline">    // This is not a header.</td>
    <td class="lineNumber">774</td>
    <td class="codeline">    // This is not a header.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class="codeline">    Others.push_back(Irr.Node);</td>
    <td class="lineNumber">775</td>
    <td class="codeline">    Others.push_back(Irr.Node);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "  => other = " << BFI.getBlockName(Irr.Node) << "\n");</td>
    <td class="lineNumber">776</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "  => other = " << BFI.getBlockName(Irr.Node) << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">777</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class="codeline">  llvm::sort(Headers);</td>
    <td class="lineNumber">778</td>
    <td class="codeline">  llvm::sort(Headers);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="codeline">  llvm::sort(Others);</td>
    <td class="lineNumber">779</td>
    <td class="codeline">  llvm::sort(Others);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class="codeline">}</td>
    <td class="lineNumber">780</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class="codeline"></td>
    <td class="lineNumber">781</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="codeline">static void createIrreducibleLoop(</td>
    <td class="lineNumber">782</td>
    <td class="codeline">static void createIrreducibleLoop(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="codeline">    BlockFrequencyInfoImplBase &BFI, const IrreducibleGraph &G,</td>
    <td class="lineNumber">783</td>
    <td class="codeline">    BlockFrequencyInfoImplBase &BFI, const IrreducibleGraph &G,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class="codeline">    LoopData *OuterLoop, std::list<LoopData>::iterator Insert,</td>
    <td class="lineNumber">784</td>
    <td class="codeline">    LoopData *OuterLoop, std::list<LoopData>::iterator Insert,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class="codeline">    const std::vector<const IrreducibleGraph::IrrNode *> &SCC) {</td>
    <td class="lineNumber">785</td>
    <td class="codeline">    const std::vector<const IrreducibleGraph::IrrNode *> &SCC) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class="codeline">  // Translate the SCC into RPO.</td>
    <td class="lineNumber">786</td>
    <td class="codeline">  // Translate the SCC into RPO.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << " - found-scc\n");</td>
    <td class="lineNumber">787</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << " - found-scc\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="codeline"></td>
    <td class="lineNumber">788</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class="codeline">  LoopData::NodeList Headers;</td>
    <td class="lineNumber">789</td>
    <td class="codeline">  LoopData::NodeList Headers;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class="codeline">  LoopData::NodeList Others;</td>
    <td class="lineNumber">790</td>
    <td class="codeline">  LoopData::NodeList Others;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class="codeline">  findIrreducibleHeaders(BFI, G, SCC, Headers, Others);</td>
    <td class="lineNumber">791</td>
    <td class="codeline">  findIrreducibleHeaders(BFI, G, SCC, Headers, Others);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class="codeline"></td>
    <td class="lineNumber">792</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="codeline">  auto Loop = BFI.Loops.emplace(Insert, OuterLoop, Headers.begin(),</td>
    <td class="lineNumber">793</td>
    <td class="codeline">  auto Loop = BFI.Loops.emplace(Insert, OuterLoop, Headers.begin(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class="codeline">                                Headers.end(), Others.begin(), Others.end());</td>
    <td class="lineNumber">794</td>
    <td class="codeline">                                Headers.end(), Others.begin(), Others.end());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="codeline"></td>
    <td class="lineNumber">795</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class="codeline">  // Update loop hierarchy.</td>
    <td class="lineNumber">796</td>
    <td class="codeline">  // Update loop hierarchy.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class="codeline">  for (const auto &N : Loop->Nodes)</td>
    <td class="lineNumber">797</td>
    <td class="codeline">  for (const auto &N : Loop->Nodes)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class="codeline">    if (BFI.Working[N.Index].isLoopHeader())</td>
    <td class="lineNumber">798</td>
    <td class="codeline">    if (BFI.Working[N.Index].isLoopHeader())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class="codeline">      BFI.Working[N.Index].Loop->Parent = &*Loop;</td>
    <td class="lineNumber">799</td>
    <td class="codeline">      BFI.Working[N.Index].Loop->Parent = &*Loop;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class="codeline">    else</td>
    <td class="lineNumber">800</td>
    <td class="codeline">    else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class="codeline">      BFI.Working[N.Index].Loop = &*Loop;</td>
    <td class="lineNumber">801</td>
    <td class="codeline">      BFI.Working[N.Index].Loop = &*Loop;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class="codeline">}</td>
    <td class="lineNumber">802</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class="codeline"></td>
    <td class="lineNumber">803</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class="codeline">iterator_range<std::list<LoopData>::iterator></td>
    <td class="lineNumber">804</td>
    <td class="codeline">iterator_range<std::list<LoopData>::iterator></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class="codeline">BlockFrequencyInfoImplBase::analyzeIrreducible(</td>
    <td class="lineNumber">805</td>
    <td class="codeline">BlockFrequencyInfoImplBase::analyzeIrreducible(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class="codeline">    const IrreducibleGraph &G, LoopData *OuterLoop,</td>
    <td class="lineNumber">806</td>
    <td class="codeline">    const IrreducibleGraph &G, LoopData *OuterLoop,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class="codeline">    std::list<LoopData>::iterator Insert) {</td>
    <td class="lineNumber">807</td>
    <td class="codeline">    std::list<LoopData>::iterator Insert) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class="codeline">  assert((OuterLoop == nullptr) == (Insert == Loops.begin()));</td>
    <td class="lineNumber">808</td>
    <td class="codeline">  assert((OuterLoop == nullptr) == (Insert == Loops.begin()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class="codeline">  auto Prev = OuterLoop ? std::prev(Insert) : Loops.end();</td>
    <td class="lineNumber">809</td>
    <td class="codeline">  auto Prev = OuterLoop ? std::prev(Insert) : Loops.end();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class="codeline"></td>
    <td class="lineNumber">810</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class="codeline">  for (auto I = scc_begin(G); !I.isAtEnd(); ++I) {</td>
    <td class="lineNumber">811</td>
    <td class="codeline">  for (auto I = scc_begin(G); !I.isAtEnd(); ++I) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class="codeline">    if (I->size() < 2)</td>
    <td class="lineNumber">812</td>
    <td class="codeline">    if (I->size() < 2)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">813</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class="codeline"></td>
    <td class="lineNumber">814</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class="codeline">    // Translate the SCC into RPO.</td>
    <td class="lineNumber">815</td>
    <td class="codeline">    // Translate the SCC into RPO.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class="codeline">    createIrreducibleLoop(*this, G, OuterLoop, Insert, *I);</td>
    <td class="lineNumber">816</td>
    <td class="codeline">    createIrreducibleLoop(*this, G, OuterLoop, Insert, *I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">817</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class="codeline"></td>
    <td class="lineNumber">818</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class="codeline">  if (OuterLoop)</td>
    <td class="lineNumber">819</td>
    <td class="codeline">  if (OuterLoop)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class="codeline">    return make_range(std::next(Prev), Insert);</td>
    <td class="lineNumber">820</td>
    <td class="codeline">    return make_range(std::next(Prev), Insert);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class="codeline">  return make_range(Loops.begin(), Insert);</td>
    <td class="lineNumber">821</td>
    <td class="codeline">  return make_range(Loops.begin(), Insert);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class="codeline">}</td>
    <td class="lineNumber">822</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class="codeline"></td>
    <td class="lineNumber">823</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class="codeline">void</td>
    <td class="lineNumber">824</td>
    <td class="codeline">void</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class="codeline">BlockFrequencyInfoImplBase::updateLoopWithIrreducible(LoopData &OuterLoop) {</td>
    <td class="lineNumber">825</td>
    <td class="codeline">BlockFrequencyInfoImplBase::updateLoopWithIrreducible(LoopData &OuterLoop) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class="codeline">  OuterLoop.Exits.clear();</td>
    <td class="lineNumber">826</td>
    <td class="codeline">  OuterLoop.Exits.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class="codeline">  for (auto &Mass : OuterLoop.BackedgeMass)</td>
    <td class="lineNumber">827</td>
    <td class="codeline">  for (auto &Mass : OuterLoop.BackedgeMass)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class="codeline">    Mass = BlockMass::getEmpty();</td>
    <td class="lineNumber">828</td>
    <td class="codeline">    Mass = BlockMass::getEmpty();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class="codeline">  auto O = OuterLoop.Nodes.begin() + 1;</td>
    <td class="lineNumber">829</td>
    <td class="codeline">  auto O = OuterLoop.Nodes.begin() + 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class="codeline">  for (auto I = O, E = OuterLoop.Nodes.end(); I != E; ++I)</td>
    <td class="lineNumber">830</td>
    <td class="codeline">  for (auto I = O, E = OuterLoop.Nodes.end(); I != E; ++I)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class="codeline">    if (!Working[I->Index].isPackaged())</td>
    <td class="lineNumber">831</td>
    <td class="codeline">    if (!Working[I->Index].isPackaged())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class="codeline">      *O++ = *I;</td>
    <td class="lineNumber">832</td>
    <td class="codeline">      *O++ = *I;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class="codeline">  OuterLoop.Nodes.erase(O, OuterLoop.Nodes.end());</td>
    <td class="lineNumber">833</td>
    <td class="codeline">  OuterLoop.Nodes.erase(O, OuterLoop.Nodes.end());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class="codeline">}</td>
    <td class="lineNumber">834</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class="codeline"></td>
    <td class="lineNumber">835</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class="codeline">void BlockFrequencyInfoImplBase::adjustLoopHeaderMass(LoopData &Loop) {</td>
    <td class="lineNumber">836</td>
    <td class="codeline">void BlockFrequencyInfoImplBase::adjustLoopHeaderMass(LoopData &Loop) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class="codeline">  assert(Loop.isIrreducible() && "this only makes sense on irreducible loops");</td>
    <td class="lineNumber">837</td>
    <td class="codeline">  assert(Loop.isIrreducible() && "this only makes sense on irreducible loops");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class="codeline"></td>
    <td class="lineNumber">838</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class="codeline">  // Since the loop has more than one header block, the mass flowing back into</td>
    <td class="lineNumber">839</td>
    <td class="codeline">  // Since the loop has more than one header block, the mass flowing back into</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class="codeline">  // each header will be different. Adjust the mass in each header loop to</td>
    <td class="lineNumber">840</td>
    <td class="codeline">  // each header will be different. Adjust the mass in each header loop to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class="codeline">  // reflect the masses flowing through back edges.</td>
    <td class="lineNumber">841</td>
    <td class="codeline">  // reflect the masses flowing through back edges.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">842</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class="codeline">  // To do this, we distribute the initial mass using the backedge masses</td>
    <td class="lineNumber">843</td>
    <td class="codeline">  // To do this, we distribute the initial mass using the backedge masses</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class="codeline">  // as weights for the distribution.</td>
    <td class="lineNumber">844</td>
    <td class="codeline">  // as weights for the distribution.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class="codeline">  BlockMass LoopMass = BlockMass::getFull();</td>
    <td class="lineNumber">845</td>
    <td class="codeline">  BlockMass LoopMass = BlockMass::getFull();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class="codeline">  Distribution Dist;</td>
    <td class="lineNumber">846</td>
    <td class="codeline">  Distribution Dist;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class="codeline"></td>
    <td class="lineNumber">847</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "adjust-loop-header-mass:\n");</td>
    <td class="lineNumber">848</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "adjust-loop-header-mass:\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class="codeline">  for (uint32_t H = 0; H < Loop.NumHeaders; ++H) {</td>
    <td class="lineNumber">849</td>
    <td class="codeline">  for (uint32_t H = 0; H < Loop.NumHeaders; ++H) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class="codeline">    auto &HeaderNode = Loop.Nodes[H];</td>
    <td class="lineNumber">850</td>
    <td class="codeline">    auto &HeaderNode = Loop.Nodes[H];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class="codeline">    auto &BackedgeMass = Loop.BackedgeMass[Loop.getHeaderIndex(HeaderNode)];</td>
    <td class="lineNumber">851</td>
    <td class="codeline">    auto &BackedgeMass = Loop.BackedgeMass[Loop.getHeaderIndex(HeaderNode)];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << " - Add back edge mass for node "</td>
    <td class="lineNumber">852</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << " - Add back edge mass for node "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class="codeline">                      << getBlockName(HeaderNode) << ": " << BackedgeMass</td>
    <td class="lineNumber">853</td>
    <td class="codeline">                      << getBlockName(HeaderNode) << ": " << BackedgeMass</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class="codeline">                      << "\n");</td>
    <td class="lineNumber">854</td>
    <td class="codeline">                      << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class="codeline">    if (BackedgeMass.getMass() > 0)</td>
    <td class="lineNumber">855</td>
    <td class="codeline">    if (BackedgeMass.getMass() > 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class="codeline">      Dist.addLocal(HeaderNode, BackedgeMass.getMass());</td>
    <td class="lineNumber">856</td>
    <td class="codeline">      Dist.addLocal(HeaderNode, BackedgeMass.getMass());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class="codeline">    else</td>
    <td class="lineNumber">857</td>
    <td class="codeline">    else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "   Nothing added. Back edge mass is zero\n");</td>
    <td class="lineNumber">858</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "   Nothing added. Back edge mass is zero\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">859</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class="codeline"></td>
    <td class="lineNumber">860</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class="codeline">  DitheringDistributer D(Dist, LoopMass);</td>
    <td class="lineNumber">861</td>
    <td class="codeline">  DitheringDistributer D(Dist, LoopMass);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class="codeline"></td>
    <td class="lineNumber">862</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << " Distribute loop mass " << LoopMass</td>
    <td class="lineNumber">863</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << " Distribute loop mass " << LoopMass</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class="codeline">                    << " to headers using above weights\n");</td>
    <td class="lineNumber">864</td>
    <td class="codeline">                    << " to headers using above weights\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class="codeline">  for (const Weight &W : Dist.Weights) {</td>
    <td class="lineNumber">865</td>
    <td class="codeline">  for (const Weight &W : Dist.Weights) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class="codeline">    BlockMass Taken = D.takeMass(W.Amount);</td>
    <td class="lineNumber">866</td>
    <td class="codeline">    BlockMass Taken = D.takeMass(W.Amount);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class="codeline">    assert(W.Type == Weight::Local && "all weights should be local");</td>
    <td class="lineNumber">867</td>
    <td class="codeline">    assert(W.Type == Weight::Local && "all weights should be local");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class="codeline">    Working[W.TargetNode.Index].getMass() = Taken;</td>
    <td class="lineNumber">868</td>
    <td class="codeline">    Working[W.TargetNode.Index].getMass() = Taken;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class="codeline">    LLVM_DEBUG(debugAssign(*this, D, W.TargetNode, Taken, nullptr));</td>
    <td class="lineNumber">869</td>
    <td class="codeline">    LLVM_DEBUG(debugAssign(*this, D, W.TargetNode, Taken, nullptr));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">870</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class="codeline">}</td>
    <td class="lineNumber">871</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">872</td>
    <td class="codeline"></td>
    <td class="lineNumber">872</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">873</td>
    <td class="codeline">void BlockFrequencyInfoImplBase::distributeIrrLoopHeaderMass(Distribution &Dist) {</td>
    <td class="lineNumber">873</td>
    <td class="codeline">void BlockFrequencyInfoImplBase::distributeIrrLoopHeaderMass(Distribution &Dist) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">874</td>
    <td class="codeline">  BlockMass LoopMass = BlockMass::getFull();</td>
    <td class="lineNumber">874</td>
    <td class="codeline">  BlockMass LoopMass = BlockMass::getFull();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">875</td>
    <td class="codeline">  DitheringDistributer D(Dist, LoopMass);</td>
    <td class="lineNumber">875</td>
    <td class="codeline">  DitheringDistributer D(Dist, LoopMass);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">876</td>
    <td class="codeline">  for (const Weight &W : Dist.Weights) {</td>
    <td class="lineNumber">876</td>
    <td class="codeline">  for (const Weight &W : Dist.Weights) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">877</td>
    <td class="codeline">    BlockMass Taken = D.takeMass(W.Amount);</td>
    <td class="lineNumber">877</td>
    <td class="codeline">    BlockMass Taken = D.takeMass(W.Amount);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">878</td>
    <td class="codeline">    assert(W.Type == Weight::Local && "all weights should be local");</td>
    <td class="lineNumber">878</td>
    <td class="codeline">    assert(W.Type == Weight::Local && "all weights should be local");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">879</td>
    <td class="codeline">    Working[W.TargetNode.Index].getMass() = Taken;</td>
    <td class="lineNumber">879</td>
    <td class="codeline">    Working[W.TargetNode.Index].getMass() = Taken;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">880</td>
    <td class="codeline">    LLVM_DEBUG(debugAssign(*this, D, W.TargetNode, Taken, nullptr));</td>
    <td class="lineNumber">880</td>
    <td class="codeline">    LLVM_DEBUG(debugAssign(*this, D, W.TargetNode, Taken, nullptr));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">881</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">881</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">882</td>
    <td class="codeline">}</td>
    <td class="lineNumber">882</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">883</td>
    <td class="codeline"></td>
    <td class="lineNumber">883</td>
    <td class="codeline"></td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Side By Side Comparison</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Side By Side Comparison</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </th>
    <th class="mainTh">Hit count</th>
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </th>
    <th class="mainTh">Hit count</th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="codeLine">//===- BlockFrequencyImplInfo.cpp - Block Frequency Info Implementation ---===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1</td>
    <td class="codeLine">//===- BlockFrequencyImplInfo.cpp - Block Frequency Info Implementation ---===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="codeLine">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3</td>
    <td class="codeLine">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="codeLine">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4</td>
    <td class="codeLine">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="codeLine">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5</td>
    <td class="codeLine">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">6</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">7</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">8</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="codeLine">// Loops should be simplified before this analysis.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">9</td>
    <td class="codeLine">// Loops should be simplified before this analysis.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">10</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">11</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">12</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="codeLine">#include "llvm/Analysis/BlockFrequencyInfoImpl.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">13</td>
    <td class="codeLine">#include "llvm/Analysis/BlockFrequencyInfoImpl.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="codeLine">#include "llvm/ADT/APInt.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">14</td>
    <td class="codeLine">#include "llvm/ADT/APInt.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="codeLine">#include "llvm/ADT/DenseMap.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">15</td>
    <td class="codeLine">#include "llvm/ADT/DenseMap.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="codeLine">#include "llvm/ADT/SCCIterator.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">16</td>
    <td class="codeLine">#include "llvm/ADT/SCCIterator.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="codeLine">#include "llvm/ADT/SmallString.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">17</td>
    <td class="codeLine">#include "llvm/ADT/SmallString.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="codeLine">#include "llvm/Config/llvm-config.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">18</td>
    <td class="codeLine">#include "llvm/Config/llvm-config.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="codeLine">#include "llvm/IR/Function.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">19</td>
    <td class="codeLine">#include "llvm/IR/Function.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="codeLine">#include "llvm/Support/BlockFrequency.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">20</td>
    <td class="codeLine">#include "llvm/Support/BlockFrequency.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="codeLine">#include "llvm/Support/BranchProbability.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">21</td>
    <td class="codeLine">#include "llvm/Support/BranchProbability.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="codeLine">#include "llvm/Support/Compiler.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">22</td>
    <td class="codeLine">#include "llvm/Support/Compiler.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="codeLine">#include "llvm/Support/Debug.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">23</td>
    <td class="codeLine">#include "llvm/Support/Debug.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="codeLine">#include "llvm/Support/MathExtras.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">24</td>
    <td class="codeLine">#include "llvm/Support/MathExtras.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="codeLine">#include "llvm/Support/ScaledNumber.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">25</td>
    <td class="codeLine">#include "llvm/Support/ScaledNumber.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="codeLine">#include "llvm/Support/raw_ostream.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">26</td>
    <td class="codeLine">#include "llvm/Support/raw_ostream.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="codeLine">#include <algorithm></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">27</td>
    <td class="codeLine">#include <algorithm></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="codeLine">#include <cassert></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">28</td>
    <td class="codeLine">#include <cassert></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="codeLine">#include <cstddef></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">29</td>
    <td class="codeLine">#include <cstddef></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="codeLine">#include <cstdint></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">30</td>
    <td class="codeLine">#include <cstdint></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="codeLine">#include <iterator></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">31</td>
    <td class="codeLine">#include <iterator></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="codeLine">#include <list></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">32</td>
    <td class="codeLine">#include <list></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="codeLine">#include <numeric></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">33</td>
    <td class="codeLine">#include <numeric></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="codeLine">#include <optional></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">34</td>
    <td class="codeLine">#include <optional></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="codeLine">#include <utility></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">35</td>
    <td class="codeLine">#include <utility></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="codeLine">#include <vector></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">36</td>
    <td class="codeLine">#include <vector></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">37</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="codeLine">using namespace llvm;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">38</td>
    <td class="codeLine">using namespace llvm;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="codeLine">using namespace llvm::bfi_detail;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">39</td>
    <td class="codeLine">using namespace llvm::bfi_detail;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">40</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="codeLine">#define DEBUG_TYPE "block-freq"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">41</td>
    <td class="codeLine">#define DEBUG_TYPE "block-freq"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">42</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="codeLine">namespace llvm {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">43</td>
    <td class="codeLine">namespace llvm {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="codeLine">cl::opt<bool> CheckBFIUnknownBlockQueries(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">44</td>
    <td class="codeLine">cl::opt<bool> CheckBFIUnknownBlockQueries(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="codeLine">    "check-bfi-unknown-block-queries",</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">45</td>
    <td class="codeLine">    "check-bfi-unknown-block-queries",</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="codeLine">    cl::init(false), cl::Hidden,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">46</td>
    <td class="codeLine">    cl::init(false), cl::Hidden,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="codeLine">    cl::desc("Check if block frequency is queried for an unknown block "</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">47</td>
    <td class="codeLine">    cl::desc("Check if block frequency is queried for an unknown block "</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="codeLine">             "for debugging missed BFI updates"));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">48</td>
    <td class="codeLine">             "for debugging missed BFI updates"));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">49</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="codeLine">cl::opt<bool> UseIterativeBFIInference(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">50</td>
    <td class="codeLine">cl::opt<bool> UseIterativeBFIInference(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="codeLine">    "use-iterative-bfi-inference", cl::Hidden,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">51</td>
    <td class="codeLine">    "use-iterative-bfi-inference", cl::Hidden,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="codeLine">    cl::desc("Apply an iterative post-processing to infer correct BFI counts"));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">52</td>
    <td class="codeLine">    cl::desc("Apply an iterative post-processing to infer correct BFI counts"));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">53</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="codeLine">cl::opt<unsigned> IterativeBFIMaxIterationsPerBlock(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">54</td>
    <td class="codeLine">cl::opt<unsigned> IterativeBFIMaxIterationsPerBlock(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="codeLine">    "iterative-bfi-max-iterations-per-block", cl::init(1000), cl::Hidden,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">55</td>
    <td class="codeLine">    "iterative-bfi-max-iterations-per-block", cl::init(1000), cl::Hidden,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="codeLine">    cl::desc("Iterative inference: maximum number of update iterations "</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">56</td>
    <td class="codeLine">    cl::desc("Iterative inference: maximum number of update iterations "</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="codeLine">             "per block"));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">57</td>
    <td class="codeLine">             "per block"));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">58</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="codeLine">cl::opt<double> IterativeBFIPrecision(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">59</td>
    <td class="codeLine">cl::opt<double> IterativeBFIPrecision(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="codeLine">    "iterative-bfi-precision", cl::init(1e-12), cl::Hidden,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">60</td>
    <td class="codeLine">    "iterative-bfi-precision", cl::init(1e-12), cl::Hidden,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="codeLine">    cl::desc("Iterative inference: delta convergence precision; smaller values "</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">61</td>
    <td class="codeLine">    cl::desc("Iterative inference: delta convergence precision; smaller values "</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="codeLine">             "typically lead to better results at the cost of worsen runtime"));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">62</td>
    <td class="codeLine">             "typically lead to better results at the cost of worsen runtime"));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="codeLine">} // namespace llvm</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">63</td>
    <td class="codeLine">} // namespace llvm</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">64</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="codeLine coveredLine">ScaledNumber<uint64_t> BlockMass::toScaled() const {</td>
    <td class="lineNumber">24</td>
    <td class="lineNumber">65</td>
    <td class="codeLine coveredLine">ScaledNumber<uint64_t> BlockMass::toScaled() const {</td>
    <td class="lineNumber">24</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="codeLine coveredLine">  if (isFull())</td>
    <td class="lineNumber">24</td>
    <td class="lineNumber">66</td>
    <td class="codeLine coveredLine">  if (isFull())</td>
    <td class="lineNumber">24</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="codeLine coveredLine">    return ScaledNumber<uint64_t>(1, 0);</td>
    <td class="lineNumber">12</td>
    <td class="lineNumber">67</td>
    <td class="codeLine coveredLine">    return ScaledNumber<uint64_t>(1, 0);</td>
    <td class="lineNumber">12</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="codeLine coveredLine">  return ScaledNumber<uint64_t>(getMass() + 1, -64);</td>
    <td class="lineNumber">12</td>
    <td class="lineNumber">68</td>
    <td class="codeLine coveredLine">  return ScaledNumber<uint64_t>(getMass() + 1, -64);</td>
    <td class="lineNumber">12</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">69</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">70</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="codeLine">#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">71</td>
    <td class="codeLine">#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="codeLine">LLVM_DUMP_METHOD void BlockMass::dump() const { print(dbgs()); }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">72</td>
    <td class="codeLine">LLVM_DUMP_METHOD void BlockMass::dump() const { print(dbgs()); }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">73</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">74</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="codeLine">static char getHexDigit(int N) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">75</td>
    <td class="codeLine">static char getHexDigit(int N) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="codeLine">  assert(N < 16);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">76</td>
    <td class="codeLine">  assert(N < 16);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="codeLine">  if (N < 10)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">77</td>
    <td class="codeLine">  if (N < 10)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="codeLine">    return '0' + N;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">78</td>
    <td class="codeLine">    return '0' + N;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="codeLine">  return 'a' + N - 10;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">79</td>
    <td class="codeLine">  return 'a' + N - 10;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">80</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">81</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="codeLine">raw_ostream &BlockMass::print(raw_ostream &OS) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">82</td>
    <td class="codeLine">raw_ostream &BlockMass::print(raw_ostream &OS) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="codeLine">  for (int Digits = 0; Digits < 16; ++Digits)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">83</td>
    <td class="codeLine">  for (int Digits = 0; Digits < 16; ++Digits)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="codeLine">    OS << getHexDigit(Mass >> (60 - Digits * 4) & 0xf);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">84</td>
    <td class="codeLine">    OS << getHexDigit(Mass >> (60 - Digits * 4) & 0xf);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="codeLine">  return OS;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">85</td>
    <td class="codeLine">  return OS;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">86</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">87</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="codeLine">namespace {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">88</td>
    <td class="codeLine">namespace {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">89</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="codeLine">using BlockNode = BlockFrequencyInfoImplBase::BlockNode;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">90</td>
    <td class="codeLine">using BlockNode = BlockFrequencyInfoImplBase::BlockNode;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="codeLine">using Distribution = BlockFrequencyInfoImplBase::Distribution;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">91</td>
    <td class="codeLine">using Distribution = BlockFrequencyInfoImplBase::Distribution;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="codeLine">using WeightList = BlockFrequencyInfoImplBase::Distribution::WeightList;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">92</td>
    <td class="codeLine">using WeightList = BlockFrequencyInfoImplBase::Distribution::WeightList;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="codeLine">using Scaled64 = BlockFrequencyInfoImplBase::Scaled64;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">93</td>
    <td class="codeLine">using Scaled64 = BlockFrequencyInfoImplBase::Scaled64;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="codeLine">using LoopData = BlockFrequencyInfoImplBase::LoopData;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">94</td>
    <td class="codeLine">using LoopData = BlockFrequencyInfoImplBase::LoopData;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="codeLine">using Weight = BlockFrequencyInfoImplBase::Weight;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">95</td>
    <td class="codeLine">using Weight = BlockFrequencyInfoImplBase::Weight;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="codeLine">using FrequencyData = BlockFrequencyInfoImplBase::FrequencyData;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">96</td>
    <td class="codeLine">using FrequencyData = BlockFrequencyInfoImplBase::FrequencyData;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">97</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="codeLine">/// Dithering mass distributer.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">98</td>
    <td class="codeLine">/// Dithering mass distributer.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">99</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="codeLine">/// This class splits up a single mass into portions by weight, dithering to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">100</td>
    <td class="codeLine">/// This class splits up a single mass into portions by weight, dithering to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="codeLine">/// spread out error.  No mass is lost.  The dithering precision depends on the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">101</td>
    <td class="codeLine">/// spread out error.  No mass is lost.  The dithering precision depends on the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="codeLine">/// precision of the product of \a BlockMass and \a BranchProbability.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">102</td>
    <td class="codeLine">/// precision of the product of \a BlockMass and \a BranchProbability.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">103</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="codeLine">/// The distribution algorithm follows.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">104</td>
    <td class="codeLine">/// The distribution algorithm follows.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">105</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="codeLine">///  1. Initialize by saving the sum of the weights in \a RemWeight and the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">106</td>
    <td class="codeLine">///  1. Initialize by saving the sum of the weights in \a RemWeight and the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="codeLine">///     mass to distribute in \a RemMass.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">107</td>
    <td class="codeLine">///     mass to distribute in \a RemMass.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">108</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="codeLine">///  2. For each portion:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">109</td>
    <td class="codeLine">///  2. For each portion:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">110</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="codeLine">///      1. Construct a branch probability, P, as the portion's weight divided</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">111</td>
    <td class="codeLine">///      1. Construct a branch probability, P, as the portion's weight divided</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="codeLine">///         by the current value of \a RemWeight.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">112</td>
    <td class="codeLine">///         by the current value of \a RemWeight.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="codeLine">///      2. Calculate the portion's mass as \a RemMass times P.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">113</td>
    <td class="codeLine">///      2. Calculate the portion's mass as \a RemMass times P.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="codeLine">///      3. Update \a RemWeight and \a RemMass at each portion by subtracting</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">114</td>
    <td class="codeLine">///      3. Update \a RemWeight and \a RemMass at each portion by subtracting</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="codeLine">///         the current portion's weight and mass.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">115</td>
    <td class="codeLine">///         the current portion's weight and mass.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="codeLine">struct DitheringDistributer {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">116</td>
    <td class="codeLine">struct DitheringDistributer {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="codeLine">  uint32_t RemWeight;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">117</td>
    <td class="codeLine">  uint32_t RemWeight;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="codeLine">  BlockMass RemMass;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">118</td>
    <td class="codeLine">  BlockMass RemMass;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">119</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="codeLine">  DitheringDistributer(Distribution &Dist, const BlockMass &Mass);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">120</td>
    <td class="codeLine">  DitheringDistributer(Distribution &Dist, const BlockMass &Mass);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">121</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="codeLine">  BlockMass takeMass(uint32_t Weight);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">122</td>
    <td class="codeLine">  BlockMass takeMass(uint32_t Weight);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">123</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">124</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="codeLine">} // end anonymous namespace</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">125</td>
    <td class="codeLine">} // end anonymous namespace</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">126</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="codeLine coveredLine">DitheringDistributer::DitheringDistributer(Distribution &Dist,</td>
    <td class="lineNumber">24</td>
    <td class="lineNumber">127</td>
    <td class="codeLine coveredLine">DitheringDistributer::DitheringDistributer(Distribution &Dist,</td>
    <td class="lineNumber">24</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="codeLine coveredLine">                                           const BlockMass &Mass) {</td>
    <td class="lineNumber">24</td>
    <td class="lineNumber">128</td>
    <td class="codeLine coveredLine">                                           const BlockMass &Mass) {</td>
    <td class="lineNumber">24</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="codeLine coveredLine">  Dist.normalize();</td>
    <td class="lineNumber">24</td>
    <td class="lineNumber">129</td>
    <td class="codeLine coveredLine">  Dist.normalize();</td>
    <td class="lineNumber">24</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="codeLine coveredLine">  RemWeight = Dist.Total;</td>
    <td class="lineNumber">24</td>
    <td class="lineNumber">130</td>
    <td class="codeLine coveredLine">  RemWeight = Dist.Total;</td>
    <td class="lineNumber">24</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="codeLine coveredLine">  RemMass = Mass;</td>
    <td class="lineNumber">24</td>
    <td class="lineNumber">131</td>
    <td class="codeLine coveredLine">  RemMass = Mass;</td>
    <td class="lineNumber">24</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="codeLine coveredLine">}</td>
    <td class="lineNumber">24</td>
    <td class="lineNumber">132</td>
    <td class="codeLine coveredLine">}</td>
    <td class="lineNumber">24</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">133</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="codeLine coveredLine">BlockMass DitheringDistributer::takeMass(uint32_t Weight) {</td>
    <td class="lineNumber">24</td>
    <td class="lineNumber">134</td>
    <td class="codeLine coveredLine">BlockMass DitheringDistributer::takeMass(uint32_t Weight) {</td>
    <td class="lineNumber">24</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="codeLine coveredLine">  assert(Weight && "invalid weight");</td>
    <td class="lineNumber">24</td>
    <td class="lineNumber">135</td>
    <td class="codeLine coveredLine">  assert(Weight && "invalid weight");</td>
    <td class="lineNumber">24</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="codeLine coveredLine">  assert(Weight <= RemWeight);</td>
    <td class="lineNumber">24</td>
    <td class="lineNumber">136</td>
    <td class="codeLine coveredLine">  assert(Weight <= RemWeight);</td>
    <td class="lineNumber">24</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="codeLine coveredLine">  BlockMass Mass = RemMass * BranchProbability(Weight, RemWeight);</td>
    <td class="lineNumber">24</td>
    <td class="lineNumber">137</td>
    <td class="codeLine coveredLine">  BlockMass Mass = RemMass * BranchProbability(Weight, RemWeight);</td>
    <td class="lineNumber">24</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">138</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="codeLine">  // Decrement totals (dither).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">139</td>
    <td class="codeLine">  // Decrement totals (dither).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="codeLine coveredLine">  RemWeight -= Weight;</td>
    <td class="lineNumber">24</td>
    <td class="lineNumber">140</td>
    <td class="codeLine coveredLine">  RemWeight -= Weight;</td>
    <td class="lineNumber">24</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="codeLine coveredLine">  RemMass -= Mass;</td>
    <td class="lineNumber">24</td>
    <td class="lineNumber">141</td>
    <td class="codeLine coveredLine">  RemMass -= Mass;</td>
    <td class="lineNumber">24</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="codeLine coveredLine">  return Mass;</td>
    <td class="lineNumber">24</td>
    <td class="lineNumber">142</td>
    <td class="codeLine coveredLine">  return Mass;</td>
    <td class="lineNumber">24</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">143</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">144</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="codeLine coveredLine">void Distribution::add(const BlockNode &Node, uint64_t Amount,</td>
    <td class="lineNumber">24</td>
    <td class="lineNumber">145</td>
    <td class="codeLine coveredLine">void Distribution::add(const BlockNode &Node, uint64_t Amount,</td>
    <td class="lineNumber">24</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="codeLine">                       Weight::DistType Type) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">146</td>
    <td class="codeLine">                       Weight::DistType Type) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="codeLine coveredLine">  assert(Amount && "invalid weight of 0");</td>
    <td class="lineNumber">24</td>
    <td class="lineNumber">147</td>
    <td class="codeLine coveredLine">  assert(Amount && "invalid weight of 0");</td>
    <td class="lineNumber">24</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="codeLine coveredLine">  uint64_t NewTotal = Total + Amount;</td>
    <td class="lineNumber">24</td>
    <td class="lineNumber">148</td>
    <td class="codeLine coveredLine">  uint64_t NewTotal = Total + Amount;</td>
    <td class="lineNumber">24</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">149</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="codeLine">  // Check for overflow.  It should be impossible to overflow twice.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">150</td>
    <td class="codeLine">  // Check for overflow.  It should be impossible to overflow twice.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="codeLine coveredLine">  bool IsOverflow = NewTotal < Total;</td>
    <td class="lineNumber">24</td>
    <td class="lineNumber">151</td>
    <td class="codeLine coveredLine">  bool IsOverflow = NewTotal < Total;</td>
    <td class="lineNumber">24</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="codeLine coveredLine">  assert(!(DidOverflow && IsOverflow) && "unexpected repeated overflow");</td>
    <td class="lineNumber">24</td>
    <td class="lineNumber">152</td>
    <td class="codeLine coveredLine">  assert(!(DidOverflow && IsOverflow) && "unexpected repeated overflow");</td>
    <td class="lineNumber">24</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="codeLine coveredLine">  DidOverflow |= IsOverflow;</td>
    <td class="lineNumber">24</td>
    <td class="lineNumber">153</td>
    <td class="codeLine coveredLine">  DidOverflow |= IsOverflow;</td>
    <td class="lineNumber">24</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">154</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="codeLine">  // Update the total.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">155</td>
    <td class="codeLine">  // Update the total.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="codeLine coveredLine">  Total = NewTotal;</td>
    <td class="lineNumber">24</td>
    <td class="lineNumber">156</td>
    <td class="codeLine coveredLine">  Total = NewTotal;</td>
    <td class="lineNumber">24</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">157</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="codeLine">  // Save the weight.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">158</td>
    <td class="codeLine">  // Save the weight.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="codeLine coveredLine">  Weights.push_back(Weight(Type, Node, Amount));</td>
    <td class="lineNumber">24</td>
    <td class="lineNumber">159</td>
    <td class="codeLine coveredLine">  Weights.push_back(Weight(Type, Node, Amount));</td>
    <td class="lineNumber">24</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="codeLine coveredLine">}</td>
    <td class="lineNumber">24</td>
    <td class="lineNumber">160</td>
    <td class="codeLine coveredLine">}</td>
    <td class="lineNumber">24</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">161</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="codeLine">static void combineWeight(Weight &W, const Weight &OtherW) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">162</td>
    <td class="codeLine">static void combineWeight(Weight &W, const Weight &OtherW) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="codeLine">  assert(OtherW.TargetNode.isValid());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">163</td>
    <td class="codeLine">  assert(OtherW.TargetNode.isValid());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="codeLine">  if (!W.Amount) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">164</td>
    <td class="codeLine">  if (!W.Amount) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="codeLine">    W = OtherW;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">165</td>
    <td class="codeLine">    W = OtherW;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">166</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">167</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="codeLine">  assert(W.Type == OtherW.Type);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">168</td>
    <td class="codeLine">  assert(W.Type == OtherW.Type);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="codeLine">  assert(W.TargetNode == OtherW.TargetNode);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">169</td>
    <td class="codeLine">  assert(W.TargetNode == OtherW.TargetNode);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="codeLine">  assert(OtherW.Amount && "Expected non-zero weight");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">170</td>
    <td class="codeLine">  assert(OtherW.Amount && "Expected non-zero weight");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="codeLine">  if (W.Amount > W.Amount + OtherW.Amount)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">171</td>
    <td class="codeLine">  if (W.Amount > W.Amount + OtherW.Amount)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="codeLine">    // Saturate on overflow.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">172</td>
    <td class="codeLine">    // Saturate on overflow.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="codeLine">    W.Amount = UINT64_MAX;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">173</td>
    <td class="codeLine">    W.Amount = UINT64_MAX;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">174</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="codeLine">    W.Amount += OtherW.Amount;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">175</td>
    <td class="codeLine">    W.Amount += OtherW.Amount;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">176</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">177</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="codeLine coveredLine">static void combineWeightsBySorting(WeightList &Weights) {</td>
    <td class="lineNumber">6</td>
    <td class="lineNumber">178</td>
    <td class="codeLine coveredLine">static void combineWeightsBySorting(WeightList &Weights) {</td>
    <td class="lineNumber">6</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="codeLine">  // Sort so edges to the same node are adjacent.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">179</td>
    <td class="codeLine">  // Sort so edges to the same node are adjacent.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="codeLine coveredLine">  llvm::sort(Weights, [](const Weight &L, const Weight &R) {</td>
    <td class="lineNumber">6</td>
    <td class="lineNumber">180</td>
    <td class="codeLine coveredLine">  llvm::sort(Weights, [](const Weight &L, const Weight &R) {</td>
    <td class="lineNumber">6</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="codeLine coveredLine">    return L.TargetNode < R.TargetNode;</td>
    <td class="lineNumber">6</td>
    <td class="lineNumber">181</td>
    <td class="codeLine coveredLine">    return L.TargetNode < R.TargetNode;</td>
    <td class="lineNumber">6</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="codeLine">  });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">182</td>
    <td class="codeLine">  });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">183</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="codeLine">  // Combine adjacent edges.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">184</td>
    <td class="codeLine">  // Combine adjacent edges.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="codeLine coveredLine">  WeightList::iterator O = Weights.begin();</td>
    <td class="lineNumber">6</td>
    <td class="lineNumber">185</td>
    <td class="codeLine coveredLine">  WeightList::iterator O = Weights.begin();</td>
    <td class="lineNumber">6</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="codeLine coveredLine">  for (WeightList::const_iterator I = O, L = O, E = Weights.end(); I != E;</td>
    <td class="lineNumber">18</td>
    <td class="lineNumber">186</td>
    <td class="codeLine coveredLine">  for (WeightList::const_iterator I = O, L = O, E = Weights.end(); I != E;</td>
    <td class="lineNumber">18</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="codeLine coveredLine">       ++O, (I = L)) {</td>
    <td class="lineNumber">12</td>
    <td class="lineNumber">187</td>
    <td class="codeLine coveredLine">       ++O, (I = L)) {</td>
    <td class="lineNumber">12</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="codeLine coveredLine">    *O = *I;</td>
    <td class="lineNumber">12</td>
    <td class="lineNumber">188</td>
    <td class="codeLine coveredLine">    *O = *I;</td>
    <td class="lineNumber">12</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">189</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="codeLine">    // Find the adjacent weights to the same node.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">190</td>
    <td class="codeLine">    // Find the adjacent weights to the same node.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="codeLine coveredLine">    for (++L; L != E && I->TargetNode == L->TargetNode; ++L)</td>
    <td class="lineNumber">12</td>
    <td class="lineNumber">191</td>
    <td class="codeLine coveredLine">    for (++L; L != E && I->TargetNode == L->TargetNode; ++L)</td>
    <td class="lineNumber">12</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="codeLine">      combineWeight(*O, *L);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">192</td>
    <td class="codeLine">      combineWeight(*O, *L);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">193</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">194</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="codeLine">  // Erase extra entries.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">195</td>
    <td class="codeLine">  // Erase extra entries.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="codeLine coveredLine">  Weights.erase(O, Weights.end());</td>
    <td class="lineNumber">6</td>
    <td class="lineNumber">196</td>
    <td class="codeLine coveredLine">  Weights.erase(O, Weights.end());</td>
    <td class="lineNumber">6</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="codeLine coveredLine">}</td>
    <td class="lineNumber">6</td>
    <td class="lineNumber">197</td>
    <td class="codeLine coveredLine">}</td>
    <td class="lineNumber">6</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">198</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="codeLine">static void combineWeightsByHashing(WeightList &Weights) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">199</td>
    <td class="codeLine">static void combineWeightsByHashing(WeightList &Weights) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="codeLine">  // Collect weights into a DenseMap.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">200</td>
    <td class="codeLine">  // Collect weights into a DenseMap.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="codeLine">  using HashTable = DenseMap<BlockNode::IndexType, Weight>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">201</td>
    <td class="codeLine">  using HashTable = DenseMap<BlockNode::IndexType, Weight>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">202</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="codeLine">  HashTable Combined(NextPowerOf2(2 * Weights.size()));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">203</td>
    <td class="codeLine">  HashTable Combined(NextPowerOf2(2 * Weights.size()));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="codeLine">  for (const Weight &W : Weights)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">204</td>
    <td class="codeLine">  for (const Weight &W : Weights)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="codeLine">    combineWeight(Combined[W.TargetNode.Index], W);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">205</td>
    <td class="codeLine">    combineWeight(Combined[W.TargetNode.Index], W);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">206</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="codeLine">  // Check whether anything changed.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">207</td>
    <td class="codeLine">  // Check whether anything changed.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="codeLine">  if (Weights.size() == Combined.size())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">208</td>
    <td class="codeLine">  if (Weights.size() == Combined.size())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">209</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">210</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="codeLine">  // Fill in the new weights.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">211</td>
    <td class="codeLine">  // Fill in the new weights.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="codeLine">  Weights.clear();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">212</td>
    <td class="codeLine">  Weights.clear();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="codeLine">  Weights.reserve(Combined.size());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">213</td>
    <td class="codeLine">  Weights.reserve(Combined.size());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="codeLine">  for (const auto &I : Combined)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">214</td>
    <td class="codeLine">  for (const auto &I : Combined)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="codeLine">    Weights.push_back(I.second);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">215</td>
    <td class="codeLine">    Weights.push_back(I.second);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">216</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">217</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="codeLine coveredLine">static void combineWeights(WeightList &Weights) {</td>
    <td class="lineNumber">6</td>
    <td class="lineNumber">218</td>
    <td class="codeLine coveredLine">static void combineWeights(WeightList &Weights) {</td>
    <td class="lineNumber">6</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="codeLine">  // Use a hash table for many successors to keep this linear.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">219</td>
    <td class="codeLine">  // Use a hash table for many successors to keep this linear.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="codeLine coveredLine">  if (Weights.size() > 128) {</td>
    <td class="lineNumber">6</td>
    <td class="lineNumber">220</td>
    <td class="codeLine coveredLine">  if (Weights.size() > 128) {</td>
    <td class="lineNumber">6</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="codeLine">    combineWeightsByHashing(Weights);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">221</td>
    <td class="codeLine">    combineWeightsByHashing(Weights);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">222</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">223</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">224</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="codeLine coveredLine">  combineWeightsBySorting(Weights);</td>
    <td class="lineNumber">6</td>
    <td class="lineNumber">225</td>
    <td class="codeLine coveredLine">  combineWeightsBySorting(Weights);</td>
    <td class="lineNumber">6</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">226</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">227</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="codeLine">static uint64_t shiftRightAndRound(uint64_t N, int Shift) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">228</td>
    <td class="codeLine">static uint64_t shiftRightAndRound(uint64_t N, int Shift) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="codeLine">  assert(Shift >= 0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">229</td>
    <td class="codeLine">  assert(Shift >= 0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="codeLine">  assert(Shift < 64);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">230</td>
    <td class="codeLine">  assert(Shift < 64);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="codeLine">  if (!Shift)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">231</td>
    <td class="codeLine">  if (!Shift)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="codeLine">    return N;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">232</td>
    <td class="codeLine">    return N;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="codeLine">  return (N >> Shift) + (UINT64_C(1) & N >> (Shift - 1));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">233</td>
    <td class="codeLine">  return (N >> Shift) + (UINT64_C(1) & N >> (Shift - 1));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">234</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">235</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="codeLine coveredLine">void Distribution::normalize() {</td>
    <td class="lineNumber">24</td>
    <td class="lineNumber">236</td>
    <td class="codeLine coveredLine">void Distribution::normalize() {</td>
    <td class="lineNumber">24</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="codeLine">  // Early exit for termination nodes.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">237</td>
    <td class="codeLine">  // Early exit for termination nodes.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="codeLine coveredLine">  if (Weights.empty())</td>
    <td class="lineNumber">24</td>
    <td class="lineNumber">238</td>
    <td class="codeLine coveredLine">  if (Weights.empty())</td>
    <td class="lineNumber">24</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="codeLine coveredLine">    return;</td>
    <td class="lineNumber">6</td>
    <td class="lineNumber">239</td>
    <td class="codeLine coveredLine">    return;</td>
    <td class="lineNumber">6</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">240</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="codeLine">  // Only bother if there are multiple successors.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">241</td>
    <td class="codeLine">  // Only bother if there are multiple successors.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="codeLine coveredLine">  if (Weights.size() > 1)</td>
    <td class="lineNumber">18</td>
    <td class="lineNumber">242</td>
    <td class="codeLine coveredLine">  if (Weights.size() > 1)</td>
    <td class="lineNumber">18</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="codeLine coveredLine">    combineWeights(Weights);</td>
    <td class="lineNumber">6</td>
    <td class="lineNumber">243</td>
    <td class="codeLine coveredLine">    combineWeights(Weights);</td>
    <td class="lineNumber">6</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">244</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="codeLine">  // Early exit when combined into a single successor.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">245</td>
    <td class="codeLine">  // Early exit when combined into a single successor.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="codeLine coveredLine">  if (Weights.size() == 1) {</td>
    <td class="lineNumber">18</td>
    <td class="lineNumber">246</td>
    <td class="codeLine coveredLine">  if (Weights.size() == 1) {</td>
    <td class="lineNumber">18</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="codeLine coveredLine">    Total = 1;</td>
    <td class="lineNumber">12</td>
    <td class="lineNumber">247</td>
    <td class="codeLine coveredLine">    Total = 1;</td>
    <td class="lineNumber">12</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="codeLine coveredLine">    Weights.front().Amount = 1;</td>
    <td class="lineNumber">12</td>
    <td class="lineNumber">248</td>
    <td class="codeLine coveredLine">    Weights.front().Amount = 1;</td>
    <td class="lineNumber">12</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="codeLine coveredLine">    return;</td>
    <td class="lineNumber">12</td>
    <td class="lineNumber">249</td>
    <td class="codeLine coveredLine">    return;</td>
    <td class="lineNumber">12</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">250</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">251</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="codeLine">  // Determine how much to shift right so that the total fits into 32-bits.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">252</td>
    <td class="codeLine">  // Determine how much to shift right so that the total fits into 32-bits.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">253</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="codeLine">  // If we shift at all, shift by 1 extra.  Otherwise, the lower limit of 1</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">254</td>
    <td class="codeLine">  // If we shift at all, shift by 1 extra.  Otherwise, the lower limit of 1</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="codeLine">  // for each weight can cause a 32-bit overflow.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">255</td>
    <td class="codeLine">  // for each weight can cause a 32-bit overflow.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="codeLine coveredLine">  int Shift = 0;</td>
    <td class="lineNumber">6</td>
    <td class="lineNumber">256</td>
    <td class="codeLine coveredLine">  int Shift = 0;</td>
    <td class="lineNumber">6</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="codeLine coveredLine">  if (DidOverflow)</td>
    <td class="lineNumber">6</td>
    <td class="lineNumber">257</td>
    <td class="codeLine coveredLine">  if (DidOverflow)</td>
    <td class="lineNumber">6</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="codeLine">    Shift = 33;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">258</td>
    <td class="codeLine">    Shift = 33;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="codeLine coveredLine">  else if (Total > UINT32_MAX)</td>
    <td class="lineNumber">6</td>
    <td class="lineNumber">259</td>
    <td class="codeLine coveredLine">  else if (Total > UINT32_MAX)</td>
    <td class="lineNumber">6</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="codeLine">    Shift = 33 - llvm::countl_zero(Total);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">260</td>
    <td class="codeLine">    Shift = 33 - llvm::countl_zero(Total);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">261</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="codeLine">  // Early exit if nothing needs to be scaled.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">262</td>
    <td class="codeLine">  // Early exit if nothing needs to be scaled.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="codeLine coveredLine">  if (!Shift) {</td>
    <td class="lineNumber">6</td>
    <td class="lineNumber">263</td>
    <td class="codeLine coveredLine">  if (!Shift) {</td>
    <td class="lineNumber">6</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="codeLine">    // If we didn't overflow then combineWeights() shouldn't have changed the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">264</td>
    <td class="codeLine">    // If we didn't overflow then combineWeights() shouldn't have changed the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="codeLine">    // sum of the weights, but let's double-check.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">265</td>
    <td class="codeLine">    // sum of the weights, but let's double-check.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="codeLine coveredLine">    assert(Total == std::accumulate(Weights.begin(), Weights.end(), UINT64_C(0),</td>
    <td class="lineNumber">18</td>
    <td class="lineNumber">266</td>
    <td class="codeLine coveredLine">    assert(Total == std::accumulate(Weights.begin(), Weights.end(), UINT64_C(0),</td>
    <td class="lineNumber">18</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="codeLine">                                    [](uint64_t Sum, const Weight &W) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">267</td>
    <td class="codeLine">                                    [](uint64_t Sum, const Weight &W) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="codeLine">                      return Sum + W.Amount;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">268</td>
    <td class="codeLine">                      return Sum + W.Amount;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="codeLine">                    }) &&</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">269</td>
    <td class="codeLine">                    }) &&</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="codeLine">           "Expected total to be correct");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">270</td>
    <td class="codeLine">           "Expected total to be correct");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="codeLine coveredLine">    return;</td>
    <td class="lineNumber">6</td>
    <td class="lineNumber">271</td>
    <td class="codeLine coveredLine">    return;</td>
    <td class="lineNumber">6</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">272</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">273</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="codeLine">  // Recompute the total through accumulation (rather than shifting it) so that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">274</td>
    <td class="codeLine">  // Recompute the total through accumulation (rather than shifting it) so that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="codeLine">  // it's accurate after shifting and any changes combineWeights() made above.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">275</td>
    <td class="codeLine">  // it's accurate after shifting and any changes combineWeights() made above.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="codeLine">  Total = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">276</td>
    <td class="codeLine">  Total = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">277</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="codeLine">  // Sum the weights to each node and shift right if necessary.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">278</td>
    <td class="codeLine">  // Sum the weights to each node and shift right if necessary.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="codeLine">  for (Weight &W : Weights) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">279</td>
    <td class="codeLine">  for (Weight &W : Weights) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="codeLine">    // Scale down below UINT32_MAX.  Since Shift is larger than necessary, we</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">280</td>
    <td class="codeLine">    // Scale down below UINT32_MAX.  Since Shift is larger than necessary, we</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="codeLine">    // can round here without concern about overflow.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">281</td>
    <td class="codeLine">    // can round here without concern about overflow.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="codeLine">    assert(W.TargetNode.isValid());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">282</td>
    <td class="codeLine">    assert(W.TargetNode.isValid());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="codeLine">    W.Amount = std::max(UINT64_C(1), shiftRightAndRound(W.Amount, Shift));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">283</td>
    <td class="codeLine">    W.Amount = std::max(UINT64_C(1), shiftRightAndRound(W.Amount, Shift));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="codeLine">    assert(W.Amount <= UINT32_MAX);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">284</td>
    <td class="codeLine">    assert(W.Amount <= UINT32_MAX);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">285</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="codeLine">    // Update the total.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">286</td>
    <td class="codeLine">    // Update the total.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="codeLine">    Total += W.Amount;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">287</td>
    <td class="codeLine">    Total += W.Amount;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">288</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="codeLine">  assert(Total <= UINT32_MAX);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">289</td>
    <td class="codeLine">  assert(Total <= UINT32_MAX);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">290</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">291</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="codeLine coveredLine">void BlockFrequencyInfoImplBase::clear() {</td>
    <td class="lineNumber">12</td>
    <td class="lineNumber">292</td>
    <td class="codeLine coveredLine">void BlockFrequencyInfoImplBase::clear() {</td>
    <td class="lineNumber">12</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="codeLine">  // Swap with a default-constructed std::vector, since std::vector<>::clear()</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">293</td>
    <td class="codeLine">  // Swap with a default-constructed std::vector, since std::vector<>::clear()</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="codeLine">  // does not actually clear heap storage.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">294</td>
    <td class="codeLine">  // does not actually clear heap storage.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="codeLine coveredLine">  std::vector<FrequencyData>().swap(Freqs);</td>
    <td class="lineNumber">12</td>
    <td class="lineNumber">295</td>
    <td class="codeLine coveredLine">  std::vector<FrequencyData>().swap(Freqs);</td>
    <td class="lineNumber">12</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="codeLine coveredLine">  IsIrrLoopHeader.clear();</td>
    <td class="lineNumber">12</td>
    <td class="lineNumber">296</td>
    <td class="codeLine coveredLine">  IsIrrLoopHeader.clear();</td>
    <td class="lineNumber">12</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="codeLine coveredLine">  std::vector<WorkingData>().swap(Working);</td>
    <td class="lineNumber">12</td>
    <td class="lineNumber">297</td>
    <td class="codeLine coveredLine">  std::vector<WorkingData>().swap(Working);</td>
    <td class="lineNumber">12</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="codeLine coveredLine">  Loops.clear();</td>
    <td class="lineNumber">12</td>
    <td class="lineNumber">298</td>
    <td class="codeLine coveredLine">  Loops.clear();</td>
    <td class="lineNumber">12</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="codeLine coveredLine">}</td>
    <td class="lineNumber">12</td>
    <td class="lineNumber">299</td>
    <td class="codeLine coveredLine">}</td>
    <td class="lineNumber">12</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">300</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="codeLine">/// Clear all memory not needed downstream.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">301</td>
    <td class="codeLine">/// Clear all memory not needed downstream.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">302</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="codeLine">/// Releases all memory not used downstream.  In particular, saves Freqs.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">303</td>
    <td class="codeLine">/// Releases all memory not used downstream.  In particular, saves Freqs.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="codeLine coveredLine">static void cleanup(BlockFrequencyInfoImplBase &BFI) {</td>
    <td class="lineNumber">6</td>
    <td class="lineNumber">304</td>
    <td class="codeLine coveredLine">static void cleanup(BlockFrequencyInfoImplBase &BFI) {</td>
    <td class="lineNumber">6</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="codeLine coveredLine">  std::vector<FrequencyData> SavedFreqs(std::move(BFI.Freqs));</td>
    <td class="lineNumber">6</td>
    <td class="lineNumber">305</td>
    <td class="codeLine coveredLine">  std::vector<FrequencyData> SavedFreqs(std::move(BFI.Freqs));</td>
    <td class="lineNumber">6</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="codeLine coveredLine">  SparseBitVector<> SavedIsIrrLoopHeader(std::move(BFI.IsIrrLoopHeader));</td>
    <td class="lineNumber">6</td>
    <td class="lineNumber">306</td>
    <td class="codeLine coveredLine">  SparseBitVector<> SavedIsIrrLoopHeader(std::move(BFI.IsIrrLoopHeader));</td>
    <td class="lineNumber">6</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="codeLine coveredLine">  BFI.clear();</td>
    <td class="lineNumber">6</td>
    <td class="lineNumber">307</td>
    <td class="codeLine coveredLine">  BFI.clear();</td>
    <td class="lineNumber">6</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="codeLine coveredLine">  BFI.Freqs = std::move(SavedFreqs);</td>
    <td class="lineNumber">6</td>
    <td class="lineNumber">308</td>
    <td class="codeLine coveredLine">  BFI.Freqs = std::move(SavedFreqs);</td>
    <td class="lineNumber">6</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="codeLine coveredLine">  BFI.IsIrrLoopHeader = std::move(SavedIsIrrLoopHeader);</td>
    <td class="lineNumber">6</td>
    <td class="lineNumber">309</td>
    <td class="codeLine coveredLine">  BFI.IsIrrLoopHeader = std::move(SavedIsIrrLoopHeader);</td>
    <td class="lineNumber">6</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="codeLine coveredLine">}</td>
    <td class="lineNumber">6</td>
    <td class="lineNumber">310</td>
    <td class="codeLine coveredLine">}</td>
    <td class="lineNumber">6</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">311</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="codeLine coveredLine">bool BlockFrequencyInfoImplBase::addToDist(Distribution &Dist,</td>
    <td class="lineNumber">24</td>
    <td class="lineNumber">312</td>
    <td class="codeLine coveredLine">bool BlockFrequencyInfoImplBase::addToDist(Distribution &Dist,</td>
    <td class="lineNumber">24</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="codeLine">                                           const LoopData *OuterLoop,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">313</td>
    <td class="codeLine">                                           const LoopData *OuterLoop,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="codeLine">                                           const BlockNode &Pred,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">314</td>
    <td class="codeLine">                                           const BlockNode &Pred,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="codeLine">                                           const BlockNode &Succ,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">315</td>
    <td class="codeLine">                                           const BlockNode &Succ,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="codeLine">                                           uint64_t Weight) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">316</td>
    <td class="codeLine">                                           uint64_t Weight) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="codeLine coveredLine">  if (!Weight)</td>
    <td class="lineNumber">24</td>
    <td class="lineNumber">317</td>
    <td class="codeLine coveredLine">  if (!Weight)</td>
    <td class="lineNumber">24</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="codeLine">    Weight = 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">318</td>
    <td class="codeLine">    Weight = 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">319</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="codeLine coveredLine">  auto isLoopHeader = [&OuterLoop](const BlockNode &Node) {</td>
    <td class="lineNumber">24</td>
    <td class="lineNumber">320</td>
    <td class="codeLine coveredLine">  auto isLoopHeader = [&OuterLoop](const BlockNode &Node) {</td>
    <td class="lineNumber">24</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="codeLine coveredLine">    return OuterLoop && OuterLoop->isHeader(Node);</td>
    <td class="lineNumber">24</td>
    <td class="lineNumber">321</td>
    <td class="codeLine coveredLine">    return OuterLoop && OuterLoop->isHeader(Node);</td>
    <td class="lineNumber">24</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="codeLine coveredLine">  };</td>
    <td class="lineNumber">24</td>
    <td class="lineNumber">322</td>
    <td class="codeLine coveredLine">  };</td>
    <td class="lineNumber">24</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">323</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="codeLine coveredLine">  BlockNode Resolved = Working[Succ.Index].getResolvedNode();</td>
    <td class="lineNumber">24</td>
    <td class="lineNumber">324</td>
    <td class="codeLine coveredLine">  BlockNode Resolved = Working[Succ.Index].getResolvedNode();</td>
    <td class="lineNumber">24</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">325</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="codeLine">#ifndef NDEBUG</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">326</td>
    <td class="codeLine">#ifndef NDEBUG</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="codeLine">  auto debugSuccessor = [&](const char *Type) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">327</td>
    <td class="codeLine">  auto debugSuccessor = [&](const char *Type) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="codeLine">    dbgs() << "  =>"</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">328</td>
    <td class="codeLine">    dbgs() << "  =>"</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="codeLine">           << " [" << Type << "] weight = " << Weight;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">329</td>
    <td class="codeLine">           << " [" << Type << "] weight = " << Weight;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="codeLine">    if (!isLoopHeader(Resolved))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">330</td>
    <td class="codeLine">    if (!isLoopHeader(Resolved))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="codeLine">      dbgs() << ", succ = " << getBlockName(Succ);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">331</td>
    <td class="codeLine">      dbgs() << ", succ = " << getBlockName(Succ);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="codeLine">    if (Resolved != Succ)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">332</td>
    <td class="codeLine">    if (Resolved != Succ)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="codeLine">      dbgs() << ", resolved = " << getBlockName(Resolved);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">333</td>
    <td class="codeLine">      dbgs() << ", resolved = " << getBlockName(Resolved);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="codeLine">    dbgs() << "\n";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">334</td>
    <td class="codeLine">    dbgs() << "\n";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="codeLine coveredLine">  };</td>
    <td class="lineNumber">24</td>
    <td class="lineNumber">335</td>
    <td class="codeLine coveredLine">  };</td>
    <td class="lineNumber">24</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="codeLine">  (void)debugSuccessor;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">336</td>
    <td class="codeLine">  (void)debugSuccessor;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">337</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">338</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="codeLine coveredLine">  if (isLoopHeader(Resolved)) {</td>
    <td class="lineNumber">24</td>
    <td class="lineNumber">339</td>
    <td class="codeLine coveredLine">  if (isLoopHeader(Resolved)) {</td>
    <td class="lineNumber">24</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="codeLine">    LLVM_DEBUG(debugSuccessor("backedge"));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">340</td>
    <td class="codeLine">    LLVM_DEBUG(debugSuccessor("backedge"));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="codeLine">    Dist.addBackedge(Resolved, Weight);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">341</td>
    <td class="codeLine">    Dist.addBackedge(Resolved, Weight);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">342</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">343</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">344</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="codeLine coveredLine">  if (Working[Resolved.Index].getContainingLoop() != OuterLoop) {</td>
    <td class="lineNumber">24</td>
    <td class="lineNumber">345</td>
    <td class="codeLine coveredLine">  if (Working[Resolved.Index].getContainingLoop() != OuterLoop) {</td>
    <td class="lineNumber">24</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="codeLine">    LLVM_DEBUG(debugSuccessor("  exit  "));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">346</td>
    <td class="codeLine">    LLVM_DEBUG(debugSuccessor("  exit  "));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="codeLine">    Dist.addExit(Resolved, Weight);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">347</td>
    <td class="codeLine">    Dist.addExit(Resolved, Weight);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">348</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">349</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">350</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="codeLine coveredLine">  if (Resolved < Pred) {</td>
    <td class="lineNumber">24</td>
    <td class="lineNumber">351</td>
    <td class="codeLine coveredLine">  if (Resolved < Pred) {</td>
    <td class="lineNumber">24</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="codeLine">    if (!isLoopHeader(Pred)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">352</td>
    <td class="codeLine">    if (!isLoopHeader(Pred)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="codeLine">      // If OuterLoop is an irreducible loop, we can't actually handle this.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">353</td>
    <td class="codeLine">      // If OuterLoop is an irreducible loop, we can't actually handle this.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="codeLine">      assert((!OuterLoop || !OuterLoop->isIrreducible()) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">354</td>
    <td class="codeLine">      assert((!OuterLoop || !OuterLoop->isIrreducible()) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="codeLine">             "unhandled irreducible control flow");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">355</td>
    <td class="codeLine">             "unhandled irreducible control flow");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">356</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="codeLine">      // Irreducible backedge.  Abort.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">357</td>
    <td class="codeLine">      // Irreducible backedge.  Abort.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="codeLine">      LLVM_DEBUG(debugSuccessor("abort!!!"));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">358</td>
    <td class="codeLine">      LLVM_DEBUG(debugSuccessor("abort!!!"));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">359</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">360</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">361</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="codeLine">    // If "Pred" is a loop header, then this isn't really a backedge; rather,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">362</td>
    <td class="codeLine">    // If "Pred" is a loop header, then this isn't really a backedge; rather,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="codeLine">    // OuterLoop must be irreducible.  These false backedges can come only from</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">363</td>
    <td class="codeLine">    // OuterLoop must be irreducible.  These false backedges can come only from</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="codeLine">    // secondary loop headers.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">364</td>
    <td class="codeLine">    // secondary loop headers.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="codeLine">    assert(OuterLoop && OuterLoop->isIrreducible() && !isLoopHeader(Resolved) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">365</td>
    <td class="codeLine">    assert(OuterLoop && OuterLoop->isIrreducible() && !isLoopHeader(Resolved) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="codeLine">           "unhandled irreducible control flow");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">366</td>
    <td class="codeLine">           "unhandled irreducible control flow");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">367</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">368</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="codeLine coveredLine">  LLVM_DEBUG(debugSuccessor(" local  "));</td>
    <td class="lineNumber">24</td>
    <td class="lineNumber">369</td>
    <td class="codeLine coveredLine">  LLVM_DEBUG(debugSuccessor(" local  "));</td>
    <td class="lineNumber">24</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="codeLine coveredLine">  Dist.addLocal(Resolved, Weight);</td>
    <td class="lineNumber">24</td>
    <td class="lineNumber">370</td>
    <td class="codeLine coveredLine">  Dist.addLocal(Resolved, Weight);</td>
    <td class="lineNumber">24</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="codeLine coveredLine">  return true;</td>
    <td class="lineNumber">24</td>
    <td class="lineNumber">371</td>
    <td class="codeLine coveredLine">  return true;</td>
    <td class="lineNumber">24</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">372</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">373</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="codeLine">bool BlockFrequencyInfoImplBase::addLoopSuccessorsToDist(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">374</td>
    <td class="codeLine">bool BlockFrequencyInfoImplBase::addLoopSuccessorsToDist(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="codeLine">    const LoopData *OuterLoop, LoopData &Loop, Distribution &Dist) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">375</td>
    <td class="codeLine">    const LoopData *OuterLoop, LoopData &Loop, Distribution &Dist) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="codeLine">  // Copy the exit map into Dist.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">376</td>
    <td class="codeLine">  // Copy the exit map into Dist.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="codeLine">  for (const auto &I : Loop.Exits)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">377</td>
    <td class="codeLine">  for (const auto &I : Loop.Exits)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="codeLine">    if (!addToDist(Dist, OuterLoop, Loop.getHeader(), I.first,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">378</td>
    <td class="codeLine">    if (!addToDist(Dist, OuterLoop, Loop.getHeader(), I.first,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="codeLine">                   I.second.getMass()))</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">379</td>
    <td class="codeLine">                   I.second.getMass()))</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="codeLine">      // Irreducible backedge.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">380</td>
    <td class="codeLine">      // Irreducible backedge.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">381</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">382</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">383</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">384</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">385</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="codeLine">/// Compute the loop scale for a loop.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">386</td>
    <td class="codeLine">/// Compute the loop scale for a loop.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="codeLine">void BlockFrequencyInfoImplBase::computeLoopScale(LoopData &Loop) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">387</td>
    <td class="codeLine">void BlockFrequencyInfoImplBase::computeLoopScale(LoopData &Loop) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="codeLine">  // Compute loop scale.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">388</td>
    <td class="codeLine">  // Compute loop scale.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "compute-loop-scale: " << getLoopName(Loop) << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">389</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "compute-loop-scale: " << getLoopName(Loop) << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">390</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="codeLine">  // Infinite loops need special handling. If we give the back edge an infinite</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">391</td>
    <td class="codeLine">  // Infinite loops need special handling. If we give the back edge an infinite</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="codeLine">  // mass, they may saturate all the other scales in the function down to 1,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">392</td>
    <td class="codeLine">  // mass, they may saturate all the other scales in the function down to 1,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="codeLine">  // making all the other region temperatures look exactly the same. Choose an</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">393</td>
    <td class="codeLine">  // making all the other region temperatures look exactly the same. Choose an</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="codeLine">  // arbitrary scale to avoid these issues.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">394</td>
    <td class="codeLine">  // arbitrary scale to avoid these issues.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">395</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="codeLine">  // FIXME: An alternate way would be to select a symbolic scale which is later</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">396</td>
    <td class="codeLine">  // FIXME: An alternate way would be to select a symbolic scale which is later</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="codeLine">  // replaced to be the maximum of all computed scales plus 1. This would</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">397</td>
    <td class="codeLine">  // replaced to be the maximum of all computed scales plus 1. This would</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="codeLine">  // appropriately describe the loop as having a large scale, without skewing</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">398</td>
    <td class="codeLine">  // appropriately describe the loop as having a large scale, without skewing</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="codeLine">  // the final frequency computation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">399</td>
    <td class="codeLine">  // the final frequency computation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="codeLine">  const Scaled64 InfiniteLoopScale(1, 12);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">400</td>
    <td class="codeLine">  const Scaled64 InfiniteLoopScale(1, 12);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">401</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="codeLine">  // LoopScale == 1 / ExitMass</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">402</td>
    <td class="codeLine">  // LoopScale == 1 / ExitMass</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="codeLine">  // ExitMass == HeadMass - BackedgeMass</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">403</td>
    <td class="codeLine">  // ExitMass == HeadMass - BackedgeMass</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="codeLine">  BlockMass TotalBackedgeMass;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">404</td>
    <td class="codeLine">  BlockMass TotalBackedgeMass;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="codeLine">  for (auto &Mass : Loop.BackedgeMass)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">405</td>
    <td class="codeLine">  for (auto &Mass : Loop.BackedgeMass)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="codeLine">    TotalBackedgeMass += Mass;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">406</td>
    <td class="codeLine">    TotalBackedgeMass += Mass;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="codeLine">  BlockMass ExitMass = BlockMass::getFull() - TotalBackedgeMass;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">407</td>
    <td class="codeLine">  BlockMass ExitMass = BlockMass::getFull() - TotalBackedgeMass;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">408</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="codeLine">  // Block scale stores the inverse of the scale. If this is an infinite loop,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">409</td>
    <td class="codeLine">  // Block scale stores the inverse of the scale. If this is an infinite loop,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="codeLine">  // its exit mass will be zero. In this case, use an arbitrary scale for the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">410</td>
    <td class="codeLine">  // its exit mass will be zero. In this case, use an arbitrary scale for the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="codeLine">  // loop scale.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">411</td>
    <td class="codeLine">  // loop scale.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="codeLine">  Loop.Scale =</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">412</td>
    <td class="codeLine">  Loop.Scale =</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="codeLine">      ExitMass.isEmpty() ? InfiniteLoopScale : ExitMass.toScaled().inverse();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">413</td>
    <td class="codeLine">      ExitMass.isEmpty() ? InfiniteLoopScale : ExitMass.toScaled().inverse();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">414</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << " - exit-mass = " << ExitMass << " ("</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">415</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << " - exit-mass = " << ExitMass << " ("</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="codeLine">                    << BlockMass::getFull() << " - " << TotalBackedgeMass</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">416</td>
    <td class="codeLine">                    << BlockMass::getFull() << " - " << TotalBackedgeMass</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="codeLine">                    << ")\n"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">417</td>
    <td class="codeLine">                    << ")\n"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="codeLine">                    << " - scale = " << Loop.Scale << "\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">418</td>
    <td class="codeLine">                    << " - scale = " << Loop.Scale << "\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">419</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">420</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="codeLine">/// Package up a loop.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">421</td>
    <td class="codeLine">/// Package up a loop.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="codeLine">void BlockFrequencyInfoImplBase::packageLoop(LoopData &Loop) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">422</td>
    <td class="codeLine">void BlockFrequencyInfoImplBase::packageLoop(LoopData &Loop) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "packaging-loop: " << getLoopName(Loop) << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">423</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "packaging-loop: " << getLoopName(Loop) << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">424</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="codeLine">  // Clear the subloop exits to prevent quadratic memory usage.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">425</td>
    <td class="codeLine">  // Clear the subloop exits to prevent quadratic memory usage.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="codeLine">  for (const BlockNode &M : Loop.Nodes) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">426</td>
    <td class="codeLine">  for (const BlockNode &M : Loop.Nodes) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="codeLine">    if (auto *Loop = Working[M.Index].getPackagedLoop())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">427</td>
    <td class="codeLine">    if (auto *Loop = Working[M.Index].getPackagedLoop())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="codeLine">      Loop->Exits.clear();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">428</td>
    <td class="codeLine">      Loop->Exits.clear();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << " - node: " << getBlockName(M.Index) << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">429</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << " - node: " << getBlockName(M.Index) << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">430</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="codeLine">  Loop.IsPackaged = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">431</td>
    <td class="codeLine">  Loop.IsPackaged = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">432</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">433</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="codeLine">#ifndef NDEBUG</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">434</td>
    <td class="codeLine">#ifndef NDEBUG</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="codeLine">static void debugAssign(const BlockFrequencyInfoImplBase &BFI,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">435</td>
    <td class="codeLine">static void debugAssign(const BlockFrequencyInfoImplBase &BFI,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="codeLine">                        const DitheringDistributer &D, const BlockNode &T,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">436</td>
    <td class="codeLine">                        const DitheringDistributer &D, const BlockNode &T,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="codeLine">                        const BlockMass &M, const char *Desc) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">437</td>
    <td class="codeLine">                        const BlockMass &M, const char *Desc) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="codeLine">  dbgs() << "  => assign " << M << " (" << D.RemMass << ")";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">438</td>
    <td class="codeLine">  dbgs() << "  => assign " << M << " (" << D.RemMass << ")";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="codeLine">  if (Desc)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">439</td>
    <td class="codeLine">  if (Desc)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="codeLine">    dbgs() << " [" << Desc << "]";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">440</td>
    <td class="codeLine">    dbgs() << " [" << Desc << "]";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="codeLine">  if (T.isValid())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">441</td>
    <td class="codeLine">  if (T.isValid())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="codeLine">    dbgs() << " to " << BFI.getBlockName(T);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">442</td>
    <td class="codeLine">    dbgs() << " to " << BFI.getBlockName(T);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="codeLine">  dbgs() << "\n";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">443</td>
    <td class="codeLine">  dbgs() << "\n";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">444</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">445</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">446</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="codeLine coveredLine">void BlockFrequencyInfoImplBase::distributeMass(const BlockNode &Source,</td>
    <td class="lineNumber">24</td>
    <td class="lineNumber">447</td>
    <td class="codeLine coveredLine">void BlockFrequencyInfoImplBase::distributeMass(const BlockNode &Source,</td>
    <td class="lineNumber">24</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="codeLine">                                                LoopData *OuterLoop,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">448</td>
    <td class="codeLine">                                                LoopData *OuterLoop,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="codeLine">                                                Distribution &Dist) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">449</td>
    <td class="codeLine">                                                Distribution &Dist) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="codeLine coveredLine">  BlockMass Mass = Working[Source.Index].getMass();</td>
    <td class="lineNumber">24</td>
    <td class="lineNumber">450</td>
    <td class="codeLine coveredLine">  BlockMass Mass = Working[Source.Index].getMass();</td>
    <td class="lineNumber">24</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="codeLine coveredLine">  LLVM_DEBUG(dbgs() << "  => mass:  " << Mass << "\n");</td>
    <td class="lineNumber">24</td>
    <td class="lineNumber">451</td>
    <td class="codeLine coveredLine">  LLVM_DEBUG(dbgs() << "  => mass:  " << Mass << "\n");</td>
    <td class="lineNumber">24</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">452</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="codeLine">  // Distribute mass to successors as laid out in Dist.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">453</td>
    <td class="codeLine">  // Distribute mass to successors as laid out in Dist.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="codeLine coveredLine">  DitheringDistributer D(Dist, Mass);</td>
    <td class="lineNumber">24</td>
    <td class="lineNumber">454</td>
    <td class="codeLine coveredLine">  DitheringDistributer D(Dist, Mass);</td>
    <td class="lineNumber">24</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">455</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="codeLine coveredLine">  for (const Weight &W : Dist.Weights) {</td>
    <td class="lineNumber">48</td>
    <td class="lineNumber">456</td>
    <td class="codeLine coveredLine">  for (const Weight &W : Dist.Weights) {</td>
    <td class="lineNumber">48</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="codeLine">    // Check for a local edge (non-backedge and non-exit).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">457</td>
    <td class="codeLine">    // Check for a local edge (non-backedge and non-exit).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="codeLine coveredLine">    BlockMass Taken = D.takeMass(W.Amount);</td>
    <td class="lineNumber">24</td>
    <td class="lineNumber">458</td>
    <td class="codeLine coveredLine">    BlockMass Taken = D.takeMass(W.Amount);</td>
    <td class="lineNumber">24</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="codeLine coveredLine">    if (W.Type == Weight::Local) {</td>
    <td class="lineNumber">24</td>
    <td class="lineNumber">459</td>
    <td class="codeLine coveredLine">    if (W.Type == Weight::Local) {</td>
    <td class="lineNumber">24</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="codeLine coveredLine">      Working[W.TargetNode.Index].getMass() += Taken;</td>
    <td class="lineNumber">24</td>
    <td class="lineNumber">460</td>
    <td class="codeLine coveredLine">      Working[W.TargetNode.Index].getMass() += Taken;</td>
    <td class="lineNumber">24</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="codeLine coveredLine">      LLVM_DEBUG(debugAssign(*this, D, W.TargetNode, Taken, nullptr));</td>
    <td class="lineNumber">24</td>
    <td class="lineNumber">461</td>
    <td class="codeLine coveredLine">      LLVM_DEBUG(debugAssign(*this, D, W.TargetNode, Taken, nullptr));</td>
    <td class="lineNumber">24</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="codeLine coveredLine">      continue;</td>
    <td class="lineNumber">24</td>
    <td class="lineNumber">462</td>
    <td class="codeLine coveredLine">      continue;</td>
    <td class="lineNumber">24</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">463</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">464</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="codeLine">    // Backedges and exits only make sense if we're processing a loop.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">465</td>
    <td class="codeLine">    // Backedges and exits only make sense if we're processing a loop.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="codeLine">    assert(OuterLoop && "backedge or exit outside of loop");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">466</td>
    <td class="codeLine">    assert(OuterLoop && "backedge or exit outside of loop");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">467</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="codeLine">    // Check for a backedge.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">468</td>
    <td class="codeLine">    // Check for a backedge.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="codeLine">    if (W.Type == Weight::Backedge) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">469</td>
    <td class="codeLine">    if (W.Type == Weight::Backedge) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="codeLine">      OuterLoop->BackedgeMass[OuterLoop->getHeaderIndex(W.TargetNode)] += Taken;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">470</td>
    <td class="codeLine">      OuterLoop->BackedgeMass[OuterLoop->getHeaderIndex(W.TargetNode)] += Taken;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="codeLine">      LLVM_DEBUG(debugAssign(*this, D, W.TargetNode, Taken, "back"));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">471</td>
    <td class="codeLine">      LLVM_DEBUG(debugAssign(*this, D, W.TargetNode, Taken, "back"));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">472</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">473</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">474</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="codeLine">    // This must be an exit.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">475</td>
    <td class="codeLine">    // This must be an exit.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="codeLine">    assert(W.Type == Weight::Exit);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">476</td>
    <td class="codeLine">    assert(W.Type == Weight::Exit);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="codeLine">    OuterLoop->Exits.push_back(std::make_pair(W.TargetNode, Taken));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">477</td>
    <td class="codeLine">    OuterLoop->Exits.push_back(std::make_pair(W.TargetNode, Taken));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="codeLine">    LLVM_DEBUG(debugAssign(*this, D, W.TargetNode, Taken, "exit"));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">478</td>
    <td class="codeLine">    LLVM_DEBUG(debugAssign(*this, D, W.TargetNode, Taken, "exit"));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">479</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="codeLine coveredLine">}</td>
    <td class="lineNumber">24</td>
    <td class="lineNumber">480</td>
    <td class="codeLine coveredLine">}</td>
    <td class="lineNumber">24</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">481</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="codeLine coveredLine">static void convertFloatingToInteger(BlockFrequencyInfoImplBase &BFI,</td>
    <td class="lineNumber">6</td>
    <td class="lineNumber">482</td>
    <td class="codeLine coveredLine">static void convertFloatingToInteger(BlockFrequencyInfoImplBase &BFI,</td>
    <td class="lineNumber">6</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="codeLine">                                     const Scaled64 &Min, const Scaled64 &Max) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">483</td>
    <td class="codeLine">                                     const Scaled64 &Min, const Scaled64 &Max) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="codeLine">  // Scale the Factor to a size that creates integers.  Ideally, integers would</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">484</td>
    <td class="codeLine">  // Scale the Factor to a size that creates integers.  Ideally, integers would</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="codeLine">  // be scaled so that Max == UINT64_MAX so that they can be best</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">485</td>
    <td class="codeLine">  // be scaled so that Max == UINT64_MAX so that they can be best</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="codeLine">  // differentiated.  However, in the presence of large frequency values, small</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">486</td>
    <td class="codeLine">  // differentiated.  However, in the presence of large frequency values, small</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="codeLine">  // frequencies are scaled down to 1, making it impossible to differentiate</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">487</td>
    <td class="codeLine">  // frequencies are scaled down to 1, making it impossible to differentiate</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="codeLine">  // small, unequal numbers. When the spread between Min and Max frequencies</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">488</td>
    <td class="codeLine">  // small, unequal numbers. When the spread between Min and Max frequencies</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="codeLine">  // fits well within MaxBits, we make the scale be at least 8.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">489</td>
    <td class="codeLine">  // fits well within MaxBits, we make the scale be at least 8.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="codeLine coveredLine">  const unsigned MaxBits = 64;</td>
    <td class="lineNumber">6</td>
    <td class="lineNumber">490</td>
    <td class="codeLine coveredLine">  const unsigned MaxBits = 64;</td>
    <td class="lineNumber">6</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="codeLine coveredLine">  const unsigned SpreadBits = (Max / Min).lg();</td>
    <td class="lineNumber">6</td>
    <td class="lineNumber">491</td>
    <td class="codeLine coveredLine">  const unsigned SpreadBits = (Max / Min).lg();</td>
    <td class="lineNumber">6</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="codeLine coveredLine">  Scaled64 ScalingFactor;</td>
    <td class="lineNumber">6</td>
    <td class="lineNumber">492</td>
    <td class="codeLine coveredLine">  Scaled64 ScalingFactor;</td>
    <td class="lineNumber">6</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="codeLine coveredLine">  if (SpreadBits <= MaxBits - 3) {</td>
    <td class="lineNumber">6</td>
    <td class="lineNumber">493</td>
    <td class="codeLine coveredLine">  if (SpreadBits <= MaxBits - 3) {</td>
    <td class="lineNumber">6</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="codeLine">    // If the values are small enough, make the scaling factor at least 8 to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">494</td>
    <td class="codeLine">    // If the values are small enough, make the scaling factor at least 8 to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="codeLine">    // allow distinguishing small values.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">495</td>
    <td class="codeLine">    // allow distinguishing small values.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="codeLine coveredLine">    ScalingFactor = Min.inverse();</td>
    <td class="lineNumber">6</td>
    <td class="lineNumber">496</td>
    <td class="codeLine coveredLine">    ScalingFactor = Min.inverse();</td>
    <td class="lineNumber">6</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="codeLine coveredLine">    ScalingFactor <<= 3;</td>
    <td class="lineNumber">6</td>
    <td class="lineNumber">497</td>
    <td class="codeLine coveredLine">    ScalingFactor <<= 3;</td>
    <td class="lineNumber">6</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">498</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="codeLine">    // If the values need more than MaxBits to be represented, saturate small</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">499</td>
    <td class="codeLine">    // If the values need more than MaxBits to be represented, saturate small</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="codeLine">    // frequency values down to 1 by using a scaling factor that benefits large</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">500</td>
    <td class="codeLine">    // frequency values down to 1 by using a scaling factor that benefits large</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="codeLine">    // frequency values.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">501</td>
    <td class="codeLine">    // frequency values.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="codeLine">    ScalingFactor = Scaled64(1, MaxBits) / Max;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">502</td>
    <td class="codeLine">    ScalingFactor = Scaled64(1, MaxBits) / Max;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">503</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">504</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="codeLine">  // Translate the floats to integers.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">505</td>
    <td class="codeLine">  // Translate the floats to integers.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="codeLine coveredLine">  LLVM_DEBUG(dbgs() << "float-to-int: min = " << Min << ", max = " << Max</td>
    <td class="lineNumber">6</td>
    <td class="lineNumber">506</td>
    <td class="codeLine coveredLine">  LLVM_DEBUG(dbgs() << "float-to-int: min = " << Min << ", max = " << Max</td>
    <td class="lineNumber">6</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="codeLine">                    << ", factor = " << ScalingFactor << "\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">507</td>
    <td class="codeLine">                    << ", factor = " << ScalingFactor << "\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="codeLine coveredLine">  for (size_t Index = 0; Index < BFI.Freqs.size(); ++Index) {</td>
    <td class="lineNumber">30</td>
    <td class="lineNumber">508</td>
    <td class="codeLine coveredLine">  for (size_t Index = 0; Index < BFI.Freqs.size(); ++Index) {</td>
    <td class="lineNumber">30</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="codeLine coveredLine">    Scaled64 Scaled = BFI.Freqs[Index].Scaled * ScalingFactor;</td>
    <td class="lineNumber">24</td>
    <td class="lineNumber">509</td>
    <td class="codeLine coveredLine">    Scaled64 Scaled = BFI.Freqs[Index].Scaled * ScalingFactor;</td>
    <td class="lineNumber">24</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="codeLine coveredLine">    BFI.Freqs[Index].Integer = std::max(UINT64_C(1), Scaled.toInt<uint64_t>());</td>
    <td class="lineNumber">24</td>
    <td class="lineNumber">510</td>
    <td class="codeLine coveredLine">    BFI.Freqs[Index].Integer = std::max(UINT64_C(1), Scaled.toInt<uint64_t>());</td>
    <td class="lineNumber">24</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="codeLine coveredLine">    LLVM_DEBUG(dbgs() << " - " << BFI.getBlockName(Index) << ": float = "</td>
    <td class="lineNumber">24</td>
    <td class="lineNumber">511</td>
    <td class="codeLine coveredLine">    LLVM_DEBUG(dbgs() << " - " << BFI.getBlockName(Index) << ": float = "</td>
    <td class="lineNumber">24</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="codeLine">                      << BFI.Freqs[Index].Scaled << ", scaled = " << Scaled</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">512</td>
    <td class="codeLine">                      << BFI.Freqs[Index].Scaled << ", scaled = " << Scaled</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class="codeLine">                      << ", int = " << BFI.Freqs[Index].Integer << "\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">513</td>
    <td class="codeLine">                      << ", int = " << BFI.Freqs[Index].Integer << "\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">514</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="codeLine coveredLine">}</td>
    <td class="lineNumber">6</td>
    <td class="lineNumber">515</td>
    <td class="codeLine coveredLine">}</td>
    <td class="lineNumber">6</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">516</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class="codeLine">/// Unwrap a loop package.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">517</td>
    <td class="codeLine">/// Unwrap a loop package.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">518</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="codeLine">/// Visits all the members of a loop, adjusting their BlockData according to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">519</td>
    <td class="codeLine">/// Visits all the members of a loop, adjusting their BlockData according to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class="codeLine">/// the loop's pseudo-node.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">520</td>
    <td class="codeLine">/// the loop's pseudo-node.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="codeLine">static void unwrapLoop(BlockFrequencyInfoImplBase &BFI, LoopData &Loop) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">521</td>
    <td class="codeLine">static void unwrapLoop(BlockFrequencyInfoImplBase &BFI, LoopData &Loop) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "unwrap-loop-package: " << BFI.getLoopName(Loop)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">522</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "unwrap-loop-package: " << BFI.getLoopName(Loop)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="codeLine">                    << ": mass = " << Loop.Mass << ", scale = " << Loop.Scale</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">523</td>
    <td class="codeLine">                    << ": mass = " << Loop.Mass << ", scale = " << Loop.Scale</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="codeLine">                    << "\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">524</td>
    <td class="codeLine">                    << "\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="codeLine">  Loop.Scale *= Loop.Mass.toScaled();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">525</td>
    <td class="codeLine">  Loop.Scale *= Loop.Mass.toScaled();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class="codeLine">  Loop.IsPackaged = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">526</td>
    <td class="codeLine">  Loop.IsPackaged = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "  => combined-scale = " << Loop.Scale << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">527</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "  => combined-scale = " << Loop.Scale << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">528</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="codeLine">  // Propagate the head scale through the loop.  Since members are visited in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">529</td>
    <td class="codeLine">  // Propagate the head scale through the loop.  Since members are visited in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="codeLine">  // RPO, the head scale will be updated by the loop scale first, and then the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">530</td>
    <td class="codeLine">  // RPO, the head scale will be updated by the loop scale first, and then the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="codeLine">  // final head scale will be used for updated the rest of the members.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">531</td>
    <td class="codeLine">  // final head scale will be used for updated the rest of the members.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="codeLine">  for (const BlockNode &N : Loop.Nodes) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">532</td>
    <td class="codeLine">  for (const BlockNode &N : Loop.Nodes) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class="codeLine">    const auto &Working = BFI.Working[N.Index];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">533</td>
    <td class="codeLine">    const auto &Working = BFI.Working[N.Index];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="codeLine">    Scaled64 &F = Working.isAPackage() ? Working.getPackagedLoop()->Scale</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">534</td>
    <td class="codeLine">    Scaled64 &F = Working.isAPackage() ? Working.getPackagedLoop()->Scale</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="codeLine">                                       : BFI.Freqs[N.Index].Scaled;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">535</td>
    <td class="codeLine">                                       : BFI.Freqs[N.Index].Scaled;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="codeLine">    Scaled64 New = Loop.Scale * F;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">536</td>
    <td class="codeLine">    Scaled64 New = Loop.Scale * F;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << " - " << BFI.getBlockName(N) << ": " << F << " => "</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">537</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << " - " << BFI.getBlockName(N) << ": " << F << " => "</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="codeLine">                      << New << "\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">538</td>
    <td class="codeLine">                      << New << "\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="codeLine">    F = New;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">539</td>
    <td class="codeLine">    F = New;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">540</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">541</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">542</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="codeLine coveredLine">void BlockFrequencyInfoImplBase::unwrapLoops() {</td>
    <td class="lineNumber">6</td>
    <td class="lineNumber">543</td>
    <td class="codeLine coveredLine">void BlockFrequencyInfoImplBase::unwrapLoops() {</td>
    <td class="lineNumber">6</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="codeLine">  // Set initial frequencies from loop-local masses.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">544</td>
    <td class="codeLine">  // Set initial frequencies from loop-local masses.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="codeLine coveredLine">  for (size_t Index = 0; Index < Working.size(); ++Index)</td>
    <td class="lineNumber">30</td>
    <td class="lineNumber">545</td>
    <td class="codeLine coveredLine">  for (size_t Index = 0; Index < Working.size(); ++Index)</td>
    <td class="lineNumber">30</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="codeLine coveredLine">    Freqs[Index].Scaled = Working[Index].Mass.toScaled();</td>
    <td class="lineNumber">24</td>
    <td class="lineNumber">546</td>
    <td class="codeLine coveredLine">    Freqs[Index].Scaled = Working[Index].Mass.toScaled();</td>
    <td class="lineNumber">24</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">547</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="codeLine coveredLine">  for (LoopData &Loop : Loops)</td>
    <td class="lineNumber">6</td>
    <td class="lineNumber">548</td>
    <td class="codeLine coveredLine">  for (LoopData &Loop : Loops)</td>
    <td class="lineNumber">6</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="codeLine">    unwrapLoop(*this, Loop);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">549</td>
    <td class="codeLine">    unwrapLoop(*this, Loop);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="codeLine coveredLine">}</td>
    <td class="lineNumber">6</td>
    <td class="lineNumber">550</td>
    <td class="codeLine coveredLine">}</td>
    <td class="lineNumber">6</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">551</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="codeLine coveredLine">void BlockFrequencyInfoImplBase::finalizeMetrics() {</td>
    <td class="lineNumber">6</td>
    <td class="lineNumber">552</td>
    <td class="codeLine coveredLine">void BlockFrequencyInfoImplBase::finalizeMetrics() {</td>
    <td class="lineNumber">6</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="codeLine">  // Unwrap loop packages in reverse post-order, tracking min and max</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">553</td>
    <td class="codeLine">  // Unwrap loop packages in reverse post-order, tracking min and max</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="codeLine">  // frequencies.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">554</td>
    <td class="codeLine">  // frequencies.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="codeLine coveredLine">  auto Min = Scaled64::getLargest();</td>
    <td class="lineNumber">6</td>
    <td class="lineNumber">555</td>
    <td class="codeLine coveredLine">  auto Min = Scaled64::getLargest();</td>
    <td class="lineNumber">6</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="codeLine coveredLine">  auto Max = Scaled64::getZero();</td>
    <td class="lineNumber">6</td>
    <td class="lineNumber">556</td>
    <td class="codeLine coveredLine">  auto Max = Scaled64::getZero();</td>
    <td class="lineNumber">6</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="codeLine coveredLine">  for (size_t Index = 0; Index < Working.size(); ++Index) {</td>
    <td class="lineNumber">30</td>
    <td class="lineNumber">557</td>
    <td class="codeLine coveredLine">  for (size_t Index = 0; Index < Working.size(); ++Index) {</td>
    <td class="lineNumber">30</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="codeLine">    // Update min/max scale.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">558</td>
    <td class="codeLine">    // Update min/max scale.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="codeLine coveredLine">    Min = std::min(Min, Freqs[Index].Scaled);</td>
    <td class="lineNumber">24</td>
    <td class="lineNumber">559</td>
    <td class="codeLine coveredLine">    Min = std::min(Min, Freqs[Index].Scaled);</td>
    <td class="lineNumber">24</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="codeLine coveredLine">    Max = std::max(Max, Freqs[Index].Scaled);</td>
    <td class="lineNumber">24</td>
    <td class="lineNumber">560</td>
    <td class="codeLine coveredLine">    Max = std::max(Max, Freqs[Index].Scaled);</td>
    <td class="lineNumber">24</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">561</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">562</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="codeLine">  // Convert to integers.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">563</td>
    <td class="codeLine">  // Convert to integers.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="codeLine coveredLine">  convertFloatingToInteger(*this, Min, Max);</td>
    <td class="lineNumber">6</td>
    <td class="lineNumber">564</td>
    <td class="codeLine coveredLine">  convertFloatingToInteger(*this, Min, Max);</td>
    <td class="lineNumber">6</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">565</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="codeLine">  // Clean up data structures.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">566</td>
    <td class="codeLine">  // Clean up data structures.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="codeLine coveredLine">  cleanup(*this);</td>
    <td class="lineNumber">6</td>
    <td class="lineNumber">567</td>
    <td class="codeLine coveredLine">  cleanup(*this);</td>
    <td class="lineNumber">6</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">568</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="codeLine">  // Print out the final stats.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">569</td>
    <td class="codeLine">  // Print out the final stats.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="codeLine coveredLine">  LLVM_DEBUG(dump());</td>
    <td class="lineNumber">6</td>
    <td class="lineNumber">570</td>
    <td class="codeLine coveredLine">  LLVM_DEBUG(dump());</td>
    <td class="lineNumber">6</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="codeLine coveredLine">}</td>
    <td class="lineNumber">6</td>
    <td class="lineNumber">571</td>
    <td class="codeLine coveredLine">}</td>
    <td class="lineNumber">6</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">572</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="codeLine">BlockFrequency</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">573</td>
    <td class="codeLine">BlockFrequency</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="codeLine coveredLine">BlockFrequencyInfoImplBase::getBlockFreq(const BlockNode &Node) const {</td>
    <td class="lineNumber">20</td>
    <td class="lineNumber">574</td>
    <td class="codeLine coveredLine">BlockFrequencyInfoImplBase::getBlockFreq(const BlockNode &Node) const {</td>
    <td class="lineNumber">20</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="codeLine coveredLine">  if (!Node.isValid()) {</td>
    <td class="lineNumber">20</td>
    <td class="lineNumber">575</td>
    <td class="codeLine coveredLine">  if (!Node.isValid()) {</td>
    <td class="lineNumber">20</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="codeLine">#ifndef NDEBUG</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">576</td>
    <td class="codeLine">#ifndef NDEBUG</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="codeLine">    if (CheckBFIUnknownBlockQueries) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">577</td>
    <td class="codeLine">    if (CheckBFIUnknownBlockQueries) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="codeLine">      SmallString<256> Msg;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">578</td>
    <td class="codeLine">      SmallString<256> Msg;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class="codeLine">      raw_svector_ostream OS(Msg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">579</td>
    <td class="codeLine">      raw_svector_ostream OS(Msg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="codeLine">      OS << "*** Detected BFI query for unknown block " << getBlockName(Node);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">580</td>
    <td class="codeLine">      OS << "*** Detected BFI query for unknown block " << getBlockName(Node);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="codeLine">      report_fatal_error(OS.str());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">581</td>
    <td class="codeLine">      report_fatal_error(OS.str());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">582</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">583</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="codeLine">    return 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">584</td>
    <td class="codeLine">    return 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">585</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="codeLine coveredLine">  return Freqs[Node.Index].Integer;</td>
    <td class="lineNumber">20</td>
    <td class="lineNumber">586</td>
    <td class="codeLine coveredLine">  return Freqs[Node.Index].Integer;</td>
    <td class="lineNumber">20</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">587</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">588</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="codeLine">std::optional<uint64_t></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">589</td>
    <td class="codeLine">std::optional<uint64_t></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class="codeLine">BlockFrequencyInfoImplBase::getBlockProfileCount(const Function &F,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">590</td>
    <td class="codeLine">BlockFrequencyInfoImplBase::getBlockProfileCount(const Function &F,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="codeLine">                                                 const BlockNode &Node,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">591</td>
    <td class="codeLine">                                                 const BlockNode &Node,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="codeLine">                                                 bool AllowSynthetic) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">592</td>
    <td class="codeLine">                                                 bool AllowSynthetic) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="codeLine">  return getProfileCountFromFreq(F, getBlockFreq(Node).getFrequency(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">593</td>
    <td class="codeLine">  return getProfileCountFromFreq(F, getBlockFreq(Node).getFrequency(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="codeLine">                                 AllowSynthetic);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">594</td>
    <td class="codeLine">                                 AllowSynthetic);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">595</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">596</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class="codeLine">std::optional<uint64_t></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">597</td>
    <td class="codeLine">std::optional<uint64_t></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="codeLine">BlockFrequencyInfoImplBase::getProfileCountFromFreq(const Function &F,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">598</td>
    <td class="codeLine">BlockFrequencyInfoImplBase::getProfileCountFromFreq(const Function &F,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="codeLine">                                                    uint64_t Freq,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">599</td>
    <td class="codeLine">                                                    uint64_t Freq,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="codeLine">                                                    bool AllowSynthetic) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">600</td>
    <td class="codeLine">                                                    bool AllowSynthetic) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="codeLine">  auto EntryCount = F.getEntryCount(AllowSynthetic);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">601</td>
    <td class="codeLine">  auto EntryCount = F.getEntryCount(AllowSynthetic);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="codeLine">  if (!EntryCount)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">602</td>
    <td class="codeLine">  if (!EntryCount)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="codeLine">    return std::nullopt;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">603</td>
    <td class="codeLine">    return std::nullopt;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="codeLine">  // Use 128 bit APInt to do the arithmetic to avoid overflow.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">604</td>
    <td class="codeLine">  // Use 128 bit APInt to do the arithmetic to avoid overflow.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="codeLine">  APInt BlockCount(128, EntryCount->getCount());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">605</td>
    <td class="codeLine">  APInt BlockCount(128, EntryCount->getCount());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="codeLine">  APInt BlockFreq(128, Freq);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">606</td>
    <td class="codeLine">  APInt BlockFreq(128, Freq);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="codeLine">  APInt EntryFreq(128, getEntryFreq());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">607</td>
    <td class="codeLine">  APInt EntryFreq(128, getEntryFreq());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="codeLine">  BlockCount *= BlockFreq;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">608</td>
    <td class="codeLine">  BlockCount *= BlockFreq;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="codeLine">  // Rounded division of BlockCount by EntryFreq. Since EntryFreq is unsigned</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">609</td>
    <td class="codeLine">  // Rounded division of BlockCount by EntryFreq. Since EntryFreq is unsigned</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="codeLine">  // lshr by 1 gives EntryFreq/2.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">610</td>
    <td class="codeLine">  // lshr by 1 gives EntryFreq/2.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="codeLine">  BlockCount = (BlockCount + EntryFreq.lshr(1)).udiv(EntryFreq);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">611</td>
    <td class="codeLine">  BlockCount = (BlockCount + EntryFreq.lshr(1)).udiv(EntryFreq);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="codeLine">  return BlockCount.getLimitedValue();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">612</td>
    <td class="codeLine">  return BlockCount.getLimitedValue();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">613</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">614</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="codeLine">bool</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">615</td>
    <td class="codeLine">bool</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="codeLine">BlockFrequencyInfoImplBase::isIrrLoopHeader(const BlockNode &Node) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">616</td>
    <td class="codeLine">BlockFrequencyInfoImplBase::isIrrLoopHeader(const BlockNode &Node) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="codeLine">  if (!Node.isValid())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">617</td>
    <td class="codeLine">  if (!Node.isValid())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">618</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="codeLine">  return IsIrrLoopHeader.test(Node.Index);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">619</td>
    <td class="codeLine">  return IsIrrLoopHeader.test(Node.Index);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">620</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">621</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="codeLine">Scaled64</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">622</td>
    <td class="codeLine">Scaled64</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="codeLine">BlockFrequencyInfoImplBase::getFloatingBlockFreq(const BlockNode &Node) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">623</td>
    <td class="codeLine">BlockFrequencyInfoImplBase::getFloatingBlockFreq(const BlockNode &Node) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="codeLine">  if (!Node.isValid())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">624</td>
    <td class="codeLine">  if (!Node.isValid())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="codeLine">    return Scaled64::getZero();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">625</td>
    <td class="codeLine">    return Scaled64::getZero();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="codeLine">  return Freqs[Node.Index].Scaled;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">626</td>
    <td class="codeLine">  return Freqs[Node.Index].Scaled;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">627</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">628</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="codeLine">void BlockFrequencyInfoImplBase::setBlockFreq(const BlockNode &Node,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">629</td>
    <td class="codeLine">void BlockFrequencyInfoImplBase::setBlockFreq(const BlockNode &Node,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class="codeLine">                                              uint64_t Freq) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">630</td>
    <td class="codeLine">                                              uint64_t Freq) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="codeLine">  assert(Node.isValid() && "Expected valid node");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">631</td>
    <td class="codeLine">  assert(Node.isValid() && "Expected valid node");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="codeLine">  assert(Node.Index < Freqs.size() && "Expected legal index");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">632</td>
    <td class="codeLine">  assert(Node.Index < Freqs.size() && "Expected legal index");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="codeLine">  Freqs[Node.Index].Integer = Freq;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">633</td>
    <td class="codeLine">  Freqs[Node.Index].Integer = Freq;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">634</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">635</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="codeLine">std::string</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">636</td>
    <td class="codeLine">std::string</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="codeLine">BlockFrequencyInfoImplBase::getBlockName(const BlockNode &Node) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">637</td>
    <td class="codeLine">BlockFrequencyInfoImplBase::getBlockName(const BlockNode &Node) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="codeLine">  return {};</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">638</td>
    <td class="codeLine">  return {};</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">639</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">640</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="codeLine">std::string</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">641</td>
    <td class="codeLine">std::string</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="codeLine">BlockFrequencyInfoImplBase::getLoopName(const LoopData &Loop) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">642</td>
    <td class="codeLine">BlockFrequencyInfoImplBase::getLoopName(const LoopData &Loop) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="codeLine">  return getBlockName(Loop.getHeader()) + (Loop.isIrreducible() ? "**" : "*");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">643</td>
    <td class="codeLine">  return getBlockName(Loop.getHeader()) + (Loop.isIrreducible() ? "**" : "*");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">644</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">645</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="codeLine">raw_ostream &</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">646</td>
    <td class="codeLine">raw_ostream &</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="codeLine">BlockFrequencyInfoImplBase::printBlockFreq(raw_ostream &OS,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">647</td>
    <td class="codeLine">BlockFrequencyInfoImplBase::printBlockFreq(raw_ostream &OS,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="codeLine">                                           const BlockNode &Node) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">648</td>
    <td class="codeLine">                                           const BlockNode &Node) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="codeLine">  return OS << getFloatingBlockFreq(Node);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">649</td>
    <td class="codeLine">  return OS << getFloatingBlockFreq(Node);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">650</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">651</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="codeLine">raw_ostream &</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">652</td>
    <td class="codeLine">raw_ostream &</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="codeLine">BlockFrequencyInfoImplBase::printBlockFreq(raw_ostream &OS,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">653</td>
    <td class="codeLine">BlockFrequencyInfoImplBase::printBlockFreq(raw_ostream &OS,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="codeLine">                                           const BlockFrequency &Freq) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">654</td>
    <td class="codeLine">                                           const BlockFrequency &Freq) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="codeLine">  Scaled64 Block(Freq.getFrequency(), 0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">655</td>
    <td class="codeLine">  Scaled64 Block(Freq.getFrequency(), 0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="codeLine">  Scaled64 Entry(getEntryFreq(), 0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">656</td>
    <td class="codeLine">  Scaled64 Entry(getEntryFreq(), 0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">657</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="codeLine">  return OS << Block / Entry;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">658</td>
    <td class="codeLine">  return OS << Block / Entry;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">659</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">660</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="codeLine">void IrreducibleGraph::addNodesInLoop(const BFIBase::LoopData &OuterLoop) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">661</td>
    <td class="codeLine">void IrreducibleGraph::addNodesInLoop(const BFIBase::LoopData &OuterLoop) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="codeLine">  Start = OuterLoop.getHeader();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">662</td>
    <td class="codeLine">  Start = OuterLoop.getHeader();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="codeLine">  Nodes.reserve(OuterLoop.Nodes.size());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">663</td>
    <td class="codeLine">  Nodes.reserve(OuterLoop.Nodes.size());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="codeLine">  for (auto N : OuterLoop.Nodes)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">664</td>
    <td class="codeLine">  for (auto N : OuterLoop.Nodes)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="codeLine">    addNode(N);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">665</td>
    <td class="codeLine">    addNode(N);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="codeLine">  indexNodes();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">666</td>
    <td class="codeLine">  indexNodes();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">667</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">668</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="codeLine">void IrreducibleGraph::addNodesInFunction() {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">669</td>
    <td class="codeLine">void IrreducibleGraph::addNodesInFunction() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="codeLine">  Start = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">670</td>
    <td class="codeLine">  Start = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="codeLine">  for (uint32_t Index = 0; Index < BFI.Working.size(); ++Index)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">671</td>
    <td class="codeLine">  for (uint32_t Index = 0; Index < BFI.Working.size(); ++Index)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class="codeLine">    if (!BFI.Working[Index].isPackaged())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">672</td>
    <td class="codeLine">    if (!BFI.Working[Index].isPackaged())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="codeLine">      addNode(Index);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">673</td>
    <td class="codeLine">      addNode(Index);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="codeLine">  indexNodes();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">674</td>
    <td class="codeLine">  indexNodes();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">675</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">676</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="codeLine">void IrreducibleGraph::indexNodes() {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">677</td>
    <td class="codeLine">void IrreducibleGraph::indexNodes() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="codeLine">  for (auto &I : Nodes)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">678</td>
    <td class="codeLine">  for (auto &I : Nodes)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="codeLine">    Lookup[I.Node.Index] = &I;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">679</td>
    <td class="codeLine">    Lookup[I.Node.Index] = &I;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">680</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">681</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="codeLine">void IrreducibleGraph::addEdge(IrrNode &Irr, const BlockNode &Succ,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">682</td>
    <td class="codeLine">void IrreducibleGraph::addEdge(IrrNode &Irr, const BlockNode &Succ,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class="codeLine">                               const BFIBase::LoopData *OuterLoop) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">683</td>
    <td class="codeLine">                               const BFIBase::LoopData *OuterLoop) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="codeLine">  if (OuterLoop && OuterLoop->isHeader(Succ))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">684</td>
    <td class="codeLine">  if (OuterLoop && OuterLoop->isHeader(Succ))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">685</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="codeLine">  auto L = Lookup.find(Succ.Index);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">686</td>
    <td class="codeLine">  auto L = Lookup.find(Succ.Index);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="codeLine">  if (L == Lookup.end())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">687</td>
    <td class="codeLine">  if (L == Lookup.end())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">688</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class="codeLine">  IrrNode &SuccIrr = *L->second;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">689</td>
    <td class="codeLine">  IrrNode &SuccIrr = *L->second;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class="codeLine">  Irr.Edges.push_back(&SuccIrr);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">690</td>
    <td class="codeLine">  Irr.Edges.push_back(&SuccIrr);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class="codeLine">  SuccIrr.Edges.push_front(&Irr);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">691</td>
    <td class="codeLine">  SuccIrr.Edges.push_front(&Irr);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="codeLine">  ++SuccIrr.NumIn;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">692</td>
    <td class="codeLine">  ++SuccIrr.NumIn;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">693</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">694</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="codeLine">namespace llvm {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">695</td>
    <td class="codeLine">namespace llvm {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">696</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class="codeLine">template <> struct GraphTraits<IrreducibleGraph> {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">697</td>
    <td class="codeLine">template <> struct GraphTraits<IrreducibleGraph> {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class="codeLine">  using GraphT = bfi_detail::IrreducibleGraph;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">698</td>
    <td class="codeLine">  using GraphT = bfi_detail::IrreducibleGraph;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class="codeLine">  using NodeRef = const GraphT::IrrNode *;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">699</td>
    <td class="codeLine">  using NodeRef = const GraphT::IrrNode *;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="codeLine">  using ChildIteratorType = GraphT::IrrNode::iterator;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">700</td>
    <td class="codeLine">  using ChildIteratorType = GraphT::IrrNode::iterator;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">701</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class="codeLine">  static NodeRef getEntryNode(const GraphT &G) { return G.StartIrr; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">702</td>
    <td class="codeLine">  static NodeRef getEntryNode(const GraphT &G) { return G.StartIrr; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="codeLine">  static ChildIteratorType child_begin(NodeRef N) { return N->succ_begin(); }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">703</td>
    <td class="codeLine">  static ChildIteratorType child_begin(NodeRef N) { return N->succ_begin(); }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class="codeLine">  static ChildIteratorType child_end(NodeRef N) { return N->succ_end(); }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">704</td>
    <td class="codeLine">  static ChildIteratorType child_end(NodeRef N) { return N->succ_end(); }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">705</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">706</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class="codeLine">} // end namespace llvm</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">707</td>
    <td class="codeLine">} // end namespace llvm</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">708</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class="codeLine">/// Find extra irreducible headers.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">709</td>
    <td class="codeLine">/// Find extra irreducible headers.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">710</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class="codeLine">/// Find entry blocks and other blocks with backedges, which exist when \c G</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">711</td>
    <td class="codeLine">/// Find entry blocks and other blocks with backedges, which exist when \c G</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class="codeLine">/// contains irreducible sub-SCCs.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">712</td>
    <td class="codeLine">/// contains irreducible sub-SCCs.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="codeLine">static void findIrreducibleHeaders(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">713</td>
    <td class="codeLine">static void findIrreducibleHeaders(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="codeLine">    const BlockFrequencyInfoImplBase &BFI,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">714</td>
    <td class="codeLine">    const BlockFrequencyInfoImplBase &BFI,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="codeLine">    const IrreducibleGraph &G,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">715</td>
    <td class="codeLine">    const IrreducibleGraph &G,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="codeLine">    const std::vector<const IrreducibleGraph::IrrNode *> &SCC,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">716</td>
    <td class="codeLine">    const std::vector<const IrreducibleGraph::IrrNode *> &SCC,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class="codeLine">    LoopData::NodeList &Headers, LoopData::NodeList &Others) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">717</td>
    <td class="codeLine">    LoopData::NodeList &Headers, LoopData::NodeList &Others) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class="codeLine">  // Map from nodes in the SCC to whether it's an entry block.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">718</td>
    <td class="codeLine">  // Map from nodes in the SCC to whether it's an entry block.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class="codeLine">  SmallDenseMap<const IrreducibleGraph::IrrNode *, bool, 8> InSCC;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">719</td>
    <td class="codeLine">  SmallDenseMap<const IrreducibleGraph::IrrNode *, bool, 8> InSCC;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">720</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="codeLine">  // InSCC also acts the set of nodes in the graph.  Seed it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">721</td>
    <td class="codeLine">  // InSCC also acts the set of nodes in the graph.  Seed it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class="codeLine">  for (const auto *I : SCC)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">722</td>
    <td class="codeLine">  for (const auto *I : SCC)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="codeLine">    InSCC[I] = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">723</td>
    <td class="codeLine">    InSCC[I] = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">724</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="codeLine">  for (auto I = InSCC.begin(), E = InSCC.end(); I != E; ++I) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">725</td>
    <td class="codeLine">  for (auto I = InSCC.begin(), E = InSCC.end(); I != E; ++I) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class="codeLine">    auto &Irr = *I->first;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">726</td>
    <td class="codeLine">    auto &Irr = *I->first;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class="codeLine">    for (const auto *P : make_range(Irr.pred_begin(), Irr.pred_end())) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">727</td>
    <td class="codeLine">    for (const auto *P : make_range(Irr.pred_begin(), Irr.pred_end())) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class="codeLine">      if (InSCC.count(P))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">728</td>
    <td class="codeLine">      if (InSCC.count(P))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">729</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">730</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class="codeLine">      // This is an entry block.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">731</td>
    <td class="codeLine">      // This is an entry block.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class="codeLine">      I->second = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">732</td>
    <td class="codeLine">      I->second = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="codeLine">      Headers.push_back(Irr.Node);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">733</td>
    <td class="codeLine">      Headers.push_back(Irr.Node);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "  => entry = " << BFI.getBlockName(Irr.Node)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">734</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "  => entry = " << BFI.getBlockName(Irr.Node)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class="codeLine">                        << "\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">735</td>
    <td class="codeLine">                        << "\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">736</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">737</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">738</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class="codeLine">  assert(Headers.size() >= 2 &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">739</td>
    <td class="codeLine">  assert(Headers.size() >= 2 &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="codeLine">         "Expected irreducible CFG; -loop-info is likely invalid");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">740</td>
    <td class="codeLine">         "Expected irreducible CFG; -loop-info is likely invalid");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class="codeLine">  if (Headers.size() == InSCC.size()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">741</td>
    <td class="codeLine">  if (Headers.size() == InSCC.size()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class="codeLine">    // Every block is a header.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">742</td>
    <td class="codeLine">    // Every block is a header.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class="codeLine">    llvm::sort(Headers);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">743</td>
    <td class="codeLine">    llvm::sort(Headers);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">744</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">745</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">746</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class="codeLine">  // Look for extra headers from irreducible sub-SCCs.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">747</td>
    <td class="codeLine">  // Look for extra headers from irreducible sub-SCCs.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="codeLine">  for (const auto &I : InSCC) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">748</td>
    <td class="codeLine">  for (const auto &I : InSCC) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="codeLine">    // Entry blocks are already headers.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">749</td>
    <td class="codeLine">    // Entry blocks are already headers.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="codeLine">    if (I.second)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">750</td>
    <td class="codeLine">    if (I.second)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">751</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">752</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class="codeLine">    auto &Irr = *I.first;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">753</td>
    <td class="codeLine">    auto &Irr = *I.first;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class="codeLine">    for (const auto *P : make_range(Irr.pred_begin(), Irr.pred_end())) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">754</td>
    <td class="codeLine">    for (const auto *P : make_range(Irr.pred_begin(), Irr.pred_end())) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class="codeLine">      // Skip forward edges.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">755</td>
    <td class="codeLine">      // Skip forward edges.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="codeLine">      if (P->Node < Irr.Node)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">756</td>
    <td class="codeLine">      if (P->Node < Irr.Node)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">757</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">758</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="codeLine">      // Skip predecessors from entry blocks.  These can have inverted</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">759</td>
    <td class="codeLine">      // Skip predecessors from entry blocks.  These can have inverted</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class="codeLine">      // ordering.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">760</td>
    <td class="codeLine">      // ordering.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class="codeLine">      if (InSCC.lookup(P))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">761</td>
    <td class="codeLine">      if (InSCC.lookup(P))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">762</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">763</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class="codeLine">      // Store the extra header.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">764</td>
    <td class="codeLine">      // Store the extra header.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class="codeLine">      Headers.push_back(Irr.Node);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">765</td>
    <td class="codeLine">      Headers.push_back(Irr.Node);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "  => extra = " << BFI.getBlockName(Irr.Node)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">766</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "  => extra = " << BFI.getBlockName(Irr.Node)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="codeLine">                        << "\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">767</td>
    <td class="codeLine">                        << "\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">768</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">769</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="codeLine">    if (Headers.back() == Irr.Node)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">770</td>
    <td class="codeLine">    if (Headers.back() == Irr.Node)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class="codeLine">      // Added this as a header.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">771</td>
    <td class="codeLine">      // Added this as a header.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">772</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">773</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="codeLine">    // This is not a header.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">774</td>
    <td class="codeLine">    // This is not a header.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class="codeLine">    Others.push_back(Irr.Node);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">775</td>
    <td class="codeLine">    Others.push_back(Irr.Node);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "  => other = " << BFI.getBlockName(Irr.Node) << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">776</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "  => other = " << BFI.getBlockName(Irr.Node) << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">777</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class="codeLine">  llvm::sort(Headers);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">778</td>
    <td class="codeLine">  llvm::sort(Headers);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="codeLine">  llvm::sort(Others);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">779</td>
    <td class="codeLine">  llvm::sort(Others);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">780</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">781</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="codeLine">static void createIrreducibleLoop(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">782</td>
    <td class="codeLine">static void createIrreducibleLoop(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="codeLine">    BlockFrequencyInfoImplBase &BFI, const IrreducibleGraph &G,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">783</td>
    <td class="codeLine">    BlockFrequencyInfoImplBase &BFI, const IrreducibleGraph &G,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class="codeLine">    LoopData *OuterLoop, std::list<LoopData>::iterator Insert,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">784</td>
    <td class="codeLine">    LoopData *OuterLoop, std::list<LoopData>::iterator Insert,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class="codeLine">    const std::vector<const IrreducibleGraph::IrrNode *> &SCC) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">785</td>
    <td class="codeLine">    const std::vector<const IrreducibleGraph::IrrNode *> &SCC) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class="codeLine">  // Translate the SCC into RPO.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">786</td>
    <td class="codeLine">  // Translate the SCC into RPO.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << " - found-scc\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">787</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << " - found-scc\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">788</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class="codeLine">  LoopData::NodeList Headers;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">789</td>
    <td class="codeLine">  LoopData::NodeList Headers;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class="codeLine">  LoopData::NodeList Others;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">790</td>
    <td class="codeLine">  LoopData::NodeList Others;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class="codeLine">  findIrreducibleHeaders(BFI, G, SCC, Headers, Others);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">791</td>
    <td class="codeLine">  findIrreducibleHeaders(BFI, G, SCC, Headers, Others);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">792</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="codeLine">  auto Loop = BFI.Loops.emplace(Insert, OuterLoop, Headers.begin(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">793</td>
    <td class="codeLine">  auto Loop = BFI.Loops.emplace(Insert, OuterLoop, Headers.begin(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class="codeLine">                                Headers.end(), Others.begin(), Others.end());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">794</td>
    <td class="codeLine">                                Headers.end(), Others.begin(), Others.end());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">795</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class="codeLine">  // Update loop hierarchy.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">796</td>
    <td class="codeLine">  // Update loop hierarchy.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class="codeLine">  for (const auto &N : Loop->Nodes)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">797</td>
    <td class="codeLine">  for (const auto &N : Loop->Nodes)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class="codeLine">    if (BFI.Working[N.Index].isLoopHeader())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">798</td>
    <td class="codeLine">    if (BFI.Working[N.Index].isLoopHeader())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class="codeLine">      BFI.Working[N.Index].Loop->Parent = &*Loop;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">799</td>
    <td class="codeLine">      BFI.Working[N.Index].Loop->Parent = &*Loop;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">800</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class="codeLine">      BFI.Working[N.Index].Loop = &*Loop;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">801</td>
    <td class="codeLine">      BFI.Working[N.Index].Loop = &*Loop;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">802</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">803</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class="codeLine">iterator_range<std::list<LoopData>::iterator></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">804</td>
    <td class="codeLine">iterator_range<std::list<LoopData>::iterator></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class="codeLine">BlockFrequencyInfoImplBase::analyzeIrreducible(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">805</td>
    <td class="codeLine">BlockFrequencyInfoImplBase::analyzeIrreducible(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class="codeLine">    const IrreducibleGraph &G, LoopData *OuterLoop,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">806</td>
    <td class="codeLine">    const IrreducibleGraph &G, LoopData *OuterLoop,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class="codeLine">    std::list<LoopData>::iterator Insert) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">807</td>
    <td class="codeLine">    std::list<LoopData>::iterator Insert) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class="codeLine">  assert((OuterLoop == nullptr) == (Insert == Loops.begin()));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">808</td>
    <td class="codeLine">  assert((OuterLoop == nullptr) == (Insert == Loops.begin()));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class="codeLine">  auto Prev = OuterLoop ? std::prev(Insert) : Loops.end();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">809</td>
    <td class="codeLine">  auto Prev = OuterLoop ? std::prev(Insert) : Loops.end();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">810</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class="codeLine">  for (auto I = scc_begin(G); !I.isAtEnd(); ++I) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">811</td>
    <td class="codeLine">  for (auto I = scc_begin(G); !I.isAtEnd(); ++I) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class="codeLine">    if (I->size() < 2)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">812</td>
    <td class="codeLine">    if (I->size() < 2)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">813</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">814</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class="codeLine">    // Translate the SCC into RPO.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">815</td>
    <td class="codeLine">    // Translate the SCC into RPO.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class="codeLine">    createIrreducibleLoop(*this, G, OuterLoop, Insert, *I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">816</td>
    <td class="codeLine">    createIrreducibleLoop(*this, G, OuterLoop, Insert, *I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">817</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">818</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class="codeLine">  if (OuterLoop)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">819</td>
    <td class="codeLine">  if (OuterLoop)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class="codeLine">    return make_range(std::next(Prev), Insert);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">820</td>
    <td class="codeLine">    return make_range(std::next(Prev), Insert);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class="codeLine">  return make_range(Loops.begin(), Insert);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">821</td>
    <td class="codeLine">  return make_range(Loops.begin(), Insert);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">822</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">823</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class="codeLine">void</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">824</td>
    <td class="codeLine">void</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class="codeLine">BlockFrequencyInfoImplBase::updateLoopWithIrreducible(LoopData &OuterLoop) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">825</td>
    <td class="codeLine">BlockFrequencyInfoImplBase::updateLoopWithIrreducible(LoopData &OuterLoop) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class="codeLine">  OuterLoop.Exits.clear();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">826</td>
    <td class="codeLine">  OuterLoop.Exits.clear();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class="codeLine">  for (auto &Mass : OuterLoop.BackedgeMass)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">827</td>
    <td class="codeLine">  for (auto &Mass : OuterLoop.BackedgeMass)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class="codeLine">    Mass = BlockMass::getEmpty();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">828</td>
    <td class="codeLine">    Mass = BlockMass::getEmpty();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class="codeLine">  auto O = OuterLoop.Nodes.begin() + 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">829</td>
    <td class="codeLine">  auto O = OuterLoop.Nodes.begin() + 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class="codeLine">  for (auto I = O, E = OuterLoop.Nodes.end(); I != E; ++I)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">830</td>
    <td class="codeLine">  for (auto I = O, E = OuterLoop.Nodes.end(); I != E; ++I)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class="codeLine">    if (!Working[I->Index].isPackaged())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">831</td>
    <td class="codeLine">    if (!Working[I->Index].isPackaged())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class="codeLine">      *O++ = *I;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">832</td>
    <td class="codeLine">      *O++ = *I;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class="codeLine">  OuterLoop.Nodes.erase(O, OuterLoop.Nodes.end());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">833</td>
    <td class="codeLine">  OuterLoop.Nodes.erase(O, OuterLoop.Nodes.end());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">834</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">835</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class="codeLine">void BlockFrequencyInfoImplBase::adjustLoopHeaderMass(LoopData &Loop) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">836</td>
    <td class="codeLine">void BlockFrequencyInfoImplBase::adjustLoopHeaderMass(LoopData &Loop) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class="codeLine">  assert(Loop.isIrreducible() && "this only makes sense on irreducible loops");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">837</td>
    <td class="codeLine">  assert(Loop.isIrreducible() && "this only makes sense on irreducible loops");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">838</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class="codeLine">  // Since the loop has more than one header block, the mass flowing back into</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">839</td>
    <td class="codeLine">  // Since the loop has more than one header block, the mass flowing back into</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class="codeLine">  // each header will be different. Adjust the mass in each header loop to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">840</td>
    <td class="codeLine">  // each header will be different. Adjust the mass in each header loop to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class="codeLine">  // reflect the masses flowing through back edges.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">841</td>
    <td class="codeLine">  // reflect the masses flowing through back edges.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">842</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class="codeLine">  // To do this, we distribute the initial mass using the backedge masses</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">843</td>
    <td class="codeLine">  // To do this, we distribute the initial mass using the backedge masses</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class="codeLine">  // as weights for the distribution.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">844</td>
    <td class="codeLine">  // as weights for the distribution.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class="codeLine">  BlockMass LoopMass = BlockMass::getFull();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">845</td>
    <td class="codeLine">  BlockMass LoopMass = BlockMass::getFull();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class="codeLine">  Distribution Dist;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">846</td>
    <td class="codeLine">  Distribution Dist;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">847</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "adjust-loop-header-mass:\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">848</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "adjust-loop-header-mass:\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class="codeLine">  for (uint32_t H = 0; H < Loop.NumHeaders; ++H) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">849</td>
    <td class="codeLine">  for (uint32_t H = 0; H < Loop.NumHeaders; ++H) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class="codeLine">    auto &HeaderNode = Loop.Nodes[H];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">850</td>
    <td class="codeLine">    auto &HeaderNode = Loop.Nodes[H];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class="codeLine">    auto &BackedgeMass = Loop.BackedgeMass[Loop.getHeaderIndex(HeaderNode)];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">851</td>
    <td class="codeLine">    auto &BackedgeMass = Loop.BackedgeMass[Loop.getHeaderIndex(HeaderNode)];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << " - Add back edge mass for node "</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">852</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << " - Add back edge mass for node "</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class="codeLine">                      << getBlockName(HeaderNode) << ": " << BackedgeMass</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">853</td>
    <td class="codeLine">                      << getBlockName(HeaderNode) << ": " << BackedgeMass</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class="codeLine">                      << "\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">854</td>
    <td class="codeLine">                      << "\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class="codeLine">    if (BackedgeMass.getMass() > 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">855</td>
    <td class="codeLine">    if (BackedgeMass.getMass() > 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class="codeLine">      Dist.addLocal(HeaderNode, BackedgeMass.getMass());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">856</td>
    <td class="codeLine">      Dist.addLocal(HeaderNode, BackedgeMass.getMass());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">857</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "   Nothing added. Back edge mass is zero\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">858</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "   Nothing added. Back edge mass is zero\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">859</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">860</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class="codeLine">  DitheringDistributer D(Dist, LoopMass);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">861</td>
    <td class="codeLine">  DitheringDistributer D(Dist, LoopMass);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">862</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << " Distribute loop mass " << LoopMass</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">863</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << " Distribute loop mass " << LoopMass</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class="codeLine">                    << " to headers using above weights\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">864</td>
    <td class="codeLine">                    << " to headers using above weights\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class="codeLine">  for (const Weight &W : Dist.Weights) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">865</td>
    <td class="codeLine">  for (const Weight &W : Dist.Weights) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class="codeLine">    BlockMass Taken = D.takeMass(W.Amount);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">866</td>
    <td class="codeLine">    BlockMass Taken = D.takeMass(W.Amount);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class="codeLine">    assert(W.Type == Weight::Local && "all weights should be local");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">867</td>
    <td class="codeLine">    assert(W.Type == Weight::Local && "all weights should be local");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class="codeLine">    Working[W.TargetNode.Index].getMass() = Taken;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">868</td>
    <td class="codeLine">    Working[W.TargetNode.Index].getMass() = Taken;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class="codeLine">    LLVM_DEBUG(debugAssign(*this, D, W.TargetNode, Taken, nullptr));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">869</td>
    <td class="codeLine">    LLVM_DEBUG(debugAssign(*this, D, W.TargetNode, Taken, nullptr));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">870</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">871</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">872</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">872</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">873</td>
    <td class="codeLine">void BlockFrequencyInfoImplBase::distributeIrrLoopHeaderMass(Distribution &Dist) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">873</td>
    <td class="codeLine">void BlockFrequencyInfoImplBase::distributeIrrLoopHeaderMass(Distribution &Dist) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">874</td>
    <td class="codeLine">  BlockMass LoopMass = BlockMass::getFull();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">874</td>
    <td class="codeLine">  BlockMass LoopMass = BlockMass::getFull();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">875</td>
    <td class="codeLine">  DitheringDistributer D(Dist, LoopMass);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">875</td>
    <td class="codeLine">  DitheringDistributer D(Dist, LoopMass);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">876</td>
    <td class="codeLine">  for (const Weight &W : Dist.Weights) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">876</td>
    <td class="codeLine">  for (const Weight &W : Dist.Weights) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">877</td>
    <td class="codeLine">    BlockMass Taken = D.takeMass(W.Amount);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">877</td>
    <td class="codeLine">    BlockMass Taken = D.takeMass(W.Amount);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">878</td>
    <td class="codeLine">    assert(W.Type == Weight::Local && "all weights should be local");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">878</td>
    <td class="codeLine">    assert(W.Type == Weight::Local && "all weights should be local");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">879</td>
    <td class="codeLine">    Working[W.TargetNode.Index].getMass() = Taken;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">879</td>
    <td class="codeLine">    Working[W.TargetNode.Index].getMass() = Taken;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">880</td>
    <td class="codeLine">    LLVM_DEBUG(debugAssign(*this, D, W.TargetNode, Taken, nullptr));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">880</td>
    <td class="codeLine">    LLVM_DEBUG(debugAssign(*this, D, W.TargetNode, Taken, nullptr));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">881</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">881</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">882</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">882</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">883</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">883</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
</table>
    </div>
    <button id="myBtn" onclick="topFunction()" title="Go to top" type="button">Top</button>
    <script src="../Javascript/drop_down.js"></script>
    <script src="../Javascript/top_button.js"></script>
  </body>
</html>