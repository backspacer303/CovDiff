<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>SeparateConstOffsetFromGEP.cpp</title>
    <link rel="stylesheet" href="../Style/style.css" />
  </head>
  <body>
    <div class="headerDiv">
      <h1>
        Code Coverage
      </h1>
      <p>
        Source file: /home/nikola/Desktop/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
      </p>
    </div>
    <button class="collapsible" type="button">Open Summary Report</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Summary Report</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line number</th>
    <th class="mainTh">Line</th>
    <th class="mainTh">Number of hits</th>
    <th class="mainTh">Tests that cover line</th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="">//===- SeparateConstOffsetFromGEP.cpp -------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="">// Loop unrolling may create many similar GEPs for array accesses.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="">// e.g., a 2-level loop</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="">// float a[32][32]; // global variable</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="">// for (int i = 0; i < 2; ++i) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="">//   for (int j = 0; j < 2; ++j) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="">//     ...</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="">//     ... = a[x + i][y + j];</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="">//     ...</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="">//   }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="">// }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="">// will probably be unrolled to:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="">// gep %a, 0, %x, %y; load</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="">// gep %a, 0, %x, %y + 1; load</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="">// gep %a, 0, %x + 1, %y; load</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="">// gep %a, 0, %x + 1, %y + 1; load</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="">// LLVM's GVN does not use partial redundancy elimination yet, and is thus</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="">// unable to reuse (gep %a, 0, %x, %y). As a result, this misoptimization incurs</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="">// significant slowdown in targets with limited addressing modes. For instance,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="">// because the PTX target does not support the reg+reg addressing mode, the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="">// NVPTX backend emits PTX code that literally computes the pointer address of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="">// each GEP, wasting tons of registers. It emits the following PTX for the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="">// first load and similar PTX for other loads.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="">// mov.u32         %r1, %x;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="">// mov.u32         %r2, %y;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="">// mul.wide.u32    %rl2, %r1, 128;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="">// mov.u64         %rl3, a;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="">// add.s64         %rl4, %rl3, %rl2;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="">// mul.wide.u32    %rl5, %r2, 4;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="">// add.s64         %rl6, %rl4, %rl5;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="">// ld.global.f32   %f1, [%rl6];</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="">// To reduce the register pressure, the optimization implemented in this file</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="">// merges the common part of a group of GEPs, so we can compute each pointer</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="">// address by adding a simple offset to the common part, saving many registers.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="">// It works by splitting each GEP into a variadic base and a constant offset.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="">// The variadic base can be computed once and reused by multiple GEPs, and the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="">// constant offsets can be nicely folded into the reg+immediate addressing mode</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="">// (supported by most targets) without using any extra register.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="">// For instance, we transform the four GEPs and four loads in the above example</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="">// into:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="">// base = gep a, 0, x, y</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="">// load base</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="">// laod base + 1  * sizeof(float)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="">// load base + 32 * sizeof(float)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="">// load base + 33 * sizeof(float)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="">// Given the transformed IR, a backend that supports the reg+immediate</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="">// addressing mode can easily fold the pointer arithmetics into the loads. For</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="">// example, the NVPTX backend can easily fold the pointer arithmetics into the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="">// ld.global.f32 instructions, and the resultant PTX uses much fewer registers.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="">// mov.u32         %r1, %tid.x;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="">// mov.u32         %r2, %tid.y;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="">// mul.wide.u32    %rl2, %r1, 128;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="">// mov.u64         %rl3, a;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="">// add.s64         %rl4, %rl3, %rl2;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="">// mul.wide.u32    %rl5, %r2, 4;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="">// add.s64         %rl6, %rl4, %rl5;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="">// ld.global.f32   %f1, [%rl6]; // so far the same as unoptimized PTX</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="">// ld.global.f32   %f2, [%rl6+4]; // much better</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="">// ld.global.f32   %f3, [%rl6+128]; // much better</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="">// ld.global.f32   %f4, [%rl6+132]; // much better</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="">// Another improvement enabled by the LowerGEP flag is to lower a GEP with</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="">// multiple indices to either multiple GEPs with a single index or arithmetic</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="">// operations (depending on whether the target uses alias analysis in codegen).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="">// Such transformation can have following benefits:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="">// (1) It can always extract constants in the indices of structure type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="">// (2) After such Lowering, there are more optimization opportunities such as</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="">//     CSE, LICM and CGP.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="">// E.g. The following GEPs have multiple indices:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="">//  BB1:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="">//    %p = getelementptr [10 x %struct]* %ptr, i64 %i, i64 %j1, i32 3</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="">//    load %p</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="">//    ...</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="">//  BB2:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="">//    %p2 = getelementptr [10 x %struct]* %ptr, i64 %i, i64 %j1, i32 2</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="">//    load %p2</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="">//    ...</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="">// We can not do CSE to the common part related to index "i64 %i". Lowering</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="">// GEPs can achieve such goals.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="">// If the target does not use alias analysis in codegen, this pass will</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="">// lower a GEP with multiple indices into arithmetic operations:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="">//  BB1:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="">//    %1 = ptrtoint [10 x %struct]* %ptr to i64    ; CSE opportunity</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="">//    %2 = mul i64 %i, length_of_10xstruct         ; CSE opportunity</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="">//    %3 = add i64 %1, %2                          ; CSE opportunity</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="">//    %4 = mul i64 %j1, length_of_struct</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="">//    %5 = add i64 %3, %4</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="">//    %6 = add i64 %3, struct_field_3              ; Constant offset</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="">//    %p = inttoptr i64 %6 to i32*</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="">//    load %p</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="">//    ...</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="">//  BB2:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="">//    %7 = ptrtoint [10 x %struct]* %ptr to i64    ; CSE opportunity</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="">//    %8 = mul i64 %i, length_of_10xstruct         ; CSE opportunity</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="">//    %9 = add i64 %7, %8                          ; CSE opportunity</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="">//    %10 = mul i64 %j2, length_of_struct</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="">//    %11 = add i64 %9, %10</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="">//    %12 = add i64 %11, struct_field_2            ; Constant offset</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="">//    %p = inttoptr i64 %12 to i32*</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="">//    load %p2</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="">//    ...</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="">// If the target uses alias analysis in codegen, this pass will lower a GEP</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="">// with multiple indices into multiple GEPs with a single index:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="">//  BB1:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="">//    %1 = bitcast [10 x %struct]* %ptr to i8*     ; CSE opportunity</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="">//    %2 = mul i64 %i, length_of_10xstruct         ; CSE opportunity</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="">//    %3 = getelementptr i8* %1, i64 %2            ; CSE opportunity</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="">//    %4 = mul i64 %j1, length_of_struct</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="">//    %5 = getelementptr i8* %3, i64 %4</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="">//    %6 = getelementptr i8* %5, struct_field_3    ; Constant offset</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="">//    %p = bitcast i8* %6 to i32*</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="">//    load %p</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="">//    ...</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="">//  BB2:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="">//    %7 = bitcast [10 x %struct]* %ptr to i8*     ; CSE opportunity</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="">//    %8 = mul i64 %i, length_of_10xstruct         ; CSE opportunity</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="">//    %9 = getelementptr i8* %7, i64 %8            ; CSE opportunity</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="">//    %10 = mul i64 %j2, length_of_struct</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="">//    %11 = getelementptr i8* %9, i64 %10</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="">//    %12 = getelementptr i8* %11, struct_field_2  ; Constant offset</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="">//    %p2 = bitcast i8* %12 to i32*</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="">//    load %p2</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="">//    ...</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="">// Lowering GEPs can also benefit other passes such as LICM and CGP.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="">// LICM (Loop Invariant Code Motion) can not hoist/sink a GEP of multiple</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="">// indices if one of the index is variant. If we lower such GEP into invariant</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="">// parts and variant parts, LICM can hoist/sink those invariant parts.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="">// CGP (CodeGen Prepare) tries to sink address calculations that match the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="">// target's addressing modes. A GEP with multiple indices may not match and will</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="">// not be sunk. If we lower such GEP into smaller parts, CGP may sink some of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="">// them. So we end up with a better addressing mode.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="">#include "llvm/Transforms/Scalar/SeparateConstOffsetFromGEP.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="">#include "llvm/ADT/APInt.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="">#include "llvm/ADT/DenseMap.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="">#include "llvm/ADT/DepthFirstIterator.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="">#include "llvm/ADT/SmallVector.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="">#include "llvm/Analysis/LoopInfo.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="">#include "llvm/Analysis/MemoryBuiltins.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="">#include "llvm/Analysis/TargetLibraryInfo.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="">#include "llvm/Analysis/TargetTransformInfo.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="">#include "llvm/Analysis/ValueTracking.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="">#include "llvm/IR/BasicBlock.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="">#include "llvm/IR/Constant.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="">#include "llvm/IR/Constants.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="">#include "llvm/IR/DataLayout.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="">#include "llvm/IR/DerivedTypes.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="">#include "llvm/IR/Dominators.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="">#include "llvm/IR/Function.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="">#include "llvm/IR/GetElementPtrTypeIterator.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="">#include "llvm/IR/IRBuilder.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="">#include "llvm/IR/Instruction.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="">#include "llvm/IR/Instructions.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="">#include "llvm/IR/Module.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="">#include "llvm/IR/PassManager.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="">#include "llvm/IR/PatternMatch.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="">#include "llvm/IR/Type.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="">#include "llvm/IR/User.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="">#include "llvm/IR/Value.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="">#include "llvm/InitializePasses.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="">#include "llvm/Pass.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="">#include "llvm/Support/Casting.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="">#include "llvm/Support/CommandLine.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="">#include "llvm/Support/ErrorHandling.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="">#include "llvm/Support/raw_ostream.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="">#include "llvm/Transforms/Scalar.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="">#include "llvm/Transforms/Utils/Local.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="">#include <cassert></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="">#include <cstdint></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="">#include <string></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="">using namespace llvm;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="">using namespace llvm::PatternMatch;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="">static cl::opt<bool> DisableSeparateConstOffsetFromGEP(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="">    "disable-separate-const-offset-from-gep", cl::init(false),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="">    cl::desc("Do not separate the constant offset from a GEP instruction"),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="">    cl::Hidden);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="">// Setting this flag may emit false positives when the input module already</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="">// contains dead instructions. Therefore, we set it only in unit tests that are</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="">// free of dead code.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="">static cl::opt<bool></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="">    VerifyNoDeadCode("reassociate-geps-verify-no-dead-code", cl::init(false),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="">                     cl::desc("Verify this pass produces no dead code"),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="">                     cl::Hidden);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="">namespace {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="">/// A helper class for separating a constant offset from a GEP index.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="">/// In real programs, a GEP index may be more complicated than a simple addition</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="">/// of something and a constant integer which can be trivially splitted. For</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="">/// example, to split ((a << 3) | 5) + b, we need to search deeper for the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="">/// constant offset, so that we can separate the index to (a << 3) + b and 5.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="">/// Therefore, this class looks into the expression that computes a given GEP</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="">/// index, and tries to find a constant integer that can be hoisted to the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="">/// outermost level of the expression as an addition. Not every constant in an</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="">/// expression can jump out. e.g., we cannot transform (b * (a + 5)) to (b * a +</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="">/// 5); nor can we transform (3 * (a + 5)) to (3 * a + 5), however in this case,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="">/// -instcombine probably already optimized (3 * (a + 5)) to (3 * a + 15).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="">class ConstantOffsetExtractor {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="">  /// Extracts a constant offset from the given GEP index. It returns the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="">  /// new index representing the remainder (equal to the original index minus</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="">  /// the constant offset), or nullptr if we cannot extract a constant offset.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="">  /// \p Idx The given GEP index</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="">  /// \p GEP The given GEP</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="">  /// \p UserChainTail Outputs the tail of UserChain so that we can</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="">  ///                  garbage-collect unused instructions in UserChain.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="">  static Value *Extract(Value *Idx, GetElementPtrInst *GEP,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="">                        User *&UserChainTail, const DominatorTree *DT);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="">  /// Looks for a constant offset from the given GEP index without extracting</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="">  /// it. It returns the numeric value of the extracted constant offset (0 if</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="">  /// failed). The meaning of the arguments are the same as Extract.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="">  static int64_t Find(Value *Idx, GetElementPtrInst *GEP,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="">                      const DominatorTree *DT);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="">private:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="uncoveredLine">  ConstantOffsetExtractor(Instruction *InsertionPt, const DominatorTree *DT)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="uncoveredLine">      : IP(InsertionPt), DL(InsertionPt->getModule()->getDataLayout()), DT(DT) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="">  /// Searches the expression that computes V for a non-zero constant C s.t.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="">  /// V can be reassociated into the form V' + C. If the searching is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="">  /// successful, returns C and update UserChain as a def-use chain from C to V;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="">  /// otherwise, UserChain is empty.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="">  /// \p V            The given expression</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="">  /// \p SignExtended Whether V will be sign-extended in the computation of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="">  ///                 GEP index</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="">  /// \p ZeroExtended Whether V will be zero-extended in the computation of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="">  ///                 GEP index</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="">  /// \p NonNegative  Whether V is guaranteed to be non-negative. For example,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="">  ///                 an index of an inbounds GEP is guaranteed to be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="">  ///                 non-negative. Levaraging this, we can better split</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="">  ///                 inbounds GEPs.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="">  APInt find(Value *V, bool SignExtended, bool ZeroExtended, bool NonNegative);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="">  /// A helper function to look into both operands of a binary operator.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="">  APInt findInEitherOperand(BinaryOperator *BO, bool SignExtended,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="">                            bool ZeroExtended);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="">  /// After finding the constant offset C from the GEP index I, we build a new</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="">  /// index I' s.t. I' + C = I. This function builds and returns the new</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="">  /// index I' according to UserChain produced by function "find".</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="">  /// The building conceptually takes two steps:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="">  /// 1) iteratively distribute s/zext towards the leaves of the expression tree</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="">  /// that computes I</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="">  /// 2) reassociate the expression tree to the form I' + C.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="">  /// For example, to extract the 5 from sext(a + (b + 5)), we first distribute</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="">  /// sext to a, b and 5 so that we have</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="">  ///   sext(a) + (sext(b) + 5).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="">  /// Then, we reassociate it to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="">  ///   (sext(a) + sext(b)) + 5.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="">  /// Given this form, we know I' is sext(a) + sext(b).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="">  Value *rebuildWithoutConstOffset();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="">  /// After the first step of rebuilding the GEP index without the constant</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="">  /// offset, distribute s/zext to the operands of all operators in UserChain.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="">  /// e.g., zext(sext(a + (b + 5)) (assuming no overflow) =></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="">  /// zext(sext(a)) + (zext(sext(b)) + zext(sext(5))).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="">  /// The function also updates UserChain to point to new subexpressions after</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="">  /// distributing s/zext. e.g., the old UserChain of the above example is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="">  /// 5 -> b + 5 -> a + (b + 5) -> sext(...) -> zext(sext(...)),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="">  /// and the new UserChain is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="">  /// zext(sext(5)) -> zext(sext(b)) + zext(sext(5)) -></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="">  ///   zext(sext(a)) + (zext(sext(b)) + zext(sext(5))</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="">  /// \p ChainIndex The index to UserChain. ChainIndex is initially</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="">  ///               UserChain.size() - 1, and is decremented during</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="">  ///               the recursion.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="">  Value *distributeExtsAndCloneChain(unsigned ChainIndex);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="">  /// Reassociates the GEP index to the form I' + C and returns I'.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="">  Value *removeConstOffset(unsigned ChainIndex);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="">  /// A helper function to apply ExtInsts, a list of s/zext, to value V.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="">  /// e.g., if ExtInsts = [sext i32 to i64, zext i16 to i32], this function</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="">  /// returns "sext i32 (zext i16 V to i32) to i64".</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="">  Value *applyExts(Value *V);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="">  /// A helper function that returns whether we can trace into the operands</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="">  /// of binary operator BO for a constant offset.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="">  /// \p SignExtended Whether BO is surrounded by sext</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="">  /// \p ZeroExtended Whether BO is surrounded by zext</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="">  /// \p NonNegative Whether BO is known to be non-negative, e.g., an in-bound</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="">  ///                array index.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="">  bool CanTraceInto(bool SignExtended, bool ZeroExtended, BinaryOperator *BO,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="">                    bool NonNegative);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="">  /// The path from the constant offset to the old GEP index. e.g., if the GEP</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="">  /// index is "a * b + (c + 5)". After running function find, UserChain[0] will</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="">  /// be the constant 5, UserChain[1] will be the subexpression "c + 5", and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="">  /// UserChain[2] will be the entire expression "a * b + (c + 5)".</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="">  /// This path helps to rebuild the new GEP index.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="">  SmallVector<User *, 8> UserChain;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="">  /// A data structure used in rebuildWithoutConstOffset. Contains all</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="">  /// sext/zext instructions along UserChain.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="">  SmallVector<CastInst *, 16> ExtInsts;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="">  /// Insertion position of cloned instructions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="">  Instruction *IP;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="">  const DataLayout &DL;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="">  const DominatorTree *DT;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="">/// A pass that tries to split every GEP in the function into a variadic</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="">/// base and a constant offset. It is a FunctionPass because searching for the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="">/// constant offset may inspect other basic blocks.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="">class SeparateConstOffsetFromGEPLegacyPass : public FunctionPass {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="">  static char ID;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="uncoveredLine">  SeparateConstOffsetFromGEPLegacyPass(bool LowerGEP = false)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="uncoveredLine">      : FunctionPass(ID), LowerGEP(LowerGEP) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="uncoveredLine">    initializeSeparateConstOffsetFromGEPLegacyPassPass(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="uncoveredLine">        *PassRegistry::getPassRegistry());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="uncoveredLine">  void getAnalysisUsage(AnalysisUsage &AU) const override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="uncoveredLine">    AU.addRequired<DominatorTreeWrapperPass>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="uncoveredLine">    AU.addRequired<TargetTransformInfoWrapperPass>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="uncoveredLine">    AU.addRequired<LoopInfoWrapperPass>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="uncoveredLine">    AU.setPreservesCFG();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="uncoveredLine">    AU.addRequired<TargetLibraryInfoWrapperPass>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="">  bool runOnFunction(Function &F) override;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="">private:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="">  bool LowerGEP;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="">/// A pass that tries to split every GEP in the function into a variadic</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="">/// base and a constant offset. It is a FunctionPass because searching for the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="">/// constant offset may inspect other basic blocks.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="">class SeparateConstOffsetFromGEP {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="uncoveredLine">  SeparateConstOffsetFromGEP(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="">      DominatorTree *DT, LoopInfo *LI, TargetLibraryInfo *TLI,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="">      function_ref<TargetTransformInfo &(Function &)> GetTTI, bool LowerGEP)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="uncoveredLine">      : DT(DT), LI(LI), TLI(TLI), GetTTI(GetTTI), LowerGEP(LowerGEP) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="">  bool run(Function &F);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="">private:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="">  /// Track the operands of an add or sub.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="">  using ExprKey = std::pair<Value *, Value *>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="">  /// Create a pair for use as a map key for a commutable operation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="uncoveredLine">  static ExprKey createNormalizedCommutablePair(Value *A, Value *B) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="uncoveredLine">    if (A < B)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="uncoveredLine">      return {A, B};</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="uncoveredLine">    return {B, A};</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="">  /// Tries to split the given GEP into a variadic base and a constant offset,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="">  /// and returns true if the splitting succeeds.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="">  bool splitGEP(GetElementPtrInst *GEP);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="">  /// Lower a GEP with multiple indices into multiple GEPs with a single index.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="">  /// Function splitGEP already split the original GEP into a variadic part and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="">  /// a constant offset (i.e., AccumulativeByteOffset). This function lowers the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="">  /// variadic part into a set of GEPs with a single index and applies</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="">  /// AccumulativeByteOffset to it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="">  /// \p Variadic                  The variadic part of the original GEP.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="">  /// \p AccumulativeByteOffset    The constant offset.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="">  void lowerToSingleIndexGEPs(GetElementPtrInst *Variadic,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="">                              int64_t AccumulativeByteOffset);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="">  /// Lower a GEP with multiple indices into ptrtoint+arithmetics+inttoptr form.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="">  /// Function splitGEP already split the original GEP into a variadic part and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="">  /// a constant offset (i.e., AccumulativeByteOffset). This function lowers the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="">  /// variadic part into a set of arithmetic operations and applies</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="">  /// AccumulativeByteOffset to it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="">  /// \p Variadic                  The variadic part of the original GEP.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="">  /// \p AccumulativeByteOffset    The constant offset.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="">  void lowerToArithmetics(GetElementPtrInst *Variadic,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="">                          int64_t AccumulativeByteOffset);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="">  /// Finds the constant offset within each index and accumulates them. If</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="">  /// LowerGEP is true, it finds in indices of both sequential and structure</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="">  /// types, otherwise it only finds in sequential indices. The output</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="">  /// NeedsExtraction indicates whether we successfully find a non-zero constant</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="">  /// offset.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="">  int64_t accumulateByteOffset(GetElementPtrInst *GEP, bool &NeedsExtraction);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="">  /// Canonicalize array indices to pointer-size integers. This helps to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="">  /// simplify the logic of splitting a GEP. For example, if a + b is a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="">  /// pointer-size integer, we have</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="">  ///   gep base, a + b = gep (gep base, a), b</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="">  /// However, this equality may not hold if the size of a + b is smaller than</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="">  /// the pointer size, because LLVM conceptually sign-extends GEP indices to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="">  /// pointer size before computing the address</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="">  /// (http://llvm.org/docs/LangRef.html#id181).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="">  /// This canonicalization is very likely already done in clang and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="">  /// instcombine. Therefore, the program will probably remain the same.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="">  /// Returns true if the module changes.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="">  /// Verified in @i32_add in split-gep.ll</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="">  bool canonicalizeArrayIndicesToIndexSize(GetElementPtrInst *GEP);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="">  /// Optimize sext(a)+sext(b) to sext(a+b) when a+b can't sign overflow.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="">  /// SeparateConstOffsetFromGEP distributes a sext to leaves before extracting</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="">  /// the constant offset. After extraction, it becomes desirable to reunion the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="">  /// distributed sexts. For example,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="">  ///                              &a[sext(i +nsw (j +nsw 5)]</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="">  ///   => distribute              &a[sext(i) +nsw (sext(j) +nsw 5)]</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="">  ///   => constant extraction     &a[sext(i) + sext(j)] + 5</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="">  ///   => reunion                 &a[sext(i +nsw j)] + 5</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="">  bool reuniteExts(Function &F);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="">  /// A helper that reunites sexts in an instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="">  bool reuniteExts(Instruction *I);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="">  /// Find the closest dominator of <Dominatee> that is equivalent to <Key>.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="">  Instruction *findClosestMatchingDominator(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="">      ExprKey Key, Instruction *Dominatee,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="">      DenseMap<ExprKey, SmallVector<Instruction *, 2>> &DominatingExprs);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="">  /// Verify F is free of dead code.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="">  void verifyNoDeadCode(Function &F);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="">  bool hasMoreThanOneUseInLoop(Value *v, Loop *L);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="">  // Swap the index operand of two GEP.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="">  void swapGEPOperand(GetElementPtrInst *First, GetElementPtrInst *Second);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="">  // Check if it is safe to swap operand of two GEP.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="">  bool isLegalToSwapOperand(GetElementPtrInst *First, GetElementPtrInst *Second,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="">                            Loop *CurLoop);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="">  const DataLayout *DL = nullptr;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="">  DominatorTree *DT = nullptr;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="">  LoopInfo *LI;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="">  TargetLibraryInfo *TLI;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="">  // Retrieved lazily since not always used.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="">  function_ref<TargetTransformInfo &(Function &)> GetTTI;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="">  /// Whether to lower a GEP with multiple indices into arithmetic operations or</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="">  /// multiple GEPs with a single index.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="">  bool LowerGEP;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="">  DenseMap<ExprKey, SmallVector<Instruction *, 2>> DominatingAdds;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="">  DenseMap<ExprKey, SmallVector<Instruction *, 2>> DominatingSubs;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="">} // end anonymous namespace</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="">char SeparateConstOffsetFromGEPLegacyPass::ID = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="coveredLine">INITIALIZE_PASS_BEGIN(</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="">    SeparateConstOffsetFromGEPLegacyPass, "separate-const-offset-from-gep",</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="">    "Split GEPs to a variadic base and a constant offset for better CSE", false,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="">    false)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="coveredLine">INITIALIZE_PASS_DEPENDENCY(DominatorTreeWrapperPass)</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="coveredLine">INITIALIZE_PASS_DEPENDENCY(ScalarEvolutionWrapperPass)</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="coveredLine">INITIALIZE_PASS_DEPENDENCY(TargetTransformInfoWrapperPass)</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="coveredLine">INITIALIZE_PASS_DEPENDENCY(LoopInfoWrapperPass)</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="coveredLine">INITIALIZE_PASS_DEPENDENCY(TargetLibraryInfoWrapperPass)</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="coveredLine">INITIALIZE_PASS_END(</td>
    <td>4</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="">    SeparateConstOffsetFromGEPLegacyPass, "separate-const-offset-from-gep",</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="">    "Split GEPs to a variadic base and a constant offset for better CSE", false,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="">    false)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class="uncoveredLine">FunctionPass *llvm::createSeparateConstOffsetFromGEPPass(bool LowerGEP) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="uncoveredLine">  return new SeparateConstOffsetFromGEPLegacyPass(LowerGEP);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="uncoveredLine">bool ConstantOffsetExtractor::CanTraceInto(bool SignExtended,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="">                                            bool ZeroExtended,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="">                                            BinaryOperator *BO,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="">                                            bool NonNegative) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="">  // We only consider ADD, SUB and OR, because a non-zero constant found in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class="">  // expressions composed of these operations can be easily hoisted as a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="">  // constant offset by reassociation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="uncoveredLine">  if (BO->getOpcode() != Instruction::Add &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="uncoveredLine">      BO->getOpcode() != Instruction::Sub &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class="uncoveredLine">      BO->getOpcode() != Instruction::Or) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="uncoveredLine">  Value *LHS = BO->getOperand(0), *RHS = BO->getOperand(1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="">  // Do not trace into "or" unless it is equivalent to "add". If LHS and RHS</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="">  // don't have common bits, (LHS | RHS) is equivalent to (LHS + RHS).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="">  // FIXME: this does not appear to be covered by any tests</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="">  //        (with x86/aarch64 backends at least)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class="uncoveredLine">  if (BO->getOpcode() == Instruction::Or &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="uncoveredLine">      !haveNoCommonBitsSet(LHS, RHS, DL, nullptr, BO, DT))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="">  // FIXME: We don't currently support constants from the RHS of subs,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="">  // when we are zero-extended, because we need a way to zero-extended</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="">  // them before they are negated.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class="uncoveredLine">  if (ZeroExtended && !SignExtended && BO->getOpcode() == Instruction::Sub)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="">  // In addition, tracing into BO requires that its surrounding s/zext (if</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="">  // any) is distributable to both operands.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="">  // Suppose BO = A op B.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class="">  //  SignExtended | ZeroExtended | Distributable?</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="">  // --------------+--------------+----------------------------------</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="">  //       0       |      0       | true because no s/zext exists</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="">  //       0       |      1       | zext(BO) == zext(A) op zext(B)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="">  //       1       |      0       | sext(BO) == sext(A) op sext(B)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="">  //       1       |      1       | zext(sext(BO)) ==</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="">  //               |              |     zext(sext(A)) op zext(sext(B))</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="uncoveredLine">  if (BO->getOpcode() == Instruction::Add && !ZeroExtended && NonNegative) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="">    // If a + b >= 0 and (a >= 0 or b >= 0), then</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="">    //   sext(a + b) = sext(a) + sext(b)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="">    // even if the addition is not marked nsw.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="">    //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="">    // Leveraging this invariant, we can trace into an sext'ed inbound GEP</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="">    // index if the constant offset is non-negative.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="">    //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="">    // Verified in @sext_add in split-gep.ll.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="uncoveredLine">    if (ConstantInt *ConstLHS = dyn_cast<ConstantInt>(LHS)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="uncoveredLine">      if (!ConstLHS->isNegative())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="uncoveredLine">        return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="uncoveredLine">    if (ConstantInt *ConstRHS = dyn_cast<ConstantInt>(RHS)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="uncoveredLine">      if (!ConstRHS->isNegative())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="uncoveredLine">        return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="">  // sext (add/sub nsw A, B) == add/sub nsw (sext A), (sext B)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="">  // zext (add/sub nuw A, B) == add/sub nuw (zext A), (zext B)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="uncoveredLine">  if (BO->getOpcode() == Instruction::Add ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="uncoveredLine">      BO->getOpcode() == Instruction::Sub) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="uncoveredLine">    if (SignExtended && !BO->hasNoSignedWrap())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="uncoveredLine">    if (ZeroExtended && !BO->hasNoUnsignedWrap())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="uncoveredLine">  return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class="uncoveredLine">APInt ConstantOffsetExtractor::findInEitherOperand(BinaryOperator *BO,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="">                                                   bool SignExtended,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="">                                                   bool ZeroExtended) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class="">  // Save off the current height of the chain, in case we need to restore it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="uncoveredLine">  size_t ChainLength = UserChain.size();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="">  // BO being non-negative does not shed light on whether its operands are</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="">  // non-negative. Clear the NonNegative flag here.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class="">  APInt ConstantOffset = find(BO->getOperand(0), SignExtended, ZeroExtended,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="uncoveredLine">                              /* NonNegative */ false);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="">  // If we found a constant offset in the left operand, stop and return that.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class="">  // This shortcut might cause us to miss opportunities of combining the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="">  // constant offsets in both operands, e.g., (a + 4) + (b + 5) => (a + b) + 9.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="">  // However, such cases are probably already handled by -instcombine,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="">  // given this pass runs after the standard optimizations.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="uncoveredLine">  if (ConstantOffset != 0) return ConstantOffset;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="">  // Reset the chain back to where it was when we started exploring this node,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class="">  // since visiting the LHS didn't pan out.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="uncoveredLine">  UserChain.resize(ChainLength);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="uncoveredLine">  ConstantOffset = find(BO->getOperand(1), SignExtended, ZeroExtended,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="uncoveredLine">                        /* NonNegative */ false);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="">  // If U is a sub operator, negate the constant offset found in the right</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="">  // operand.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="uncoveredLine">  if (BO->getOpcode() == Instruction::Sub)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="uncoveredLine">    ConstantOffset = -ConstantOffset;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="">  // If RHS wasn't a suitable candidate either, reset the chain again.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="uncoveredLine">  if (ConstantOffset == 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="uncoveredLine">    UserChain.resize(ChainLength);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="uncoveredLine">  return ConstantOffset;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class="uncoveredLine">APInt ConstantOffsetExtractor::find(Value *V, bool SignExtended,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="">                                    bool ZeroExtended, bool NonNegative) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="">  // TODO(jingyue): We could trace into integer/pointer casts, such as</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="">  // inttoptr, ptrtoint, bitcast, and addrspacecast. We choose to handle only</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class="">  // integers because it gives good enough results for our benchmarks.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="uncoveredLine">  unsigned BitWidth = cast<IntegerType>(V->getType())->getBitWidth();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class="">  // We cannot do much with Values that are not a User, such as an Argument.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="uncoveredLine">  User *U = dyn_cast<User>(V);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="uncoveredLine">  if (U == nullptr) return APInt(BitWidth, 0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="uncoveredLine">  APInt ConstantOffset(BitWidth, 0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="uncoveredLine">  if (ConstantInt *CI = dyn_cast<ConstantInt>(V)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="">    // Hooray, we found it!</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class="uncoveredLine">    ConstantOffset = CI->getValue();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="uncoveredLine">  } else if (BinaryOperator *BO = dyn_cast<BinaryOperator>(V)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class="">    // Trace into subexpressions for more hoisting opportunities.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="uncoveredLine">    if (CanTraceInto(SignExtended, ZeroExtended, BO, NonNegative))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="uncoveredLine">      ConstantOffset = findInEitherOperand(BO, SignExtended, ZeroExtended);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="uncoveredLine">  } else if (isa<TruncInst>(V)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="">    ConstantOffset =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="uncoveredLine">        find(U->getOperand(0), SignExtended, ZeroExtended, NonNegative)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="uncoveredLine">            .trunc(BitWidth);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="uncoveredLine">  } else if (isa<SExtInst>(V)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="uncoveredLine">    ConstantOffset = find(U->getOperand(0), /* SignExtended */ true,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="uncoveredLine">                          ZeroExtended, NonNegative).sext(BitWidth);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="uncoveredLine">  } else if (isa<ZExtInst>(V)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="">    // As an optimization, we can clear the SignExtended flag because</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="">    // sext(zext(a)) = zext(a). Verified in @sext_zext in split-gep.ll.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="">    //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class="">    // Clear the NonNegative flag, because zext(a) >= 0 does not imply a >= 0.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="">    ConstantOffset =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="uncoveredLine">        find(U->getOperand(0), /* SignExtended */ false,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="uncoveredLine">             /* ZeroExtended */ true, /* NonNegative */ false).zext(BitWidth);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="">  // If we found a non-zero constant offset, add it to the path for</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="">  // rebuildWithoutConstOffset. Zero is a valid constant offset, but doesn't</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="">  // help this optimization.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="uncoveredLine">  if (ConstantOffset != 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="uncoveredLine">    UserChain.push_back(U);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="uncoveredLine">  return ConstantOffset;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="uncoveredLine">Value *ConstantOffsetExtractor::applyExts(Value *V) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="uncoveredLine">  Value *Current = V;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="">  // ExtInsts is built in the use-def order. Therefore, we apply them to V</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="">  // in the reversed order.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="uncoveredLine">  for (CastInst *I : llvm::reverse(ExtInsts)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="uncoveredLine">    if (Constant *C = dyn_cast<Constant>(Current)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="">      // If Current is a constant, apply s/zext using ConstantExpr::getCast.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="">      // ConstantExpr::getCast emits a ConstantInt if C is a ConstantInt.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="uncoveredLine">      Current = ConstantExpr::getCast(I->getOpcode(), C, I->getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="">    } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="uncoveredLine">      Instruction *Ext = I->clone();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="uncoveredLine">      Ext->setOperand(0, Current);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="uncoveredLine">      Ext->insertBefore(IP);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="uncoveredLine">      Current = Ext;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="uncoveredLine">  return Current;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="uncoveredLine">Value *ConstantOffsetExtractor::rebuildWithoutConstOffset() {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="uncoveredLine">  distributeExtsAndCloneChain(UserChain.size() - 1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="">  // Remove all nullptrs (used to be s/zext) from UserChain.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="uncoveredLine">  unsigned NewSize = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="uncoveredLine">  for (User *I : UserChain) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="uncoveredLine">    if (I != nullptr) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class="uncoveredLine">      UserChain[NewSize] = I;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="uncoveredLine">      NewSize++;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="uncoveredLine">  UserChain.resize(NewSize);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class="uncoveredLine">  return removeConstOffset(UserChain.size() - 1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class="">Value *</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="uncoveredLine">ConstantOffsetExtractor::distributeExtsAndCloneChain(unsigned ChainIndex) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class="uncoveredLine">  User *U = UserChain[ChainIndex];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class="uncoveredLine">  if (ChainIndex == 0) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="uncoveredLine">    assert(isa<ConstantInt>(U));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="">    // If U is a ConstantInt, applyExts will return a ConstantInt as well.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class="uncoveredLine">    return UserChain[ChainIndex] = cast<ConstantInt>(applyExts(U));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="uncoveredLine">  if (CastInst *Cast = dyn_cast<CastInst>(U)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="uncoveredLine">    assert(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class="">        (isa<SExtInst>(Cast) || isa<ZExtInst>(Cast) || isa<TruncInst>(Cast)) &&</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="">        "Only following instructions can be traced: sext, zext & trunc");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class="uncoveredLine">    ExtInsts.push_back(Cast);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="uncoveredLine">    UserChain[ChainIndex] = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class="uncoveredLine">    return distributeExtsAndCloneChain(ChainIndex - 1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class="">  // Function find only trace into BinaryOperator and CastInst.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="uncoveredLine">  BinaryOperator *BO = cast<BinaryOperator>(U);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class="">  // OpNo = which operand of BO is UserChain[ChainIndex - 1]</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class="uncoveredLine">  unsigned OpNo = (BO->getOperand(0) == UserChain[ChainIndex - 1] ? 0 : 1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="uncoveredLine">  Value *TheOther = applyExts(BO->getOperand(1 - OpNo));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="uncoveredLine">  Value *NextInChain = distributeExtsAndCloneChain(ChainIndex - 1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="uncoveredLine">  BinaryOperator *NewBO = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class="uncoveredLine">  if (OpNo == 0) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class="uncoveredLine">    NewBO = BinaryOperator::Create(BO->getOpcode(), NextInChain, TheOther,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class="uncoveredLine">                                   BO->getName(), IP);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class="">  } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="uncoveredLine">    NewBO = BinaryOperator::Create(BO->getOpcode(), TheOther, NextInChain,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class="uncoveredLine">                                   BO->getName(), IP);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class="uncoveredLine">  return UserChain[ChainIndex] = NewBO;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class="uncoveredLine">Value *ConstantOffsetExtractor::removeConstOffset(unsigned ChainIndex) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class="uncoveredLine">  if (ChainIndex == 0) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="uncoveredLine">    assert(isa<ConstantInt>(UserChain[ChainIndex]));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class="uncoveredLine">    return ConstantInt::getNullValue(UserChain[ChainIndex]->getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="uncoveredLine">  BinaryOperator *BO = cast<BinaryOperator>(UserChain[ChainIndex]);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="uncoveredLine">  assert((BO->use_empty() || BO->hasOneUse()) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class="">         "distributeExtsAndCloneChain clones each BinaryOperator in "</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class="">         "UserChain, so no one should be used more than "</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class="">         "once");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class="uncoveredLine">  unsigned OpNo = (BO->getOperand(0) == UserChain[ChainIndex - 1] ? 0 : 1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="uncoveredLine">  assert(BO->getOperand(OpNo) == UserChain[ChainIndex - 1]);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class="uncoveredLine">  Value *NextInChain = removeConstOffset(ChainIndex - 1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class="uncoveredLine">  Value *TheOther = BO->getOperand(1 - OpNo);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="">  // If NextInChain is 0 and not the LHS of a sub, we can simplify the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="">  // sub-expression to be just TheOther.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class="uncoveredLine">  if (ConstantInt *CI = dyn_cast<ConstantInt>(NextInChain)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class="uncoveredLine">    if (CI->isZero() && !(BO->getOpcode() == Instruction::Sub && OpNo == 0))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="uncoveredLine">      return TheOther;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class="uncoveredLine">  BinaryOperator::BinaryOps NewOp = BO->getOpcode();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class="uncoveredLine">  if (BO->getOpcode() == Instruction::Or) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class="">    // Rebuild "or" as "add", because "or" may be invalid for the new</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class="">    // expression.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class="">    //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="">    // For instance, given</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="">    //   a | (b + 5) where a and b + 5 have no common bits,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="">    // we can extract 5 as the constant offset.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="">    //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class="">    // However, reusing the "or" in the new index would give us</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class="">    //   (a | b) + 5</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class="">    // which does not equal a | (b + 5).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="">    //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class="">    // Replacing the "or" with "add" is fine, because</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class="">    //   a | (b + 5) = a + (b + 5) = (a + b) + 5</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class="uncoveredLine">    NewOp = Instruction::Add;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="">  BinaryOperator *NewBO;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="uncoveredLine">  if (OpNo == 0) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class="uncoveredLine">    NewBO = BinaryOperator::Create(NewOp, NextInChain, TheOther, "", IP);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="">  } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class="uncoveredLine">    NewBO = BinaryOperator::Create(NewOp, TheOther, NextInChain, "", IP);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class="uncoveredLine">  NewBO->takeName(BO);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class="uncoveredLine">  return NewBO;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="uncoveredLine">Value *ConstantOffsetExtractor::Extract(Value *Idx, GetElementPtrInst *GEP,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class="">                                        User *&UserChainTail,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class="">                                        const DominatorTree *DT) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="uncoveredLine">  ConstantOffsetExtractor Extractor(GEP, DT);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="">  // Find a non-zero constant offset first.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class="">  APInt ConstantOffset =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class="">      Extractor.find(Idx, /* SignExtended */ false, /* ZeroExtended */ false,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class="uncoveredLine">                     GEP->isInBounds());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class="uncoveredLine">  if (ConstantOffset == 0) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="uncoveredLine">    UserChainTail = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class="uncoveredLine">    return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class="">  // Separates the constant offset from the GEP index.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class="uncoveredLine">  Value *IdxWithoutConstOffset = Extractor.rebuildWithoutConstOffset();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="uncoveredLine">  UserChainTail = Extractor.UserChain.back();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class="uncoveredLine">  return IdxWithoutConstOffset;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class="uncoveredLine">int64_t ConstantOffsetExtractor::Find(Value *Idx, GetElementPtrInst *GEP,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class="">                                      const DominatorTree *DT) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class="">  // If Idx is an index of an inbound GEP, Idx is guaranteed to be non-negative.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class="uncoveredLine">  return ConstantOffsetExtractor(GEP, DT)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class="uncoveredLine">      .find(Idx, /* SignExtended */ false, /* ZeroExtended */ false,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class="uncoveredLine">            GEP->isInBounds())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class="uncoveredLine">      .getSExtValue();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class="uncoveredLine">bool SeparateConstOffsetFromGEP::canonicalizeArrayIndicesToIndexSize(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class="">    GetElementPtrInst *GEP) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class="uncoveredLine">  bool Changed = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class="uncoveredLine">  Type *PtrIdxTy = DL->getIndexType(GEP->getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class="uncoveredLine">  gep_type_iterator GTI = gep_type_begin(*GEP);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class="uncoveredLine">  for (User::op_iterator I = GEP->op_begin() + 1, E = GEP->op_end();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class="uncoveredLine">       I != E; ++I, ++GTI) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class="">    // Skip struct member indices which must be i32.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class="uncoveredLine">    if (GTI.isSequential()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class="uncoveredLine">      if ((*I)->getType() != PtrIdxTy) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class="uncoveredLine">        *I = CastInst::CreateIntegerCast(*I, PtrIdxTy, true, "idxprom", GEP);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class="uncoveredLine">        Changed = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class="uncoveredLine">  return Changed;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class="">int64_t</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class="uncoveredLine">SeparateConstOffsetFromGEP::accumulateByteOffset(GetElementPtrInst *GEP,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class="">                                                 bool &NeedsExtraction) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class="uncoveredLine">  NeedsExtraction = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class="uncoveredLine">  int64_t AccumulativeByteOffset = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class="uncoveredLine">  gep_type_iterator GTI = gep_type_begin(*GEP);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class="uncoveredLine">  for (unsigned I = 1, E = GEP->getNumOperands(); I != E; ++I, ++GTI) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class="uncoveredLine">    if (GTI.isSequential()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class="">      // Constant offsets of scalable types are not really constant.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class="uncoveredLine">      if (isa<ScalableVectorType>(GTI.getIndexedType()))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class="">      // Tries to extract a constant offset from this GEP index.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class="">      int64_t ConstantOffset =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class="uncoveredLine">          ConstantOffsetExtractor::Find(GEP->getOperand(I), GEP, DT);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class="uncoveredLine">      if (ConstantOffset != 0) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class="uncoveredLine">        NeedsExtraction = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class="">        // A GEP may have multiple indices.  We accumulate the extracted</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class="">        // constant offset to a byte offset, and later offset the remainder of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class="">        // the original GEP with this byte offset.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class="uncoveredLine">        AccumulativeByteOffset +=</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class="uncoveredLine">            ConstantOffset * DL->getTypeAllocSize(GTI.getIndexedType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class="uncoveredLine">    } else if (LowerGEP) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class="uncoveredLine">      StructType *StTy = GTI.getStructType();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class="uncoveredLine">      uint64_t Field = cast<ConstantInt>(GEP->getOperand(I))->getZExtValue();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class="">      // Skip field 0 as the offset is always 0.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class="uncoveredLine">      if (Field != 0) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class="uncoveredLine">        NeedsExtraction = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class="uncoveredLine">        AccumulativeByteOffset +=</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class="uncoveredLine">            DL->getStructLayout(StTy)->getElementOffset(Field);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class="uncoveredLine">  return AccumulativeByteOffset;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class="uncoveredLine">void SeparateConstOffsetFromGEP::lowerToSingleIndexGEPs(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class="">    GetElementPtrInst *Variadic, int64_t AccumulativeByteOffset) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class="uncoveredLine">  IRBuilder<> Builder(Variadic);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class="uncoveredLine">  Type *PtrIndexTy = DL->getIndexType(Variadic->getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class="uncoveredLine">  Value *ResultPtr = Variadic->getOperand(0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class="uncoveredLine">  Loop *L = LI->getLoopFor(Variadic->getParent());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class="">  // Check if the base is not loop invariant or used more than once.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class="">  bool isSwapCandidate =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="uncoveredLine">      L && L->isLoopInvariant(ResultPtr) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class="uncoveredLine">      !hasMoreThanOneUseInLoop(ResultPtr, L);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">872</td>
    <td class="uncoveredLine">  Value *FirstResult = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">873</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">874</td>
    <td class="uncoveredLine">  gep_type_iterator GTI = gep_type_begin(*Variadic);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">875</td>
    <td class="">  // Create an ugly GEP for each sequential index. We don't create GEPs for</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">876</td>
    <td class="">  // structure indices, as they are accumulated in the constant offset index.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">877</td>
    <td class="uncoveredLine">  for (unsigned I = 1, E = Variadic->getNumOperands(); I != E; ++I, ++GTI) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">878</td>
    <td class="uncoveredLine">    if (GTI.isSequential()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">879</td>
    <td class="uncoveredLine">      Value *Idx = Variadic->getOperand(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">880</td>
    <td class="">      // Skip zero indices.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">881</td>
    <td class="uncoveredLine">      if (ConstantInt *CI = dyn_cast<ConstantInt>(Idx))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">882</td>
    <td class="uncoveredLine">        if (CI->isZero())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">883</td>
    <td class="uncoveredLine">          continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">884</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">885</td>
    <td class="">      APInt ElementSize = APInt(PtrIndexTy->getIntegerBitWidth(),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">886</td>
    <td class="uncoveredLine">                                DL->getTypeAllocSize(GTI.getIndexedType()));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">887</td>
    <td class="">      // Scale the index by element size.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">888</td>
    <td class="uncoveredLine">      if (ElementSize != 1) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">889</td>
    <td class="uncoveredLine">        if (ElementSize.isPowerOf2()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">890</td>
    <td class="uncoveredLine">          Idx = Builder.CreateShl(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">891</td>
    <td class="uncoveredLine">              Idx, ConstantInt::get(PtrIndexTy, ElementSize.logBase2()));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">892</td>
    <td class="">        } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">893</td>
    <td class="uncoveredLine">          Idx =</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">894</td>
    <td class="uncoveredLine">              Builder.CreateMul(Idx, ConstantInt::get(PtrIndexTy, ElementSize));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">895</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">896</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">897</td>
    <td class="">      // Create an ugly GEP with a single index for each index.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">898</td>
    <td class="">      ResultPtr =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">899</td>
    <td class="uncoveredLine">          Builder.CreateGEP(Builder.getInt8Ty(), ResultPtr, Idx, "uglygep");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">900</td>
    <td class="uncoveredLine">      if (FirstResult == nullptr)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">901</td>
    <td class="uncoveredLine">        FirstResult = ResultPtr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">902</td>
    <td class="uncoveredLine">    }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">903</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">904</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">905</td>
    <td class="">  // Create a GEP with the constant offset index.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">906</td>
    <td class="uncoveredLine">  if (AccumulativeByteOffset != 0) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">907</td>
    <td class="uncoveredLine">    Value *Offset = ConstantInt::get(PtrIndexTy, AccumulativeByteOffset);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">908</td>
    <td class="">    ResultPtr =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">909</td>
    <td class="uncoveredLine">        Builder.CreateGEP(Builder.getInt8Ty(), ResultPtr, Offset, "uglygep");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">910</td>
    <td class="">  } else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">911</td>
    <td class="uncoveredLine">    isSwapCandidate = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">912</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">913</td>
    <td class="">  // If we created a GEP with constant index, and the base is loop invariant,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">914</td>
    <td class="">  // then we swap the first one with it, so LICM can move constant GEP out</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">915</td>
    <td class="">  // later.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">916</td>
    <td class="uncoveredLine">  auto *FirstGEP = dyn_cast_or_null<GetElementPtrInst>(FirstResult);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">917</td>
    <td class="uncoveredLine">  auto *SecondGEP = dyn_cast<GetElementPtrInst>(ResultPtr);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">918</td>
    <td class="uncoveredLine">  if (isSwapCandidate && isLegalToSwapOperand(FirstGEP, SecondGEP, L))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">919</td>
    <td class="uncoveredLine">    swapGEPOperand(FirstGEP, SecondGEP);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">920</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">921</td>
    <td class="uncoveredLine">  Variadic->replaceAllUsesWith(ResultPtr);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">922</td>
    <td class="uncoveredLine">  Variadic->eraseFromParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">923</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">924</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">925</td>
    <td class="">void</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">926</td>
    <td class="uncoveredLine">SeparateConstOffsetFromGEP::lowerToArithmetics(GetElementPtrInst *Variadic,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">927</td>
    <td class="">                                               int64_t AccumulativeByteOffset) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">928</td>
    <td class="uncoveredLine">  IRBuilder<> Builder(Variadic);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">929</td>
    <td class="uncoveredLine">  Type *IntPtrTy = DL->getIntPtrType(Variadic->getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">930</td>
    <td class="uncoveredLine">  assert(IntPtrTy == DL->getIndexType(Variadic->getType()) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">931</td>
    <td class="">         "Pointer type must match index type for arithmetic-based lowering of "</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">932</td>
    <td class="">         "split GEPs");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">933</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">934</td>
    <td class="uncoveredLine">  Value *ResultPtr = Builder.CreatePtrToInt(Variadic->getOperand(0), IntPtrTy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">935</td>
    <td class="uncoveredLine">  gep_type_iterator GTI = gep_type_begin(*Variadic);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">936</td>
    <td class="">  // Create ADD/SHL/MUL arithmetic operations for each sequential indices. We</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">937</td>
    <td class="">  // don't create arithmetics for structure indices, as they are accumulated</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">938</td>
    <td class="">  // in the constant offset index.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">939</td>
    <td class="uncoveredLine">  for (unsigned I = 1, E = Variadic->getNumOperands(); I != E; ++I, ++GTI) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">940</td>
    <td class="uncoveredLine">    if (GTI.isSequential()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">941</td>
    <td class="uncoveredLine">      Value *Idx = Variadic->getOperand(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">942</td>
    <td class="">      // Skip zero indices.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">943</td>
    <td class="uncoveredLine">      if (ConstantInt *CI = dyn_cast<ConstantInt>(Idx))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">944</td>
    <td class="uncoveredLine">        if (CI->isZero())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">945</td>
    <td class="uncoveredLine">          continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">946</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">947</td>
    <td class="">      APInt ElementSize = APInt(IntPtrTy->getIntegerBitWidth(),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">948</td>
    <td class="uncoveredLine">                                DL->getTypeAllocSize(GTI.getIndexedType()));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">949</td>
    <td class="">      // Scale the index by element size.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">950</td>
    <td class="uncoveredLine">      if (ElementSize != 1) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">951</td>
    <td class="uncoveredLine">        if (ElementSize.isPowerOf2()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">952</td>
    <td class="uncoveredLine">          Idx = Builder.CreateShl(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">953</td>
    <td class="uncoveredLine">              Idx, ConstantInt::get(IntPtrTy, ElementSize.logBase2()));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">954</td>
    <td class="">        } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">955</td>
    <td class="uncoveredLine">          Idx = Builder.CreateMul(Idx, ConstantInt::get(IntPtrTy, ElementSize));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">956</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">957</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">958</td>
    <td class="">      // Create an ADD for each index.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">959</td>
    <td class="uncoveredLine">      ResultPtr = Builder.CreateAdd(ResultPtr, Idx);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">960</td>
    <td class="uncoveredLine">    }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">961</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">962</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">963</td>
    <td class="">  // Create an ADD for the constant offset index.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">964</td>
    <td class="uncoveredLine">  if (AccumulativeByteOffset != 0) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">965</td>
    <td class="uncoveredLine">    ResultPtr = Builder.CreateAdd(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">966</td>
    <td class="uncoveredLine">        ResultPtr, ConstantInt::get(IntPtrTy, AccumulativeByteOffset));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">967</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">968</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">969</td>
    <td class="uncoveredLine">  ResultPtr = Builder.CreateIntToPtr(ResultPtr, Variadic->getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">970</td>
    <td class="uncoveredLine">  Variadic->replaceAllUsesWith(ResultPtr);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">971</td>
    <td class="uncoveredLine">  Variadic->eraseFromParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">972</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">973</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">974</td>
    <td class="uncoveredLine">bool SeparateConstOffsetFromGEP::splitGEP(GetElementPtrInst *GEP) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">975</td>
    <td class="">  // Skip vector GEPs.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">976</td>
    <td class="uncoveredLine">  if (GEP->getType()->isVectorTy())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">977</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">978</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">979</td>
    <td class="">  // The backend can already nicely handle the case where all indices are</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">980</td>
    <td class="">  // constant.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">981</td>
    <td class="uncoveredLine">  if (GEP->hasAllConstantIndices())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">982</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">983</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">984</td>
    <td class="uncoveredLine">  bool Changed = canonicalizeArrayIndicesToIndexSize(GEP);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">985</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">986</td>
    <td class="">  bool NeedsExtraction;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">987</td>
    <td class="uncoveredLine">  int64_t AccumulativeByteOffset = accumulateByteOffset(GEP, NeedsExtraction);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">988</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">989</td>
    <td class="uncoveredLine">  if (!NeedsExtraction)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">990</td>
    <td class="uncoveredLine">    return Changed;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">991</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">992</td>
    <td class="uncoveredLine">  TargetTransformInfo &TTI = GetTTI(*GEP->getFunction());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">993</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">994</td>
    <td class="">  // If LowerGEP is disabled, before really splitting the GEP, check whether the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">995</td>
    <td class="">  // backend supports the addressing mode we are about to produce. If no, this</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">996</td>
    <td class="">  // splitting probably won't be beneficial.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">997</td>
    <td class="">  // If LowerGEP is enabled, even the extracted constant offset can not match</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">998</td>
    <td class="">  // the addressing mode, we can still do optimizations to other lowered parts</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">999</td>
    <td class="">  // of variable indices. Therefore, we don't check for addressing modes in that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1000</td>
    <td class="">  // case.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1001</td>
    <td class="uncoveredLine">  if (!LowerGEP) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1002</td>
    <td class="uncoveredLine">    unsigned AddrSpace = GEP->getPointerAddressSpace();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1003</td>
    <td class="uncoveredLine">    if (!TTI.isLegalAddressingMode(GEP->getResultElementType(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1004</td>
    <td class="">                                   /*BaseGV=*/nullptr, AccumulativeByteOffset,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1005</td>
    <td class="">                                   /*HasBaseReg=*/true, /*Scale=*/0,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1006</td>
    <td class="">                                   AddrSpace)) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1007</td>
    <td class="uncoveredLine">      return Changed;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1008</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1009</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1010</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1011</td>
    <td class="">  // Remove the constant offset in each sequential index. The resultant GEP</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1012</td>
    <td class="">  // computes the variadic base.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1013</td>
    <td class="">  // Notice that we don't remove struct field indices here. If LowerGEP is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1014</td>
    <td class="">  // disabled, a structure index is not accumulated and we still use the old</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1015</td>
    <td class="">  // one. If LowerGEP is enabled, a structure index is accumulated in the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1016</td>
    <td class="">  // constant offset. LowerToSingleIndexGEPs or lowerToArithmetics will later</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1017</td>
    <td class="">  // handle the constant offset and won't need a new structure index.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1018</td>
    <td class="uncoveredLine">  gep_type_iterator GTI = gep_type_begin(*GEP);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1019</td>
    <td class="uncoveredLine">  for (unsigned I = 1, E = GEP->getNumOperands(); I != E; ++I, ++GTI) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1020</td>
    <td class="uncoveredLine">    if (GTI.isSequential()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1021</td>
    <td class="">      // Constant offsets of scalable types are not really constant.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1022</td>
    <td class="uncoveredLine">      if (isa<ScalableVectorType>(GTI.getIndexedType()))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1023</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1024</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1025</td>
    <td class="">      // Splits this GEP index into a variadic part and a constant offset, and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1026</td>
    <td class="">      // uses the variadic part as the new index.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1027</td>
    <td class="uncoveredLine">      Value *OldIdx = GEP->getOperand(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1028</td>
    <td class="">      User *UserChainTail;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1029</td>
    <td class="">      Value *NewIdx =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1030</td>
    <td class="uncoveredLine">          ConstantOffsetExtractor::Extract(OldIdx, GEP, UserChainTail, DT);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1031</td>
    <td class="uncoveredLine">      if (NewIdx != nullptr) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1032</td>
    <td class="">        // Switches to the index with the constant offset removed.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1033</td>
    <td class="uncoveredLine">        GEP->setOperand(I, NewIdx);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1034</td>
    <td class="">        // After switching to the new index, we can garbage-collect UserChain</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1035</td>
    <td class="">        // and the old index if they are not used.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1036</td>
    <td class="uncoveredLine">        RecursivelyDeleteTriviallyDeadInstructions(UserChainTail);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1037</td>
    <td class="uncoveredLine">        RecursivelyDeleteTriviallyDeadInstructions(OldIdx);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1038</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1039</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1040</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1041</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1042</td>
    <td class="">  // Clear the inbounds attribute because the new index may be off-bound.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1043</td>
    <td class="">  // e.g.,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1044</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1045</td>
    <td class="">  //   b     = add i64 a, 5</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1046</td>
    <td class="">  //   addr  = gep inbounds float, float* p, i64 b</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1047</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1048</td>
    <td class="">  // is transformed to:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1049</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1050</td>
    <td class="">  //   addr2 = gep float, float* p, i64 a ; inbounds removed</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1051</td>
    <td class="">  //   addr  = gep inbounds float, float* addr2, i64 5</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1052</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1053</td>
    <td class="">  // If a is -4, although the old index b is in bounds, the new index a is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1054</td>
    <td class="">  // off-bound. http://llvm.org/docs/LangRef.html#id181 says "if the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1055</td>
    <td class="">  // inbounds keyword is not present, the offsets are added to the base</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1056</td>
    <td class="">  // address with silently-wrapping two's complement arithmetic".</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1057</td>
    <td class="">  // Therefore, the final code will be a semantically equivalent.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1058</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1059</td>
    <td class="">  // TODO(jingyue): do some range analysis to keep as many inbounds as</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1060</td>
    <td class="">  // possible. GEPs with inbounds are more friendly to alias analysis.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1061</td>
    <td class="uncoveredLine">  bool GEPWasInBounds = GEP->isInBounds();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1062</td>
    <td class="uncoveredLine">  GEP->setIsInBounds(false);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1063</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1064</td>
    <td class="">  // Lowers a GEP to either GEPs with a single index or arithmetic operations.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1065</td>
    <td class="uncoveredLine">  if (LowerGEP) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1066</td>
    <td class="">    // As currently BasicAA does not analyze ptrtoint/inttoptr, do not lower to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1067</td>
    <td class="">    // arithmetic operations if the target uses alias analysis in codegen.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1068</td>
    <td class="">    // Additionally, pointers that aren't integral (and so can't be safely</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1069</td>
    <td class="">    // converted to integers) or those whose offset size is different from their</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1070</td>
    <td class="">    // pointer size (which means that doing integer arithmetic on them could</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1071</td>
    <td class="">    // affect that data) can't be lowered in this way.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1072</td>
    <td class="uncoveredLine">    unsigned AddrSpace = GEP->getPointerAddressSpace();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1073</td>
    <td class="uncoveredLine">    bool PointerHasExtraData = DL->getPointerSizeInBits(AddrSpace) !=</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1074</td>
    <td class="uncoveredLine">                               DL->getIndexSizeInBits(AddrSpace);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1075</td>
    <td class="uncoveredLine">    if (TTI.useAA() || DL->isNonIntegralAddressSpace(AddrSpace) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1076</td>
    <td class="">        PointerHasExtraData)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1077</td>
    <td class="uncoveredLine">      lowerToSingleIndexGEPs(GEP, AccumulativeByteOffset);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1078</td>
    <td class="">    else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1079</td>
    <td class="uncoveredLine">      lowerToArithmetics(GEP, AccumulativeByteOffset);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1080</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1081</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1082</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1083</td>
    <td class="">  // No need to create another GEP if the accumulative byte offset is 0.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1084</td>
    <td class="uncoveredLine">  if (AccumulativeByteOffset == 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1085</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1086</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1087</td>
    <td class="">  // Offsets the base with the accumulative byte offset.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1088</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1089</td>
    <td class="">  //   %gep                        ; the base</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1090</td>
    <td class="">  //   ... %gep ...</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1091</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1092</td>
    <td class="">  // => add the offset</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1093</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1094</td>
    <td class="">  //   %gep2                       ; clone of %gep</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1095</td>
    <td class="">  //   %new.gep = gep %gep2, <offset / sizeof(*%gep)></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1096</td>
    <td class="">  //   %gep                        ; will be removed</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1097</td>
    <td class="">  //   ... %gep ...</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1098</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1099</td>
    <td class="">  // => replace all uses of %gep with %new.gep and remove %gep</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1100</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1101</td>
    <td class="">  //   %gep2                       ; clone of %gep</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1102</td>
    <td class="">  //   %new.gep = gep %gep2, <offset / sizeof(*%gep)></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1103</td>
    <td class="">  //   ... %new.gep ...</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1104</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1105</td>
    <td class="">  // If AccumulativeByteOffset is not a multiple of sizeof(*%gep), we emit an</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1106</td>
    <td class="">  // uglygep (http://llvm.org/docs/GetElementPtr.html#what-s-an-uglygep):</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1107</td>
    <td class="">  // bitcast %gep2 to i8*, add the offset, and bitcast the result back to the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1108</td>
    <td class="">  // type of %gep.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1109</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1110</td>
    <td class="">  //   %gep2                       ; clone of %gep</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1111</td>
    <td class="">  //   %0       = bitcast %gep2 to i8*</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1112</td>
    <td class="">  //   %uglygep = gep %0, <offset></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1113</td>
    <td class="">  //   %new.gep = bitcast %uglygep to <type of %gep></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1114</td>
    <td class="">  //   ... %new.gep ...</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1115</td>
    <td class="uncoveredLine">  Instruction *NewGEP = GEP->clone();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1116</td>
    <td class="uncoveredLine">  NewGEP->insertBefore(GEP);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1117</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1118</td>
    <td class="">  // Per ANSI C standard, signed / unsigned = unsigned and signed % unsigned =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1119</td>
    <td class="">  // unsigned.. Therefore, we cast ElementTypeSizeOfGEP to signed because it is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1120</td>
    <td class="">  // used with unsigned integers later.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1121</td>
    <td class="">  int64_t ElementTypeSizeOfGEP = static_cast<int64_t>(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1122</td>
    <td class="uncoveredLine">      DL->getTypeAllocSize(GEP->getResultElementType()));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1123</td>
    <td class="uncoveredLine">  Type *PtrIdxTy = DL->getIndexType(GEP->getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1124</td>
    <td class="uncoveredLine">  if (AccumulativeByteOffset % ElementTypeSizeOfGEP == 0) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1125</td>
    <td class="">    // Very likely. As long as %gep is naturally aligned, the byte offset we</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1126</td>
    <td class="">    // extracted should be a multiple of sizeof(*%gep).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1127</td>
    <td class="uncoveredLine">    int64_t Index = AccumulativeByteOffset / ElementTypeSizeOfGEP;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1128</td>
    <td class="uncoveredLine">    NewGEP = GetElementPtrInst::Create(GEP->getResultElementType(), NewGEP,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1129</td>
    <td class="uncoveredLine">                                       ConstantInt::get(PtrIdxTy, Index, true),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1130</td>
    <td class="uncoveredLine">                                       GEP->getName(), GEP);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1131</td>
    <td class="uncoveredLine">    NewGEP->copyMetadata(*GEP);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1132</td>
    <td class="">    // Inherit the inbounds attribute of the original GEP.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1133</td>
    <td class="uncoveredLine">    cast<GetElementPtrInst>(NewGEP)->setIsInBounds(GEPWasInBounds);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1134</td>
    <td class="">  } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1135</td>
    <td class="">    // Unlikely but possible. For example,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1136</td>
    <td class="">    // #pragma pack(1)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1137</td>
    <td class="">    // struct S {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1138</td>
    <td class="">    //   int a[3];</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1139</td>
    <td class="">    //   int64 b[8];</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1140</td>
    <td class="">    // };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1141</td>
    <td class="">    // #pragma pack()</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1142</td>
    <td class="">    //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1143</td>
    <td class="">    // Suppose the gep before extraction is &s[i + 1].b[j + 3]. After</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1144</td>
    <td class="">    // extraction, it becomes &s[i].b[j] and AccumulativeByteOffset is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1145</td>
    <td class="">    // sizeof(S) + 3 * sizeof(int64) = 100, which is not a multiple of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1146</td>
    <td class="">    // sizeof(int64).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1147</td>
    <td class="">    //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1148</td>
    <td class="">    // Emit an uglygep in this case.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1149</td>
    <td class="uncoveredLine">    IRBuilder<> Builder(GEP);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1150</td>
    <td class="uncoveredLine">    NewGEP = cast<Instruction>(Builder.CreateGEP(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1151</td>
    <td class="uncoveredLine">        Builder.getInt8Ty(), NewGEP,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1152</td>
    <td class="uncoveredLine">        {ConstantInt::get(PtrIdxTy, AccumulativeByteOffset, true)}, "uglygep",</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1153</td>
    <td class="">        GEPWasInBounds));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1154</td>
    <td class="uncoveredLine">    NewGEP->copyMetadata(*GEP);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1155</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1156</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1157</td>
    <td class="uncoveredLine">  GEP->replaceAllUsesWith(NewGEP);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1158</td>
    <td class="uncoveredLine">  GEP->eraseFromParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1159</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1160</td>
    <td class="uncoveredLine">  return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1161</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1162</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1163</td>
    <td class="uncoveredLine">bool SeparateConstOffsetFromGEPLegacyPass::runOnFunction(Function &F) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1164</td>
    <td class="uncoveredLine">  if (skipFunction(F))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1165</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1166</td>
    <td class="uncoveredLine">  auto *DT = &getAnalysis<DominatorTreeWrapperPass>().getDomTree();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1167</td>
    <td class="uncoveredLine">  auto *LI = &getAnalysis<LoopInfoWrapperPass>().getLoopInfo();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1168</td>
    <td class="uncoveredLine">  auto *TLI = &getAnalysis<TargetLibraryInfoWrapperPass>().getTLI(F);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1169</td>
    <td class="uncoveredLine">  auto GetTTI = [this](Function &F) -> TargetTransformInfo & {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1170</td>
    <td class="uncoveredLine">    return this->getAnalysis<TargetTransformInfoWrapperPass>().getTTI(F);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1171</td>
    <td class="uncoveredLine">  };</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1172</td>
    <td class="uncoveredLine">  SeparateConstOffsetFromGEP Impl(DT, LI, TLI, GetTTI, LowerGEP);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1173</td>
    <td class="uncoveredLine">  return Impl.run(F);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1174</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1175</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1176</td>
    <td class="uncoveredLine">bool SeparateConstOffsetFromGEP::run(Function &F) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1177</td>
    <td class="uncoveredLine">  if (DisableSeparateConstOffsetFromGEP)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1178</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1179</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1180</td>
    <td class="uncoveredLine">  DL = &F.getParent()->getDataLayout();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1181</td>
    <td class="uncoveredLine">  bool Changed = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1182</td>
    <td class="uncoveredLine">  for (BasicBlock &B : F) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1183</td>
    <td class="uncoveredLine">    if (!DT->isReachableFromEntry(&B))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1184</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1185</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1186</td>
    <td class="uncoveredLine">    for (Instruction &I : llvm::make_early_inc_range(B))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1187</td>
    <td class="uncoveredLine">      if (GetElementPtrInst *GEP = dyn_cast<GetElementPtrInst>(&I))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1188</td>
    <td class="uncoveredLine">        Changed |= splitGEP(GEP);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1189</td>
    <td class="">    // No need to split GEP ConstantExprs because all its indices are constant</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1190</td>
    <td class="">    // already.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1191</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1192</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1193</td>
    <td class="uncoveredLine">  Changed |= reuniteExts(F);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1194</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1195</td>
    <td class="uncoveredLine">  if (VerifyNoDeadCode)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1196</td>
    <td class="uncoveredLine">    verifyNoDeadCode(F);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1197</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1198</td>
    <td class="uncoveredLine">  return Changed;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1199</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1200</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1201</td>
    <td class="uncoveredLine">Instruction *SeparateConstOffsetFromGEP::findClosestMatchingDominator(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1202</td>
    <td class="">    ExprKey Key, Instruction *Dominatee,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1203</td>
    <td class="">    DenseMap<ExprKey, SmallVector<Instruction *, 2>> &DominatingExprs) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1204</td>
    <td class="uncoveredLine">  auto Pos = DominatingExprs.find(Key);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1205</td>
    <td class="uncoveredLine">  if (Pos == DominatingExprs.end())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1206</td>
    <td class="uncoveredLine">    return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1207</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1208</td>
    <td class="uncoveredLine">  auto &Candidates = Pos->second;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1209</td>
    <td class="">  // Because we process the basic blocks in pre-order of the dominator tree, a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1210</td>
    <td class="">  // candidate that doesn't dominate the current instruction won't dominate any</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1211</td>
    <td class="">  // future instruction either. Therefore, we pop it out of the stack. This</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1212</td>
    <td class="">  // optimization makes the algorithm O(n).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1213</td>
    <td class="uncoveredLine">  while (!Candidates.empty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1214</td>
    <td class="uncoveredLine">    Instruction *Candidate = Candidates.back();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1215</td>
    <td class="uncoveredLine">    if (DT->dominates(Candidate, Dominatee))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1216</td>
    <td class="uncoveredLine">      return Candidate;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1217</td>
    <td class="uncoveredLine">    Candidates.pop_back();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1218</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1219</td>
    <td class="uncoveredLine">  return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1220</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1221</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1222</td>
    <td class="uncoveredLine">bool SeparateConstOffsetFromGEP::reuniteExts(Instruction *I) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1223</td>
    <td class="uncoveredLine">  if (!I->getType()->isIntOrIntVectorTy())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1224</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1225</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1226</td>
    <td class="">  //   Dom: LHS+RHS</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1227</td>
    <td class="">  //   I: sext(LHS)+sext(RHS)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1228</td>
    <td class="">  // If Dom can't sign overflow and Dom dominates I, optimize I to sext(Dom).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1229</td>
    <td class="">  // TODO: handle zext</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1230</td>
    <td class="uncoveredLine">  Value *LHS = nullptr, *RHS = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1231</td>
    <td class="uncoveredLine">  if (match(I, m_Add(m_SExt(m_Value(LHS)), m_SExt(m_Value(RHS))))) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1232</td>
    <td class="uncoveredLine">    if (LHS->getType() == RHS->getType()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1233</td>
    <td class="uncoveredLine">      ExprKey Key = createNormalizedCommutablePair(LHS, RHS);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1234</td>
    <td class="uncoveredLine">      if (auto *Dom = findClosestMatchingDominator(Key, I, DominatingAdds)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1235</td>
    <td class="uncoveredLine">        Instruction *NewSExt = new SExtInst(Dom, I->getType(), "", I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1236</td>
    <td class="uncoveredLine">        NewSExt->takeName(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1237</td>
    <td class="uncoveredLine">        I->replaceAllUsesWith(NewSExt);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1238</td>
    <td class="uncoveredLine">        RecursivelyDeleteTriviallyDeadInstructions(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1239</td>
    <td class="uncoveredLine">        return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1240</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1241</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1242</td>
    <td class="uncoveredLine">  } else if (match(I, m_Sub(m_SExt(m_Value(LHS)), m_SExt(m_Value(RHS))))) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1243</td>
    <td class="uncoveredLine">    if (LHS->getType() == RHS->getType()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1244</td>
    <td class="uncoveredLine">      if (auto *Dom =</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1245</td>
    <td class="uncoveredLine">              findClosestMatchingDominator({LHS, RHS}, I, DominatingSubs)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1246</td>
    <td class="uncoveredLine">        Instruction *NewSExt = new SExtInst(Dom, I->getType(), "", I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1247</td>
    <td class="uncoveredLine">        NewSExt->takeName(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1248</td>
    <td class="uncoveredLine">        I->replaceAllUsesWith(NewSExt);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1249</td>
    <td class="uncoveredLine">        RecursivelyDeleteTriviallyDeadInstructions(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1250</td>
    <td class="uncoveredLine">        return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1251</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1252</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1253</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1254</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1255</td>
    <td class="">  // Add I to DominatingExprs if it's an add/sub that can't sign overflow.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1256</td>
    <td class="uncoveredLine">  if (match(I, m_NSWAdd(m_Value(LHS), m_Value(RHS)))) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1257</td>
    <td class="uncoveredLine">    if (programUndefinedIfPoison(I)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1258</td>
    <td class="uncoveredLine">      ExprKey Key = createNormalizedCommutablePair(LHS, RHS);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1259</td>
    <td class="uncoveredLine">      DominatingAdds[Key].push_back(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1260</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1261</td>
    <td class="uncoveredLine">  } else if (match(I, m_NSWSub(m_Value(LHS), m_Value(RHS)))) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1262</td>
    <td class="uncoveredLine">    if (programUndefinedIfPoison(I))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1263</td>
    <td class="uncoveredLine">      DominatingSubs[{LHS, RHS}].push_back(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1264</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1265</td>
    <td class="uncoveredLine">  return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1266</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1267</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1268</td>
    <td class="uncoveredLine">bool SeparateConstOffsetFromGEP::reuniteExts(Function &F) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1269</td>
    <td class="uncoveredLine">  bool Changed = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1270</td>
    <td class="uncoveredLine">  DominatingAdds.clear();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1271</td>
    <td class="uncoveredLine">  DominatingSubs.clear();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1272</td>
    <td class="uncoveredLine">  for (const auto Node : depth_first(DT)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1273</td>
    <td class="uncoveredLine">    BasicBlock *BB = Node->getBlock();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1274</td>
    <td class="uncoveredLine">    for (Instruction &I : llvm::make_early_inc_range(*BB))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1275</td>
    <td class="uncoveredLine">      Changed |= reuniteExts(&I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1276</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1277</td>
    <td class="uncoveredLine">  return Changed;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1278</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1279</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1280</td>
    <td class="uncoveredLine">void SeparateConstOffsetFromGEP::verifyNoDeadCode(Function &F) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1281</td>
    <td class="uncoveredLine">  for (BasicBlock &B : F) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1282</td>
    <td class="uncoveredLine">    for (Instruction &I : B) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1283</td>
    <td class="uncoveredLine">      if (isInstructionTriviallyDead(&I)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1284</td>
    <td class="uncoveredLine">        std::string ErrMessage;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1285</td>
    <td class="uncoveredLine">        raw_string_ostream RSO(ErrMessage);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1286</td>
    <td class="uncoveredLine">        RSO << "Dead instruction detected!\n" << I << "\n";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1287</td>
    <td class="uncoveredLine">        llvm_unreachable(RSO.str().c_str());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1288</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1289</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1290</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1291</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1292</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1293</td>
    <td class="uncoveredLine">bool SeparateConstOffsetFromGEP::isLegalToSwapOperand(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1294</td>
    <td class="">    GetElementPtrInst *FirstGEP, GetElementPtrInst *SecondGEP, Loop *CurLoop) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1295</td>
    <td class="uncoveredLine">  if (!FirstGEP || !FirstGEP->hasOneUse())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1296</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1297</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1298</td>
    <td class="uncoveredLine">  if (!SecondGEP || FirstGEP->getParent() != SecondGEP->getParent())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1299</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1300</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1301</td>
    <td class="uncoveredLine">  if (FirstGEP == SecondGEP)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1302</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1303</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1304</td>
    <td class="uncoveredLine">  unsigned FirstNum = FirstGEP->getNumOperands();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1305</td>
    <td class="uncoveredLine">  unsigned SecondNum = SecondGEP->getNumOperands();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1306</td>
    <td class="">  // Give up if the number of operands are not 2.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1307</td>
    <td class="uncoveredLine">  if (FirstNum != SecondNum || FirstNum != 2)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1308</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1309</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1310</td>
    <td class="uncoveredLine">  Value *FirstBase = FirstGEP->getOperand(0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1311</td>
    <td class="uncoveredLine">  Value *SecondBase = SecondGEP->getOperand(0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1312</td>
    <td class="uncoveredLine">  Value *FirstOffset = FirstGEP->getOperand(1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1313</td>
    <td class="">  // Give up if the index of the first GEP is loop invariant.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1314</td>
    <td class="uncoveredLine">  if (CurLoop->isLoopInvariant(FirstOffset))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1315</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1316</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1317</td>
    <td class="">  // Give up if base doesn't have same type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1318</td>
    <td class="uncoveredLine">  if (FirstBase->getType() != SecondBase->getType())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1319</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1320</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1321</td>
    <td class="uncoveredLine">  Instruction *FirstOffsetDef = dyn_cast<Instruction>(FirstOffset);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1322</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1323</td>
    <td class="">  // Check if the second operand of first GEP has constant coefficient.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1324</td>
    <td class="">  // For an example, for the following code,  we won't gain anything by</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1325</td>
    <td class="">  // hoisting the second GEP out because the second GEP can be folded away.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1326</td>
    <td class="">  //   %scevgep.sum.ur159 = add i64 %idxprom48.ur, 256</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1327</td>
    <td class="">  //   %67 = shl i64 %scevgep.sum.ur159, 2</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1328</td>
    <td class="">  //   %uglygep160 = getelementptr i8* %65, i64 %67</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1329</td>
    <td class="">  //   %uglygep161 = getelementptr i8* %uglygep160, i64 -1024</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1330</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1331</td>
    <td class="">  // Skip constant shift instruction which may be generated by Splitting GEPs.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1332</td>
    <td class="uncoveredLine">  if (FirstOffsetDef && FirstOffsetDef->isShift() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1333</td>
    <td class="uncoveredLine">      isa<ConstantInt>(FirstOffsetDef->getOperand(1)))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1334</td>
    <td class="uncoveredLine">    FirstOffsetDef = dyn_cast<Instruction>(FirstOffsetDef->getOperand(0));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1335</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1336</td>
    <td class="">  // Give up if FirstOffsetDef is an Add or Sub with constant.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1337</td>
    <td class="">  // Because it may not profitable at all due to constant folding.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1338</td>
    <td class="uncoveredLine">  if (FirstOffsetDef)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1339</td>
    <td class="uncoveredLine">    if (BinaryOperator *BO = dyn_cast<BinaryOperator>(FirstOffsetDef)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1340</td>
    <td class="uncoveredLine">      unsigned opc = BO->getOpcode();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1341</td>
    <td class="uncoveredLine">      if ((opc == Instruction::Add || opc == Instruction::Sub) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1342</td>
    <td class="uncoveredLine">          (isa<ConstantInt>(BO->getOperand(0)) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1343</td>
    <td class="uncoveredLine">           isa<ConstantInt>(BO->getOperand(1))))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1344</td>
    <td class="uncoveredLine">        return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1345</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1346</td>
    <td class="uncoveredLine">  return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1347</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1348</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1349</td>
    <td class="uncoveredLine">bool SeparateConstOffsetFromGEP::hasMoreThanOneUseInLoop(Value *V, Loop *L) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1350</td>
    <td class="uncoveredLine">  int UsesInLoop = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1351</td>
    <td class="uncoveredLine">  for (User *U : V->users()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1352</td>
    <td class="uncoveredLine">    if (Instruction *User = dyn_cast<Instruction>(U))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1353</td>
    <td class="uncoveredLine">      if (L->contains(User))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1354</td>
    <td class="uncoveredLine">        if (++UsesInLoop > 1)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1355</td>
    <td class="uncoveredLine">          return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1356</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1357</td>
    <td class="uncoveredLine">  return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1358</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1359</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1360</td>
    <td class="uncoveredLine">void SeparateConstOffsetFromGEP::swapGEPOperand(GetElementPtrInst *First,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1361</td>
    <td class="">                                                GetElementPtrInst *Second) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1362</td>
    <td class="uncoveredLine">  Value *Offset1 = First->getOperand(1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1363</td>
    <td class="uncoveredLine">  Value *Offset2 = Second->getOperand(1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1364</td>
    <td class="uncoveredLine">  First->setOperand(1, Offset2);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1365</td>
    <td class="uncoveredLine">  Second->setOperand(1, Offset1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1366</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1367</td>
    <td class="">  // We changed p+o+c to p+c+o, p+c may not be inbound anymore.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1368</td>
    <td class="uncoveredLine">  const DataLayout &DAL = First->getModule()->getDataLayout();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1369</td>
    <td class="">  APInt Offset(DAL.getIndexSizeInBits(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1370</td>
    <td class="">                   cast<PointerType>(First->getType())->getAddressSpace()),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1371</td>
    <td class="uncoveredLine">               0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1372</td>
    <td class="">  Value *NewBase =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1373</td>
    <td class="uncoveredLine">      First->stripAndAccumulateInBoundsConstantOffsets(DAL, Offset);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1374</td>
    <td class="">  uint64_t ObjectSize;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1375</td>
    <td class="uncoveredLine">  if (!getObjectSize(NewBase, ObjectSize, DAL, TLI) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1376</td>
    <td class="uncoveredLine">     Offset.ugt(ObjectSize)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1377</td>
    <td class="uncoveredLine">    First->setIsInBounds(false);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1378</td>
    <td class="uncoveredLine">    Second->setIsInBounds(false);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1379</td>
    <td class="">  } else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1380</td>
    <td class="uncoveredLine">    First->setIsInBounds(true);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1381</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1382</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1383</td>
    <td class="uncoveredLine">void SeparateConstOffsetFromGEPPass::printPipeline(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1384</td>
    <td class="">    raw_ostream &OS, function_ref<StringRef(StringRef)> MapClassName2PassName) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1385</td>
    <td class="">  static_cast<PassInfoMixin<SeparateConstOffsetFromGEPPass> *>(this)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1386</td>
    <td class="uncoveredLine">      ->printPipeline(OS, MapClassName2PassName);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1387</td>
    <td class="uncoveredLine">  OS << '<';</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1388</td>
    <td class="uncoveredLine">  if (LowerGEP)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1389</td>
    <td class="uncoveredLine">    OS << "lower-gep";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1390</td>
    <td class="uncoveredLine">  OS << '>';</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1391</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1392</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1393</td>
    <td class="">PreservedAnalyses</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1394</td>
    <td class="uncoveredLine">SeparateConstOffsetFromGEPPass::run(Function &F, FunctionAnalysisManager &AM) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1395</td>
    <td class="uncoveredLine">  auto *DT = &AM.getResult<DominatorTreeAnalysis>(F);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1396</td>
    <td class="uncoveredLine">  auto *LI = &AM.getResult<LoopAnalysis>(F);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1397</td>
    <td class="uncoveredLine">  auto *TLI = &AM.getResult<TargetLibraryAnalysis>(F);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1398</td>
    <td class="uncoveredLine">  auto GetTTI = [&AM](Function &F) -> TargetTransformInfo & {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1399</td>
    <td class="uncoveredLine">    return AM.getResult<TargetIRAnalysis>(F);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1400</td>
    <td class="uncoveredLine">  };</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1401</td>
    <td class="uncoveredLine">  SeparateConstOffsetFromGEP Impl(DT, LI, TLI, GetTTI, LowerGEP);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1402</td>
    <td class="uncoveredLine">  if (!Impl.run(F))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1403</td>
    <td class="uncoveredLine">    return PreservedAnalyses::all();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1404</td>
    <td class="uncoveredLine">  PreservedAnalyses PA;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1405</td>
    <td class="uncoveredLine">  PA.preserveSet<CFGAnalyses>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1406</td>
    <td class="uncoveredLine">  return PA;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1407</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1408</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Functions Report</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Functions Report</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Function name</th>
    <th class="mainTh">Number of hits</th>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_123ConstantOffsetExtractorC2EPN4llvm11InstructionEPKNS1_13DominatorTreeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_136SeparateConstOffsetFromGEPLegacyPassC2Eb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_136SeparateConstOffsetFromGEPLegacyPass16getAnalysisUsageERN4llvm13AnalysisUsageE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_126SeparateConstOffsetFromGEPC2EPN4llvm13DominatorTreeEPNS1_8LoopInfoEPNS1_17TargetLibraryInfoENS1_12function_refIFRNS1_19TargetTransformInfoERNS1_8FunctionEEEEb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_126SeparateConstOffsetFromGEP30createNormalizedCommutablePairEPN4llvm5ValueES3_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL54initializeSeparateConstOffsetFromGEPLegacyPassPassOnceRN4llvm12PassRegistryE</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm50initializeSeparateConstOffsetFromGEPLegacyPassPassERNS_12PassRegistryE</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm36createSeparateConstOffsetFromGEPPassEb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_123ConstantOffsetExtractor12CanTraceIntoEbbPN4llvm14BinaryOperatorEb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_123ConstantOffsetExtractor19findInEitherOperandEPN4llvm14BinaryOperatorEbb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_123ConstantOffsetExtractor4findEPN4llvm5ValueEbbb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_123ConstantOffsetExtractor9applyExtsEPN4llvm5ValueE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_123ConstantOffsetExtractor25rebuildWithoutConstOffsetEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_123ConstantOffsetExtractor27distributeExtsAndCloneChainEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_123ConstantOffsetExtractor17removeConstOffsetEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_123ConstantOffsetExtractor7ExtractEPN4llvm5ValueEPNS1_17GetElementPtrInstERPNS1_4UserEPKNS1_13DominatorTreeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_123ConstantOffsetExtractor4FindEPN4llvm5ValueEPNS1_17GetElementPtrInstEPKNS1_13DominatorTreeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_126SeparateConstOffsetFromGEP35canonicalizeArrayIndicesToIndexSizeEPN4llvm17GetElementPtrInstE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_126SeparateConstOffsetFromGEP20accumulateByteOffsetEPN4llvm17GetElementPtrInstERb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_126SeparateConstOffsetFromGEP22lowerToSingleIndexGEPsEPN4llvm17GetElementPtrInstEl</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_126SeparateConstOffsetFromGEP18lowerToArithmeticsEPN4llvm17GetElementPtrInstEl</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_126SeparateConstOffsetFromGEP8splitGEPEPN4llvm17GetElementPtrInstE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_136SeparateConstOffsetFromGEPLegacyPass13runOnFunctionERN4llvm8FunctionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN12_GLOBAL__N_136SeparateConstOffsetFromGEPLegacyPass13runOnFunctionERN4llvm8FunctionEENKUlS3_E_clES3_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_126SeparateConstOffsetFromGEP3runERN4llvm8FunctionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_126SeparateConstOffsetFromGEP28findClosestMatchingDominatorESt4pairIPN4llvm5ValueES4_EPNS2_11InstructionERNS2_8DenseMapIS5_NS2_11SmallVectorIS7_Lj2EEENS2_12DenseMapInfoIS5_vEENS2_6detail12DenseMapPairIS5_SA_EEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_126SeparateConstOffsetFromGEP11reuniteExtsEPN4llvm11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_126SeparateConstOffsetFromGEP11reuniteExtsERN4llvm8FunctionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_126SeparateConstOffsetFromGEP16verifyNoDeadCodeERN4llvm8FunctionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_126SeparateConstOffsetFromGEP20isLegalToSwapOperandEPN4llvm17GetElementPtrInstES3_PNS1_4LoopE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_126SeparateConstOffsetFromGEP23hasMoreThanOneUseInLoopEPN4llvm5ValueEPNS1_4LoopE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_126SeparateConstOffsetFromGEP14swapGEPOperandEPN4llvm17GetElementPtrInstES3_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm30SeparateConstOffsetFromGEPPass13printPipelineERNS_11raw_ostreamENS_12function_refIFNS_9StringRefES4_EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm30SeparateConstOffsetFromGEPPass3runERNS_8FunctionERNS_15AnalysisManagerIS1_JEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN4llvm30SeparateConstOffsetFromGEPPass3runERNS_8FunctionERNS_15AnalysisManagerIS1_JEEEENKUlS2_E_clES2_</td>
    <td class="numberOfCalls">0</td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Coverage Diff</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Coverage Diff</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span> BUT NOT </span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </th>
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
      <span> BUT NOT </span>
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="codeline">//===- SeparateConstOffsetFromGEP.cpp -------------------------------------===//</td>
    <td class="lineNumber">1</td>
    <td class="codeline">//===- SeparateConstOffsetFromGEP.cpp -------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="codeline">//</td>
    <td class="lineNumber">2</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="codeline">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">3</td>
    <td class="codeline">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="codeline">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">4</td>
    <td class="codeline">// See https://llvm.org/LICENSE.txt for license information.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="codeline">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">5</td>
    <td class="codeline">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="codeline">//</td>
    <td class="lineNumber">6</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">7</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="codeline">//</td>
    <td class="lineNumber">8</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="codeline">// Loop unrolling may create many similar GEPs for array accesses.</td>
    <td class="lineNumber">9</td>
    <td class="codeline">// Loop unrolling may create many similar GEPs for array accesses.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="codeline">// e.g., a 2-level loop</td>
    <td class="lineNumber">10</td>
    <td class="codeline">// e.g., a 2-level loop</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="codeline">//</td>
    <td class="lineNumber">11</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="codeline">// float a[32][32]; // global variable</td>
    <td class="lineNumber">12</td>
    <td class="codeline">// float a[32][32]; // global variable</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="codeline">//</td>
    <td class="lineNumber">13</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="codeline">// for (int i = 0; i < 2; ++i) {</td>
    <td class="lineNumber">14</td>
    <td class="codeline">// for (int i = 0; i < 2; ++i) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="codeline">//   for (int j = 0; j < 2; ++j) {</td>
    <td class="lineNumber">15</td>
    <td class="codeline">//   for (int j = 0; j < 2; ++j) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="codeline">//     ...</td>
    <td class="lineNumber">16</td>
    <td class="codeline">//     ...</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="codeline">//     ... = a[x + i][y + j];</td>
    <td class="lineNumber">17</td>
    <td class="codeline">//     ... = a[x + i][y + j];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="codeline">//     ...</td>
    <td class="lineNumber">18</td>
    <td class="codeline">//     ...</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="codeline">//   }</td>
    <td class="lineNumber">19</td>
    <td class="codeline">//   }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="codeline">// }</td>
    <td class="lineNumber">20</td>
    <td class="codeline">// }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="codeline">//</td>
    <td class="lineNumber">21</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="codeline">// will probably be unrolled to:</td>
    <td class="lineNumber">22</td>
    <td class="codeline">// will probably be unrolled to:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="codeline">//</td>
    <td class="lineNumber">23</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="codeline">// gep %a, 0, %x, %y; load</td>
    <td class="lineNumber">24</td>
    <td class="codeline">// gep %a, 0, %x, %y; load</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="codeline">// gep %a, 0, %x, %y + 1; load</td>
    <td class="lineNumber">25</td>
    <td class="codeline">// gep %a, 0, %x, %y + 1; load</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="codeline">// gep %a, 0, %x + 1, %y; load</td>
    <td class="lineNumber">26</td>
    <td class="codeline">// gep %a, 0, %x + 1, %y; load</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="codeline">// gep %a, 0, %x + 1, %y + 1; load</td>
    <td class="lineNumber">27</td>
    <td class="codeline">// gep %a, 0, %x + 1, %y + 1; load</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="codeline">//</td>
    <td class="lineNumber">28</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="codeline">// LLVM's GVN does not use partial redundancy elimination yet, and is thus</td>
    <td class="lineNumber">29</td>
    <td class="codeline">// LLVM's GVN does not use partial redundancy elimination yet, and is thus</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="codeline">// unable to reuse (gep %a, 0, %x, %y). As a result, this misoptimization incurs</td>
    <td class="lineNumber">30</td>
    <td class="codeline">// unable to reuse (gep %a, 0, %x, %y). As a result, this misoptimization incurs</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="codeline">// significant slowdown in targets with limited addressing modes. For instance,</td>
    <td class="lineNumber">31</td>
    <td class="codeline">// significant slowdown in targets with limited addressing modes. For instance,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="codeline">// because the PTX target does not support the reg+reg addressing mode, the</td>
    <td class="lineNumber">32</td>
    <td class="codeline">// because the PTX target does not support the reg+reg addressing mode, the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="codeline">// NVPTX backend emits PTX code that literally computes the pointer address of</td>
    <td class="lineNumber">33</td>
    <td class="codeline">// NVPTX backend emits PTX code that literally computes the pointer address of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="codeline">// each GEP, wasting tons of registers. It emits the following PTX for the</td>
    <td class="lineNumber">34</td>
    <td class="codeline">// each GEP, wasting tons of registers. It emits the following PTX for the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="codeline">// first load and similar PTX for other loads.</td>
    <td class="lineNumber">35</td>
    <td class="codeline">// first load and similar PTX for other loads.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="codeline">//</td>
    <td class="lineNumber">36</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="codeline">// mov.u32         %r1, %x;</td>
    <td class="lineNumber">37</td>
    <td class="codeline">// mov.u32         %r1, %x;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="codeline">// mov.u32         %r2, %y;</td>
    <td class="lineNumber">38</td>
    <td class="codeline">// mov.u32         %r2, %y;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="codeline">// mul.wide.u32    %rl2, %r1, 128;</td>
    <td class="lineNumber">39</td>
    <td class="codeline">// mul.wide.u32    %rl2, %r1, 128;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="codeline">// mov.u64         %rl3, a;</td>
    <td class="lineNumber">40</td>
    <td class="codeline">// mov.u64         %rl3, a;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="codeline">// add.s64         %rl4, %rl3, %rl2;</td>
    <td class="lineNumber">41</td>
    <td class="codeline">// add.s64         %rl4, %rl3, %rl2;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="codeline">// mul.wide.u32    %rl5, %r2, 4;</td>
    <td class="lineNumber">42</td>
    <td class="codeline">// mul.wide.u32    %rl5, %r2, 4;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="codeline">// add.s64         %rl6, %rl4, %rl5;</td>
    <td class="lineNumber">43</td>
    <td class="codeline">// add.s64         %rl6, %rl4, %rl5;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="codeline">// ld.global.f32   %f1, [%rl6];</td>
    <td class="lineNumber">44</td>
    <td class="codeline">// ld.global.f32   %f1, [%rl6];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="codeline">//</td>
    <td class="lineNumber">45</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="codeline">// To reduce the register pressure, the optimization implemented in this file</td>
    <td class="lineNumber">46</td>
    <td class="codeline">// To reduce the register pressure, the optimization implemented in this file</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="codeline">// merges the common part of a group of GEPs, so we can compute each pointer</td>
    <td class="lineNumber">47</td>
    <td class="codeline">// merges the common part of a group of GEPs, so we can compute each pointer</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="codeline">// address by adding a simple offset to the common part, saving many registers.</td>
    <td class="lineNumber">48</td>
    <td class="codeline">// address by adding a simple offset to the common part, saving many registers.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="codeline">//</td>
    <td class="lineNumber">49</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="codeline">// It works by splitting each GEP into a variadic base and a constant offset.</td>
    <td class="lineNumber">50</td>
    <td class="codeline">// It works by splitting each GEP into a variadic base and a constant offset.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="codeline">// The variadic base can be computed once and reused by multiple GEPs, and the</td>
    <td class="lineNumber">51</td>
    <td class="codeline">// The variadic base can be computed once and reused by multiple GEPs, and the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="codeline">// constant offsets can be nicely folded into the reg+immediate addressing mode</td>
    <td class="lineNumber">52</td>
    <td class="codeline">// constant offsets can be nicely folded into the reg+immediate addressing mode</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="codeline">// (supported by most targets) without using any extra register.</td>
    <td class="lineNumber">53</td>
    <td class="codeline">// (supported by most targets) without using any extra register.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="codeline">//</td>
    <td class="lineNumber">54</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="codeline">// For instance, we transform the four GEPs and four loads in the above example</td>
    <td class="lineNumber">55</td>
    <td class="codeline">// For instance, we transform the four GEPs and four loads in the above example</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="codeline">// into:</td>
    <td class="lineNumber">56</td>
    <td class="codeline">// into:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="codeline">//</td>
    <td class="lineNumber">57</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="codeline">// base = gep a, 0, x, y</td>
    <td class="lineNumber">58</td>
    <td class="codeline">// base = gep a, 0, x, y</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="codeline">// load base</td>
    <td class="lineNumber">59</td>
    <td class="codeline">// load base</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="codeline">// laod base + 1  * sizeof(float)</td>
    <td class="lineNumber">60</td>
    <td class="codeline">// laod base + 1  * sizeof(float)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="codeline">// load base + 32 * sizeof(float)</td>
    <td class="lineNumber">61</td>
    <td class="codeline">// load base + 32 * sizeof(float)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="codeline">// load base + 33 * sizeof(float)</td>
    <td class="lineNumber">62</td>
    <td class="codeline">// load base + 33 * sizeof(float)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="codeline">//</td>
    <td class="lineNumber">63</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="codeline">// Given the transformed IR, a backend that supports the reg+immediate</td>
    <td class="lineNumber">64</td>
    <td class="codeline">// Given the transformed IR, a backend that supports the reg+immediate</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="codeline">// addressing mode can easily fold the pointer arithmetics into the loads. For</td>
    <td class="lineNumber">65</td>
    <td class="codeline">// addressing mode can easily fold the pointer arithmetics into the loads. For</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="codeline">// example, the NVPTX backend can easily fold the pointer arithmetics into the</td>
    <td class="lineNumber">66</td>
    <td class="codeline">// example, the NVPTX backend can easily fold the pointer arithmetics into the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="codeline">// ld.global.f32 instructions, and the resultant PTX uses much fewer registers.</td>
    <td class="lineNumber">67</td>
    <td class="codeline">// ld.global.f32 instructions, and the resultant PTX uses much fewer registers.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="codeline">//</td>
    <td class="lineNumber">68</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="codeline">// mov.u32         %r1, %tid.x;</td>
    <td class="lineNumber">69</td>
    <td class="codeline">// mov.u32         %r1, %tid.x;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="codeline">// mov.u32         %r2, %tid.y;</td>
    <td class="lineNumber">70</td>
    <td class="codeline">// mov.u32         %r2, %tid.y;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="codeline">// mul.wide.u32    %rl2, %r1, 128;</td>
    <td class="lineNumber">71</td>
    <td class="codeline">// mul.wide.u32    %rl2, %r1, 128;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="codeline">// mov.u64         %rl3, a;</td>
    <td class="lineNumber">72</td>
    <td class="codeline">// mov.u64         %rl3, a;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="codeline">// add.s64         %rl4, %rl3, %rl2;</td>
    <td class="lineNumber">73</td>
    <td class="codeline">// add.s64         %rl4, %rl3, %rl2;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="codeline">// mul.wide.u32    %rl5, %r2, 4;</td>
    <td class="lineNumber">74</td>
    <td class="codeline">// mul.wide.u32    %rl5, %r2, 4;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="codeline">// add.s64         %rl6, %rl4, %rl5;</td>
    <td class="lineNumber">75</td>
    <td class="codeline">// add.s64         %rl6, %rl4, %rl5;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="codeline">// ld.global.f32   %f1, [%rl6]; // so far the same as unoptimized PTX</td>
    <td class="lineNumber">76</td>
    <td class="codeline">// ld.global.f32   %f1, [%rl6]; // so far the same as unoptimized PTX</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="codeline">// ld.global.f32   %f2, [%rl6+4]; // much better</td>
    <td class="lineNumber">77</td>
    <td class="codeline">// ld.global.f32   %f2, [%rl6+4]; // much better</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="codeline">// ld.global.f32   %f3, [%rl6+128]; // much better</td>
    <td class="lineNumber">78</td>
    <td class="codeline">// ld.global.f32   %f3, [%rl6+128]; // much better</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="codeline">// ld.global.f32   %f4, [%rl6+132]; // much better</td>
    <td class="lineNumber">79</td>
    <td class="codeline">// ld.global.f32   %f4, [%rl6+132]; // much better</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="codeline">//</td>
    <td class="lineNumber">80</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="codeline">// Another improvement enabled by the LowerGEP flag is to lower a GEP with</td>
    <td class="lineNumber">81</td>
    <td class="codeline">// Another improvement enabled by the LowerGEP flag is to lower a GEP with</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="codeline">// multiple indices to either multiple GEPs with a single index or arithmetic</td>
    <td class="lineNumber">82</td>
    <td class="codeline">// multiple indices to either multiple GEPs with a single index or arithmetic</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="codeline">// operations (depending on whether the target uses alias analysis in codegen).</td>
    <td class="lineNumber">83</td>
    <td class="codeline">// operations (depending on whether the target uses alias analysis in codegen).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="codeline">// Such transformation can have following benefits:</td>
    <td class="lineNumber">84</td>
    <td class="codeline">// Such transformation can have following benefits:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="codeline">// (1) It can always extract constants in the indices of structure type.</td>
    <td class="lineNumber">85</td>
    <td class="codeline">// (1) It can always extract constants in the indices of structure type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="codeline">// (2) After such Lowering, there are more optimization opportunities such as</td>
    <td class="lineNumber">86</td>
    <td class="codeline">// (2) After such Lowering, there are more optimization opportunities such as</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="codeline">//     CSE, LICM and CGP.</td>
    <td class="lineNumber">87</td>
    <td class="codeline">//     CSE, LICM and CGP.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="codeline">//</td>
    <td class="lineNumber">88</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="codeline">// E.g. The following GEPs have multiple indices:</td>
    <td class="lineNumber">89</td>
    <td class="codeline">// E.g. The following GEPs have multiple indices:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="codeline">//  BB1:</td>
    <td class="lineNumber">90</td>
    <td class="codeline">//  BB1:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="codeline">//    %p = getelementptr [10 x %struct]* %ptr, i64 %i, i64 %j1, i32 3</td>
    <td class="lineNumber">91</td>
    <td class="codeline">//    %p = getelementptr [10 x %struct]* %ptr, i64 %i, i64 %j1, i32 3</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="codeline">//    load %p</td>
    <td class="lineNumber">92</td>
    <td class="codeline">//    load %p</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="codeline">//    ...</td>
    <td class="lineNumber">93</td>
    <td class="codeline">//    ...</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="codeline">//  BB2:</td>
    <td class="lineNumber">94</td>
    <td class="codeline">//  BB2:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="codeline">//    %p2 = getelementptr [10 x %struct]* %ptr, i64 %i, i64 %j1, i32 2</td>
    <td class="lineNumber">95</td>
    <td class="codeline">//    %p2 = getelementptr [10 x %struct]* %ptr, i64 %i, i64 %j1, i32 2</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="codeline">//    load %p2</td>
    <td class="lineNumber">96</td>
    <td class="codeline">//    load %p2</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="codeline">//    ...</td>
    <td class="lineNumber">97</td>
    <td class="codeline">//    ...</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="codeline">//</td>
    <td class="lineNumber">98</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="codeline">// We can not do CSE to the common part related to index "i64 %i". Lowering</td>
    <td class="lineNumber">99</td>
    <td class="codeline">// We can not do CSE to the common part related to index "i64 %i". Lowering</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="codeline">// GEPs can achieve such goals.</td>
    <td class="lineNumber">100</td>
    <td class="codeline">// GEPs can achieve such goals.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="codeline">// If the target does not use alias analysis in codegen, this pass will</td>
    <td class="lineNumber">101</td>
    <td class="codeline">// If the target does not use alias analysis in codegen, this pass will</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="codeline">// lower a GEP with multiple indices into arithmetic operations:</td>
    <td class="lineNumber">102</td>
    <td class="codeline">// lower a GEP with multiple indices into arithmetic operations:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="codeline">//  BB1:</td>
    <td class="lineNumber">103</td>
    <td class="codeline">//  BB1:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="codeline">//    %1 = ptrtoint [10 x %struct]* %ptr to i64    ; CSE opportunity</td>
    <td class="lineNumber">104</td>
    <td class="codeline">//    %1 = ptrtoint [10 x %struct]* %ptr to i64    ; CSE opportunity</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="codeline">//    %2 = mul i64 %i, length_of_10xstruct         ; CSE opportunity</td>
    <td class="lineNumber">105</td>
    <td class="codeline">//    %2 = mul i64 %i, length_of_10xstruct         ; CSE opportunity</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="codeline">//    %3 = add i64 %1, %2                          ; CSE opportunity</td>
    <td class="lineNumber">106</td>
    <td class="codeline">//    %3 = add i64 %1, %2                          ; CSE opportunity</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="codeline">//    %4 = mul i64 %j1, length_of_struct</td>
    <td class="lineNumber">107</td>
    <td class="codeline">//    %4 = mul i64 %j1, length_of_struct</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="codeline">//    %5 = add i64 %3, %4</td>
    <td class="lineNumber">108</td>
    <td class="codeline">//    %5 = add i64 %3, %4</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="codeline">//    %6 = add i64 %3, struct_field_3              ; Constant offset</td>
    <td class="lineNumber">109</td>
    <td class="codeline">//    %6 = add i64 %3, struct_field_3              ; Constant offset</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="codeline">//    %p = inttoptr i64 %6 to i32*</td>
    <td class="lineNumber">110</td>
    <td class="codeline">//    %p = inttoptr i64 %6 to i32*</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="codeline">//    load %p</td>
    <td class="lineNumber">111</td>
    <td class="codeline">//    load %p</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="codeline">//    ...</td>
    <td class="lineNumber">112</td>
    <td class="codeline">//    ...</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="codeline">//  BB2:</td>
    <td class="lineNumber">113</td>
    <td class="codeline">//  BB2:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="codeline">//    %7 = ptrtoint [10 x %struct]* %ptr to i64    ; CSE opportunity</td>
    <td class="lineNumber">114</td>
    <td class="codeline">//    %7 = ptrtoint [10 x %struct]* %ptr to i64    ; CSE opportunity</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="codeline">//    %8 = mul i64 %i, length_of_10xstruct         ; CSE opportunity</td>
    <td class="lineNumber">115</td>
    <td class="codeline">//    %8 = mul i64 %i, length_of_10xstruct         ; CSE opportunity</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="codeline">//    %9 = add i64 %7, %8                          ; CSE opportunity</td>
    <td class="lineNumber">116</td>
    <td class="codeline">//    %9 = add i64 %7, %8                          ; CSE opportunity</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="codeline">//    %10 = mul i64 %j2, length_of_struct</td>
    <td class="lineNumber">117</td>
    <td class="codeline">//    %10 = mul i64 %j2, length_of_struct</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="codeline">//    %11 = add i64 %9, %10</td>
    <td class="lineNumber">118</td>
    <td class="codeline">//    %11 = add i64 %9, %10</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="codeline">//    %12 = add i64 %11, struct_field_2            ; Constant offset</td>
    <td class="lineNumber">119</td>
    <td class="codeline">//    %12 = add i64 %11, struct_field_2            ; Constant offset</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="codeline">//    %p = inttoptr i64 %12 to i32*</td>
    <td class="lineNumber">120</td>
    <td class="codeline">//    %p = inttoptr i64 %12 to i32*</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="codeline">//    load %p2</td>
    <td class="lineNumber">121</td>
    <td class="codeline">//    load %p2</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="codeline">//    ...</td>
    <td class="lineNumber">122</td>
    <td class="codeline">//    ...</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="codeline">//</td>
    <td class="lineNumber">123</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="codeline">// If the target uses alias analysis in codegen, this pass will lower a GEP</td>
    <td class="lineNumber">124</td>
    <td class="codeline">// If the target uses alias analysis in codegen, this pass will lower a GEP</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="codeline">// with multiple indices into multiple GEPs with a single index:</td>
    <td class="lineNumber">125</td>
    <td class="codeline">// with multiple indices into multiple GEPs with a single index:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="codeline">//  BB1:</td>
    <td class="lineNumber">126</td>
    <td class="codeline">//  BB1:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="codeline">//    %1 = bitcast [10 x %struct]* %ptr to i8*     ; CSE opportunity</td>
    <td class="lineNumber">127</td>
    <td class="codeline">//    %1 = bitcast [10 x %struct]* %ptr to i8*     ; CSE opportunity</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="codeline">//    %2 = mul i64 %i, length_of_10xstruct         ; CSE opportunity</td>
    <td class="lineNumber">128</td>
    <td class="codeline">//    %2 = mul i64 %i, length_of_10xstruct         ; CSE opportunity</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="codeline">//    %3 = getelementptr i8* %1, i64 %2            ; CSE opportunity</td>
    <td class="lineNumber">129</td>
    <td class="codeline">//    %3 = getelementptr i8* %1, i64 %2            ; CSE opportunity</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="codeline">//    %4 = mul i64 %j1, length_of_struct</td>
    <td class="lineNumber">130</td>
    <td class="codeline">//    %4 = mul i64 %j1, length_of_struct</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="codeline">//    %5 = getelementptr i8* %3, i64 %4</td>
    <td class="lineNumber">131</td>
    <td class="codeline">//    %5 = getelementptr i8* %3, i64 %4</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="codeline">//    %6 = getelementptr i8* %5, struct_field_3    ; Constant offset</td>
    <td class="lineNumber">132</td>
    <td class="codeline">//    %6 = getelementptr i8* %5, struct_field_3    ; Constant offset</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="codeline">//    %p = bitcast i8* %6 to i32*</td>
    <td class="lineNumber">133</td>
    <td class="codeline">//    %p = bitcast i8* %6 to i32*</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="codeline">//    load %p</td>
    <td class="lineNumber">134</td>
    <td class="codeline">//    load %p</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="codeline">//    ...</td>
    <td class="lineNumber">135</td>
    <td class="codeline">//    ...</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="codeline">//  BB2:</td>
    <td class="lineNumber">136</td>
    <td class="codeline">//  BB2:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="codeline">//    %7 = bitcast [10 x %struct]* %ptr to i8*     ; CSE opportunity</td>
    <td class="lineNumber">137</td>
    <td class="codeline">//    %7 = bitcast [10 x %struct]* %ptr to i8*     ; CSE opportunity</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="codeline">//    %8 = mul i64 %i, length_of_10xstruct         ; CSE opportunity</td>
    <td class="lineNumber">138</td>
    <td class="codeline">//    %8 = mul i64 %i, length_of_10xstruct         ; CSE opportunity</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="codeline">//    %9 = getelementptr i8* %7, i64 %8            ; CSE opportunity</td>
    <td class="lineNumber">139</td>
    <td class="codeline">//    %9 = getelementptr i8* %7, i64 %8            ; CSE opportunity</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="codeline">//    %10 = mul i64 %j2, length_of_struct</td>
    <td class="lineNumber">140</td>
    <td class="codeline">//    %10 = mul i64 %j2, length_of_struct</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="codeline">//    %11 = getelementptr i8* %9, i64 %10</td>
    <td class="lineNumber">141</td>
    <td class="codeline">//    %11 = getelementptr i8* %9, i64 %10</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="codeline">//    %12 = getelementptr i8* %11, struct_field_2  ; Constant offset</td>
    <td class="lineNumber">142</td>
    <td class="codeline">//    %12 = getelementptr i8* %11, struct_field_2  ; Constant offset</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="codeline">//    %p2 = bitcast i8* %12 to i32*</td>
    <td class="lineNumber">143</td>
    <td class="codeline">//    %p2 = bitcast i8* %12 to i32*</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="codeline">//    load %p2</td>
    <td class="lineNumber">144</td>
    <td class="codeline">//    load %p2</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="codeline">//    ...</td>
    <td class="lineNumber">145</td>
    <td class="codeline">//    ...</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="codeline">//</td>
    <td class="lineNumber">146</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="codeline">// Lowering GEPs can also benefit other passes such as LICM and CGP.</td>
    <td class="lineNumber">147</td>
    <td class="codeline">// Lowering GEPs can also benefit other passes such as LICM and CGP.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="codeline">// LICM (Loop Invariant Code Motion) can not hoist/sink a GEP of multiple</td>
    <td class="lineNumber">148</td>
    <td class="codeline">// LICM (Loop Invariant Code Motion) can not hoist/sink a GEP of multiple</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="codeline">// indices if one of the index is variant. If we lower such GEP into invariant</td>
    <td class="lineNumber">149</td>
    <td class="codeline">// indices if one of the index is variant. If we lower such GEP into invariant</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="codeline">// parts and variant parts, LICM can hoist/sink those invariant parts.</td>
    <td class="lineNumber">150</td>
    <td class="codeline">// parts and variant parts, LICM can hoist/sink those invariant parts.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="codeline">// CGP (CodeGen Prepare) tries to sink address calculations that match the</td>
    <td class="lineNumber">151</td>
    <td class="codeline">// CGP (CodeGen Prepare) tries to sink address calculations that match the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="codeline">// target's addressing modes. A GEP with multiple indices may not match and will</td>
    <td class="lineNumber">152</td>
    <td class="codeline">// target's addressing modes. A GEP with multiple indices may not match and will</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="codeline">// not be sunk. If we lower such GEP into smaller parts, CGP may sink some of</td>
    <td class="lineNumber">153</td>
    <td class="codeline">// not be sunk. If we lower such GEP into smaller parts, CGP may sink some of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="codeline">// them. So we end up with a better addressing mode.</td>
    <td class="lineNumber">154</td>
    <td class="codeline">// them. So we end up with a better addressing mode.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="codeline">//</td>
    <td class="lineNumber">155</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">156</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="codeline"></td>
    <td class="lineNumber">157</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="codeline">#include "llvm/Transforms/Scalar/SeparateConstOffsetFromGEP.h"</td>
    <td class="lineNumber">158</td>
    <td class="codeline">#include "llvm/Transforms/Scalar/SeparateConstOffsetFromGEP.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="codeline">#include "llvm/ADT/APInt.h"</td>
    <td class="lineNumber">159</td>
    <td class="codeline">#include "llvm/ADT/APInt.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="codeline">#include "llvm/ADT/DenseMap.h"</td>
    <td class="lineNumber">160</td>
    <td class="codeline">#include "llvm/ADT/DenseMap.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="codeline">#include "llvm/ADT/DepthFirstIterator.h"</td>
    <td class="lineNumber">161</td>
    <td class="codeline">#include "llvm/ADT/DepthFirstIterator.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="codeline">#include "llvm/ADT/SmallVector.h"</td>
    <td class="lineNumber">162</td>
    <td class="codeline">#include "llvm/ADT/SmallVector.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="codeline">#include "llvm/Analysis/LoopInfo.h"</td>
    <td class="lineNumber">163</td>
    <td class="codeline">#include "llvm/Analysis/LoopInfo.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="codeline">#include "llvm/Analysis/MemoryBuiltins.h"</td>
    <td class="lineNumber">164</td>
    <td class="codeline">#include "llvm/Analysis/MemoryBuiltins.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="codeline">#include "llvm/Analysis/TargetLibraryInfo.h"</td>
    <td class="lineNumber">165</td>
    <td class="codeline">#include "llvm/Analysis/TargetLibraryInfo.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="codeline">#include "llvm/Analysis/TargetTransformInfo.h"</td>
    <td class="lineNumber">166</td>
    <td class="codeline">#include "llvm/Analysis/TargetTransformInfo.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="codeline">#include "llvm/Analysis/ValueTracking.h"</td>
    <td class="lineNumber">167</td>
    <td class="codeline">#include "llvm/Analysis/ValueTracking.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="codeline">#include "llvm/IR/BasicBlock.h"</td>
    <td class="lineNumber">168</td>
    <td class="codeline">#include "llvm/IR/BasicBlock.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="codeline">#include "llvm/IR/Constant.h"</td>
    <td class="lineNumber">169</td>
    <td class="codeline">#include "llvm/IR/Constant.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="codeline">#include "llvm/IR/Constants.h"</td>
    <td class="lineNumber">170</td>
    <td class="codeline">#include "llvm/IR/Constants.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="codeline">#include "llvm/IR/DataLayout.h"</td>
    <td class="lineNumber">171</td>
    <td class="codeline">#include "llvm/IR/DataLayout.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="codeline">#include "llvm/IR/DerivedTypes.h"</td>
    <td class="lineNumber">172</td>
    <td class="codeline">#include "llvm/IR/DerivedTypes.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="codeline">#include "llvm/IR/Dominators.h"</td>
    <td class="lineNumber">173</td>
    <td class="codeline">#include "llvm/IR/Dominators.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="codeline">#include "llvm/IR/Function.h"</td>
    <td class="lineNumber">174</td>
    <td class="codeline">#include "llvm/IR/Function.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="codeline">#include "llvm/IR/GetElementPtrTypeIterator.h"</td>
    <td class="lineNumber">175</td>
    <td class="codeline">#include "llvm/IR/GetElementPtrTypeIterator.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="codeline">#include "llvm/IR/IRBuilder.h"</td>
    <td class="lineNumber">176</td>
    <td class="codeline">#include "llvm/IR/IRBuilder.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="codeline">#include "llvm/IR/Instruction.h"</td>
    <td class="lineNumber">177</td>
    <td class="codeline">#include "llvm/IR/Instruction.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="codeline">#include "llvm/IR/Instructions.h"</td>
    <td class="lineNumber">178</td>
    <td class="codeline">#include "llvm/IR/Instructions.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="codeline">#include "llvm/IR/Module.h"</td>
    <td class="lineNumber">179</td>
    <td class="codeline">#include "llvm/IR/Module.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="codeline">#include "llvm/IR/PassManager.h"</td>
    <td class="lineNumber">180</td>
    <td class="codeline">#include "llvm/IR/PassManager.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="codeline">#include "llvm/IR/PatternMatch.h"</td>
    <td class="lineNumber">181</td>
    <td class="codeline">#include "llvm/IR/PatternMatch.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="codeline">#include "llvm/IR/Type.h"</td>
    <td class="lineNumber">182</td>
    <td class="codeline">#include "llvm/IR/Type.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="codeline">#include "llvm/IR/User.h"</td>
    <td class="lineNumber">183</td>
    <td class="codeline">#include "llvm/IR/User.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="codeline">#include "llvm/IR/Value.h"</td>
    <td class="lineNumber">184</td>
    <td class="codeline">#include "llvm/IR/Value.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="codeline">#include "llvm/InitializePasses.h"</td>
    <td class="lineNumber">185</td>
    <td class="codeline">#include "llvm/InitializePasses.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="codeline">#include "llvm/Pass.h"</td>
    <td class="lineNumber">186</td>
    <td class="codeline">#include "llvm/Pass.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="codeline">#include "llvm/Support/Casting.h"</td>
    <td class="lineNumber">187</td>
    <td class="codeline">#include "llvm/Support/Casting.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="codeline">#include "llvm/Support/CommandLine.h"</td>
    <td class="lineNumber">188</td>
    <td class="codeline">#include "llvm/Support/CommandLine.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="codeline">#include "llvm/Support/ErrorHandling.h"</td>
    <td class="lineNumber">189</td>
    <td class="codeline">#include "llvm/Support/ErrorHandling.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="codeline">#include "llvm/Support/raw_ostream.h"</td>
    <td class="lineNumber">190</td>
    <td class="codeline">#include "llvm/Support/raw_ostream.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="codeline">#include "llvm/Transforms/Scalar.h"</td>
    <td class="lineNumber">191</td>
    <td class="codeline">#include "llvm/Transforms/Scalar.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="codeline">#include "llvm/Transforms/Utils/Local.h"</td>
    <td class="lineNumber">192</td>
    <td class="codeline">#include "llvm/Transforms/Utils/Local.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="codeline">#include <cassert></td>
    <td class="lineNumber">193</td>
    <td class="codeline">#include <cassert></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="codeline">#include <cstdint></td>
    <td class="lineNumber">194</td>
    <td class="codeline">#include <cstdint></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="codeline">#include <string></td>
    <td class="lineNumber">195</td>
    <td class="codeline">#include <string></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="codeline"></td>
    <td class="lineNumber">196</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="codeline">using namespace llvm;</td>
    <td class="lineNumber">197</td>
    <td class="codeline">using namespace llvm;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="codeline">using namespace llvm::PatternMatch;</td>
    <td class="lineNumber">198</td>
    <td class="codeline">using namespace llvm::PatternMatch;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="codeline"></td>
    <td class="lineNumber">199</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="codeline">static cl::opt<bool> DisableSeparateConstOffsetFromGEP(</td>
    <td class="lineNumber">200</td>
    <td class="codeline">static cl::opt<bool> DisableSeparateConstOffsetFromGEP(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="codeline">    "disable-separate-const-offset-from-gep", cl::init(false),</td>
    <td class="lineNumber">201</td>
    <td class="codeline">    "disable-separate-const-offset-from-gep", cl::init(false),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="codeline">    cl::desc("Do not separate the constant offset from a GEP instruction"),</td>
    <td class="lineNumber">202</td>
    <td class="codeline">    cl::desc("Do not separate the constant offset from a GEP instruction"),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="codeline">    cl::Hidden);</td>
    <td class="lineNumber">203</td>
    <td class="codeline">    cl::Hidden);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="codeline"></td>
    <td class="lineNumber">204</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="codeline">// Setting this flag may emit false positives when the input module already</td>
    <td class="lineNumber">205</td>
    <td class="codeline">// Setting this flag may emit false positives when the input module already</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="codeline">// contains dead instructions. Therefore, we set it only in unit tests that are</td>
    <td class="lineNumber">206</td>
    <td class="codeline">// contains dead instructions. Therefore, we set it only in unit tests that are</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="codeline">// free of dead code.</td>
    <td class="lineNumber">207</td>
    <td class="codeline">// free of dead code.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="codeline">static cl::opt<bool></td>
    <td class="lineNumber">208</td>
    <td class="codeline">static cl::opt<bool></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="codeline">    VerifyNoDeadCode("reassociate-geps-verify-no-dead-code", cl::init(false),</td>
    <td class="lineNumber">209</td>
    <td class="codeline">    VerifyNoDeadCode("reassociate-geps-verify-no-dead-code", cl::init(false),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="codeline">                     cl::desc("Verify this pass produces no dead code"),</td>
    <td class="lineNumber">210</td>
    <td class="codeline">                     cl::desc("Verify this pass produces no dead code"),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="codeline">                     cl::Hidden);</td>
    <td class="lineNumber">211</td>
    <td class="codeline">                     cl::Hidden);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="codeline"></td>
    <td class="lineNumber">212</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="codeline">namespace {</td>
    <td class="lineNumber">213</td>
    <td class="codeline">namespace {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="codeline"></td>
    <td class="lineNumber">214</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="codeline">/// A helper class for separating a constant offset from a GEP index.</td>
    <td class="lineNumber">215</td>
    <td class="codeline">/// A helper class for separating a constant offset from a GEP index.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="codeline">///</td>
    <td class="lineNumber">216</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="codeline">/// In real programs, a GEP index may be more complicated than a simple addition</td>
    <td class="lineNumber">217</td>
    <td class="codeline">/// In real programs, a GEP index may be more complicated than a simple addition</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="codeline">/// of something and a constant integer which can be trivially splitted. For</td>
    <td class="lineNumber">218</td>
    <td class="codeline">/// of something and a constant integer which can be trivially splitted. For</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="codeline">/// example, to split ((a << 3) | 5) + b, we need to search deeper for the</td>
    <td class="lineNumber">219</td>
    <td class="codeline">/// example, to split ((a << 3) | 5) + b, we need to search deeper for the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="codeline">/// constant offset, so that we can separate the index to (a << 3) + b and 5.</td>
    <td class="lineNumber">220</td>
    <td class="codeline">/// constant offset, so that we can separate the index to (a << 3) + b and 5.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="codeline">///</td>
    <td class="lineNumber">221</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="codeline">/// Therefore, this class looks into the expression that computes a given GEP</td>
    <td class="lineNumber">222</td>
    <td class="codeline">/// Therefore, this class looks into the expression that computes a given GEP</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="codeline">/// index, and tries to find a constant integer that can be hoisted to the</td>
    <td class="lineNumber">223</td>
    <td class="codeline">/// index, and tries to find a constant integer that can be hoisted to the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="codeline">/// outermost level of the expression as an addition. Not every constant in an</td>
    <td class="lineNumber">224</td>
    <td class="codeline">/// outermost level of the expression as an addition. Not every constant in an</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="codeline">/// expression can jump out. e.g., we cannot transform (b * (a + 5)) to (b * a +</td>
    <td class="lineNumber">225</td>
    <td class="codeline">/// expression can jump out. e.g., we cannot transform (b * (a + 5)) to (b * a +</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="codeline">/// 5); nor can we transform (3 * (a + 5)) to (3 * a + 5), however in this case,</td>
    <td class="lineNumber">226</td>
    <td class="codeline">/// 5); nor can we transform (3 * (a + 5)) to (3 * a + 5), however in this case,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="codeline">/// -instcombine probably already optimized (3 * (a + 5)) to (3 * a + 15).</td>
    <td class="lineNumber">227</td>
    <td class="codeline">/// -instcombine probably already optimized (3 * (a + 5)) to (3 * a + 15).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="codeline">class ConstantOffsetExtractor {</td>
    <td class="lineNumber">228</td>
    <td class="codeline">class ConstantOffsetExtractor {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">229</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="codeline">  /// Extracts a constant offset from the given GEP index. It returns the</td>
    <td class="lineNumber">230</td>
    <td class="codeline">  /// Extracts a constant offset from the given GEP index. It returns the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="codeline">  /// new index representing the remainder (equal to the original index minus</td>
    <td class="lineNumber">231</td>
    <td class="codeline">  /// new index representing the remainder (equal to the original index minus</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="codeline">  /// the constant offset), or nullptr if we cannot extract a constant offset.</td>
    <td class="lineNumber">232</td>
    <td class="codeline">  /// the constant offset), or nullptr if we cannot extract a constant offset.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="codeline">  /// \p Idx The given GEP index</td>
    <td class="lineNumber">233</td>
    <td class="codeline">  /// \p Idx The given GEP index</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="codeline">  /// \p GEP The given GEP</td>
    <td class="lineNumber">234</td>
    <td class="codeline">  /// \p GEP The given GEP</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="codeline">  /// \p UserChainTail Outputs the tail of UserChain so that we can</td>
    <td class="lineNumber">235</td>
    <td class="codeline">  /// \p UserChainTail Outputs the tail of UserChain so that we can</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="codeline">  ///                  garbage-collect unused instructions in UserChain.</td>
    <td class="lineNumber">236</td>
    <td class="codeline">  ///                  garbage-collect unused instructions in UserChain.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="codeline">  static Value *Extract(Value *Idx, GetElementPtrInst *GEP,</td>
    <td class="lineNumber">237</td>
    <td class="codeline">  static Value *Extract(Value *Idx, GetElementPtrInst *GEP,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="codeline">                        User *&UserChainTail, const DominatorTree *DT);</td>
    <td class="lineNumber">238</td>
    <td class="codeline">                        User *&UserChainTail, const DominatorTree *DT);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="codeline"></td>
    <td class="lineNumber">239</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="codeline">  /// Looks for a constant offset from the given GEP index without extracting</td>
    <td class="lineNumber">240</td>
    <td class="codeline">  /// Looks for a constant offset from the given GEP index without extracting</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="codeline">  /// it. It returns the numeric value of the extracted constant offset (0 if</td>
    <td class="lineNumber">241</td>
    <td class="codeline">  /// it. It returns the numeric value of the extracted constant offset (0 if</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="codeline">  /// failed). The meaning of the arguments are the same as Extract.</td>
    <td class="lineNumber">242</td>
    <td class="codeline">  /// failed). The meaning of the arguments are the same as Extract.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="codeline">  static int64_t Find(Value *Idx, GetElementPtrInst *GEP,</td>
    <td class="lineNumber">243</td>
    <td class="codeline">  static int64_t Find(Value *Idx, GetElementPtrInst *GEP,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="codeline">                      const DominatorTree *DT);</td>
    <td class="lineNumber">244</td>
    <td class="codeline">                      const DominatorTree *DT);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="codeline"></td>
    <td class="lineNumber">245</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="codeline">private:</td>
    <td class="lineNumber">246</td>
    <td class="codeline">private:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="codeline">  ConstantOffsetExtractor(Instruction *InsertionPt, const DominatorTree *DT)</td>
    <td class="lineNumber">247</td>
    <td class="codeline">  ConstantOffsetExtractor(Instruction *InsertionPt, const DominatorTree *DT)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="codeline">      : IP(InsertionPt), DL(InsertionPt->getModule()->getDataLayout()), DT(DT) {</td>
    <td class="lineNumber">248</td>
    <td class="codeline">      : IP(InsertionPt), DL(InsertionPt->getModule()->getDataLayout()), DT(DT) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">249</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="codeline"></td>
    <td class="lineNumber">250</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="codeline">  /// Searches the expression that computes V for a non-zero constant C s.t.</td>
    <td class="lineNumber">251</td>
    <td class="codeline">  /// Searches the expression that computes V for a non-zero constant C s.t.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="codeline">  /// V can be reassociated into the form V' + C. If the searching is</td>
    <td class="lineNumber">252</td>
    <td class="codeline">  /// V can be reassociated into the form V' + C. If the searching is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="codeline">  /// successful, returns C and update UserChain as a def-use chain from C to V;</td>
    <td class="lineNumber">253</td>
    <td class="codeline">  /// successful, returns C and update UserChain as a def-use chain from C to V;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="codeline">  /// otherwise, UserChain is empty.</td>
    <td class="lineNumber">254</td>
    <td class="codeline">  /// otherwise, UserChain is empty.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">255</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="codeline">  /// \p V            The given expression</td>
    <td class="lineNumber">256</td>
    <td class="codeline">  /// \p V            The given expression</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="codeline">  /// \p SignExtended Whether V will be sign-extended in the computation of the</td>
    <td class="lineNumber">257</td>
    <td class="codeline">  /// \p SignExtended Whether V will be sign-extended in the computation of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="codeline">  ///                 GEP index</td>
    <td class="lineNumber">258</td>
    <td class="codeline">  ///                 GEP index</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="codeline">  /// \p ZeroExtended Whether V will be zero-extended in the computation of the</td>
    <td class="lineNumber">259</td>
    <td class="codeline">  /// \p ZeroExtended Whether V will be zero-extended in the computation of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="codeline">  ///                 GEP index</td>
    <td class="lineNumber">260</td>
    <td class="codeline">  ///                 GEP index</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="codeline">  /// \p NonNegative  Whether V is guaranteed to be non-negative. For example,</td>
    <td class="lineNumber">261</td>
    <td class="codeline">  /// \p NonNegative  Whether V is guaranteed to be non-negative. For example,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="codeline">  ///                 an index of an inbounds GEP is guaranteed to be</td>
    <td class="lineNumber">262</td>
    <td class="codeline">  ///                 an index of an inbounds GEP is guaranteed to be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="codeline">  ///                 non-negative. Levaraging this, we can better split</td>
    <td class="lineNumber">263</td>
    <td class="codeline">  ///                 non-negative. Levaraging this, we can better split</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="codeline">  ///                 inbounds GEPs.</td>
    <td class="lineNumber">264</td>
    <td class="codeline">  ///                 inbounds GEPs.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="codeline">  APInt find(Value *V, bool SignExtended, bool ZeroExtended, bool NonNegative);</td>
    <td class="lineNumber">265</td>
    <td class="codeline">  APInt find(Value *V, bool SignExtended, bool ZeroExtended, bool NonNegative);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="codeline"></td>
    <td class="lineNumber">266</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="codeline">  /// A helper function to look into both operands of a binary operator.</td>
    <td class="lineNumber">267</td>
    <td class="codeline">  /// A helper function to look into both operands of a binary operator.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="codeline">  APInt findInEitherOperand(BinaryOperator *BO, bool SignExtended,</td>
    <td class="lineNumber">268</td>
    <td class="codeline">  APInt findInEitherOperand(BinaryOperator *BO, bool SignExtended,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="codeline">                            bool ZeroExtended);</td>
    <td class="lineNumber">269</td>
    <td class="codeline">                            bool ZeroExtended);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="codeline"></td>
    <td class="lineNumber">270</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="codeline">  /// After finding the constant offset C from the GEP index I, we build a new</td>
    <td class="lineNumber">271</td>
    <td class="codeline">  /// After finding the constant offset C from the GEP index I, we build a new</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="codeline">  /// index I' s.t. I' + C = I. This function builds and returns the new</td>
    <td class="lineNumber">272</td>
    <td class="codeline">  /// index I' s.t. I' + C = I. This function builds and returns the new</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="codeline">  /// index I' according to UserChain produced by function "find".</td>
    <td class="lineNumber">273</td>
    <td class="codeline">  /// index I' according to UserChain produced by function "find".</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">274</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="codeline">  /// The building conceptually takes two steps:</td>
    <td class="lineNumber">275</td>
    <td class="codeline">  /// The building conceptually takes two steps:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="codeline">  /// 1) iteratively distribute s/zext towards the leaves of the expression tree</td>
    <td class="lineNumber">276</td>
    <td class="codeline">  /// 1) iteratively distribute s/zext towards the leaves of the expression tree</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="codeline">  /// that computes I</td>
    <td class="lineNumber">277</td>
    <td class="codeline">  /// that computes I</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="codeline">  /// 2) reassociate the expression tree to the form I' + C.</td>
    <td class="lineNumber">278</td>
    <td class="codeline">  /// 2) reassociate the expression tree to the form I' + C.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">279</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="codeline">  /// For example, to extract the 5 from sext(a + (b + 5)), we first distribute</td>
    <td class="lineNumber">280</td>
    <td class="codeline">  /// For example, to extract the 5 from sext(a + (b + 5)), we first distribute</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="codeline">  /// sext to a, b and 5 so that we have</td>
    <td class="lineNumber">281</td>
    <td class="codeline">  /// sext to a, b and 5 so that we have</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="codeline">  ///   sext(a) + (sext(b) + 5).</td>
    <td class="lineNumber">282</td>
    <td class="codeline">  ///   sext(a) + (sext(b) + 5).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="codeline">  /// Then, we reassociate it to</td>
    <td class="lineNumber">283</td>
    <td class="codeline">  /// Then, we reassociate it to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="codeline">  ///   (sext(a) + sext(b)) + 5.</td>
    <td class="lineNumber">284</td>
    <td class="codeline">  ///   (sext(a) + sext(b)) + 5.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="codeline">  /// Given this form, we know I' is sext(a) + sext(b).</td>
    <td class="lineNumber">285</td>
    <td class="codeline">  /// Given this form, we know I' is sext(a) + sext(b).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="codeline">  Value *rebuildWithoutConstOffset();</td>
    <td class="lineNumber">286</td>
    <td class="codeline">  Value *rebuildWithoutConstOffset();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="codeline"></td>
    <td class="lineNumber">287</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="codeline">  /// After the first step of rebuilding the GEP index without the constant</td>
    <td class="lineNumber">288</td>
    <td class="codeline">  /// After the first step of rebuilding the GEP index without the constant</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="codeline">  /// offset, distribute s/zext to the operands of all operators in UserChain.</td>
    <td class="lineNumber">289</td>
    <td class="codeline">  /// offset, distribute s/zext to the operands of all operators in UserChain.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="codeline">  /// e.g., zext(sext(a + (b + 5)) (assuming no overflow) =></td>
    <td class="lineNumber">290</td>
    <td class="codeline">  /// e.g., zext(sext(a + (b + 5)) (assuming no overflow) =></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="codeline">  /// zext(sext(a)) + (zext(sext(b)) + zext(sext(5))).</td>
    <td class="lineNumber">291</td>
    <td class="codeline">  /// zext(sext(a)) + (zext(sext(b)) + zext(sext(5))).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">292</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="codeline">  /// The function also updates UserChain to point to new subexpressions after</td>
    <td class="lineNumber">293</td>
    <td class="codeline">  /// The function also updates UserChain to point to new subexpressions after</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="codeline">  /// distributing s/zext. e.g., the old UserChain of the above example is</td>
    <td class="lineNumber">294</td>
    <td class="codeline">  /// distributing s/zext. e.g., the old UserChain of the above example is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="codeline">  /// 5 -> b + 5 -> a + (b + 5) -> sext(...) -> zext(sext(...)),</td>
    <td class="lineNumber">295</td>
    <td class="codeline">  /// 5 -> b + 5 -> a + (b + 5) -> sext(...) -> zext(sext(...)),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="codeline">  /// and the new UserChain is</td>
    <td class="lineNumber">296</td>
    <td class="codeline">  /// and the new UserChain is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="codeline">  /// zext(sext(5)) -> zext(sext(b)) + zext(sext(5)) -></td>
    <td class="lineNumber">297</td>
    <td class="codeline">  /// zext(sext(5)) -> zext(sext(b)) + zext(sext(5)) -></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="codeline">  ///   zext(sext(a)) + (zext(sext(b)) + zext(sext(5))</td>
    <td class="lineNumber">298</td>
    <td class="codeline">  ///   zext(sext(a)) + (zext(sext(b)) + zext(sext(5))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">299</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="codeline">  /// \p ChainIndex The index to UserChain. ChainIndex is initially</td>
    <td class="lineNumber">300</td>
    <td class="codeline">  /// \p ChainIndex The index to UserChain. ChainIndex is initially</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="codeline">  ///               UserChain.size() - 1, and is decremented during</td>
    <td class="lineNumber">301</td>
    <td class="codeline">  ///               UserChain.size() - 1, and is decremented during</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="codeline">  ///               the recursion.</td>
    <td class="lineNumber">302</td>
    <td class="codeline">  ///               the recursion.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="codeline">  Value *distributeExtsAndCloneChain(unsigned ChainIndex);</td>
    <td class="lineNumber">303</td>
    <td class="codeline">  Value *distributeExtsAndCloneChain(unsigned ChainIndex);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="codeline"></td>
    <td class="lineNumber">304</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="codeline">  /// Reassociates the GEP index to the form I' + C and returns I'.</td>
    <td class="lineNumber">305</td>
    <td class="codeline">  /// Reassociates the GEP index to the form I' + C and returns I'.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="codeline">  Value *removeConstOffset(unsigned ChainIndex);</td>
    <td class="lineNumber">306</td>
    <td class="codeline">  Value *removeConstOffset(unsigned ChainIndex);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="codeline"></td>
    <td class="lineNumber">307</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="codeline">  /// A helper function to apply ExtInsts, a list of s/zext, to value V.</td>
    <td class="lineNumber">308</td>
    <td class="codeline">  /// A helper function to apply ExtInsts, a list of s/zext, to value V.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="codeline">  /// e.g., if ExtInsts = [sext i32 to i64, zext i16 to i32], this function</td>
    <td class="lineNumber">309</td>
    <td class="codeline">  /// e.g., if ExtInsts = [sext i32 to i64, zext i16 to i32], this function</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="codeline">  /// returns "sext i32 (zext i16 V to i32) to i64".</td>
    <td class="lineNumber">310</td>
    <td class="codeline">  /// returns "sext i32 (zext i16 V to i32) to i64".</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="codeline">  Value *applyExts(Value *V);</td>
    <td class="lineNumber">311</td>
    <td class="codeline">  Value *applyExts(Value *V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="codeline"></td>
    <td class="lineNumber">312</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="codeline">  /// A helper function that returns whether we can trace into the operands</td>
    <td class="lineNumber">313</td>
    <td class="codeline">  /// A helper function that returns whether we can trace into the operands</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="codeline">  /// of binary operator BO for a constant offset.</td>
    <td class="lineNumber">314</td>
    <td class="codeline">  /// of binary operator BO for a constant offset.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">315</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="codeline">  /// \p SignExtended Whether BO is surrounded by sext</td>
    <td class="lineNumber">316</td>
    <td class="codeline">  /// \p SignExtended Whether BO is surrounded by sext</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="codeline">  /// \p ZeroExtended Whether BO is surrounded by zext</td>
    <td class="lineNumber">317</td>
    <td class="codeline">  /// \p ZeroExtended Whether BO is surrounded by zext</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="codeline">  /// \p NonNegative Whether BO is known to be non-negative, e.g., an in-bound</td>
    <td class="lineNumber">318</td>
    <td class="codeline">  /// \p NonNegative Whether BO is known to be non-negative, e.g., an in-bound</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="codeline">  ///                array index.</td>
    <td class="lineNumber">319</td>
    <td class="codeline">  ///                array index.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="codeline">  bool CanTraceInto(bool SignExtended, bool ZeroExtended, BinaryOperator *BO,</td>
    <td class="lineNumber">320</td>
    <td class="codeline">  bool CanTraceInto(bool SignExtended, bool ZeroExtended, BinaryOperator *BO,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="codeline">                    bool NonNegative);</td>
    <td class="lineNumber">321</td>
    <td class="codeline">                    bool NonNegative);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="codeline"></td>
    <td class="lineNumber">322</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="codeline">  /// The path from the constant offset to the old GEP index. e.g., if the GEP</td>
    <td class="lineNumber">323</td>
    <td class="codeline">  /// The path from the constant offset to the old GEP index. e.g., if the GEP</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="codeline">  /// index is "a * b + (c + 5)". After running function find, UserChain[0] will</td>
    <td class="lineNumber">324</td>
    <td class="codeline">  /// index is "a * b + (c + 5)". After running function find, UserChain[0] will</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="codeline">  /// be the constant 5, UserChain[1] will be the subexpression "c + 5", and</td>
    <td class="lineNumber">325</td>
    <td class="codeline">  /// be the constant 5, UserChain[1] will be the subexpression "c + 5", and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="codeline">  /// UserChain[2] will be the entire expression "a * b + (c + 5)".</td>
    <td class="lineNumber">326</td>
    <td class="codeline">  /// UserChain[2] will be the entire expression "a * b + (c + 5)".</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">327</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="codeline">  /// This path helps to rebuild the new GEP index.</td>
    <td class="lineNumber">328</td>
    <td class="codeline">  /// This path helps to rebuild the new GEP index.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="codeline">  SmallVector<User *, 8> UserChain;</td>
    <td class="lineNumber">329</td>
    <td class="codeline">  SmallVector<User *, 8> UserChain;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="codeline"></td>
    <td class="lineNumber">330</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="codeline">  /// A data structure used in rebuildWithoutConstOffset. Contains all</td>
    <td class="lineNumber">331</td>
    <td class="codeline">  /// A data structure used in rebuildWithoutConstOffset. Contains all</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="codeline">  /// sext/zext instructions along UserChain.</td>
    <td class="lineNumber">332</td>
    <td class="codeline">  /// sext/zext instructions along UserChain.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="codeline">  SmallVector<CastInst *, 16> ExtInsts;</td>
    <td class="lineNumber">333</td>
    <td class="codeline">  SmallVector<CastInst *, 16> ExtInsts;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="codeline"></td>
    <td class="lineNumber">334</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="codeline">  /// Insertion position of cloned instructions.</td>
    <td class="lineNumber">335</td>
    <td class="codeline">  /// Insertion position of cloned instructions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="codeline">  Instruction *IP;</td>
    <td class="lineNumber">336</td>
    <td class="codeline">  Instruction *IP;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="codeline"></td>
    <td class="lineNumber">337</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="codeline">  const DataLayout &DL;</td>
    <td class="lineNumber">338</td>
    <td class="codeline">  const DataLayout &DL;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="codeline">  const DominatorTree *DT;</td>
    <td class="lineNumber">339</td>
    <td class="codeline">  const DominatorTree *DT;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="codeline">};</td>
    <td class="lineNumber">340</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="codeline"></td>
    <td class="lineNumber">341</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="codeline">/// A pass that tries to split every GEP in the function into a variadic</td>
    <td class="lineNumber">342</td>
    <td class="codeline">/// A pass that tries to split every GEP in the function into a variadic</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="codeline">/// base and a constant offset. It is a FunctionPass because searching for the</td>
    <td class="lineNumber">343</td>
    <td class="codeline">/// base and a constant offset. It is a FunctionPass because searching for the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="codeline">/// constant offset may inspect other basic blocks.</td>
    <td class="lineNumber">344</td>
    <td class="codeline">/// constant offset may inspect other basic blocks.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="codeline">class SeparateConstOffsetFromGEPLegacyPass : public FunctionPass {</td>
    <td class="lineNumber">345</td>
    <td class="codeline">class SeparateConstOffsetFromGEPLegacyPass : public FunctionPass {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">346</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="codeline">  static char ID;</td>
    <td class="lineNumber">347</td>
    <td class="codeline">  static char ID;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="codeline"></td>
    <td class="lineNumber">348</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="codeline">  SeparateConstOffsetFromGEPLegacyPass(bool LowerGEP = false)</td>
    <td class="lineNumber">349</td>
    <td class="codeline">  SeparateConstOffsetFromGEPLegacyPass(bool LowerGEP = false)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="codeline">      : FunctionPass(ID), LowerGEP(LowerGEP) {</td>
    <td class="lineNumber">350</td>
    <td class="codeline">      : FunctionPass(ID), LowerGEP(LowerGEP) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="codeline">    initializeSeparateConstOffsetFromGEPLegacyPassPass(</td>
    <td class="lineNumber">351</td>
    <td class="codeline">    initializeSeparateConstOffsetFromGEPLegacyPassPass(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="codeline">        *PassRegistry::getPassRegistry());</td>
    <td class="lineNumber">352</td>
    <td class="codeline">        *PassRegistry::getPassRegistry());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">353</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="codeline"></td>
    <td class="lineNumber">354</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="codeline">  void getAnalysisUsage(AnalysisUsage &AU) const override {</td>
    <td class="lineNumber">355</td>
    <td class="codeline">  void getAnalysisUsage(AnalysisUsage &AU) const override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="codeline">    AU.addRequired<DominatorTreeWrapperPass>();</td>
    <td class="lineNumber">356</td>
    <td class="codeline">    AU.addRequired<DominatorTreeWrapperPass>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="codeline">    AU.addRequired<TargetTransformInfoWrapperPass>();</td>
    <td class="lineNumber">357</td>
    <td class="codeline">    AU.addRequired<TargetTransformInfoWrapperPass>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="codeline">    AU.addRequired<LoopInfoWrapperPass>();</td>
    <td class="lineNumber">358</td>
    <td class="codeline">    AU.addRequired<LoopInfoWrapperPass>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="codeline">    AU.setPreservesCFG();</td>
    <td class="lineNumber">359</td>
    <td class="codeline">    AU.setPreservesCFG();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="codeline">    AU.addRequired<TargetLibraryInfoWrapperPass>();</td>
    <td class="lineNumber">360</td>
    <td class="codeline">    AU.addRequired<TargetLibraryInfoWrapperPass>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">361</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="codeline"></td>
    <td class="lineNumber">362</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="codeline">  bool runOnFunction(Function &F) override;</td>
    <td class="lineNumber">363</td>
    <td class="codeline">  bool runOnFunction(Function &F) override;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="codeline"></td>
    <td class="lineNumber">364</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="codeline">private:</td>
    <td class="lineNumber">365</td>
    <td class="codeline">private:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="codeline">  bool LowerGEP;</td>
    <td class="lineNumber">366</td>
    <td class="codeline">  bool LowerGEP;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="codeline">};</td>
    <td class="lineNumber">367</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="codeline"></td>
    <td class="lineNumber">368</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="codeline">/// A pass that tries to split every GEP in the function into a variadic</td>
    <td class="lineNumber">369</td>
    <td class="codeline">/// A pass that tries to split every GEP in the function into a variadic</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="codeline">/// base and a constant offset. It is a FunctionPass because searching for the</td>
    <td class="lineNumber">370</td>
    <td class="codeline">/// base and a constant offset. It is a FunctionPass because searching for the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="codeline">/// constant offset may inspect other basic blocks.</td>
    <td class="lineNumber">371</td>
    <td class="codeline">/// constant offset may inspect other basic blocks.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="codeline">class SeparateConstOffsetFromGEP {</td>
    <td class="lineNumber">372</td>
    <td class="codeline">class SeparateConstOffsetFromGEP {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">373</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="codeline">  SeparateConstOffsetFromGEP(</td>
    <td class="lineNumber">374</td>
    <td class="codeline">  SeparateConstOffsetFromGEP(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="codeline">      DominatorTree *DT, LoopInfo *LI, TargetLibraryInfo *TLI,</td>
    <td class="lineNumber">375</td>
    <td class="codeline">      DominatorTree *DT, LoopInfo *LI, TargetLibraryInfo *TLI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="codeline">      function_ref<TargetTransformInfo &(Function &)> GetTTI, bool LowerGEP)</td>
    <td class="lineNumber">376</td>
    <td class="codeline">      function_ref<TargetTransformInfo &(Function &)> GetTTI, bool LowerGEP)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="codeline">      : DT(DT), LI(LI), TLI(TLI), GetTTI(GetTTI), LowerGEP(LowerGEP) {}</td>
    <td class="lineNumber">377</td>
    <td class="codeline">      : DT(DT), LI(LI), TLI(TLI), GetTTI(GetTTI), LowerGEP(LowerGEP) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="codeline"></td>
    <td class="lineNumber">378</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="codeline">  bool run(Function &F);</td>
    <td class="lineNumber">379</td>
    <td class="codeline">  bool run(Function &F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="codeline"></td>
    <td class="lineNumber">380</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="codeline">private:</td>
    <td class="lineNumber">381</td>
    <td class="codeline">private:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="codeline">  /// Track the operands of an add or sub.</td>
    <td class="lineNumber">382</td>
    <td class="codeline">  /// Track the operands of an add or sub.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="codeline">  using ExprKey = std::pair<Value *, Value *>;</td>
    <td class="lineNumber">383</td>
    <td class="codeline">  using ExprKey = std::pair<Value *, Value *>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="codeline"></td>
    <td class="lineNumber">384</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="codeline">  /// Create a pair for use as a map key for a commutable operation.</td>
    <td class="lineNumber">385</td>
    <td class="codeline">  /// Create a pair for use as a map key for a commutable operation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="codeline">  static ExprKey createNormalizedCommutablePair(Value *A, Value *B) {</td>
    <td class="lineNumber">386</td>
    <td class="codeline">  static ExprKey createNormalizedCommutablePair(Value *A, Value *B) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="codeline">    if (A < B)</td>
    <td class="lineNumber">387</td>
    <td class="codeline">    if (A < B)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="codeline">      return {A, B};</td>
    <td class="lineNumber">388</td>
    <td class="codeline">      return {A, B};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="codeline">    return {B, A};</td>
    <td class="lineNumber">389</td>
    <td class="codeline">    return {B, A};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">390</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="codeline"></td>
    <td class="lineNumber">391</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="codeline">  /// Tries to split the given GEP into a variadic base and a constant offset,</td>
    <td class="lineNumber">392</td>
    <td class="codeline">  /// Tries to split the given GEP into a variadic base and a constant offset,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="codeline">  /// and returns true if the splitting succeeds.</td>
    <td class="lineNumber">393</td>
    <td class="codeline">  /// and returns true if the splitting succeeds.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="codeline">  bool splitGEP(GetElementPtrInst *GEP);</td>
    <td class="lineNumber">394</td>
    <td class="codeline">  bool splitGEP(GetElementPtrInst *GEP);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="codeline"></td>
    <td class="lineNumber">395</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="codeline">  /// Lower a GEP with multiple indices into multiple GEPs with a single index.</td>
    <td class="lineNumber">396</td>
    <td class="codeline">  /// Lower a GEP with multiple indices into multiple GEPs with a single index.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="codeline">  /// Function splitGEP already split the original GEP into a variadic part and</td>
    <td class="lineNumber">397</td>
    <td class="codeline">  /// Function splitGEP already split the original GEP into a variadic part and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="codeline">  /// a constant offset (i.e., AccumulativeByteOffset). This function lowers the</td>
    <td class="lineNumber">398</td>
    <td class="codeline">  /// a constant offset (i.e., AccumulativeByteOffset). This function lowers the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="codeline">  /// variadic part into a set of GEPs with a single index and applies</td>
    <td class="lineNumber">399</td>
    <td class="codeline">  /// variadic part into a set of GEPs with a single index and applies</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="codeline">  /// AccumulativeByteOffset to it.</td>
    <td class="lineNumber">400</td>
    <td class="codeline">  /// AccumulativeByteOffset to it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="codeline">  /// \p Variadic                  The variadic part of the original GEP.</td>
    <td class="lineNumber">401</td>
    <td class="codeline">  /// \p Variadic                  The variadic part of the original GEP.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="codeline">  /// \p AccumulativeByteOffset    The constant offset.</td>
    <td class="lineNumber">402</td>
    <td class="codeline">  /// \p AccumulativeByteOffset    The constant offset.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="codeline">  void lowerToSingleIndexGEPs(GetElementPtrInst *Variadic,</td>
    <td class="lineNumber">403</td>
    <td class="codeline">  void lowerToSingleIndexGEPs(GetElementPtrInst *Variadic,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="codeline">                              int64_t AccumulativeByteOffset);</td>
    <td class="lineNumber">404</td>
    <td class="codeline">                              int64_t AccumulativeByteOffset);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="codeline"></td>
    <td class="lineNumber">405</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="codeline">  /// Lower a GEP with multiple indices into ptrtoint+arithmetics+inttoptr form.</td>
    <td class="lineNumber">406</td>
    <td class="codeline">  /// Lower a GEP with multiple indices into ptrtoint+arithmetics+inttoptr form.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="codeline">  /// Function splitGEP already split the original GEP into a variadic part and</td>
    <td class="lineNumber">407</td>
    <td class="codeline">  /// Function splitGEP already split the original GEP into a variadic part and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="codeline">  /// a constant offset (i.e., AccumulativeByteOffset). This function lowers the</td>
    <td class="lineNumber">408</td>
    <td class="codeline">  /// a constant offset (i.e., AccumulativeByteOffset). This function lowers the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="codeline">  /// variadic part into a set of arithmetic operations and applies</td>
    <td class="lineNumber">409</td>
    <td class="codeline">  /// variadic part into a set of arithmetic operations and applies</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="codeline">  /// AccumulativeByteOffset to it.</td>
    <td class="lineNumber">410</td>
    <td class="codeline">  /// AccumulativeByteOffset to it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="codeline">  /// \p Variadic                  The variadic part of the original GEP.</td>
    <td class="lineNumber">411</td>
    <td class="codeline">  /// \p Variadic                  The variadic part of the original GEP.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="codeline">  /// \p AccumulativeByteOffset    The constant offset.</td>
    <td class="lineNumber">412</td>
    <td class="codeline">  /// \p AccumulativeByteOffset    The constant offset.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="codeline">  void lowerToArithmetics(GetElementPtrInst *Variadic,</td>
    <td class="lineNumber">413</td>
    <td class="codeline">  void lowerToArithmetics(GetElementPtrInst *Variadic,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="codeline">                          int64_t AccumulativeByteOffset);</td>
    <td class="lineNumber">414</td>
    <td class="codeline">                          int64_t AccumulativeByteOffset);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="codeline"></td>
    <td class="lineNumber">415</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="codeline">  /// Finds the constant offset within each index and accumulates them. If</td>
    <td class="lineNumber">416</td>
    <td class="codeline">  /// Finds the constant offset within each index and accumulates them. If</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="codeline">  /// LowerGEP is true, it finds in indices of both sequential and structure</td>
    <td class="lineNumber">417</td>
    <td class="codeline">  /// LowerGEP is true, it finds in indices of both sequential and structure</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="codeline">  /// types, otherwise it only finds in sequential indices. The output</td>
    <td class="lineNumber">418</td>
    <td class="codeline">  /// types, otherwise it only finds in sequential indices. The output</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="codeline">  /// NeedsExtraction indicates whether we successfully find a non-zero constant</td>
    <td class="lineNumber">419</td>
    <td class="codeline">  /// NeedsExtraction indicates whether we successfully find a non-zero constant</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="codeline">  /// offset.</td>
    <td class="lineNumber">420</td>
    <td class="codeline">  /// offset.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="codeline">  int64_t accumulateByteOffset(GetElementPtrInst *GEP, bool &NeedsExtraction);</td>
    <td class="lineNumber">421</td>
    <td class="codeline">  int64_t accumulateByteOffset(GetElementPtrInst *GEP, bool &NeedsExtraction);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="codeline"></td>
    <td class="lineNumber">422</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="codeline">  /// Canonicalize array indices to pointer-size integers. This helps to</td>
    <td class="lineNumber">423</td>
    <td class="codeline">  /// Canonicalize array indices to pointer-size integers. This helps to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="codeline">  /// simplify the logic of splitting a GEP. For example, if a + b is a</td>
    <td class="lineNumber">424</td>
    <td class="codeline">  /// simplify the logic of splitting a GEP. For example, if a + b is a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="codeline">  /// pointer-size integer, we have</td>
    <td class="lineNumber">425</td>
    <td class="codeline">  /// pointer-size integer, we have</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="codeline">  ///   gep base, a + b = gep (gep base, a), b</td>
    <td class="lineNumber">426</td>
    <td class="codeline">  ///   gep base, a + b = gep (gep base, a), b</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="codeline">  /// However, this equality may not hold if the size of a + b is smaller than</td>
    <td class="lineNumber">427</td>
    <td class="codeline">  /// However, this equality may not hold if the size of a + b is smaller than</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="codeline">  /// the pointer size, because LLVM conceptually sign-extends GEP indices to</td>
    <td class="lineNumber">428</td>
    <td class="codeline">  /// the pointer size, because LLVM conceptually sign-extends GEP indices to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="codeline">  /// pointer size before computing the address</td>
    <td class="lineNumber">429</td>
    <td class="codeline">  /// pointer size before computing the address</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="codeline">  /// (http://llvm.org/docs/LangRef.html#id181).</td>
    <td class="lineNumber">430</td>
    <td class="codeline">  /// (http://llvm.org/docs/LangRef.html#id181).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">431</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="codeline">  /// This canonicalization is very likely already done in clang and</td>
    <td class="lineNumber">432</td>
    <td class="codeline">  /// This canonicalization is very likely already done in clang and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="codeline">  /// instcombine. Therefore, the program will probably remain the same.</td>
    <td class="lineNumber">433</td>
    <td class="codeline">  /// instcombine. Therefore, the program will probably remain the same.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">434</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="codeline">  /// Returns true if the module changes.</td>
    <td class="lineNumber">435</td>
    <td class="codeline">  /// Returns true if the module changes.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">436</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="codeline">  /// Verified in @i32_add in split-gep.ll</td>
    <td class="lineNumber">437</td>
    <td class="codeline">  /// Verified in @i32_add in split-gep.ll</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="codeline">  bool canonicalizeArrayIndicesToIndexSize(GetElementPtrInst *GEP);</td>
    <td class="lineNumber">438</td>
    <td class="codeline">  bool canonicalizeArrayIndicesToIndexSize(GetElementPtrInst *GEP);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="codeline"></td>
    <td class="lineNumber">439</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="codeline">  /// Optimize sext(a)+sext(b) to sext(a+b) when a+b can't sign overflow.</td>
    <td class="lineNumber">440</td>
    <td class="codeline">  /// Optimize sext(a)+sext(b) to sext(a+b) when a+b can't sign overflow.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="codeline">  /// SeparateConstOffsetFromGEP distributes a sext to leaves before extracting</td>
    <td class="lineNumber">441</td>
    <td class="codeline">  /// SeparateConstOffsetFromGEP distributes a sext to leaves before extracting</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="codeline">  /// the constant offset. After extraction, it becomes desirable to reunion the</td>
    <td class="lineNumber">442</td>
    <td class="codeline">  /// the constant offset. After extraction, it becomes desirable to reunion the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="codeline">  /// distributed sexts. For example,</td>
    <td class="lineNumber">443</td>
    <td class="codeline">  /// distributed sexts. For example,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">444</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="codeline">  ///                              &a[sext(i +nsw (j +nsw 5)]</td>
    <td class="lineNumber">445</td>
    <td class="codeline">  ///                              &a[sext(i +nsw (j +nsw 5)]</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="codeline">  ///   => distribute              &a[sext(i) +nsw (sext(j) +nsw 5)]</td>
    <td class="lineNumber">446</td>
    <td class="codeline">  ///   => distribute              &a[sext(i) +nsw (sext(j) +nsw 5)]</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="codeline">  ///   => constant extraction     &a[sext(i) + sext(j)] + 5</td>
    <td class="lineNumber">447</td>
    <td class="codeline">  ///   => constant extraction     &a[sext(i) + sext(j)] + 5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="codeline">  ///   => reunion                 &a[sext(i +nsw j)] + 5</td>
    <td class="lineNumber">448</td>
    <td class="codeline">  ///   => reunion                 &a[sext(i +nsw j)] + 5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="codeline">  bool reuniteExts(Function &F);</td>
    <td class="lineNumber">449</td>
    <td class="codeline">  bool reuniteExts(Function &F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="codeline"></td>
    <td class="lineNumber">450</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="codeline">  /// A helper that reunites sexts in an instruction.</td>
    <td class="lineNumber">451</td>
    <td class="codeline">  /// A helper that reunites sexts in an instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="codeline">  bool reuniteExts(Instruction *I);</td>
    <td class="lineNumber">452</td>
    <td class="codeline">  bool reuniteExts(Instruction *I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="codeline"></td>
    <td class="lineNumber">453</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="codeline">  /// Find the closest dominator of <Dominatee> that is equivalent to <Key>.</td>
    <td class="lineNumber">454</td>
    <td class="codeline">  /// Find the closest dominator of <Dominatee> that is equivalent to <Key>.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="codeline">  Instruction *findClosestMatchingDominator(</td>
    <td class="lineNumber">455</td>
    <td class="codeline">  Instruction *findClosestMatchingDominator(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="codeline">      ExprKey Key, Instruction *Dominatee,</td>
    <td class="lineNumber">456</td>
    <td class="codeline">      ExprKey Key, Instruction *Dominatee,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="codeline">      DenseMap<ExprKey, SmallVector<Instruction *, 2>> &DominatingExprs);</td>
    <td class="lineNumber">457</td>
    <td class="codeline">      DenseMap<ExprKey, SmallVector<Instruction *, 2>> &DominatingExprs);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="codeline"></td>
    <td class="lineNumber">458</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="codeline">  /// Verify F is free of dead code.</td>
    <td class="lineNumber">459</td>
    <td class="codeline">  /// Verify F is free of dead code.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="codeline">  void verifyNoDeadCode(Function &F);</td>
    <td class="lineNumber">460</td>
    <td class="codeline">  void verifyNoDeadCode(Function &F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="codeline"></td>
    <td class="lineNumber">461</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="codeline">  bool hasMoreThanOneUseInLoop(Value *v, Loop *L);</td>
    <td class="lineNumber">462</td>
    <td class="codeline">  bool hasMoreThanOneUseInLoop(Value *v, Loop *L);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="codeline"></td>
    <td class="lineNumber">463</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="codeline">  // Swap the index operand of two GEP.</td>
    <td class="lineNumber">464</td>
    <td class="codeline">  // Swap the index operand of two GEP.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="codeline">  void swapGEPOperand(GetElementPtrInst *First, GetElementPtrInst *Second);</td>
    <td class="lineNumber">465</td>
    <td class="codeline">  void swapGEPOperand(GetElementPtrInst *First, GetElementPtrInst *Second);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="codeline"></td>
    <td class="lineNumber">466</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="codeline">  // Check if it is safe to swap operand of two GEP.</td>
    <td class="lineNumber">467</td>
    <td class="codeline">  // Check if it is safe to swap operand of two GEP.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="codeline">  bool isLegalToSwapOperand(GetElementPtrInst *First, GetElementPtrInst *Second,</td>
    <td class="lineNumber">468</td>
    <td class="codeline">  bool isLegalToSwapOperand(GetElementPtrInst *First, GetElementPtrInst *Second,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="codeline">                            Loop *CurLoop);</td>
    <td class="lineNumber">469</td>
    <td class="codeline">                            Loop *CurLoop);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="codeline"></td>
    <td class="lineNumber">470</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="codeline">  const DataLayout *DL = nullptr;</td>
    <td class="lineNumber">471</td>
    <td class="codeline">  const DataLayout *DL = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="codeline">  DominatorTree *DT = nullptr;</td>
    <td class="lineNumber">472</td>
    <td class="codeline">  DominatorTree *DT = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="codeline">  LoopInfo *LI;</td>
    <td class="lineNumber">473</td>
    <td class="codeline">  LoopInfo *LI;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="codeline">  TargetLibraryInfo *TLI;</td>
    <td class="lineNumber">474</td>
    <td class="codeline">  TargetLibraryInfo *TLI;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="codeline">  // Retrieved lazily since not always used.</td>
    <td class="lineNumber">475</td>
    <td class="codeline">  // Retrieved lazily since not always used.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="codeline">  function_ref<TargetTransformInfo &(Function &)> GetTTI;</td>
    <td class="lineNumber">476</td>
    <td class="codeline">  function_ref<TargetTransformInfo &(Function &)> GetTTI;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="codeline"></td>
    <td class="lineNumber">477</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="codeline">  /// Whether to lower a GEP with multiple indices into arithmetic operations or</td>
    <td class="lineNumber">478</td>
    <td class="codeline">  /// Whether to lower a GEP with multiple indices into arithmetic operations or</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="codeline">  /// multiple GEPs with a single index.</td>
    <td class="lineNumber">479</td>
    <td class="codeline">  /// multiple GEPs with a single index.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="codeline">  bool LowerGEP;</td>
    <td class="lineNumber">480</td>
    <td class="codeline">  bool LowerGEP;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="codeline"></td>
    <td class="lineNumber">481</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="codeline">  DenseMap<ExprKey, SmallVector<Instruction *, 2>> DominatingAdds;</td>
    <td class="lineNumber">482</td>
    <td class="codeline">  DenseMap<ExprKey, SmallVector<Instruction *, 2>> DominatingAdds;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="codeline">  DenseMap<ExprKey, SmallVector<Instruction *, 2>> DominatingSubs;</td>
    <td class="lineNumber">483</td>
    <td class="codeline">  DenseMap<ExprKey, SmallVector<Instruction *, 2>> DominatingSubs;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="codeline">};</td>
    <td class="lineNumber">484</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="codeline"></td>
    <td class="lineNumber">485</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="codeline">} // end anonymous namespace</td>
    <td class="lineNumber">486</td>
    <td class="codeline">} // end anonymous namespace</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="codeline"></td>
    <td class="lineNumber">487</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="codeline">char SeparateConstOffsetFromGEPLegacyPass::ID = 0;</td>
    <td class="lineNumber">488</td>
    <td class="codeline">char SeparateConstOffsetFromGEPLegacyPass::ID = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="codeline"></td>
    <td class="lineNumber">489</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="codeline">INITIALIZE_PASS_BEGIN(</td>
    <td class="lineNumber">490</td>
    <td class="codeline">INITIALIZE_PASS_BEGIN(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="codeline">    SeparateConstOffsetFromGEPLegacyPass, "separate-const-offset-from-gep",</td>
    <td class="lineNumber">491</td>
    <td class="codeline">    SeparateConstOffsetFromGEPLegacyPass, "separate-const-offset-from-gep",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="codeline">    "Split GEPs to a variadic base and a constant offset for better CSE", false,</td>
    <td class="lineNumber">492</td>
    <td class="codeline">    "Split GEPs to a variadic base and a constant offset for better CSE", false,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="codeline">    false)</td>
    <td class="lineNumber">493</td>
    <td class="codeline">    false)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(DominatorTreeWrapperPass)</td>
    <td class="lineNumber">494</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(DominatorTreeWrapperPass)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(ScalarEvolutionWrapperPass)</td>
    <td class="lineNumber">495</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(ScalarEvolutionWrapperPass)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(TargetTransformInfoWrapperPass)</td>
    <td class="lineNumber">496</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(TargetTransformInfoWrapperPass)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(LoopInfoWrapperPass)</td>
    <td class="lineNumber">497</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(LoopInfoWrapperPass)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(TargetLibraryInfoWrapperPass)</td>
    <td class="lineNumber">498</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(TargetLibraryInfoWrapperPass)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="codeline">INITIALIZE_PASS_END(</td>
    <td class="lineNumber">499</td>
    <td class="codeline">INITIALIZE_PASS_END(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="codeline">    SeparateConstOffsetFromGEPLegacyPass, "separate-const-offset-from-gep",</td>
    <td class="lineNumber">500</td>
    <td class="codeline">    SeparateConstOffsetFromGEPLegacyPass, "separate-const-offset-from-gep",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="codeline">    "Split GEPs to a variadic base and a constant offset for better CSE", false,</td>
    <td class="lineNumber">501</td>
    <td class="codeline">    "Split GEPs to a variadic base and a constant offset for better CSE", false,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="codeline">    false)</td>
    <td class="lineNumber">502</td>
    <td class="codeline">    false)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="codeline"></td>
    <td class="lineNumber">503</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class="codeline">FunctionPass *llvm::createSeparateConstOffsetFromGEPPass(bool LowerGEP) {</td>
    <td class="lineNumber">504</td>
    <td class="codeline">FunctionPass *llvm::createSeparateConstOffsetFromGEPPass(bool LowerGEP) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="codeline">  return new SeparateConstOffsetFromGEPLegacyPass(LowerGEP);</td>
    <td class="lineNumber">505</td>
    <td class="codeline">  return new SeparateConstOffsetFromGEPLegacyPass(LowerGEP);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="codeline">}</td>
    <td class="lineNumber">506</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="codeline"></td>
    <td class="lineNumber">507</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="codeline">bool ConstantOffsetExtractor::CanTraceInto(bool SignExtended,</td>
    <td class="lineNumber">508</td>
    <td class="codeline">bool ConstantOffsetExtractor::CanTraceInto(bool SignExtended,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="codeline">                                            bool ZeroExtended,</td>
    <td class="lineNumber">509</td>
    <td class="codeline">                                            bool ZeroExtended,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="codeline">                                            BinaryOperator *BO,</td>
    <td class="lineNumber">510</td>
    <td class="codeline">                                            BinaryOperator *BO,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="codeline">                                            bool NonNegative) {</td>
    <td class="lineNumber">511</td>
    <td class="codeline">                                            bool NonNegative) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="codeline">  // We only consider ADD, SUB and OR, because a non-zero constant found in</td>
    <td class="lineNumber">512</td>
    <td class="codeline">  // We only consider ADD, SUB and OR, because a non-zero constant found in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class="codeline">  // expressions composed of these operations can be easily hoisted as a</td>
    <td class="lineNumber">513</td>
    <td class="codeline">  // expressions composed of these operations can be easily hoisted as a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="codeline">  // constant offset by reassociation.</td>
    <td class="lineNumber">514</td>
    <td class="codeline">  // constant offset by reassociation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="codeline">  if (BO->getOpcode() != Instruction::Add &&</td>
    <td class="lineNumber">515</td>
    <td class="codeline">  if (BO->getOpcode() != Instruction::Add &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="codeline">      BO->getOpcode() != Instruction::Sub &&</td>
    <td class="lineNumber">516</td>
    <td class="codeline">      BO->getOpcode() != Instruction::Sub &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class="codeline">      BO->getOpcode() != Instruction::Or) {</td>
    <td class="lineNumber">517</td>
    <td class="codeline">      BO->getOpcode() != Instruction::Or) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">518</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">519</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class="codeline"></td>
    <td class="lineNumber">520</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="codeline">  Value *LHS = BO->getOperand(0), *RHS = BO->getOperand(1);</td>
    <td class="lineNumber">521</td>
    <td class="codeline">  Value *LHS = BO->getOperand(0), *RHS = BO->getOperand(1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="codeline">  // Do not trace into "or" unless it is equivalent to "add". If LHS and RHS</td>
    <td class="lineNumber">522</td>
    <td class="codeline">  // Do not trace into "or" unless it is equivalent to "add". If LHS and RHS</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="codeline">  // don't have common bits, (LHS | RHS) is equivalent to (LHS + RHS).</td>
    <td class="lineNumber">523</td>
    <td class="codeline">  // don't have common bits, (LHS | RHS) is equivalent to (LHS + RHS).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="codeline">  // FIXME: this does not appear to be covered by any tests</td>
    <td class="lineNumber">524</td>
    <td class="codeline">  // FIXME: this does not appear to be covered by any tests</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="codeline">  //        (with x86/aarch64 backends at least)</td>
    <td class="lineNumber">525</td>
    <td class="codeline">  //        (with x86/aarch64 backends at least)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class="codeline">  if (BO->getOpcode() == Instruction::Or &&</td>
    <td class="lineNumber">526</td>
    <td class="codeline">  if (BO->getOpcode() == Instruction::Or &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="codeline">      !haveNoCommonBitsSet(LHS, RHS, DL, nullptr, BO, DT))</td>
    <td class="lineNumber">527</td>
    <td class="codeline">      !haveNoCommonBitsSet(LHS, RHS, DL, nullptr, BO, DT))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">528</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="codeline"></td>
    <td class="lineNumber">529</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="codeline">  // FIXME: We don't currently support constants from the RHS of subs,</td>
    <td class="lineNumber">530</td>
    <td class="codeline">  // FIXME: We don't currently support constants from the RHS of subs,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="codeline">  // when we are zero-extended, because we need a way to zero-extended</td>
    <td class="lineNumber">531</td>
    <td class="codeline">  // when we are zero-extended, because we need a way to zero-extended</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="codeline">  // them before they are negated.</td>
    <td class="lineNumber">532</td>
    <td class="codeline">  // them before they are negated.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class="codeline">  if (ZeroExtended && !SignExtended && BO->getOpcode() == Instruction::Sub)</td>
    <td class="lineNumber">533</td>
    <td class="codeline">  if (ZeroExtended && !SignExtended && BO->getOpcode() == Instruction::Sub)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">534</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="codeline"></td>
    <td class="lineNumber">535</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="codeline">  // In addition, tracing into BO requires that its surrounding s/zext (if</td>
    <td class="lineNumber">536</td>
    <td class="codeline">  // In addition, tracing into BO requires that its surrounding s/zext (if</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="codeline">  // any) is distributable to both operands.</td>
    <td class="lineNumber">537</td>
    <td class="codeline">  // any) is distributable to both operands.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">538</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="codeline">  // Suppose BO = A op B.</td>
    <td class="lineNumber">539</td>
    <td class="codeline">  // Suppose BO = A op B.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class="codeline">  //  SignExtended | ZeroExtended | Distributable?</td>
    <td class="lineNumber">540</td>
    <td class="codeline">  //  SignExtended | ZeroExtended | Distributable?</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="codeline">  // --------------+--------------+----------------------------------</td>
    <td class="lineNumber">541</td>
    <td class="codeline">  // --------------+--------------+----------------------------------</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="codeline">  //       0       |      0       | true because no s/zext exists</td>
    <td class="lineNumber">542</td>
    <td class="codeline">  //       0       |      0       | true because no s/zext exists</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="codeline">  //       0       |      1       | zext(BO) == zext(A) op zext(B)</td>
    <td class="lineNumber">543</td>
    <td class="codeline">  //       0       |      1       | zext(BO) == zext(A) op zext(B)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="codeline">  //       1       |      0       | sext(BO) == sext(A) op sext(B)</td>
    <td class="lineNumber">544</td>
    <td class="codeline">  //       1       |      0       | sext(BO) == sext(A) op sext(B)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="codeline">  //       1       |      1       | zext(sext(BO)) ==</td>
    <td class="lineNumber">545</td>
    <td class="codeline">  //       1       |      1       | zext(sext(BO)) ==</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="codeline">  //               |              |     zext(sext(A)) op zext(sext(B))</td>
    <td class="lineNumber">546</td>
    <td class="codeline">  //               |              |     zext(sext(A)) op zext(sext(B))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="codeline">  if (BO->getOpcode() == Instruction::Add && !ZeroExtended && NonNegative) {</td>
    <td class="lineNumber">547</td>
    <td class="codeline">  if (BO->getOpcode() == Instruction::Add && !ZeroExtended && NonNegative) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="codeline">    // If a + b >= 0 and (a >= 0 or b >= 0), then</td>
    <td class="lineNumber">548</td>
    <td class="codeline">    // If a + b >= 0 and (a >= 0 or b >= 0), then</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="codeline">    //   sext(a + b) = sext(a) + sext(b)</td>
    <td class="lineNumber">549</td>
    <td class="codeline">    //   sext(a + b) = sext(a) + sext(b)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="codeline">    // even if the addition is not marked nsw.</td>
    <td class="lineNumber">550</td>
    <td class="codeline">    // even if the addition is not marked nsw.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="codeline">    //</td>
    <td class="lineNumber">551</td>
    <td class="codeline">    //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="codeline">    // Leveraging this invariant, we can trace into an sext'ed inbound GEP</td>
    <td class="lineNumber">552</td>
    <td class="codeline">    // Leveraging this invariant, we can trace into an sext'ed inbound GEP</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="codeline">    // index if the constant offset is non-negative.</td>
    <td class="lineNumber">553</td>
    <td class="codeline">    // index if the constant offset is non-negative.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="codeline">    //</td>
    <td class="lineNumber">554</td>
    <td class="codeline">    //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="codeline">    // Verified in @sext_add in split-gep.ll.</td>
    <td class="lineNumber">555</td>
    <td class="codeline">    // Verified in @sext_add in split-gep.ll.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="codeline">    if (ConstantInt *ConstLHS = dyn_cast<ConstantInt>(LHS)) {</td>
    <td class="lineNumber">556</td>
    <td class="codeline">    if (ConstantInt *ConstLHS = dyn_cast<ConstantInt>(LHS)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="codeline">      if (!ConstLHS->isNegative())</td>
    <td class="lineNumber">557</td>
    <td class="codeline">      if (!ConstLHS->isNegative())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="codeline">        return true;</td>
    <td class="lineNumber">558</td>
    <td class="codeline">        return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">559</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="codeline">    if (ConstantInt *ConstRHS = dyn_cast<ConstantInt>(RHS)) {</td>
    <td class="lineNumber">560</td>
    <td class="codeline">    if (ConstantInt *ConstRHS = dyn_cast<ConstantInt>(RHS)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="codeline">      if (!ConstRHS->isNegative())</td>
    <td class="lineNumber">561</td>
    <td class="codeline">      if (!ConstRHS->isNegative())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="codeline">        return true;</td>
    <td class="lineNumber">562</td>
    <td class="codeline">        return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">563</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">564</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class="codeline"></td>
    <td class="lineNumber">565</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="codeline">  // sext (add/sub nsw A, B) == add/sub nsw (sext A), (sext B)</td>
    <td class="lineNumber">566</td>
    <td class="codeline">  // sext (add/sub nsw A, B) == add/sub nsw (sext A), (sext B)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="codeline">  // zext (add/sub nuw A, B) == add/sub nuw (zext A), (zext B)</td>
    <td class="lineNumber">567</td>
    <td class="codeline">  // zext (add/sub nuw A, B) == add/sub nuw (zext A), (zext B)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="codeline">  if (BO->getOpcode() == Instruction::Add ||</td>
    <td class="lineNumber">568</td>
    <td class="codeline">  if (BO->getOpcode() == Instruction::Add ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="codeline">      BO->getOpcode() == Instruction::Sub) {</td>
    <td class="lineNumber">569</td>
    <td class="codeline">      BO->getOpcode() == Instruction::Sub) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="codeline">    if (SignExtended && !BO->hasNoSignedWrap())</td>
    <td class="lineNumber">570</td>
    <td class="codeline">    if (SignExtended && !BO->hasNoSignedWrap())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">571</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="codeline">    if (ZeroExtended && !BO->hasNoUnsignedWrap())</td>
    <td class="lineNumber">572</td>
    <td class="codeline">    if (ZeroExtended && !BO->hasNoUnsignedWrap())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">573</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">574</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="codeline"></td>
    <td class="lineNumber">575</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="codeline">  return true;</td>
    <td class="lineNumber">576</td>
    <td class="codeline">  return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="codeline">}</td>
    <td class="lineNumber">577</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="codeline"></td>
    <td class="lineNumber">578</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class="codeline">APInt ConstantOffsetExtractor::findInEitherOperand(BinaryOperator *BO,</td>
    <td class="lineNumber">579</td>
    <td class="codeline">APInt ConstantOffsetExtractor::findInEitherOperand(BinaryOperator *BO,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="codeline">                                                   bool SignExtended,</td>
    <td class="lineNumber">580</td>
    <td class="codeline">                                                   bool SignExtended,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="codeline">                                                   bool ZeroExtended) {</td>
    <td class="lineNumber">581</td>
    <td class="codeline">                                                   bool ZeroExtended) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class="codeline">  // Save off the current height of the chain, in case we need to restore it.</td>
    <td class="lineNumber">582</td>
    <td class="codeline">  // Save off the current height of the chain, in case we need to restore it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="codeline">  size_t ChainLength = UserChain.size();</td>
    <td class="lineNumber">583</td>
    <td class="codeline">  size_t ChainLength = UserChain.size();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="codeline"></td>
    <td class="lineNumber">584</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="codeline">  // BO being non-negative does not shed light on whether its operands are</td>
    <td class="lineNumber">585</td>
    <td class="codeline">  // BO being non-negative does not shed light on whether its operands are</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="codeline">  // non-negative. Clear the NonNegative flag here.</td>
    <td class="lineNumber">586</td>
    <td class="codeline">  // non-negative. Clear the NonNegative flag here.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class="codeline">  APInt ConstantOffset = find(BO->getOperand(0), SignExtended, ZeroExtended,</td>
    <td class="lineNumber">587</td>
    <td class="codeline">  APInt ConstantOffset = find(BO->getOperand(0), SignExtended, ZeroExtended,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="codeline">                              /* NonNegative */ false);</td>
    <td class="lineNumber">588</td>
    <td class="codeline">                              /* NonNegative */ false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="codeline">  // If we found a constant offset in the left operand, stop and return that.</td>
    <td class="lineNumber">589</td>
    <td class="codeline">  // If we found a constant offset in the left operand, stop and return that.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class="codeline">  // This shortcut might cause us to miss opportunities of combining the</td>
    <td class="lineNumber">590</td>
    <td class="codeline">  // This shortcut might cause us to miss opportunities of combining the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="codeline">  // constant offsets in both operands, e.g., (a + 4) + (b + 5) => (a + b) + 9.</td>
    <td class="lineNumber">591</td>
    <td class="codeline">  // constant offsets in both operands, e.g., (a + 4) + (b + 5) => (a + b) + 9.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="codeline">  // However, such cases are probably already handled by -instcombine,</td>
    <td class="lineNumber">592</td>
    <td class="codeline">  // However, such cases are probably already handled by -instcombine,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="codeline">  // given this pass runs after the standard optimizations.</td>
    <td class="lineNumber">593</td>
    <td class="codeline">  // given this pass runs after the standard optimizations.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="codeline">  if (ConstantOffset != 0) return ConstantOffset;</td>
    <td class="lineNumber">594</td>
    <td class="codeline">  if (ConstantOffset != 0) return ConstantOffset;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="codeline"></td>
    <td class="lineNumber">595</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="codeline">  // Reset the chain back to where it was when we started exploring this node,</td>
    <td class="lineNumber">596</td>
    <td class="codeline">  // Reset the chain back to where it was when we started exploring this node,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class="codeline">  // since visiting the LHS didn't pan out.</td>
    <td class="lineNumber">597</td>
    <td class="codeline">  // since visiting the LHS didn't pan out.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="codeline">  UserChain.resize(ChainLength);</td>
    <td class="lineNumber">598</td>
    <td class="codeline">  UserChain.resize(ChainLength);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="codeline"></td>
    <td class="lineNumber">599</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="codeline">  ConstantOffset = find(BO->getOperand(1), SignExtended, ZeroExtended,</td>
    <td class="lineNumber">600</td>
    <td class="codeline">  ConstantOffset = find(BO->getOperand(1), SignExtended, ZeroExtended,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="codeline">                        /* NonNegative */ false);</td>
    <td class="lineNumber">601</td>
    <td class="codeline">                        /* NonNegative */ false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="codeline">  // If U is a sub operator, negate the constant offset found in the right</td>
    <td class="lineNumber">602</td>
    <td class="codeline">  // If U is a sub operator, negate the constant offset found in the right</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="codeline">  // operand.</td>
    <td class="lineNumber">603</td>
    <td class="codeline">  // operand.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="codeline">  if (BO->getOpcode() == Instruction::Sub)</td>
    <td class="lineNumber">604</td>
    <td class="codeline">  if (BO->getOpcode() == Instruction::Sub)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="codeline">    ConstantOffset = -ConstantOffset;</td>
    <td class="lineNumber">605</td>
    <td class="codeline">    ConstantOffset = -ConstantOffset;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="codeline"></td>
    <td class="lineNumber">606</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="codeline">  // If RHS wasn't a suitable candidate either, reset the chain again.</td>
    <td class="lineNumber">607</td>
    <td class="codeline">  // If RHS wasn't a suitable candidate either, reset the chain again.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="codeline">  if (ConstantOffset == 0)</td>
    <td class="lineNumber">608</td>
    <td class="codeline">  if (ConstantOffset == 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="codeline">    UserChain.resize(ChainLength);</td>
    <td class="lineNumber">609</td>
    <td class="codeline">    UserChain.resize(ChainLength);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="codeline"></td>
    <td class="lineNumber">610</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="codeline">  return ConstantOffset;</td>
    <td class="lineNumber">611</td>
    <td class="codeline">  return ConstantOffset;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="codeline">}</td>
    <td class="lineNumber">612</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class="codeline"></td>
    <td class="lineNumber">613</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class="codeline">APInt ConstantOffsetExtractor::find(Value *V, bool SignExtended,</td>
    <td class="lineNumber">614</td>
    <td class="codeline">APInt ConstantOffsetExtractor::find(Value *V, bool SignExtended,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="codeline">                                    bool ZeroExtended, bool NonNegative) {</td>
    <td class="lineNumber">615</td>
    <td class="codeline">                                    bool ZeroExtended, bool NonNegative) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="codeline">  // TODO(jingyue): We could trace into integer/pointer casts, such as</td>
    <td class="lineNumber">616</td>
    <td class="codeline">  // TODO(jingyue): We could trace into integer/pointer casts, such as</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="codeline">  // inttoptr, ptrtoint, bitcast, and addrspacecast. We choose to handle only</td>
    <td class="lineNumber">617</td>
    <td class="codeline">  // inttoptr, ptrtoint, bitcast, and addrspacecast. We choose to handle only</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class="codeline">  // integers because it gives good enough results for our benchmarks.</td>
    <td class="lineNumber">618</td>
    <td class="codeline">  // integers because it gives good enough results for our benchmarks.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="codeline">  unsigned BitWidth = cast<IntegerType>(V->getType())->getBitWidth();</td>
    <td class="lineNumber">619</td>
    <td class="codeline">  unsigned BitWidth = cast<IntegerType>(V->getType())->getBitWidth();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="codeline"></td>
    <td class="lineNumber">620</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class="codeline">  // We cannot do much with Values that are not a User, such as an Argument.</td>
    <td class="lineNumber">621</td>
    <td class="codeline">  // We cannot do much with Values that are not a User, such as an Argument.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="codeline">  User *U = dyn_cast<User>(V);</td>
    <td class="lineNumber">622</td>
    <td class="codeline">  User *U = dyn_cast<User>(V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="codeline">  if (U == nullptr) return APInt(BitWidth, 0);</td>
    <td class="lineNumber">623</td>
    <td class="codeline">  if (U == nullptr) return APInt(BitWidth, 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="codeline"></td>
    <td class="lineNumber">624</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="codeline">  APInt ConstantOffset(BitWidth, 0);</td>
    <td class="lineNumber">625</td>
    <td class="codeline">  APInt ConstantOffset(BitWidth, 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="codeline">  if (ConstantInt *CI = dyn_cast<ConstantInt>(V)) {</td>
    <td class="lineNumber">626</td>
    <td class="codeline">  if (ConstantInt *CI = dyn_cast<ConstantInt>(V)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="codeline">    // Hooray, we found it!</td>
    <td class="lineNumber">627</td>
    <td class="codeline">    // Hooray, we found it!</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class="codeline">    ConstantOffset = CI->getValue();</td>
    <td class="lineNumber">628</td>
    <td class="codeline">    ConstantOffset = CI->getValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="codeline">  } else if (BinaryOperator *BO = dyn_cast<BinaryOperator>(V)) {</td>
    <td class="lineNumber">629</td>
    <td class="codeline">  } else if (BinaryOperator *BO = dyn_cast<BinaryOperator>(V)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class="codeline">    // Trace into subexpressions for more hoisting opportunities.</td>
    <td class="lineNumber">630</td>
    <td class="codeline">    // Trace into subexpressions for more hoisting opportunities.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="codeline">    if (CanTraceInto(SignExtended, ZeroExtended, BO, NonNegative))</td>
    <td class="lineNumber">631</td>
    <td class="codeline">    if (CanTraceInto(SignExtended, ZeroExtended, BO, NonNegative))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="codeline">      ConstantOffset = findInEitherOperand(BO, SignExtended, ZeroExtended);</td>
    <td class="lineNumber">632</td>
    <td class="codeline">      ConstantOffset = findInEitherOperand(BO, SignExtended, ZeroExtended);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="codeline">  } else if (isa<TruncInst>(V)) {</td>
    <td class="lineNumber">633</td>
    <td class="codeline">  } else if (isa<TruncInst>(V)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="codeline">    ConstantOffset =</td>
    <td class="lineNumber">634</td>
    <td class="codeline">    ConstantOffset =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="codeline">        find(U->getOperand(0), SignExtended, ZeroExtended, NonNegative)</td>
    <td class="lineNumber">635</td>
    <td class="codeline">        find(U->getOperand(0), SignExtended, ZeroExtended, NonNegative)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="codeline">            .trunc(BitWidth);</td>
    <td class="lineNumber">636</td>
    <td class="codeline">            .trunc(BitWidth);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="codeline">  } else if (isa<SExtInst>(V)) {</td>
    <td class="lineNumber">637</td>
    <td class="codeline">  } else if (isa<SExtInst>(V)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="codeline">    ConstantOffset = find(U->getOperand(0), /* SignExtended */ true,</td>
    <td class="lineNumber">638</td>
    <td class="codeline">    ConstantOffset = find(U->getOperand(0), /* SignExtended */ true,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="codeline">                          ZeroExtended, NonNegative).sext(BitWidth);</td>
    <td class="lineNumber">639</td>
    <td class="codeline">                          ZeroExtended, NonNegative).sext(BitWidth);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="codeline">  } else if (isa<ZExtInst>(V)) {</td>
    <td class="lineNumber">640</td>
    <td class="codeline">  } else if (isa<ZExtInst>(V)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="codeline">    // As an optimization, we can clear the SignExtended flag because</td>
    <td class="lineNumber">641</td>
    <td class="codeline">    // As an optimization, we can clear the SignExtended flag because</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="codeline">    // sext(zext(a)) = zext(a). Verified in @sext_zext in split-gep.ll.</td>
    <td class="lineNumber">642</td>
    <td class="codeline">    // sext(zext(a)) = zext(a). Verified in @sext_zext in split-gep.ll.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="codeline">    //</td>
    <td class="lineNumber">643</td>
    <td class="codeline">    //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class="codeline">    // Clear the NonNegative flag, because zext(a) >= 0 does not imply a >= 0.</td>
    <td class="lineNumber">644</td>
    <td class="codeline">    // Clear the NonNegative flag, because zext(a) >= 0 does not imply a >= 0.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="codeline">    ConstantOffset =</td>
    <td class="lineNumber">645</td>
    <td class="codeline">    ConstantOffset =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="codeline">        find(U->getOperand(0), /* SignExtended */ false,</td>
    <td class="lineNumber">646</td>
    <td class="codeline">        find(U->getOperand(0), /* SignExtended */ false,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="codeline">             /* ZeroExtended */ true, /* NonNegative */ false).zext(BitWidth);</td>
    <td class="lineNumber">647</td>
    <td class="codeline">             /* ZeroExtended */ true, /* NonNegative */ false).zext(BitWidth);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">648</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="codeline"></td>
    <td class="lineNumber">649</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="codeline">  // If we found a non-zero constant offset, add it to the path for</td>
    <td class="lineNumber">650</td>
    <td class="codeline">  // If we found a non-zero constant offset, add it to the path for</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="codeline">  // rebuildWithoutConstOffset. Zero is a valid constant offset, but doesn't</td>
    <td class="lineNumber">651</td>
    <td class="codeline">  // rebuildWithoutConstOffset. Zero is a valid constant offset, but doesn't</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="codeline">  // help this optimization.</td>
    <td class="lineNumber">652</td>
    <td class="codeline">  // help this optimization.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="codeline">  if (ConstantOffset != 0)</td>
    <td class="lineNumber">653</td>
    <td class="codeline">  if (ConstantOffset != 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="codeline">    UserChain.push_back(U);</td>
    <td class="lineNumber">654</td>
    <td class="codeline">    UserChain.push_back(U);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="codeline">  return ConstantOffset;</td>
    <td class="lineNumber">655</td>
    <td class="codeline">  return ConstantOffset;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="codeline">}</td>
    <td class="lineNumber">656</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class="codeline"></td>
    <td class="lineNumber">657</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="codeline">Value *ConstantOffsetExtractor::applyExts(Value *V) {</td>
    <td class="lineNumber">658</td>
    <td class="codeline">Value *ConstantOffsetExtractor::applyExts(Value *V) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="codeline">  Value *Current = V;</td>
    <td class="lineNumber">659</td>
    <td class="codeline">  Value *Current = V;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="codeline">  // ExtInsts is built in the use-def order. Therefore, we apply them to V</td>
    <td class="lineNumber">660</td>
    <td class="codeline">  // ExtInsts is built in the use-def order. Therefore, we apply them to V</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="codeline">  // in the reversed order.</td>
    <td class="lineNumber">661</td>
    <td class="codeline">  // in the reversed order.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="codeline">  for (CastInst *I : llvm::reverse(ExtInsts)) {</td>
    <td class="lineNumber">662</td>
    <td class="codeline">  for (CastInst *I : llvm::reverse(ExtInsts)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="codeline">    if (Constant *C = dyn_cast<Constant>(Current)) {</td>
    <td class="lineNumber">663</td>
    <td class="codeline">    if (Constant *C = dyn_cast<Constant>(Current)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="codeline">      // If Current is a constant, apply s/zext using ConstantExpr::getCast.</td>
    <td class="lineNumber">664</td>
    <td class="codeline">      // If Current is a constant, apply s/zext using ConstantExpr::getCast.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="codeline">      // ConstantExpr::getCast emits a ConstantInt if C is a ConstantInt.</td>
    <td class="lineNumber">665</td>
    <td class="codeline">      // ConstantExpr::getCast emits a ConstantInt if C is a ConstantInt.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="codeline">      Current = ConstantExpr::getCast(I->getOpcode(), C, I->getType());</td>
    <td class="lineNumber">666</td>
    <td class="codeline">      Current = ConstantExpr::getCast(I->getOpcode(), C, I->getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="codeline">    } else {</td>
    <td class="lineNumber">667</td>
    <td class="codeline">    } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="codeline">      Instruction *Ext = I->clone();</td>
    <td class="lineNumber">668</td>
    <td class="codeline">      Instruction *Ext = I->clone();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="codeline">      Ext->setOperand(0, Current);</td>
    <td class="lineNumber">669</td>
    <td class="codeline">      Ext->setOperand(0, Current);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="codeline">      Ext->insertBefore(IP);</td>
    <td class="lineNumber">670</td>
    <td class="codeline">      Ext->insertBefore(IP);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="codeline">      Current = Ext;</td>
    <td class="lineNumber">671</td>
    <td class="codeline">      Current = Ext;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">672</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">673</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="codeline">  return Current;</td>
    <td class="lineNumber">674</td>
    <td class="codeline">  return Current;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class="codeline">}</td>
    <td class="lineNumber">675</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class="codeline"></td>
    <td class="lineNumber">676</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="codeline">Value *ConstantOffsetExtractor::rebuildWithoutConstOffset() {</td>
    <td class="lineNumber">677</td>
    <td class="codeline">Value *ConstantOffsetExtractor::rebuildWithoutConstOffset() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="codeline">  distributeExtsAndCloneChain(UserChain.size() - 1);</td>
    <td class="lineNumber">678</td>
    <td class="codeline">  distributeExtsAndCloneChain(UserChain.size() - 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="codeline">  // Remove all nullptrs (used to be s/zext) from UserChain.</td>
    <td class="lineNumber">679</td>
    <td class="codeline">  // Remove all nullptrs (used to be s/zext) from UserChain.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="codeline">  unsigned NewSize = 0;</td>
    <td class="lineNumber">680</td>
    <td class="codeline">  unsigned NewSize = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="codeline">  for (User *I : UserChain) {</td>
    <td class="lineNumber">681</td>
    <td class="codeline">  for (User *I : UserChain) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="codeline">    if (I != nullptr) {</td>
    <td class="lineNumber">682</td>
    <td class="codeline">    if (I != nullptr) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class="codeline">      UserChain[NewSize] = I;</td>
    <td class="lineNumber">683</td>
    <td class="codeline">      UserChain[NewSize] = I;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="codeline">      NewSize++;</td>
    <td class="lineNumber">684</td>
    <td class="codeline">      NewSize++;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">685</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">686</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="codeline">  UserChain.resize(NewSize);</td>
    <td class="lineNumber">687</td>
    <td class="codeline">  UserChain.resize(NewSize);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class="codeline">  return removeConstOffset(UserChain.size() - 1);</td>
    <td class="lineNumber">688</td>
    <td class="codeline">  return removeConstOffset(UserChain.size() - 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class="codeline">}</td>
    <td class="lineNumber">689</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class="codeline"></td>
    <td class="lineNumber">690</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class="codeline">Value *</td>
    <td class="lineNumber">691</td>
    <td class="codeline">Value *</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="codeline">ConstantOffsetExtractor::distributeExtsAndCloneChain(unsigned ChainIndex) {</td>
    <td class="lineNumber">692</td>
    <td class="codeline">ConstantOffsetExtractor::distributeExtsAndCloneChain(unsigned ChainIndex) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class="codeline">  User *U = UserChain[ChainIndex];</td>
    <td class="lineNumber">693</td>
    <td class="codeline">  User *U = UserChain[ChainIndex];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class="codeline">  if (ChainIndex == 0) {</td>
    <td class="lineNumber">694</td>
    <td class="codeline">  if (ChainIndex == 0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="codeline">    assert(isa<ConstantInt>(U));</td>
    <td class="lineNumber">695</td>
    <td class="codeline">    assert(isa<ConstantInt>(U));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="codeline">    // If U is a ConstantInt, applyExts will return a ConstantInt as well.</td>
    <td class="lineNumber">696</td>
    <td class="codeline">    // If U is a ConstantInt, applyExts will return a ConstantInt as well.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class="codeline">    return UserChain[ChainIndex] = cast<ConstantInt>(applyExts(U));</td>
    <td class="lineNumber">697</td>
    <td class="codeline">    return UserChain[ChainIndex] = cast<ConstantInt>(applyExts(U));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">698</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class="codeline"></td>
    <td class="lineNumber">699</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="codeline">  if (CastInst *Cast = dyn_cast<CastInst>(U)) {</td>
    <td class="lineNumber">700</td>
    <td class="codeline">  if (CastInst *Cast = dyn_cast<CastInst>(U)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="codeline">    assert(</td>
    <td class="lineNumber">701</td>
    <td class="codeline">    assert(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class="codeline">        (isa<SExtInst>(Cast) || isa<ZExtInst>(Cast) || isa<TruncInst>(Cast)) &&</td>
    <td class="lineNumber">702</td>
    <td class="codeline">        (isa<SExtInst>(Cast) || isa<ZExtInst>(Cast) || isa<TruncInst>(Cast)) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="codeline">        "Only following instructions can be traced: sext, zext & trunc");</td>
    <td class="lineNumber">703</td>
    <td class="codeline">        "Only following instructions can be traced: sext, zext & trunc");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class="codeline">    ExtInsts.push_back(Cast);</td>
    <td class="lineNumber">704</td>
    <td class="codeline">    ExtInsts.push_back(Cast);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="codeline">    UserChain[ChainIndex] = nullptr;</td>
    <td class="lineNumber">705</td>
    <td class="codeline">    UserChain[ChainIndex] = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class="codeline">    return distributeExtsAndCloneChain(ChainIndex - 1);</td>
    <td class="lineNumber">706</td>
    <td class="codeline">    return distributeExtsAndCloneChain(ChainIndex - 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">707</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class="codeline"></td>
    <td class="lineNumber">708</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class="codeline">  // Function find only trace into BinaryOperator and CastInst.</td>
    <td class="lineNumber">709</td>
    <td class="codeline">  // Function find only trace into BinaryOperator and CastInst.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="codeline">  BinaryOperator *BO = cast<BinaryOperator>(U);</td>
    <td class="lineNumber">710</td>
    <td class="codeline">  BinaryOperator *BO = cast<BinaryOperator>(U);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class="codeline">  // OpNo = which operand of BO is UserChain[ChainIndex - 1]</td>
    <td class="lineNumber">711</td>
    <td class="codeline">  // OpNo = which operand of BO is UserChain[ChainIndex - 1]</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class="codeline">  unsigned OpNo = (BO->getOperand(0) == UserChain[ChainIndex - 1] ? 0 : 1);</td>
    <td class="lineNumber">712</td>
    <td class="codeline">  unsigned OpNo = (BO->getOperand(0) == UserChain[ChainIndex - 1] ? 0 : 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="codeline">  Value *TheOther = applyExts(BO->getOperand(1 - OpNo));</td>
    <td class="lineNumber">713</td>
    <td class="codeline">  Value *TheOther = applyExts(BO->getOperand(1 - OpNo));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="codeline">  Value *NextInChain = distributeExtsAndCloneChain(ChainIndex - 1);</td>
    <td class="lineNumber">714</td>
    <td class="codeline">  Value *NextInChain = distributeExtsAndCloneChain(ChainIndex - 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="codeline"></td>
    <td class="lineNumber">715</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="codeline">  BinaryOperator *NewBO = nullptr;</td>
    <td class="lineNumber">716</td>
    <td class="codeline">  BinaryOperator *NewBO = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class="codeline">  if (OpNo == 0) {</td>
    <td class="lineNumber">717</td>
    <td class="codeline">  if (OpNo == 0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class="codeline">    NewBO = BinaryOperator::Create(BO->getOpcode(), NextInChain, TheOther,</td>
    <td class="lineNumber">718</td>
    <td class="codeline">    NewBO = BinaryOperator::Create(BO->getOpcode(), NextInChain, TheOther,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class="codeline">                                   BO->getName(), IP);</td>
    <td class="lineNumber">719</td>
    <td class="codeline">                                   BO->getName(), IP);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">720</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="codeline">    NewBO = BinaryOperator::Create(BO->getOpcode(), TheOther, NextInChain,</td>
    <td class="lineNumber">721</td>
    <td class="codeline">    NewBO = BinaryOperator::Create(BO->getOpcode(), TheOther, NextInChain,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class="codeline">                                   BO->getName(), IP);</td>
    <td class="lineNumber">722</td>
    <td class="codeline">                                   BO->getName(), IP);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">723</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class="codeline">  return UserChain[ChainIndex] = NewBO;</td>
    <td class="lineNumber">724</td>
    <td class="codeline">  return UserChain[ChainIndex] = NewBO;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="codeline">}</td>
    <td class="lineNumber">725</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class="codeline"></td>
    <td class="lineNumber">726</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class="codeline">Value *ConstantOffsetExtractor::removeConstOffset(unsigned ChainIndex) {</td>
    <td class="lineNumber">727</td>
    <td class="codeline">Value *ConstantOffsetExtractor::removeConstOffset(unsigned ChainIndex) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class="codeline">  if (ChainIndex == 0) {</td>
    <td class="lineNumber">728</td>
    <td class="codeline">  if (ChainIndex == 0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="codeline">    assert(isa<ConstantInt>(UserChain[ChainIndex]));</td>
    <td class="lineNumber">729</td>
    <td class="codeline">    assert(isa<ConstantInt>(UserChain[ChainIndex]));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class="codeline">    return ConstantInt::getNullValue(UserChain[ChainIndex]->getType());</td>
    <td class="lineNumber">730</td>
    <td class="codeline">    return ConstantInt::getNullValue(UserChain[ChainIndex]->getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">731</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class="codeline"></td>
    <td class="lineNumber">732</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="codeline">  BinaryOperator *BO = cast<BinaryOperator>(UserChain[ChainIndex]);</td>
    <td class="lineNumber">733</td>
    <td class="codeline">  BinaryOperator *BO = cast<BinaryOperator>(UserChain[ChainIndex]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="codeline">  assert((BO->use_empty() || BO->hasOneUse()) &&</td>
    <td class="lineNumber">734</td>
    <td class="codeline">  assert((BO->use_empty() || BO->hasOneUse()) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class="codeline">         "distributeExtsAndCloneChain clones each BinaryOperator in "</td>
    <td class="lineNumber">735</td>
    <td class="codeline">         "distributeExtsAndCloneChain clones each BinaryOperator in "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class="codeline">         "UserChain, so no one should be used more than "</td>
    <td class="lineNumber">736</td>
    <td class="codeline">         "UserChain, so no one should be used more than "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class="codeline">         "once");</td>
    <td class="lineNumber">737</td>
    <td class="codeline">         "once");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class="codeline"></td>
    <td class="lineNumber">738</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class="codeline">  unsigned OpNo = (BO->getOperand(0) == UserChain[ChainIndex - 1] ? 0 : 1);</td>
    <td class="lineNumber">739</td>
    <td class="codeline">  unsigned OpNo = (BO->getOperand(0) == UserChain[ChainIndex - 1] ? 0 : 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="codeline">  assert(BO->getOperand(OpNo) == UserChain[ChainIndex - 1]);</td>
    <td class="lineNumber">740</td>
    <td class="codeline">  assert(BO->getOperand(OpNo) == UserChain[ChainIndex - 1]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class="codeline">  Value *NextInChain = removeConstOffset(ChainIndex - 1);</td>
    <td class="lineNumber">741</td>
    <td class="codeline">  Value *NextInChain = removeConstOffset(ChainIndex - 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class="codeline">  Value *TheOther = BO->getOperand(1 - OpNo);</td>
    <td class="lineNumber">742</td>
    <td class="codeline">  Value *TheOther = BO->getOperand(1 - OpNo);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class="codeline"></td>
    <td class="lineNumber">743</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="codeline">  // If NextInChain is 0 and not the LHS of a sub, we can simplify the</td>
    <td class="lineNumber">744</td>
    <td class="codeline">  // If NextInChain is 0 and not the LHS of a sub, we can simplify the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="codeline">  // sub-expression to be just TheOther.</td>
    <td class="lineNumber">745</td>
    <td class="codeline">  // sub-expression to be just TheOther.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class="codeline">  if (ConstantInt *CI = dyn_cast<ConstantInt>(NextInChain)) {</td>
    <td class="lineNumber">746</td>
    <td class="codeline">  if (ConstantInt *CI = dyn_cast<ConstantInt>(NextInChain)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class="codeline">    if (CI->isZero() && !(BO->getOpcode() == Instruction::Sub && OpNo == 0))</td>
    <td class="lineNumber">747</td>
    <td class="codeline">    if (CI->isZero() && !(BO->getOpcode() == Instruction::Sub && OpNo == 0))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="codeline">      return TheOther;</td>
    <td class="lineNumber">748</td>
    <td class="codeline">      return TheOther;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">749</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="codeline"></td>
    <td class="lineNumber">750</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class="codeline">  BinaryOperator::BinaryOps NewOp = BO->getOpcode();</td>
    <td class="lineNumber">751</td>
    <td class="codeline">  BinaryOperator::BinaryOps NewOp = BO->getOpcode();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class="codeline">  if (BO->getOpcode() == Instruction::Or) {</td>
    <td class="lineNumber">752</td>
    <td class="codeline">  if (BO->getOpcode() == Instruction::Or) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class="codeline">    // Rebuild "or" as "add", because "or" may be invalid for the new</td>
    <td class="lineNumber">753</td>
    <td class="codeline">    // Rebuild "or" as "add", because "or" may be invalid for the new</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class="codeline">    // expression.</td>
    <td class="lineNumber">754</td>
    <td class="codeline">    // expression.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class="codeline">    //</td>
    <td class="lineNumber">755</td>
    <td class="codeline">    //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="codeline">    // For instance, given</td>
    <td class="lineNumber">756</td>
    <td class="codeline">    // For instance, given</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="codeline">    //   a | (b + 5) where a and b + 5 have no common bits,</td>
    <td class="lineNumber">757</td>
    <td class="codeline">    //   a | (b + 5) where a and b + 5 have no common bits,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="codeline">    // we can extract 5 as the constant offset.</td>
    <td class="lineNumber">758</td>
    <td class="codeline">    // we can extract 5 as the constant offset.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="codeline">    //</td>
    <td class="lineNumber">759</td>
    <td class="codeline">    //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class="codeline">    // However, reusing the "or" in the new index would give us</td>
    <td class="lineNumber">760</td>
    <td class="codeline">    // However, reusing the "or" in the new index would give us</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class="codeline">    //   (a | b) + 5</td>
    <td class="lineNumber">761</td>
    <td class="codeline">    //   (a | b) + 5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class="codeline">    // which does not equal a | (b + 5).</td>
    <td class="lineNumber">762</td>
    <td class="codeline">    // which does not equal a | (b + 5).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="codeline">    //</td>
    <td class="lineNumber">763</td>
    <td class="codeline">    //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class="codeline">    // Replacing the "or" with "add" is fine, because</td>
    <td class="lineNumber">764</td>
    <td class="codeline">    // Replacing the "or" with "add" is fine, because</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class="codeline">    //   a | (b + 5) = a + (b + 5) = (a + b) + 5</td>
    <td class="lineNumber">765</td>
    <td class="codeline">    //   a | (b + 5) = a + (b + 5) = (a + b) + 5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class="codeline">    NewOp = Instruction::Add;</td>
    <td class="lineNumber">766</td>
    <td class="codeline">    NewOp = Instruction::Add;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">767</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class="codeline"></td>
    <td class="lineNumber">768</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="codeline">  BinaryOperator *NewBO;</td>
    <td class="lineNumber">769</td>
    <td class="codeline">  BinaryOperator *NewBO;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="codeline">  if (OpNo == 0) {</td>
    <td class="lineNumber">770</td>
    <td class="codeline">  if (OpNo == 0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class="codeline">    NewBO = BinaryOperator::Create(NewOp, NextInChain, TheOther, "", IP);</td>
    <td class="lineNumber">771</td>
    <td class="codeline">    NewBO = BinaryOperator::Create(NewOp, NextInChain, TheOther, "", IP);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">772</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class="codeline">    NewBO = BinaryOperator::Create(NewOp, TheOther, NextInChain, "", IP);</td>
    <td class="lineNumber">773</td>
    <td class="codeline">    NewBO = BinaryOperator::Create(NewOp, TheOther, NextInChain, "", IP);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">774</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class="codeline">  NewBO->takeName(BO);</td>
    <td class="lineNumber">775</td>
    <td class="codeline">  NewBO->takeName(BO);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class="codeline">  return NewBO;</td>
    <td class="lineNumber">776</td>
    <td class="codeline">  return NewBO;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="codeline">}</td>
    <td class="lineNumber">777</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class="codeline"></td>
    <td class="lineNumber">778</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="codeline">Value *ConstantOffsetExtractor::Extract(Value *Idx, GetElementPtrInst *GEP,</td>
    <td class="lineNumber">779</td>
    <td class="codeline">Value *ConstantOffsetExtractor::Extract(Value *Idx, GetElementPtrInst *GEP,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class="codeline">                                        User *&UserChainTail,</td>
    <td class="lineNumber">780</td>
    <td class="codeline">                                        User *&UserChainTail,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class="codeline">                                        const DominatorTree *DT) {</td>
    <td class="lineNumber">781</td>
    <td class="codeline">                                        const DominatorTree *DT) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="codeline">  ConstantOffsetExtractor Extractor(GEP, DT);</td>
    <td class="lineNumber">782</td>
    <td class="codeline">  ConstantOffsetExtractor Extractor(GEP, DT);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="codeline">  // Find a non-zero constant offset first.</td>
    <td class="lineNumber">783</td>
    <td class="codeline">  // Find a non-zero constant offset first.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class="codeline">  APInt ConstantOffset =</td>
    <td class="lineNumber">784</td>
    <td class="codeline">  APInt ConstantOffset =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class="codeline">      Extractor.find(Idx, /* SignExtended */ false, /* ZeroExtended */ false,</td>
    <td class="lineNumber">785</td>
    <td class="codeline">      Extractor.find(Idx, /* SignExtended */ false, /* ZeroExtended */ false,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class="codeline">                     GEP->isInBounds());</td>
    <td class="lineNumber">786</td>
    <td class="codeline">                     GEP->isInBounds());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class="codeline">  if (ConstantOffset == 0) {</td>
    <td class="lineNumber">787</td>
    <td class="codeline">  if (ConstantOffset == 0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="codeline">    UserChainTail = nullptr;</td>
    <td class="lineNumber">788</td>
    <td class="codeline">    UserChainTail = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class="codeline">    return nullptr;</td>
    <td class="lineNumber">789</td>
    <td class="codeline">    return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">790</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class="codeline">  // Separates the constant offset from the GEP index.</td>
    <td class="lineNumber">791</td>
    <td class="codeline">  // Separates the constant offset from the GEP index.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class="codeline">  Value *IdxWithoutConstOffset = Extractor.rebuildWithoutConstOffset();</td>
    <td class="lineNumber">792</td>
    <td class="codeline">  Value *IdxWithoutConstOffset = Extractor.rebuildWithoutConstOffset();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="codeline">  UserChainTail = Extractor.UserChain.back();</td>
    <td class="lineNumber">793</td>
    <td class="codeline">  UserChainTail = Extractor.UserChain.back();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class="codeline">  return IdxWithoutConstOffset;</td>
    <td class="lineNumber">794</td>
    <td class="codeline">  return IdxWithoutConstOffset;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="codeline">}</td>
    <td class="lineNumber">795</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class="codeline"></td>
    <td class="lineNumber">796</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class="codeline">int64_t ConstantOffsetExtractor::Find(Value *Idx, GetElementPtrInst *GEP,</td>
    <td class="lineNumber">797</td>
    <td class="codeline">int64_t ConstantOffsetExtractor::Find(Value *Idx, GetElementPtrInst *GEP,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class="codeline">                                      const DominatorTree *DT) {</td>
    <td class="lineNumber">798</td>
    <td class="codeline">                                      const DominatorTree *DT) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class="codeline">  // If Idx is an index of an inbound GEP, Idx is guaranteed to be non-negative.</td>
    <td class="lineNumber">799</td>
    <td class="codeline">  // If Idx is an index of an inbound GEP, Idx is guaranteed to be non-negative.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class="codeline">  return ConstantOffsetExtractor(GEP, DT)</td>
    <td class="lineNumber">800</td>
    <td class="codeline">  return ConstantOffsetExtractor(GEP, DT)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class="codeline">      .find(Idx, /* SignExtended */ false, /* ZeroExtended */ false,</td>
    <td class="lineNumber">801</td>
    <td class="codeline">      .find(Idx, /* SignExtended */ false, /* ZeroExtended */ false,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class="codeline">            GEP->isInBounds())</td>
    <td class="lineNumber">802</td>
    <td class="codeline">            GEP->isInBounds())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class="codeline">      .getSExtValue();</td>
    <td class="lineNumber">803</td>
    <td class="codeline">      .getSExtValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class="codeline">}</td>
    <td class="lineNumber">804</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class="codeline"></td>
    <td class="lineNumber">805</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class="codeline">bool SeparateConstOffsetFromGEP::canonicalizeArrayIndicesToIndexSize(</td>
    <td class="lineNumber">806</td>
    <td class="codeline">bool SeparateConstOffsetFromGEP::canonicalizeArrayIndicesToIndexSize(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class="codeline">    GetElementPtrInst *GEP) {</td>
    <td class="lineNumber">807</td>
    <td class="codeline">    GetElementPtrInst *GEP) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class="codeline">  bool Changed = false;</td>
    <td class="lineNumber">808</td>
    <td class="codeline">  bool Changed = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class="codeline">  Type *PtrIdxTy = DL->getIndexType(GEP->getType());</td>
    <td class="lineNumber">809</td>
    <td class="codeline">  Type *PtrIdxTy = DL->getIndexType(GEP->getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class="codeline">  gep_type_iterator GTI = gep_type_begin(*GEP);</td>
    <td class="lineNumber">810</td>
    <td class="codeline">  gep_type_iterator GTI = gep_type_begin(*GEP);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class="codeline">  for (User::op_iterator I = GEP->op_begin() + 1, E = GEP->op_end();</td>
    <td class="lineNumber">811</td>
    <td class="codeline">  for (User::op_iterator I = GEP->op_begin() + 1, E = GEP->op_end();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class="codeline">       I != E; ++I, ++GTI) {</td>
    <td class="lineNumber">812</td>
    <td class="codeline">       I != E; ++I, ++GTI) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class="codeline">    // Skip struct member indices which must be i32.</td>
    <td class="lineNumber">813</td>
    <td class="codeline">    // Skip struct member indices which must be i32.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class="codeline">    if (GTI.isSequential()) {</td>
    <td class="lineNumber">814</td>
    <td class="codeline">    if (GTI.isSequential()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class="codeline">      if ((*I)->getType() != PtrIdxTy) {</td>
    <td class="lineNumber">815</td>
    <td class="codeline">      if ((*I)->getType() != PtrIdxTy) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class="codeline">        *I = CastInst::CreateIntegerCast(*I, PtrIdxTy, true, "idxprom", GEP);</td>
    <td class="lineNumber">816</td>
    <td class="codeline">        *I = CastInst::CreateIntegerCast(*I, PtrIdxTy, true, "idxprom", GEP);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class="codeline">        Changed = true;</td>
    <td class="lineNumber">817</td>
    <td class="codeline">        Changed = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">818</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">819</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">820</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class="codeline">  return Changed;</td>
    <td class="lineNumber">821</td>
    <td class="codeline">  return Changed;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class="codeline">}</td>
    <td class="lineNumber">822</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class="codeline"></td>
    <td class="lineNumber">823</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class="codeline">int64_t</td>
    <td class="lineNumber">824</td>
    <td class="codeline">int64_t</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class="codeline">SeparateConstOffsetFromGEP::accumulateByteOffset(GetElementPtrInst *GEP,</td>
    <td class="lineNumber">825</td>
    <td class="codeline">SeparateConstOffsetFromGEP::accumulateByteOffset(GetElementPtrInst *GEP,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class="codeline">                                                 bool &NeedsExtraction) {</td>
    <td class="lineNumber">826</td>
    <td class="codeline">                                                 bool &NeedsExtraction) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class="codeline">  NeedsExtraction = false;</td>
    <td class="lineNumber">827</td>
    <td class="codeline">  NeedsExtraction = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class="codeline">  int64_t AccumulativeByteOffset = 0;</td>
    <td class="lineNumber">828</td>
    <td class="codeline">  int64_t AccumulativeByteOffset = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class="codeline">  gep_type_iterator GTI = gep_type_begin(*GEP);</td>
    <td class="lineNumber">829</td>
    <td class="codeline">  gep_type_iterator GTI = gep_type_begin(*GEP);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class="codeline">  for (unsigned I = 1, E = GEP->getNumOperands(); I != E; ++I, ++GTI) {</td>
    <td class="lineNumber">830</td>
    <td class="codeline">  for (unsigned I = 1, E = GEP->getNumOperands(); I != E; ++I, ++GTI) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class="codeline">    if (GTI.isSequential()) {</td>
    <td class="lineNumber">831</td>
    <td class="codeline">    if (GTI.isSequential()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class="codeline">      // Constant offsets of scalable types are not really constant.</td>
    <td class="lineNumber">832</td>
    <td class="codeline">      // Constant offsets of scalable types are not really constant.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class="codeline">      if (isa<ScalableVectorType>(GTI.getIndexedType()))</td>
    <td class="lineNumber">833</td>
    <td class="codeline">      if (isa<ScalableVectorType>(GTI.getIndexedType()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">834</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class="codeline"></td>
    <td class="lineNumber">835</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class="codeline">      // Tries to extract a constant offset from this GEP index.</td>
    <td class="lineNumber">836</td>
    <td class="codeline">      // Tries to extract a constant offset from this GEP index.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class="codeline">      int64_t ConstantOffset =</td>
    <td class="lineNumber">837</td>
    <td class="codeline">      int64_t ConstantOffset =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class="codeline">          ConstantOffsetExtractor::Find(GEP->getOperand(I), GEP, DT);</td>
    <td class="lineNumber">838</td>
    <td class="codeline">          ConstantOffsetExtractor::Find(GEP->getOperand(I), GEP, DT);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class="codeline">      if (ConstantOffset != 0) {</td>
    <td class="lineNumber">839</td>
    <td class="codeline">      if (ConstantOffset != 0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class="codeline">        NeedsExtraction = true;</td>
    <td class="lineNumber">840</td>
    <td class="codeline">        NeedsExtraction = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class="codeline">        // A GEP may have multiple indices.  We accumulate the extracted</td>
    <td class="lineNumber">841</td>
    <td class="codeline">        // A GEP may have multiple indices.  We accumulate the extracted</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class="codeline">        // constant offset to a byte offset, and later offset the remainder of</td>
    <td class="lineNumber">842</td>
    <td class="codeline">        // constant offset to a byte offset, and later offset the remainder of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class="codeline">        // the original GEP with this byte offset.</td>
    <td class="lineNumber">843</td>
    <td class="codeline">        // the original GEP with this byte offset.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class="codeline">        AccumulativeByteOffset +=</td>
    <td class="lineNumber">844</td>
    <td class="codeline">        AccumulativeByteOffset +=</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class="codeline">            ConstantOffset * DL->getTypeAllocSize(GTI.getIndexedType());</td>
    <td class="lineNumber">845</td>
    <td class="codeline">            ConstantOffset * DL->getTypeAllocSize(GTI.getIndexedType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">846</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class="codeline">    } else if (LowerGEP) {</td>
    <td class="lineNumber">847</td>
    <td class="codeline">    } else if (LowerGEP) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class="codeline">      StructType *StTy = GTI.getStructType();</td>
    <td class="lineNumber">848</td>
    <td class="codeline">      StructType *StTy = GTI.getStructType();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class="codeline">      uint64_t Field = cast<ConstantInt>(GEP->getOperand(I))->getZExtValue();</td>
    <td class="lineNumber">849</td>
    <td class="codeline">      uint64_t Field = cast<ConstantInt>(GEP->getOperand(I))->getZExtValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class="codeline">      // Skip field 0 as the offset is always 0.</td>
    <td class="lineNumber">850</td>
    <td class="codeline">      // Skip field 0 as the offset is always 0.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class="codeline">      if (Field != 0) {</td>
    <td class="lineNumber">851</td>
    <td class="codeline">      if (Field != 0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class="codeline">        NeedsExtraction = true;</td>
    <td class="lineNumber">852</td>
    <td class="codeline">        NeedsExtraction = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class="codeline">        AccumulativeByteOffset +=</td>
    <td class="lineNumber">853</td>
    <td class="codeline">        AccumulativeByteOffset +=</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class="codeline">            DL->getStructLayout(StTy)->getElementOffset(Field);</td>
    <td class="lineNumber">854</td>
    <td class="codeline">            DL->getStructLayout(StTy)->getElementOffset(Field);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">855</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">856</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">857</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class="codeline">  return AccumulativeByteOffset;</td>
    <td class="lineNumber">858</td>
    <td class="codeline">  return AccumulativeByteOffset;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class="codeline">}</td>
    <td class="lineNumber">859</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class="codeline"></td>
    <td class="lineNumber">860</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class="codeline">void SeparateConstOffsetFromGEP::lowerToSingleIndexGEPs(</td>
    <td class="lineNumber">861</td>
    <td class="codeline">void SeparateConstOffsetFromGEP::lowerToSingleIndexGEPs(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class="codeline">    GetElementPtrInst *Variadic, int64_t AccumulativeByteOffset) {</td>
    <td class="lineNumber">862</td>
    <td class="codeline">    GetElementPtrInst *Variadic, int64_t AccumulativeByteOffset) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class="codeline">  IRBuilder<> Builder(Variadic);</td>
    <td class="lineNumber">863</td>
    <td class="codeline">  IRBuilder<> Builder(Variadic);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class="codeline">  Type *PtrIndexTy = DL->getIndexType(Variadic->getType());</td>
    <td class="lineNumber">864</td>
    <td class="codeline">  Type *PtrIndexTy = DL->getIndexType(Variadic->getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class="codeline"></td>
    <td class="lineNumber">865</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class="codeline">  Value *ResultPtr = Variadic->getOperand(0);</td>
    <td class="lineNumber">866</td>
    <td class="codeline">  Value *ResultPtr = Variadic->getOperand(0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class="codeline">  Loop *L = LI->getLoopFor(Variadic->getParent());</td>
    <td class="lineNumber">867</td>
    <td class="codeline">  Loop *L = LI->getLoopFor(Variadic->getParent());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class="codeline">  // Check if the base is not loop invariant or used more than once.</td>
    <td class="lineNumber">868</td>
    <td class="codeline">  // Check if the base is not loop invariant or used more than once.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class="codeline">  bool isSwapCandidate =</td>
    <td class="lineNumber">869</td>
    <td class="codeline">  bool isSwapCandidate =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="codeline">      L && L->isLoopInvariant(ResultPtr) &&</td>
    <td class="lineNumber">870</td>
    <td class="codeline">      L && L->isLoopInvariant(ResultPtr) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class="codeline">      !hasMoreThanOneUseInLoop(ResultPtr, L);</td>
    <td class="lineNumber">871</td>
    <td class="codeline">      !hasMoreThanOneUseInLoop(ResultPtr, L);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">872</td>
    <td class="codeline">  Value *FirstResult = nullptr;</td>
    <td class="lineNumber">872</td>
    <td class="codeline">  Value *FirstResult = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">873</td>
    <td class="codeline"></td>
    <td class="lineNumber">873</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">874</td>
    <td class="codeline">  gep_type_iterator GTI = gep_type_begin(*Variadic);</td>
    <td class="lineNumber">874</td>
    <td class="codeline">  gep_type_iterator GTI = gep_type_begin(*Variadic);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">875</td>
    <td class="codeline">  // Create an ugly GEP for each sequential index. We don't create GEPs for</td>
    <td class="lineNumber">875</td>
    <td class="codeline">  // Create an ugly GEP for each sequential index. We don't create GEPs for</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">876</td>
    <td class="codeline">  // structure indices, as they are accumulated in the constant offset index.</td>
    <td class="lineNumber">876</td>
    <td class="codeline">  // structure indices, as they are accumulated in the constant offset index.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">877</td>
    <td class="codeline">  for (unsigned I = 1, E = Variadic->getNumOperands(); I != E; ++I, ++GTI) {</td>
    <td class="lineNumber">877</td>
    <td class="codeline">  for (unsigned I = 1, E = Variadic->getNumOperands(); I != E; ++I, ++GTI) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">878</td>
    <td class="codeline">    if (GTI.isSequential()) {</td>
    <td class="lineNumber">878</td>
    <td class="codeline">    if (GTI.isSequential()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">879</td>
    <td class="codeline">      Value *Idx = Variadic->getOperand(I);</td>
    <td class="lineNumber">879</td>
    <td class="codeline">      Value *Idx = Variadic->getOperand(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">880</td>
    <td class="codeline">      // Skip zero indices.</td>
    <td class="lineNumber">880</td>
    <td class="codeline">      // Skip zero indices.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">881</td>
    <td class="codeline">      if (ConstantInt *CI = dyn_cast<ConstantInt>(Idx))</td>
    <td class="lineNumber">881</td>
    <td class="codeline">      if (ConstantInt *CI = dyn_cast<ConstantInt>(Idx))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">882</td>
    <td class="codeline">        if (CI->isZero())</td>
    <td class="lineNumber">882</td>
    <td class="codeline">        if (CI->isZero())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">883</td>
    <td class="codeline">          continue;</td>
    <td class="lineNumber">883</td>
    <td class="codeline">          continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">884</td>
    <td class="codeline"></td>
    <td class="lineNumber">884</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">885</td>
    <td class="codeline">      APInt ElementSize = APInt(PtrIndexTy->getIntegerBitWidth(),</td>
    <td class="lineNumber">885</td>
    <td class="codeline">      APInt ElementSize = APInt(PtrIndexTy->getIntegerBitWidth(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">886</td>
    <td class="codeline">                                DL->getTypeAllocSize(GTI.getIndexedType()));</td>
    <td class="lineNumber">886</td>
    <td class="codeline">                                DL->getTypeAllocSize(GTI.getIndexedType()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">887</td>
    <td class="codeline">      // Scale the index by element size.</td>
    <td class="lineNumber">887</td>
    <td class="codeline">      // Scale the index by element size.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">888</td>
    <td class="codeline">      if (ElementSize != 1) {</td>
    <td class="lineNumber">888</td>
    <td class="codeline">      if (ElementSize != 1) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">889</td>
    <td class="codeline">        if (ElementSize.isPowerOf2()) {</td>
    <td class="lineNumber">889</td>
    <td class="codeline">        if (ElementSize.isPowerOf2()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">890</td>
    <td class="codeline">          Idx = Builder.CreateShl(</td>
    <td class="lineNumber">890</td>
    <td class="codeline">          Idx = Builder.CreateShl(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">891</td>
    <td class="codeline">              Idx, ConstantInt::get(PtrIndexTy, ElementSize.logBase2()));</td>
    <td class="lineNumber">891</td>
    <td class="codeline">              Idx, ConstantInt::get(PtrIndexTy, ElementSize.logBase2()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">892</td>
    <td class="codeline">        } else {</td>
    <td class="lineNumber">892</td>
    <td class="codeline">        } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">893</td>
    <td class="codeline">          Idx =</td>
    <td class="lineNumber">893</td>
    <td class="codeline">          Idx =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">894</td>
    <td class="codeline">              Builder.CreateMul(Idx, ConstantInt::get(PtrIndexTy, ElementSize));</td>
    <td class="lineNumber">894</td>
    <td class="codeline">              Builder.CreateMul(Idx, ConstantInt::get(PtrIndexTy, ElementSize));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">895</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">895</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">896</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">896</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">897</td>
    <td class="codeline">      // Create an ugly GEP with a single index for each index.</td>
    <td class="lineNumber">897</td>
    <td class="codeline">      // Create an ugly GEP with a single index for each index.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">898</td>
    <td class="codeline">      ResultPtr =</td>
    <td class="lineNumber">898</td>
    <td class="codeline">      ResultPtr =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">899</td>
    <td class="codeline">          Builder.CreateGEP(Builder.getInt8Ty(), ResultPtr, Idx, "uglygep");</td>
    <td class="lineNumber">899</td>
    <td class="codeline">          Builder.CreateGEP(Builder.getInt8Ty(), ResultPtr, Idx, "uglygep");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">900</td>
    <td class="codeline">      if (FirstResult == nullptr)</td>
    <td class="lineNumber">900</td>
    <td class="codeline">      if (FirstResult == nullptr)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">901</td>
    <td class="codeline">        FirstResult = ResultPtr;</td>
    <td class="lineNumber">901</td>
    <td class="codeline">        FirstResult = ResultPtr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">902</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">902</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">903</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">903</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">904</td>
    <td class="codeline"></td>
    <td class="lineNumber">904</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">905</td>
    <td class="codeline">  // Create a GEP with the constant offset index.</td>
    <td class="lineNumber">905</td>
    <td class="codeline">  // Create a GEP with the constant offset index.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">906</td>
    <td class="codeline">  if (AccumulativeByteOffset != 0) {</td>
    <td class="lineNumber">906</td>
    <td class="codeline">  if (AccumulativeByteOffset != 0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">907</td>
    <td class="codeline">    Value *Offset = ConstantInt::get(PtrIndexTy, AccumulativeByteOffset);</td>
    <td class="lineNumber">907</td>
    <td class="codeline">    Value *Offset = ConstantInt::get(PtrIndexTy, AccumulativeByteOffset);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">908</td>
    <td class="codeline">    ResultPtr =</td>
    <td class="lineNumber">908</td>
    <td class="codeline">    ResultPtr =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">909</td>
    <td class="codeline">        Builder.CreateGEP(Builder.getInt8Ty(), ResultPtr, Offset, "uglygep");</td>
    <td class="lineNumber">909</td>
    <td class="codeline">        Builder.CreateGEP(Builder.getInt8Ty(), ResultPtr, Offset, "uglygep");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">910</td>
    <td class="codeline">  } else</td>
    <td class="lineNumber">910</td>
    <td class="codeline">  } else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">911</td>
    <td class="codeline">    isSwapCandidate = false;</td>
    <td class="lineNumber">911</td>
    <td class="codeline">    isSwapCandidate = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">912</td>
    <td class="codeline"></td>
    <td class="lineNumber">912</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">913</td>
    <td class="codeline">  // If we created a GEP with constant index, and the base is loop invariant,</td>
    <td class="lineNumber">913</td>
    <td class="codeline">  // If we created a GEP with constant index, and the base is loop invariant,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">914</td>
    <td class="codeline">  // then we swap the first one with it, so LICM can move constant GEP out</td>
    <td class="lineNumber">914</td>
    <td class="codeline">  // then we swap the first one with it, so LICM can move constant GEP out</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">915</td>
    <td class="codeline">  // later.</td>
    <td class="lineNumber">915</td>
    <td class="codeline">  // later.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">916</td>
    <td class="codeline">  auto *FirstGEP = dyn_cast_or_null<GetElementPtrInst>(FirstResult);</td>
    <td class="lineNumber">916</td>
    <td class="codeline">  auto *FirstGEP = dyn_cast_or_null<GetElementPtrInst>(FirstResult);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">917</td>
    <td class="codeline">  auto *SecondGEP = dyn_cast<GetElementPtrInst>(ResultPtr);</td>
    <td class="lineNumber">917</td>
    <td class="codeline">  auto *SecondGEP = dyn_cast<GetElementPtrInst>(ResultPtr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">918</td>
    <td class="codeline">  if (isSwapCandidate && isLegalToSwapOperand(FirstGEP, SecondGEP, L))</td>
    <td class="lineNumber">918</td>
    <td class="codeline">  if (isSwapCandidate && isLegalToSwapOperand(FirstGEP, SecondGEP, L))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">919</td>
    <td class="codeline">    swapGEPOperand(FirstGEP, SecondGEP);</td>
    <td class="lineNumber">919</td>
    <td class="codeline">    swapGEPOperand(FirstGEP, SecondGEP);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">920</td>
    <td class="codeline"></td>
    <td class="lineNumber">920</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">921</td>
    <td class="codeline">  Variadic->replaceAllUsesWith(ResultPtr);</td>
    <td class="lineNumber">921</td>
    <td class="codeline">  Variadic->replaceAllUsesWith(ResultPtr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">922</td>
    <td class="codeline">  Variadic->eraseFromParent();</td>
    <td class="lineNumber">922</td>
    <td class="codeline">  Variadic->eraseFromParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">923</td>
    <td class="codeline">}</td>
    <td class="lineNumber">923</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">924</td>
    <td class="codeline"></td>
    <td class="lineNumber">924</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">925</td>
    <td class="codeline">void</td>
    <td class="lineNumber">925</td>
    <td class="codeline">void</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">926</td>
    <td class="codeline">SeparateConstOffsetFromGEP::lowerToArithmetics(GetElementPtrInst *Variadic,</td>
    <td class="lineNumber">926</td>
    <td class="codeline">SeparateConstOffsetFromGEP::lowerToArithmetics(GetElementPtrInst *Variadic,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">927</td>
    <td class="codeline">                                               int64_t AccumulativeByteOffset) {</td>
    <td class="lineNumber">927</td>
    <td class="codeline">                                               int64_t AccumulativeByteOffset) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">928</td>
    <td class="codeline">  IRBuilder<> Builder(Variadic);</td>
    <td class="lineNumber">928</td>
    <td class="codeline">  IRBuilder<> Builder(Variadic);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">929</td>
    <td class="codeline">  Type *IntPtrTy = DL->getIntPtrType(Variadic->getType());</td>
    <td class="lineNumber">929</td>
    <td class="codeline">  Type *IntPtrTy = DL->getIntPtrType(Variadic->getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">930</td>
    <td class="codeline">  assert(IntPtrTy == DL->getIndexType(Variadic->getType()) &&</td>
    <td class="lineNumber">930</td>
    <td class="codeline">  assert(IntPtrTy == DL->getIndexType(Variadic->getType()) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">931</td>
    <td class="codeline">         "Pointer type must match index type for arithmetic-based lowering of "</td>
    <td class="lineNumber">931</td>
    <td class="codeline">         "Pointer type must match index type for arithmetic-based lowering of "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">932</td>
    <td class="codeline">         "split GEPs");</td>
    <td class="lineNumber">932</td>
    <td class="codeline">         "split GEPs");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">933</td>
    <td class="codeline"></td>
    <td class="lineNumber">933</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">934</td>
    <td class="codeline">  Value *ResultPtr = Builder.CreatePtrToInt(Variadic->getOperand(0), IntPtrTy);</td>
    <td class="lineNumber">934</td>
    <td class="codeline">  Value *ResultPtr = Builder.CreatePtrToInt(Variadic->getOperand(0), IntPtrTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">935</td>
    <td class="codeline">  gep_type_iterator GTI = gep_type_begin(*Variadic);</td>
    <td class="lineNumber">935</td>
    <td class="codeline">  gep_type_iterator GTI = gep_type_begin(*Variadic);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">936</td>
    <td class="codeline">  // Create ADD/SHL/MUL arithmetic operations for each sequential indices. We</td>
    <td class="lineNumber">936</td>
    <td class="codeline">  // Create ADD/SHL/MUL arithmetic operations for each sequential indices. We</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">937</td>
    <td class="codeline">  // don't create arithmetics for structure indices, as they are accumulated</td>
    <td class="lineNumber">937</td>
    <td class="codeline">  // don't create arithmetics for structure indices, as they are accumulated</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">938</td>
    <td class="codeline">  // in the constant offset index.</td>
    <td class="lineNumber">938</td>
    <td class="codeline">  // in the constant offset index.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">939</td>
    <td class="codeline">  for (unsigned I = 1, E = Variadic->getNumOperands(); I != E; ++I, ++GTI) {</td>
    <td class="lineNumber">939</td>
    <td class="codeline">  for (unsigned I = 1, E = Variadic->getNumOperands(); I != E; ++I, ++GTI) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">940</td>
    <td class="codeline">    if (GTI.isSequential()) {</td>
    <td class="lineNumber">940</td>
    <td class="codeline">    if (GTI.isSequential()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">941</td>
    <td class="codeline">      Value *Idx = Variadic->getOperand(I);</td>
    <td class="lineNumber">941</td>
    <td class="codeline">      Value *Idx = Variadic->getOperand(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">942</td>
    <td class="codeline">      // Skip zero indices.</td>
    <td class="lineNumber">942</td>
    <td class="codeline">      // Skip zero indices.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">943</td>
    <td class="codeline">      if (ConstantInt *CI = dyn_cast<ConstantInt>(Idx))</td>
    <td class="lineNumber">943</td>
    <td class="codeline">      if (ConstantInt *CI = dyn_cast<ConstantInt>(Idx))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">944</td>
    <td class="codeline">        if (CI->isZero())</td>
    <td class="lineNumber">944</td>
    <td class="codeline">        if (CI->isZero())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">945</td>
    <td class="codeline">          continue;</td>
    <td class="lineNumber">945</td>
    <td class="codeline">          continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">946</td>
    <td class="codeline"></td>
    <td class="lineNumber">946</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">947</td>
    <td class="codeline">      APInt ElementSize = APInt(IntPtrTy->getIntegerBitWidth(),</td>
    <td class="lineNumber">947</td>
    <td class="codeline">      APInt ElementSize = APInt(IntPtrTy->getIntegerBitWidth(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">948</td>
    <td class="codeline">                                DL->getTypeAllocSize(GTI.getIndexedType()));</td>
    <td class="lineNumber">948</td>
    <td class="codeline">                                DL->getTypeAllocSize(GTI.getIndexedType()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">949</td>
    <td class="codeline">      // Scale the index by element size.</td>
    <td class="lineNumber">949</td>
    <td class="codeline">      // Scale the index by element size.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">950</td>
    <td class="codeline">      if (ElementSize != 1) {</td>
    <td class="lineNumber">950</td>
    <td class="codeline">      if (ElementSize != 1) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">951</td>
    <td class="codeline">        if (ElementSize.isPowerOf2()) {</td>
    <td class="lineNumber">951</td>
    <td class="codeline">        if (ElementSize.isPowerOf2()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">952</td>
    <td class="codeline">          Idx = Builder.CreateShl(</td>
    <td class="lineNumber">952</td>
    <td class="codeline">          Idx = Builder.CreateShl(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">953</td>
    <td class="codeline">              Idx, ConstantInt::get(IntPtrTy, ElementSize.logBase2()));</td>
    <td class="lineNumber">953</td>
    <td class="codeline">              Idx, ConstantInt::get(IntPtrTy, ElementSize.logBase2()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">954</td>
    <td class="codeline">        } else {</td>
    <td class="lineNumber">954</td>
    <td class="codeline">        } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">955</td>
    <td class="codeline">          Idx = Builder.CreateMul(Idx, ConstantInt::get(IntPtrTy, ElementSize));</td>
    <td class="lineNumber">955</td>
    <td class="codeline">          Idx = Builder.CreateMul(Idx, ConstantInt::get(IntPtrTy, ElementSize));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">956</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">956</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">957</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">957</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">958</td>
    <td class="codeline">      // Create an ADD for each index.</td>
    <td class="lineNumber">958</td>
    <td class="codeline">      // Create an ADD for each index.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">959</td>
    <td class="codeline">      ResultPtr = Builder.CreateAdd(ResultPtr, Idx);</td>
    <td class="lineNumber">959</td>
    <td class="codeline">      ResultPtr = Builder.CreateAdd(ResultPtr, Idx);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">960</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">960</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">961</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">961</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">962</td>
    <td class="codeline"></td>
    <td class="lineNumber">962</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">963</td>
    <td class="codeline">  // Create an ADD for the constant offset index.</td>
    <td class="lineNumber">963</td>
    <td class="codeline">  // Create an ADD for the constant offset index.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">964</td>
    <td class="codeline">  if (AccumulativeByteOffset != 0) {</td>
    <td class="lineNumber">964</td>
    <td class="codeline">  if (AccumulativeByteOffset != 0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">965</td>
    <td class="codeline">    ResultPtr = Builder.CreateAdd(</td>
    <td class="lineNumber">965</td>
    <td class="codeline">    ResultPtr = Builder.CreateAdd(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">966</td>
    <td class="codeline">        ResultPtr, ConstantInt::get(IntPtrTy, AccumulativeByteOffset));</td>
    <td class="lineNumber">966</td>
    <td class="codeline">        ResultPtr, ConstantInt::get(IntPtrTy, AccumulativeByteOffset));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">967</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">967</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">968</td>
    <td class="codeline"></td>
    <td class="lineNumber">968</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">969</td>
    <td class="codeline">  ResultPtr = Builder.CreateIntToPtr(ResultPtr, Variadic->getType());</td>
    <td class="lineNumber">969</td>
    <td class="codeline">  ResultPtr = Builder.CreateIntToPtr(ResultPtr, Variadic->getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">970</td>
    <td class="codeline">  Variadic->replaceAllUsesWith(ResultPtr);</td>
    <td class="lineNumber">970</td>
    <td class="codeline">  Variadic->replaceAllUsesWith(ResultPtr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">971</td>
    <td class="codeline">  Variadic->eraseFromParent();</td>
    <td class="lineNumber">971</td>
    <td class="codeline">  Variadic->eraseFromParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">972</td>
    <td class="codeline">}</td>
    <td class="lineNumber">972</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">973</td>
    <td class="codeline"></td>
    <td class="lineNumber">973</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">974</td>
    <td class="codeline">bool SeparateConstOffsetFromGEP::splitGEP(GetElementPtrInst *GEP) {</td>
    <td class="lineNumber">974</td>
    <td class="codeline">bool SeparateConstOffsetFromGEP::splitGEP(GetElementPtrInst *GEP) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">975</td>
    <td class="codeline">  // Skip vector GEPs.</td>
    <td class="lineNumber">975</td>
    <td class="codeline">  // Skip vector GEPs.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">976</td>
    <td class="codeline">  if (GEP->getType()->isVectorTy())</td>
    <td class="lineNumber">976</td>
    <td class="codeline">  if (GEP->getType()->isVectorTy())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">977</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">977</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">978</td>
    <td class="codeline"></td>
    <td class="lineNumber">978</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">979</td>
    <td class="codeline">  // The backend can already nicely handle the case where all indices are</td>
    <td class="lineNumber">979</td>
    <td class="codeline">  // The backend can already nicely handle the case where all indices are</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">980</td>
    <td class="codeline">  // constant.</td>
    <td class="lineNumber">980</td>
    <td class="codeline">  // constant.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">981</td>
    <td class="codeline">  if (GEP->hasAllConstantIndices())</td>
    <td class="lineNumber">981</td>
    <td class="codeline">  if (GEP->hasAllConstantIndices())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">982</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">982</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">983</td>
    <td class="codeline"></td>
    <td class="lineNumber">983</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">984</td>
    <td class="codeline">  bool Changed = canonicalizeArrayIndicesToIndexSize(GEP);</td>
    <td class="lineNumber">984</td>
    <td class="codeline">  bool Changed = canonicalizeArrayIndicesToIndexSize(GEP);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">985</td>
    <td class="codeline"></td>
    <td class="lineNumber">985</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">986</td>
    <td class="codeline">  bool NeedsExtraction;</td>
    <td class="lineNumber">986</td>
    <td class="codeline">  bool NeedsExtraction;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">987</td>
    <td class="codeline">  int64_t AccumulativeByteOffset = accumulateByteOffset(GEP, NeedsExtraction);</td>
    <td class="lineNumber">987</td>
    <td class="codeline">  int64_t AccumulativeByteOffset = accumulateByteOffset(GEP, NeedsExtraction);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">988</td>
    <td class="codeline"></td>
    <td class="lineNumber">988</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">989</td>
    <td class="codeline">  if (!NeedsExtraction)</td>
    <td class="lineNumber">989</td>
    <td class="codeline">  if (!NeedsExtraction)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">990</td>
    <td class="codeline">    return Changed;</td>
    <td class="lineNumber">990</td>
    <td class="codeline">    return Changed;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">991</td>
    <td class="codeline"></td>
    <td class="lineNumber">991</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">992</td>
    <td class="codeline">  TargetTransformInfo &TTI = GetTTI(*GEP->getFunction());</td>
    <td class="lineNumber">992</td>
    <td class="codeline">  TargetTransformInfo &TTI = GetTTI(*GEP->getFunction());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">993</td>
    <td class="codeline"></td>
    <td class="lineNumber">993</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">994</td>
    <td class="codeline">  // If LowerGEP is disabled, before really splitting the GEP, check whether the</td>
    <td class="lineNumber">994</td>
    <td class="codeline">  // If LowerGEP is disabled, before really splitting the GEP, check whether the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">995</td>
    <td class="codeline">  // backend supports the addressing mode we are about to produce. If no, this</td>
    <td class="lineNumber">995</td>
    <td class="codeline">  // backend supports the addressing mode we are about to produce. If no, this</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">996</td>
    <td class="codeline">  // splitting probably won't be beneficial.</td>
    <td class="lineNumber">996</td>
    <td class="codeline">  // splitting probably won't be beneficial.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">997</td>
    <td class="codeline">  // If LowerGEP is enabled, even the extracted constant offset can not match</td>
    <td class="lineNumber">997</td>
    <td class="codeline">  // If LowerGEP is enabled, even the extracted constant offset can not match</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">998</td>
    <td class="codeline">  // the addressing mode, we can still do optimizations to other lowered parts</td>
    <td class="lineNumber">998</td>
    <td class="codeline">  // the addressing mode, we can still do optimizations to other lowered parts</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">999</td>
    <td class="codeline">  // of variable indices. Therefore, we don't check for addressing modes in that</td>
    <td class="lineNumber">999</td>
    <td class="codeline">  // of variable indices. Therefore, we don't check for addressing modes in that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1000</td>
    <td class="codeline">  // case.</td>
    <td class="lineNumber">1000</td>
    <td class="codeline">  // case.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1001</td>
    <td class="codeline">  if (!LowerGEP) {</td>
    <td class="lineNumber">1001</td>
    <td class="codeline">  if (!LowerGEP) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1002</td>
    <td class="codeline">    unsigned AddrSpace = GEP->getPointerAddressSpace();</td>
    <td class="lineNumber">1002</td>
    <td class="codeline">    unsigned AddrSpace = GEP->getPointerAddressSpace();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1003</td>
    <td class="codeline">    if (!TTI.isLegalAddressingMode(GEP->getResultElementType(),</td>
    <td class="lineNumber">1003</td>
    <td class="codeline">    if (!TTI.isLegalAddressingMode(GEP->getResultElementType(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1004</td>
    <td class="codeline">                                   /*BaseGV=*/nullptr, AccumulativeByteOffset,</td>
    <td class="lineNumber">1004</td>
    <td class="codeline">                                   /*BaseGV=*/nullptr, AccumulativeByteOffset,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1005</td>
    <td class="codeline">                                   /*HasBaseReg=*/true, /*Scale=*/0,</td>
    <td class="lineNumber">1005</td>
    <td class="codeline">                                   /*HasBaseReg=*/true, /*Scale=*/0,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1006</td>
    <td class="codeline">                                   AddrSpace)) {</td>
    <td class="lineNumber">1006</td>
    <td class="codeline">                                   AddrSpace)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1007</td>
    <td class="codeline">      return Changed;</td>
    <td class="lineNumber">1007</td>
    <td class="codeline">      return Changed;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1008</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1008</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1009</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1009</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1010</td>
    <td class="codeline"></td>
    <td class="lineNumber">1010</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1011</td>
    <td class="codeline">  // Remove the constant offset in each sequential index. The resultant GEP</td>
    <td class="lineNumber">1011</td>
    <td class="codeline">  // Remove the constant offset in each sequential index. The resultant GEP</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1012</td>
    <td class="codeline">  // computes the variadic base.</td>
    <td class="lineNumber">1012</td>
    <td class="codeline">  // computes the variadic base.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1013</td>
    <td class="codeline">  // Notice that we don't remove struct field indices here. If LowerGEP is</td>
    <td class="lineNumber">1013</td>
    <td class="codeline">  // Notice that we don't remove struct field indices here. If LowerGEP is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1014</td>
    <td class="codeline">  // disabled, a structure index is not accumulated and we still use the old</td>
    <td class="lineNumber">1014</td>
    <td class="codeline">  // disabled, a structure index is not accumulated and we still use the old</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1015</td>
    <td class="codeline">  // one. If LowerGEP is enabled, a structure index is accumulated in the</td>
    <td class="lineNumber">1015</td>
    <td class="codeline">  // one. If LowerGEP is enabled, a structure index is accumulated in the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1016</td>
    <td class="codeline">  // constant offset. LowerToSingleIndexGEPs or lowerToArithmetics will later</td>
    <td class="lineNumber">1016</td>
    <td class="codeline">  // constant offset. LowerToSingleIndexGEPs or lowerToArithmetics will later</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1017</td>
    <td class="codeline">  // handle the constant offset and won't need a new structure index.</td>
    <td class="lineNumber">1017</td>
    <td class="codeline">  // handle the constant offset and won't need a new structure index.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1018</td>
    <td class="codeline">  gep_type_iterator GTI = gep_type_begin(*GEP);</td>
    <td class="lineNumber">1018</td>
    <td class="codeline">  gep_type_iterator GTI = gep_type_begin(*GEP);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1019</td>
    <td class="codeline">  for (unsigned I = 1, E = GEP->getNumOperands(); I != E; ++I, ++GTI) {</td>
    <td class="lineNumber">1019</td>
    <td class="codeline">  for (unsigned I = 1, E = GEP->getNumOperands(); I != E; ++I, ++GTI) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1020</td>
    <td class="codeline">    if (GTI.isSequential()) {</td>
    <td class="lineNumber">1020</td>
    <td class="codeline">    if (GTI.isSequential()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1021</td>
    <td class="codeline">      // Constant offsets of scalable types are not really constant.</td>
    <td class="lineNumber">1021</td>
    <td class="codeline">      // Constant offsets of scalable types are not really constant.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1022</td>
    <td class="codeline">      if (isa<ScalableVectorType>(GTI.getIndexedType()))</td>
    <td class="lineNumber">1022</td>
    <td class="codeline">      if (isa<ScalableVectorType>(GTI.getIndexedType()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1023</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">1023</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1024</td>
    <td class="codeline"></td>
    <td class="lineNumber">1024</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1025</td>
    <td class="codeline">      // Splits this GEP index into a variadic part and a constant offset, and</td>
    <td class="lineNumber">1025</td>
    <td class="codeline">      // Splits this GEP index into a variadic part and a constant offset, and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1026</td>
    <td class="codeline">      // uses the variadic part as the new index.</td>
    <td class="lineNumber">1026</td>
    <td class="codeline">      // uses the variadic part as the new index.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1027</td>
    <td class="codeline">      Value *OldIdx = GEP->getOperand(I);</td>
    <td class="lineNumber">1027</td>
    <td class="codeline">      Value *OldIdx = GEP->getOperand(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1028</td>
    <td class="codeline">      User *UserChainTail;</td>
    <td class="lineNumber">1028</td>
    <td class="codeline">      User *UserChainTail;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1029</td>
    <td class="codeline">      Value *NewIdx =</td>
    <td class="lineNumber">1029</td>
    <td class="codeline">      Value *NewIdx =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1030</td>
    <td class="codeline">          ConstantOffsetExtractor::Extract(OldIdx, GEP, UserChainTail, DT);</td>
    <td class="lineNumber">1030</td>
    <td class="codeline">          ConstantOffsetExtractor::Extract(OldIdx, GEP, UserChainTail, DT);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1031</td>
    <td class="codeline">      if (NewIdx != nullptr) {</td>
    <td class="lineNumber">1031</td>
    <td class="codeline">      if (NewIdx != nullptr) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1032</td>
    <td class="codeline">        // Switches to the index with the constant offset removed.</td>
    <td class="lineNumber">1032</td>
    <td class="codeline">        // Switches to the index with the constant offset removed.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1033</td>
    <td class="codeline">        GEP->setOperand(I, NewIdx);</td>
    <td class="lineNumber">1033</td>
    <td class="codeline">        GEP->setOperand(I, NewIdx);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1034</td>
    <td class="codeline">        // After switching to the new index, we can garbage-collect UserChain</td>
    <td class="lineNumber">1034</td>
    <td class="codeline">        // After switching to the new index, we can garbage-collect UserChain</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1035</td>
    <td class="codeline">        // and the old index if they are not used.</td>
    <td class="lineNumber">1035</td>
    <td class="codeline">        // and the old index if they are not used.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1036</td>
    <td class="codeline">        RecursivelyDeleteTriviallyDeadInstructions(UserChainTail);</td>
    <td class="lineNumber">1036</td>
    <td class="codeline">        RecursivelyDeleteTriviallyDeadInstructions(UserChainTail);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1037</td>
    <td class="codeline">        RecursivelyDeleteTriviallyDeadInstructions(OldIdx);</td>
    <td class="lineNumber">1037</td>
    <td class="codeline">        RecursivelyDeleteTriviallyDeadInstructions(OldIdx);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1038</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1038</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1039</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1039</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1040</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1040</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1041</td>
    <td class="codeline"></td>
    <td class="lineNumber">1041</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1042</td>
    <td class="codeline">  // Clear the inbounds attribute because the new index may be off-bound.</td>
    <td class="lineNumber">1042</td>
    <td class="codeline">  // Clear the inbounds attribute because the new index may be off-bound.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1043</td>
    <td class="codeline">  // e.g.,</td>
    <td class="lineNumber">1043</td>
    <td class="codeline">  // e.g.,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1044</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">1044</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1045</td>
    <td class="codeline">  //   b     = add i64 a, 5</td>
    <td class="lineNumber">1045</td>
    <td class="codeline">  //   b     = add i64 a, 5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1046</td>
    <td class="codeline">  //   addr  = gep inbounds float, float* p, i64 b</td>
    <td class="lineNumber">1046</td>
    <td class="codeline">  //   addr  = gep inbounds float, float* p, i64 b</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1047</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">1047</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1048</td>
    <td class="codeline">  // is transformed to:</td>
    <td class="lineNumber">1048</td>
    <td class="codeline">  // is transformed to:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1049</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">1049</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1050</td>
    <td class="codeline">  //   addr2 = gep float, float* p, i64 a ; inbounds removed</td>
    <td class="lineNumber">1050</td>
    <td class="codeline">  //   addr2 = gep float, float* p, i64 a ; inbounds removed</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1051</td>
    <td class="codeline">  //   addr  = gep inbounds float, float* addr2, i64 5</td>
    <td class="lineNumber">1051</td>
    <td class="codeline">  //   addr  = gep inbounds float, float* addr2, i64 5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1052</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">1052</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1053</td>
    <td class="codeline">  // If a is -4, although the old index b is in bounds, the new index a is</td>
    <td class="lineNumber">1053</td>
    <td class="codeline">  // If a is -4, although the old index b is in bounds, the new index a is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1054</td>
    <td class="codeline">  // off-bound. http://llvm.org/docs/LangRef.html#id181 says "if the</td>
    <td class="lineNumber">1054</td>
    <td class="codeline">  // off-bound. http://llvm.org/docs/LangRef.html#id181 says "if the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1055</td>
    <td class="codeline">  // inbounds keyword is not present, the offsets are added to the base</td>
    <td class="lineNumber">1055</td>
    <td class="codeline">  // inbounds keyword is not present, the offsets are added to the base</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1056</td>
    <td class="codeline">  // address with silently-wrapping two's complement arithmetic".</td>
    <td class="lineNumber">1056</td>
    <td class="codeline">  // address with silently-wrapping two's complement arithmetic".</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1057</td>
    <td class="codeline">  // Therefore, the final code will be a semantically equivalent.</td>
    <td class="lineNumber">1057</td>
    <td class="codeline">  // Therefore, the final code will be a semantically equivalent.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1058</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">1058</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1059</td>
    <td class="codeline">  // TODO(jingyue): do some range analysis to keep as many inbounds as</td>
    <td class="lineNumber">1059</td>
    <td class="codeline">  // TODO(jingyue): do some range analysis to keep as many inbounds as</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1060</td>
    <td class="codeline">  // possible. GEPs with inbounds are more friendly to alias analysis.</td>
    <td class="lineNumber">1060</td>
    <td class="codeline">  // possible. GEPs with inbounds are more friendly to alias analysis.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1061</td>
    <td class="codeline">  bool GEPWasInBounds = GEP->isInBounds();</td>
    <td class="lineNumber">1061</td>
    <td class="codeline">  bool GEPWasInBounds = GEP->isInBounds();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1062</td>
    <td class="codeline">  GEP->setIsInBounds(false);</td>
    <td class="lineNumber">1062</td>
    <td class="codeline">  GEP->setIsInBounds(false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1063</td>
    <td class="codeline"></td>
    <td class="lineNumber">1063</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1064</td>
    <td class="codeline">  // Lowers a GEP to either GEPs with a single index or arithmetic operations.</td>
    <td class="lineNumber">1064</td>
    <td class="codeline">  // Lowers a GEP to either GEPs with a single index or arithmetic operations.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1065</td>
    <td class="codeline">  if (LowerGEP) {</td>
    <td class="lineNumber">1065</td>
    <td class="codeline">  if (LowerGEP) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1066</td>
    <td class="codeline">    // As currently BasicAA does not analyze ptrtoint/inttoptr, do not lower to</td>
    <td class="lineNumber">1066</td>
    <td class="codeline">    // As currently BasicAA does not analyze ptrtoint/inttoptr, do not lower to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1067</td>
    <td class="codeline">    // arithmetic operations if the target uses alias analysis in codegen.</td>
    <td class="lineNumber">1067</td>
    <td class="codeline">    // arithmetic operations if the target uses alias analysis in codegen.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1068</td>
    <td class="codeline">    // Additionally, pointers that aren't integral (and so can't be safely</td>
    <td class="lineNumber">1068</td>
    <td class="codeline">    // Additionally, pointers that aren't integral (and so can't be safely</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1069</td>
    <td class="codeline">    // converted to integers) or those whose offset size is different from their</td>
    <td class="lineNumber">1069</td>
    <td class="codeline">    // converted to integers) or those whose offset size is different from their</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1070</td>
    <td class="codeline">    // pointer size (which means that doing integer arithmetic on them could</td>
    <td class="lineNumber">1070</td>
    <td class="codeline">    // pointer size (which means that doing integer arithmetic on them could</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1071</td>
    <td class="codeline">    // affect that data) can't be lowered in this way.</td>
    <td class="lineNumber">1071</td>
    <td class="codeline">    // affect that data) can't be lowered in this way.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1072</td>
    <td class="codeline">    unsigned AddrSpace = GEP->getPointerAddressSpace();</td>
    <td class="lineNumber">1072</td>
    <td class="codeline">    unsigned AddrSpace = GEP->getPointerAddressSpace();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1073</td>
    <td class="codeline">    bool PointerHasExtraData = DL->getPointerSizeInBits(AddrSpace) !=</td>
    <td class="lineNumber">1073</td>
    <td class="codeline">    bool PointerHasExtraData = DL->getPointerSizeInBits(AddrSpace) !=</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1074</td>
    <td class="codeline">                               DL->getIndexSizeInBits(AddrSpace);</td>
    <td class="lineNumber">1074</td>
    <td class="codeline">                               DL->getIndexSizeInBits(AddrSpace);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1075</td>
    <td class="codeline">    if (TTI.useAA() || DL->isNonIntegralAddressSpace(AddrSpace) ||</td>
    <td class="lineNumber">1075</td>
    <td class="codeline">    if (TTI.useAA() || DL->isNonIntegralAddressSpace(AddrSpace) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1076</td>
    <td class="codeline">        PointerHasExtraData)</td>
    <td class="lineNumber">1076</td>
    <td class="codeline">        PointerHasExtraData)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1077</td>
    <td class="codeline">      lowerToSingleIndexGEPs(GEP, AccumulativeByteOffset);</td>
    <td class="lineNumber">1077</td>
    <td class="codeline">      lowerToSingleIndexGEPs(GEP, AccumulativeByteOffset);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1078</td>
    <td class="codeline">    else</td>
    <td class="lineNumber">1078</td>
    <td class="codeline">    else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1079</td>
    <td class="codeline">      lowerToArithmetics(GEP, AccumulativeByteOffset);</td>
    <td class="lineNumber">1079</td>
    <td class="codeline">      lowerToArithmetics(GEP, AccumulativeByteOffset);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1080</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">1080</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1081</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1081</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1082</td>
    <td class="codeline"></td>
    <td class="lineNumber">1082</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1083</td>
    <td class="codeline">  // No need to create another GEP if the accumulative byte offset is 0.</td>
    <td class="lineNumber">1083</td>
    <td class="codeline">  // No need to create another GEP if the accumulative byte offset is 0.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1084</td>
    <td class="codeline">  if (AccumulativeByteOffset == 0)</td>
    <td class="lineNumber">1084</td>
    <td class="codeline">  if (AccumulativeByteOffset == 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1085</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">1085</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1086</td>
    <td class="codeline"></td>
    <td class="lineNumber">1086</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1087</td>
    <td class="codeline">  // Offsets the base with the accumulative byte offset.</td>
    <td class="lineNumber">1087</td>
    <td class="codeline">  // Offsets the base with the accumulative byte offset.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1088</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">1088</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1089</td>
    <td class="codeline">  //   %gep                        ; the base</td>
    <td class="lineNumber">1089</td>
    <td class="codeline">  //   %gep                        ; the base</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1090</td>
    <td class="codeline">  //   ... %gep ...</td>
    <td class="lineNumber">1090</td>
    <td class="codeline">  //   ... %gep ...</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1091</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">1091</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1092</td>
    <td class="codeline">  // => add the offset</td>
    <td class="lineNumber">1092</td>
    <td class="codeline">  // => add the offset</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1093</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">1093</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1094</td>
    <td class="codeline">  //   %gep2                       ; clone of %gep</td>
    <td class="lineNumber">1094</td>
    <td class="codeline">  //   %gep2                       ; clone of %gep</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1095</td>
    <td class="codeline">  //   %new.gep = gep %gep2, <offset / sizeof(*%gep)></td>
    <td class="lineNumber">1095</td>
    <td class="codeline">  //   %new.gep = gep %gep2, <offset / sizeof(*%gep)></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1096</td>
    <td class="codeline">  //   %gep                        ; will be removed</td>
    <td class="lineNumber">1096</td>
    <td class="codeline">  //   %gep                        ; will be removed</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1097</td>
    <td class="codeline">  //   ... %gep ...</td>
    <td class="lineNumber">1097</td>
    <td class="codeline">  //   ... %gep ...</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1098</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">1098</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1099</td>
    <td class="codeline">  // => replace all uses of %gep with %new.gep and remove %gep</td>
    <td class="lineNumber">1099</td>
    <td class="codeline">  // => replace all uses of %gep with %new.gep and remove %gep</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1100</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">1100</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1101</td>
    <td class="codeline">  //   %gep2                       ; clone of %gep</td>
    <td class="lineNumber">1101</td>
    <td class="codeline">  //   %gep2                       ; clone of %gep</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1102</td>
    <td class="codeline">  //   %new.gep = gep %gep2, <offset / sizeof(*%gep)></td>
    <td class="lineNumber">1102</td>
    <td class="codeline">  //   %new.gep = gep %gep2, <offset / sizeof(*%gep)></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1103</td>
    <td class="codeline">  //   ... %new.gep ...</td>
    <td class="lineNumber">1103</td>
    <td class="codeline">  //   ... %new.gep ...</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1104</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">1104</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1105</td>
    <td class="codeline">  // If AccumulativeByteOffset is not a multiple of sizeof(*%gep), we emit an</td>
    <td class="lineNumber">1105</td>
    <td class="codeline">  // If AccumulativeByteOffset is not a multiple of sizeof(*%gep), we emit an</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1106</td>
    <td class="codeline">  // uglygep (http://llvm.org/docs/GetElementPtr.html#what-s-an-uglygep):</td>
    <td class="lineNumber">1106</td>
    <td class="codeline">  // uglygep (http://llvm.org/docs/GetElementPtr.html#what-s-an-uglygep):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1107</td>
    <td class="codeline">  // bitcast %gep2 to i8*, add the offset, and bitcast the result back to the</td>
    <td class="lineNumber">1107</td>
    <td class="codeline">  // bitcast %gep2 to i8*, add the offset, and bitcast the result back to the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1108</td>
    <td class="codeline">  // type of %gep.</td>
    <td class="lineNumber">1108</td>
    <td class="codeline">  // type of %gep.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1109</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">1109</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1110</td>
    <td class="codeline">  //   %gep2                       ; clone of %gep</td>
    <td class="lineNumber">1110</td>
    <td class="codeline">  //   %gep2                       ; clone of %gep</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1111</td>
    <td class="codeline">  //   %0       = bitcast %gep2 to i8*</td>
    <td class="lineNumber">1111</td>
    <td class="codeline">  //   %0       = bitcast %gep2 to i8*</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1112</td>
    <td class="codeline">  //   %uglygep = gep %0, <offset></td>
    <td class="lineNumber">1112</td>
    <td class="codeline">  //   %uglygep = gep %0, <offset></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1113</td>
    <td class="codeline">  //   %new.gep = bitcast %uglygep to <type of %gep></td>
    <td class="lineNumber">1113</td>
    <td class="codeline">  //   %new.gep = bitcast %uglygep to <type of %gep></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1114</td>
    <td class="codeline">  //   ... %new.gep ...</td>
    <td class="lineNumber">1114</td>
    <td class="codeline">  //   ... %new.gep ...</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1115</td>
    <td class="codeline">  Instruction *NewGEP = GEP->clone();</td>
    <td class="lineNumber">1115</td>
    <td class="codeline">  Instruction *NewGEP = GEP->clone();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1116</td>
    <td class="codeline">  NewGEP->insertBefore(GEP);</td>
    <td class="lineNumber">1116</td>
    <td class="codeline">  NewGEP->insertBefore(GEP);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1117</td>
    <td class="codeline"></td>
    <td class="lineNumber">1117</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1118</td>
    <td class="codeline">  // Per ANSI C standard, signed / unsigned = unsigned and signed % unsigned =</td>
    <td class="lineNumber">1118</td>
    <td class="codeline">  // Per ANSI C standard, signed / unsigned = unsigned and signed % unsigned =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1119</td>
    <td class="codeline">  // unsigned.. Therefore, we cast ElementTypeSizeOfGEP to signed because it is</td>
    <td class="lineNumber">1119</td>
    <td class="codeline">  // unsigned.. Therefore, we cast ElementTypeSizeOfGEP to signed because it is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1120</td>
    <td class="codeline">  // used with unsigned integers later.</td>
    <td class="lineNumber">1120</td>
    <td class="codeline">  // used with unsigned integers later.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1121</td>
    <td class="codeline">  int64_t ElementTypeSizeOfGEP = static_cast<int64_t>(</td>
    <td class="lineNumber">1121</td>
    <td class="codeline">  int64_t ElementTypeSizeOfGEP = static_cast<int64_t>(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1122</td>
    <td class="codeline">      DL->getTypeAllocSize(GEP->getResultElementType()));</td>
    <td class="lineNumber">1122</td>
    <td class="codeline">      DL->getTypeAllocSize(GEP->getResultElementType()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1123</td>
    <td class="codeline">  Type *PtrIdxTy = DL->getIndexType(GEP->getType());</td>
    <td class="lineNumber">1123</td>
    <td class="codeline">  Type *PtrIdxTy = DL->getIndexType(GEP->getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1124</td>
    <td class="codeline">  if (AccumulativeByteOffset % ElementTypeSizeOfGEP == 0) {</td>
    <td class="lineNumber">1124</td>
    <td class="codeline">  if (AccumulativeByteOffset % ElementTypeSizeOfGEP == 0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1125</td>
    <td class="codeline">    // Very likely. As long as %gep is naturally aligned, the byte offset we</td>
    <td class="lineNumber">1125</td>
    <td class="codeline">    // Very likely. As long as %gep is naturally aligned, the byte offset we</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1126</td>
    <td class="codeline">    // extracted should be a multiple of sizeof(*%gep).</td>
    <td class="lineNumber">1126</td>
    <td class="codeline">    // extracted should be a multiple of sizeof(*%gep).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1127</td>
    <td class="codeline">    int64_t Index = AccumulativeByteOffset / ElementTypeSizeOfGEP;</td>
    <td class="lineNumber">1127</td>
    <td class="codeline">    int64_t Index = AccumulativeByteOffset / ElementTypeSizeOfGEP;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1128</td>
    <td class="codeline">    NewGEP = GetElementPtrInst::Create(GEP->getResultElementType(), NewGEP,</td>
    <td class="lineNumber">1128</td>
    <td class="codeline">    NewGEP = GetElementPtrInst::Create(GEP->getResultElementType(), NewGEP,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1129</td>
    <td class="codeline">                                       ConstantInt::get(PtrIdxTy, Index, true),</td>
    <td class="lineNumber">1129</td>
    <td class="codeline">                                       ConstantInt::get(PtrIdxTy, Index, true),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1130</td>
    <td class="codeline">                                       GEP->getName(), GEP);</td>
    <td class="lineNumber">1130</td>
    <td class="codeline">                                       GEP->getName(), GEP);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1131</td>
    <td class="codeline">    NewGEP->copyMetadata(*GEP);</td>
    <td class="lineNumber">1131</td>
    <td class="codeline">    NewGEP->copyMetadata(*GEP);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1132</td>
    <td class="codeline">    // Inherit the inbounds attribute of the original GEP.</td>
    <td class="lineNumber">1132</td>
    <td class="codeline">    // Inherit the inbounds attribute of the original GEP.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1133</td>
    <td class="codeline">    cast<GetElementPtrInst>(NewGEP)->setIsInBounds(GEPWasInBounds);</td>
    <td class="lineNumber">1133</td>
    <td class="codeline">    cast<GetElementPtrInst>(NewGEP)->setIsInBounds(GEPWasInBounds);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1134</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">1134</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1135</td>
    <td class="codeline">    // Unlikely but possible. For example,</td>
    <td class="lineNumber">1135</td>
    <td class="codeline">    // Unlikely but possible. For example,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1136</td>
    <td class="codeline">    // #pragma pack(1)</td>
    <td class="lineNumber">1136</td>
    <td class="codeline">    // #pragma pack(1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1137</td>
    <td class="codeline">    // struct S {</td>
    <td class="lineNumber">1137</td>
    <td class="codeline">    // struct S {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1138</td>
    <td class="codeline">    //   int a[3];</td>
    <td class="lineNumber">1138</td>
    <td class="codeline">    //   int a[3];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1139</td>
    <td class="codeline">    //   int64 b[8];</td>
    <td class="lineNumber">1139</td>
    <td class="codeline">    //   int64 b[8];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1140</td>
    <td class="codeline">    // };</td>
    <td class="lineNumber">1140</td>
    <td class="codeline">    // };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1141</td>
    <td class="codeline">    // #pragma pack()</td>
    <td class="lineNumber">1141</td>
    <td class="codeline">    // #pragma pack()</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1142</td>
    <td class="codeline">    //</td>
    <td class="lineNumber">1142</td>
    <td class="codeline">    //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1143</td>
    <td class="codeline">    // Suppose the gep before extraction is &s[i + 1].b[j + 3]. After</td>
    <td class="lineNumber">1143</td>
    <td class="codeline">    // Suppose the gep before extraction is &s[i + 1].b[j + 3]. After</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1144</td>
    <td class="codeline">    // extraction, it becomes &s[i].b[j] and AccumulativeByteOffset is</td>
    <td class="lineNumber">1144</td>
    <td class="codeline">    // extraction, it becomes &s[i].b[j] and AccumulativeByteOffset is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1145</td>
    <td class="codeline">    // sizeof(S) + 3 * sizeof(int64) = 100, which is not a multiple of</td>
    <td class="lineNumber">1145</td>
    <td class="codeline">    // sizeof(S) + 3 * sizeof(int64) = 100, which is not a multiple of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1146</td>
    <td class="codeline">    // sizeof(int64).</td>
    <td class="lineNumber">1146</td>
    <td class="codeline">    // sizeof(int64).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1147</td>
    <td class="codeline">    //</td>
    <td class="lineNumber">1147</td>
    <td class="codeline">    //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1148</td>
    <td class="codeline">    // Emit an uglygep in this case.</td>
    <td class="lineNumber">1148</td>
    <td class="codeline">    // Emit an uglygep in this case.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1149</td>
    <td class="codeline">    IRBuilder<> Builder(GEP);</td>
    <td class="lineNumber">1149</td>
    <td class="codeline">    IRBuilder<> Builder(GEP);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1150</td>
    <td class="codeline">    NewGEP = cast<Instruction>(Builder.CreateGEP(</td>
    <td class="lineNumber">1150</td>
    <td class="codeline">    NewGEP = cast<Instruction>(Builder.CreateGEP(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1151</td>
    <td class="codeline">        Builder.getInt8Ty(), NewGEP,</td>
    <td class="lineNumber">1151</td>
    <td class="codeline">        Builder.getInt8Ty(), NewGEP,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1152</td>
    <td class="codeline">        {ConstantInt::get(PtrIdxTy, AccumulativeByteOffset, true)}, "uglygep",</td>
    <td class="lineNumber">1152</td>
    <td class="codeline">        {ConstantInt::get(PtrIdxTy, AccumulativeByteOffset, true)}, "uglygep",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1153</td>
    <td class="codeline">        GEPWasInBounds));</td>
    <td class="lineNumber">1153</td>
    <td class="codeline">        GEPWasInBounds));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1154</td>
    <td class="codeline">    NewGEP->copyMetadata(*GEP);</td>
    <td class="lineNumber">1154</td>
    <td class="codeline">    NewGEP->copyMetadata(*GEP);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1155</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1155</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1156</td>
    <td class="codeline"></td>
    <td class="lineNumber">1156</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1157</td>
    <td class="codeline">  GEP->replaceAllUsesWith(NewGEP);</td>
    <td class="lineNumber">1157</td>
    <td class="codeline">  GEP->replaceAllUsesWith(NewGEP);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1158</td>
    <td class="codeline">  GEP->eraseFromParent();</td>
    <td class="lineNumber">1158</td>
    <td class="codeline">  GEP->eraseFromParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1159</td>
    <td class="codeline"></td>
    <td class="lineNumber">1159</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1160</td>
    <td class="codeline">  return true;</td>
    <td class="lineNumber">1160</td>
    <td class="codeline">  return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1161</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1161</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1162</td>
    <td class="codeline"></td>
    <td class="lineNumber">1162</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1163</td>
    <td class="codeline">bool SeparateConstOffsetFromGEPLegacyPass::runOnFunction(Function &F) {</td>
    <td class="lineNumber">1163</td>
    <td class="codeline">bool SeparateConstOffsetFromGEPLegacyPass::runOnFunction(Function &F) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1164</td>
    <td class="codeline">  if (skipFunction(F))</td>
    <td class="lineNumber">1164</td>
    <td class="codeline">  if (skipFunction(F))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1165</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1165</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1166</td>
    <td class="codeline">  auto *DT = &getAnalysis<DominatorTreeWrapperPass>().getDomTree();</td>
    <td class="lineNumber">1166</td>
    <td class="codeline">  auto *DT = &getAnalysis<DominatorTreeWrapperPass>().getDomTree();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1167</td>
    <td class="codeline">  auto *LI = &getAnalysis<LoopInfoWrapperPass>().getLoopInfo();</td>
    <td class="lineNumber">1167</td>
    <td class="codeline">  auto *LI = &getAnalysis<LoopInfoWrapperPass>().getLoopInfo();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1168</td>
    <td class="codeline">  auto *TLI = &getAnalysis<TargetLibraryInfoWrapperPass>().getTLI(F);</td>
    <td class="lineNumber">1168</td>
    <td class="codeline">  auto *TLI = &getAnalysis<TargetLibraryInfoWrapperPass>().getTLI(F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1169</td>
    <td class="codeline">  auto GetTTI = [this](Function &F) -> TargetTransformInfo & {</td>
    <td class="lineNumber">1169</td>
    <td class="codeline">  auto GetTTI = [this](Function &F) -> TargetTransformInfo & {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1170</td>
    <td class="codeline">    return this->getAnalysis<TargetTransformInfoWrapperPass>().getTTI(F);</td>
    <td class="lineNumber">1170</td>
    <td class="codeline">    return this->getAnalysis<TargetTransformInfoWrapperPass>().getTTI(F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1171</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">1171</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1172</td>
    <td class="codeline">  SeparateConstOffsetFromGEP Impl(DT, LI, TLI, GetTTI, LowerGEP);</td>
    <td class="lineNumber">1172</td>
    <td class="codeline">  SeparateConstOffsetFromGEP Impl(DT, LI, TLI, GetTTI, LowerGEP);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1173</td>
    <td class="codeline">  return Impl.run(F);</td>
    <td class="lineNumber">1173</td>
    <td class="codeline">  return Impl.run(F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1174</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1174</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1175</td>
    <td class="codeline"></td>
    <td class="lineNumber">1175</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1176</td>
    <td class="codeline">bool SeparateConstOffsetFromGEP::run(Function &F) {</td>
    <td class="lineNumber">1176</td>
    <td class="codeline">bool SeparateConstOffsetFromGEP::run(Function &F) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1177</td>
    <td class="codeline">  if (DisableSeparateConstOffsetFromGEP)</td>
    <td class="lineNumber">1177</td>
    <td class="codeline">  if (DisableSeparateConstOffsetFromGEP)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1178</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1178</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1179</td>
    <td class="codeline"></td>
    <td class="lineNumber">1179</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1180</td>
    <td class="codeline">  DL = &F.getParent()->getDataLayout();</td>
    <td class="lineNumber">1180</td>
    <td class="codeline">  DL = &F.getParent()->getDataLayout();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1181</td>
    <td class="codeline">  bool Changed = false;</td>
    <td class="lineNumber">1181</td>
    <td class="codeline">  bool Changed = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1182</td>
    <td class="codeline">  for (BasicBlock &B : F) {</td>
    <td class="lineNumber">1182</td>
    <td class="codeline">  for (BasicBlock &B : F) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1183</td>
    <td class="codeline">    if (!DT->isReachableFromEntry(&B))</td>
    <td class="lineNumber">1183</td>
    <td class="codeline">    if (!DT->isReachableFromEntry(&B))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1184</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">1184</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1185</td>
    <td class="codeline"></td>
    <td class="lineNumber">1185</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1186</td>
    <td class="codeline">    for (Instruction &I : llvm::make_early_inc_range(B))</td>
    <td class="lineNumber">1186</td>
    <td class="codeline">    for (Instruction &I : llvm::make_early_inc_range(B))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1187</td>
    <td class="codeline">      if (GetElementPtrInst *GEP = dyn_cast<GetElementPtrInst>(&I))</td>
    <td class="lineNumber">1187</td>
    <td class="codeline">      if (GetElementPtrInst *GEP = dyn_cast<GetElementPtrInst>(&I))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1188</td>
    <td class="codeline">        Changed |= splitGEP(GEP);</td>
    <td class="lineNumber">1188</td>
    <td class="codeline">        Changed |= splitGEP(GEP);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1189</td>
    <td class="codeline">    // No need to split GEP ConstantExprs because all its indices are constant</td>
    <td class="lineNumber">1189</td>
    <td class="codeline">    // No need to split GEP ConstantExprs because all its indices are constant</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1190</td>
    <td class="codeline">    // already.</td>
    <td class="lineNumber">1190</td>
    <td class="codeline">    // already.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1191</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1191</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1192</td>
    <td class="codeline"></td>
    <td class="lineNumber">1192</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1193</td>
    <td class="codeline">  Changed |= reuniteExts(F);</td>
    <td class="lineNumber">1193</td>
    <td class="codeline">  Changed |= reuniteExts(F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1194</td>
    <td class="codeline"></td>
    <td class="lineNumber">1194</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1195</td>
    <td class="codeline">  if (VerifyNoDeadCode)</td>
    <td class="lineNumber">1195</td>
    <td class="codeline">  if (VerifyNoDeadCode)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1196</td>
    <td class="codeline">    verifyNoDeadCode(F);</td>
    <td class="lineNumber">1196</td>
    <td class="codeline">    verifyNoDeadCode(F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1197</td>
    <td class="codeline"></td>
    <td class="lineNumber">1197</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1198</td>
    <td class="codeline">  return Changed;</td>
    <td class="lineNumber">1198</td>
    <td class="codeline">  return Changed;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1199</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1199</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1200</td>
    <td class="codeline"></td>
    <td class="lineNumber">1200</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1201</td>
    <td class="codeline">Instruction *SeparateConstOffsetFromGEP::findClosestMatchingDominator(</td>
    <td class="lineNumber">1201</td>
    <td class="codeline">Instruction *SeparateConstOffsetFromGEP::findClosestMatchingDominator(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1202</td>
    <td class="codeline">    ExprKey Key, Instruction *Dominatee,</td>
    <td class="lineNumber">1202</td>
    <td class="codeline">    ExprKey Key, Instruction *Dominatee,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1203</td>
    <td class="codeline">    DenseMap<ExprKey, SmallVector<Instruction *, 2>> &DominatingExprs) {</td>
    <td class="lineNumber">1203</td>
    <td class="codeline">    DenseMap<ExprKey, SmallVector<Instruction *, 2>> &DominatingExprs) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1204</td>
    <td class="codeline">  auto Pos = DominatingExprs.find(Key);</td>
    <td class="lineNumber">1204</td>
    <td class="codeline">  auto Pos = DominatingExprs.find(Key);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1205</td>
    <td class="codeline">  if (Pos == DominatingExprs.end())</td>
    <td class="lineNumber">1205</td>
    <td class="codeline">  if (Pos == DominatingExprs.end())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1206</td>
    <td class="codeline">    return nullptr;</td>
    <td class="lineNumber">1206</td>
    <td class="codeline">    return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1207</td>
    <td class="codeline"></td>
    <td class="lineNumber">1207</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1208</td>
    <td class="codeline">  auto &Candidates = Pos->second;</td>
    <td class="lineNumber">1208</td>
    <td class="codeline">  auto &Candidates = Pos->second;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1209</td>
    <td class="codeline">  // Because we process the basic blocks in pre-order of the dominator tree, a</td>
    <td class="lineNumber">1209</td>
    <td class="codeline">  // Because we process the basic blocks in pre-order of the dominator tree, a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1210</td>
    <td class="codeline">  // candidate that doesn't dominate the current instruction won't dominate any</td>
    <td class="lineNumber">1210</td>
    <td class="codeline">  // candidate that doesn't dominate the current instruction won't dominate any</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1211</td>
    <td class="codeline">  // future instruction either. Therefore, we pop it out of the stack. This</td>
    <td class="lineNumber">1211</td>
    <td class="codeline">  // future instruction either. Therefore, we pop it out of the stack. This</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1212</td>
    <td class="codeline">  // optimization makes the algorithm O(n).</td>
    <td class="lineNumber">1212</td>
    <td class="codeline">  // optimization makes the algorithm O(n).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1213</td>
    <td class="codeline">  while (!Candidates.empty()) {</td>
    <td class="lineNumber">1213</td>
    <td class="codeline">  while (!Candidates.empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1214</td>
    <td class="codeline">    Instruction *Candidate = Candidates.back();</td>
    <td class="lineNumber">1214</td>
    <td class="codeline">    Instruction *Candidate = Candidates.back();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1215</td>
    <td class="codeline">    if (DT->dominates(Candidate, Dominatee))</td>
    <td class="lineNumber">1215</td>
    <td class="codeline">    if (DT->dominates(Candidate, Dominatee))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1216</td>
    <td class="codeline">      return Candidate;</td>
    <td class="lineNumber">1216</td>
    <td class="codeline">      return Candidate;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1217</td>
    <td class="codeline">    Candidates.pop_back();</td>
    <td class="lineNumber">1217</td>
    <td class="codeline">    Candidates.pop_back();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1218</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1218</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1219</td>
    <td class="codeline">  return nullptr;</td>
    <td class="lineNumber">1219</td>
    <td class="codeline">  return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1220</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1220</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1221</td>
    <td class="codeline"></td>
    <td class="lineNumber">1221</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1222</td>
    <td class="codeline">bool SeparateConstOffsetFromGEP::reuniteExts(Instruction *I) {</td>
    <td class="lineNumber">1222</td>
    <td class="codeline">bool SeparateConstOffsetFromGEP::reuniteExts(Instruction *I) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1223</td>
    <td class="codeline">  if (!I->getType()->isIntOrIntVectorTy())</td>
    <td class="lineNumber">1223</td>
    <td class="codeline">  if (!I->getType()->isIntOrIntVectorTy())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1224</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1224</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1225</td>
    <td class="codeline"></td>
    <td class="lineNumber">1225</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1226</td>
    <td class="codeline">  //   Dom: LHS+RHS</td>
    <td class="lineNumber">1226</td>
    <td class="codeline">  //   Dom: LHS+RHS</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1227</td>
    <td class="codeline">  //   I: sext(LHS)+sext(RHS)</td>
    <td class="lineNumber">1227</td>
    <td class="codeline">  //   I: sext(LHS)+sext(RHS)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1228</td>
    <td class="codeline">  // If Dom can't sign overflow and Dom dominates I, optimize I to sext(Dom).</td>
    <td class="lineNumber">1228</td>
    <td class="codeline">  // If Dom can't sign overflow and Dom dominates I, optimize I to sext(Dom).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1229</td>
    <td class="codeline">  // TODO: handle zext</td>
    <td class="lineNumber">1229</td>
    <td class="codeline">  // TODO: handle zext</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1230</td>
    <td class="codeline">  Value *LHS = nullptr, *RHS = nullptr;</td>
    <td class="lineNumber">1230</td>
    <td class="codeline">  Value *LHS = nullptr, *RHS = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1231</td>
    <td class="codeline">  if (match(I, m_Add(m_SExt(m_Value(LHS)), m_SExt(m_Value(RHS))))) {</td>
    <td class="lineNumber">1231</td>
    <td class="codeline">  if (match(I, m_Add(m_SExt(m_Value(LHS)), m_SExt(m_Value(RHS))))) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1232</td>
    <td class="codeline">    if (LHS->getType() == RHS->getType()) {</td>
    <td class="lineNumber">1232</td>
    <td class="codeline">    if (LHS->getType() == RHS->getType()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1233</td>
    <td class="codeline">      ExprKey Key = createNormalizedCommutablePair(LHS, RHS);</td>
    <td class="lineNumber">1233</td>
    <td class="codeline">      ExprKey Key = createNormalizedCommutablePair(LHS, RHS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1234</td>
    <td class="codeline">      if (auto *Dom = findClosestMatchingDominator(Key, I, DominatingAdds)) {</td>
    <td class="lineNumber">1234</td>
    <td class="codeline">      if (auto *Dom = findClosestMatchingDominator(Key, I, DominatingAdds)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1235</td>
    <td class="codeline">        Instruction *NewSExt = new SExtInst(Dom, I->getType(), "", I);</td>
    <td class="lineNumber">1235</td>
    <td class="codeline">        Instruction *NewSExt = new SExtInst(Dom, I->getType(), "", I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1236</td>
    <td class="codeline">        NewSExt->takeName(I);</td>
    <td class="lineNumber">1236</td>
    <td class="codeline">        NewSExt->takeName(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1237</td>
    <td class="codeline">        I->replaceAllUsesWith(NewSExt);</td>
    <td class="lineNumber">1237</td>
    <td class="codeline">        I->replaceAllUsesWith(NewSExt);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1238</td>
    <td class="codeline">        RecursivelyDeleteTriviallyDeadInstructions(I);</td>
    <td class="lineNumber">1238</td>
    <td class="codeline">        RecursivelyDeleteTriviallyDeadInstructions(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1239</td>
    <td class="codeline">        return true;</td>
    <td class="lineNumber">1239</td>
    <td class="codeline">        return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1240</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1240</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1241</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1241</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1242</td>
    <td class="codeline">  } else if (match(I, m_Sub(m_SExt(m_Value(LHS)), m_SExt(m_Value(RHS))))) {</td>
    <td class="lineNumber">1242</td>
    <td class="codeline">  } else if (match(I, m_Sub(m_SExt(m_Value(LHS)), m_SExt(m_Value(RHS))))) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1243</td>
    <td class="codeline">    if (LHS->getType() == RHS->getType()) {</td>
    <td class="lineNumber">1243</td>
    <td class="codeline">    if (LHS->getType() == RHS->getType()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1244</td>
    <td class="codeline">      if (auto *Dom =</td>
    <td class="lineNumber">1244</td>
    <td class="codeline">      if (auto *Dom =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1245</td>
    <td class="codeline">              findClosestMatchingDominator({LHS, RHS}, I, DominatingSubs)) {</td>
    <td class="lineNumber">1245</td>
    <td class="codeline">              findClosestMatchingDominator({LHS, RHS}, I, DominatingSubs)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1246</td>
    <td class="codeline">        Instruction *NewSExt = new SExtInst(Dom, I->getType(), "", I);</td>
    <td class="lineNumber">1246</td>
    <td class="codeline">        Instruction *NewSExt = new SExtInst(Dom, I->getType(), "", I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1247</td>
    <td class="codeline">        NewSExt->takeName(I);</td>
    <td class="lineNumber">1247</td>
    <td class="codeline">        NewSExt->takeName(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1248</td>
    <td class="codeline">        I->replaceAllUsesWith(NewSExt);</td>
    <td class="lineNumber">1248</td>
    <td class="codeline">        I->replaceAllUsesWith(NewSExt);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1249</td>
    <td class="codeline">        RecursivelyDeleteTriviallyDeadInstructions(I);</td>
    <td class="lineNumber">1249</td>
    <td class="codeline">        RecursivelyDeleteTriviallyDeadInstructions(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1250</td>
    <td class="codeline">        return true;</td>
    <td class="lineNumber">1250</td>
    <td class="codeline">        return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1251</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1251</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1252</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1252</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1253</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1253</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1254</td>
    <td class="codeline"></td>
    <td class="lineNumber">1254</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1255</td>
    <td class="codeline">  // Add I to DominatingExprs if it's an add/sub that can't sign overflow.</td>
    <td class="lineNumber">1255</td>
    <td class="codeline">  // Add I to DominatingExprs if it's an add/sub that can't sign overflow.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1256</td>
    <td class="codeline">  if (match(I, m_NSWAdd(m_Value(LHS), m_Value(RHS)))) {</td>
    <td class="lineNumber">1256</td>
    <td class="codeline">  if (match(I, m_NSWAdd(m_Value(LHS), m_Value(RHS)))) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1257</td>
    <td class="codeline">    if (programUndefinedIfPoison(I)) {</td>
    <td class="lineNumber">1257</td>
    <td class="codeline">    if (programUndefinedIfPoison(I)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1258</td>
    <td class="codeline">      ExprKey Key = createNormalizedCommutablePair(LHS, RHS);</td>
    <td class="lineNumber">1258</td>
    <td class="codeline">      ExprKey Key = createNormalizedCommutablePair(LHS, RHS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1259</td>
    <td class="codeline">      DominatingAdds[Key].push_back(I);</td>
    <td class="lineNumber">1259</td>
    <td class="codeline">      DominatingAdds[Key].push_back(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1260</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1260</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1261</td>
    <td class="codeline">  } else if (match(I, m_NSWSub(m_Value(LHS), m_Value(RHS)))) {</td>
    <td class="lineNumber">1261</td>
    <td class="codeline">  } else if (match(I, m_NSWSub(m_Value(LHS), m_Value(RHS)))) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1262</td>
    <td class="codeline">    if (programUndefinedIfPoison(I))</td>
    <td class="lineNumber">1262</td>
    <td class="codeline">    if (programUndefinedIfPoison(I))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1263</td>
    <td class="codeline">      DominatingSubs[{LHS, RHS}].push_back(I);</td>
    <td class="lineNumber">1263</td>
    <td class="codeline">      DominatingSubs[{LHS, RHS}].push_back(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1264</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1264</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1265</td>
    <td class="codeline">  return false;</td>
    <td class="lineNumber">1265</td>
    <td class="codeline">  return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1266</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1266</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1267</td>
    <td class="codeline"></td>
    <td class="lineNumber">1267</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1268</td>
    <td class="codeline">bool SeparateConstOffsetFromGEP::reuniteExts(Function &F) {</td>
    <td class="lineNumber">1268</td>
    <td class="codeline">bool SeparateConstOffsetFromGEP::reuniteExts(Function &F) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1269</td>
    <td class="codeline">  bool Changed = false;</td>
    <td class="lineNumber">1269</td>
    <td class="codeline">  bool Changed = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1270</td>
    <td class="codeline">  DominatingAdds.clear();</td>
    <td class="lineNumber">1270</td>
    <td class="codeline">  DominatingAdds.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1271</td>
    <td class="codeline">  DominatingSubs.clear();</td>
    <td class="lineNumber">1271</td>
    <td class="codeline">  DominatingSubs.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1272</td>
    <td class="codeline">  for (const auto Node : depth_first(DT)) {</td>
    <td class="lineNumber">1272</td>
    <td class="codeline">  for (const auto Node : depth_first(DT)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1273</td>
    <td class="codeline">    BasicBlock *BB = Node->getBlock();</td>
    <td class="lineNumber">1273</td>
    <td class="codeline">    BasicBlock *BB = Node->getBlock();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1274</td>
    <td class="codeline">    for (Instruction &I : llvm::make_early_inc_range(*BB))</td>
    <td class="lineNumber">1274</td>
    <td class="codeline">    for (Instruction &I : llvm::make_early_inc_range(*BB))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1275</td>
    <td class="codeline">      Changed |= reuniteExts(&I);</td>
    <td class="lineNumber">1275</td>
    <td class="codeline">      Changed |= reuniteExts(&I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1276</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1276</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1277</td>
    <td class="codeline">  return Changed;</td>
    <td class="lineNumber">1277</td>
    <td class="codeline">  return Changed;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1278</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1278</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1279</td>
    <td class="codeline"></td>
    <td class="lineNumber">1279</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1280</td>
    <td class="codeline">void SeparateConstOffsetFromGEP::verifyNoDeadCode(Function &F) {</td>
    <td class="lineNumber">1280</td>
    <td class="codeline">void SeparateConstOffsetFromGEP::verifyNoDeadCode(Function &F) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1281</td>
    <td class="codeline">  for (BasicBlock &B : F) {</td>
    <td class="lineNumber">1281</td>
    <td class="codeline">  for (BasicBlock &B : F) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1282</td>
    <td class="codeline">    for (Instruction &I : B) {</td>
    <td class="lineNumber">1282</td>
    <td class="codeline">    for (Instruction &I : B) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1283</td>
    <td class="codeline">      if (isInstructionTriviallyDead(&I)) {</td>
    <td class="lineNumber">1283</td>
    <td class="codeline">      if (isInstructionTriviallyDead(&I)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1284</td>
    <td class="codeline">        std::string ErrMessage;</td>
    <td class="lineNumber">1284</td>
    <td class="codeline">        std::string ErrMessage;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1285</td>
    <td class="codeline">        raw_string_ostream RSO(ErrMessage);</td>
    <td class="lineNumber">1285</td>
    <td class="codeline">        raw_string_ostream RSO(ErrMessage);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1286</td>
    <td class="codeline">        RSO << "Dead instruction detected!\n" << I << "\n";</td>
    <td class="lineNumber">1286</td>
    <td class="codeline">        RSO << "Dead instruction detected!\n" << I << "\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1287</td>
    <td class="codeline">        llvm_unreachable(RSO.str().c_str());</td>
    <td class="lineNumber">1287</td>
    <td class="codeline">        llvm_unreachable(RSO.str().c_str());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1288</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1288</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1289</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1289</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1290</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1290</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1291</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1291</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1292</td>
    <td class="codeline"></td>
    <td class="lineNumber">1292</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1293</td>
    <td class="codeline">bool SeparateConstOffsetFromGEP::isLegalToSwapOperand(</td>
    <td class="lineNumber">1293</td>
    <td class="codeline">bool SeparateConstOffsetFromGEP::isLegalToSwapOperand(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1294</td>
    <td class="codeline">    GetElementPtrInst *FirstGEP, GetElementPtrInst *SecondGEP, Loop *CurLoop) {</td>
    <td class="lineNumber">1294</td>
    <td class="codeline">    GetElementPtrInst *FirstGEP, GetElementPtrInst *SecondGEP, Loop *CurLoop) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1295</td>
    <td class="codeline">  if (!FirstGEP || !FirstGEP->hasOneUse())</td>
    <td class="lineNumber">1295</td>
    <td class="codeline">  if (!FirstGEP || !FirstGEP->hasOneUse())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1296</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1296</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1297</td>
    <td class="codeline"></td>
    <td class="lineNumber">1297</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1298</td>
    <td class="codeline">  if (!SecondGEP || FirstGEP->getParent() != SecondGEP->getParent())</td>
    <td class="lineNumber">1298</td>
    <td class="codeline">  if (!SecondGEP || FirstGEP->getParent() != SecondGEP->getParent())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1299</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1299</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1300</td>
    <td class="codeline"></td>
    <td class="lineNumber">1300</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1301</td>
    <td class="codeline">  if (FirstGEP == SecondGEP)</td>
    <td class="lineNumber">1301</td>
    <td class="codeline">  if (FirstGEP == SecondGEP)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1302</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1302</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1303</td>
    <td class="codeline"></td>
    <td class="lineNumber">1303</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1304</td>
    <td class="codeline">  unsigned FirstNum = FirstGEP->getNumOperands();</td>
    <td class="lineNumber">1304</td>
    <td class="codeline">  unsigned FirstNum = FirstGEP->getNumOperands();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1305</td>
    <td class="codeline">  unsigned SecondNum = SecondGEP->getNumOperands();</td>
    <td class="lineNumber">1305</td>
    <td class="codeline">  unsigned SecondNum = SecondGEP->getNumOperands();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1306</td>
    <td class="codeline">  // Give up if the number of operands are not 2.</td>
    <td class="lineNumber">1306</td>
    <td class="codeline">  // Give up if the number of operands are not 2.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1307</td>
    <td class="codeline">  if (FirstNum != SecondNum || FirstNum != 2)</td>
    <td class="lineNumber">1307</td>
    <td class="codeline">  if (FirstNum != SecondNum || FirstNum != 2)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1308</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1308</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1309</td>
    <td class="codeline"></td>
    <td class="lineNumber">1309</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1310</td>
    <td class="codeline">  Value *FirstBase = FirstGEP->getOperand(0);</td>
    <td class="lineNumber">1310</td>
    <td class="codeline">  Value *FirstBase = FirstGEP->getOperand(0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1311</td>
    <td class="codeline">  Value *SecondBase = SecondGEP->getOperand(0);</td>
    <td class="lineNumber">1311</td>
    <td class="codeline">  Value *SecondBase = SecondGEP->getOperand(0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1312</td>
    <td class="codeline">  Value *FirstOffset = FirstGEP->getOperand(1);</td>
    <td class="lineNumber">1312</td>
    <td class="codeline">  Value *FirstOffset = FirstGEP->getOperand(1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1313</td>
    <td class="codeline">  // Give up if the index of the first GEP is loop invariant.</td>
    <td class="lineNumber">1313</td>
    <td class="codeline">  // Give up if the index of the first GEP is loop invariant.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1314</td>
    <td class="codeline">  if (CurLoop->isLoopInvariant(FirstOffset))</td>
    <td class="lineNumber">1314</td>
    <td class="codeline">  if (CurLoop->isLoopInvariant(FirstOffset))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1315</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1315</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1316</td>
    <td class="codeline"></td>
    <td class="lineNumber">1316</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1317</td>
    <td class="codeline">  // Give up if base doesn't have same type.</td>
    <td class="lineNumber">1317</td>
    <td class="codeline">  // Give up if base doesn't have same type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1318</td>
    <td class="codeline">  if (FirstBase->getType() != SecondBase->getType())</td>
    <td class="lineNumber">1318</td>
    <td class="codeline">  if (FirstBase->getType() != SecondBase->getType())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1319</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1319</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1320</td>
    <td class="codeline"></td>
    <td class="lineNumber">1320</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1321</td>
    <td class="codeline">  Instruction *FirstOffsetDef = dyn_cast<Instruction>(FirstOffset);</td>
    <td class="lineNumber">1321</td>
    <td class="codeline">  Instruction *FirstOffsetDef = dyn_cast<Instruction>(FirstOffset);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1322</td>
    <td class="codeline"></td>
    <td class="lineNumber">1322</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1323</td>
    <td class="codeline">  // Check if the second operand of first GEP has constant coefficient.</td>
    <td class="lineNumber">1323</td>
    <td class="codeline">  // Check if the second operand of first GEP has constant coefficient.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1324</td>
    <td class="codeline">  // For an example, for the following code,  we won't gain anything by</td>
    <td class="lineNumber">1324</td>
    <td class="codeline">  // For an example, for the following code,  we won't gain anything by</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1325</td>
    <td class="codeline">  // hoisting the second GEP out because the second GEP can be folded away.</td>
    <td class="lineNumber">1325</td>
    <td class="codeline">  // hoisting the second GEP out because the second GEP can be folded away.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1326</td>
    <td class="codeline">  //   %scevgep.sum.ur159 = add i64 %idxprom48.ur, 256</td>
    <td class="lineNumber">1326</td>
    <td class="codeline">  //   %scevgep.sum.ur159 = add i64 %idxprom48.ur, 256</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1327</td>
    <td class="codeline">  //   %67 = shl i64 %scevgep.sum.ur159, 2</td>
    <td class="lineNumber">1327</td>
    <td class="codeline">  //   %67 = shl i64 %scevgep.sum.ur159, 2</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1328</td>
    <td class="codeline">  //   %uglygep160 = getelementptr i8* %65, i64 %67</td>
    <td class="lineNumber">1328</td>
    <td class="codeline">  //   %uglygep160 = getelementptr i8* %65, i64 %67</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1329</td>
    <td class="codeline">  //   %uglygep161 = getelementptr i8* %uglygep160, i64 -1024</td>
    <td class="lineNumber">1329</td>
    <td class="codeline">  //   %uglygep161 = getelementptr i8* %uglygep160, i64 -1024</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1330</td>
    <td class="codeline"></td>
    <td class="lineNumber">1330</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1331</td>
    <td class="codeline">  // Skip constant shift instruction which may be generated by Splitting GEPs.</td>
    <td class="lineNumber">1331</td>
    <td class="codeline">  // Skip constant shift instruction which may be generated by Splitting GEPs.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1332</td>
    <td class="codeline">  if (FirstOffsetDef && FirstOffsetDef->isShift() &&</td>
    <td class="lineNumber">1332</td>
    <td class="codeline">  if (FirstOffsetDef && FirstOffsetDef->isShift() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1333</td>
    <td class="codeline">      isa<ConstantInt>(FirstOffsetDef->getOperand(1)))</td>
    <td class="lineNumber">1333</td>
    <td class="codeline">      isa<ConstantInt>(FirstOffsetDef->getOperand(1)))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1334</td>
    <td class="codeline">    FirstOffsetDef = dyn_cast<Instruction>(FirstOffsetDef->getOperand(0));</td>
    <td class="lineNumber">1334</td>
    <td class="codeline">    FirstOffsetDef = dyn_cast<Instruction>(FirstOffsetDef->getOperand(0));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1335</td>
    <td class="codeline"></td>
    <td class="lineNumber">1335</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1336</td>
    <td class="codeline">  // Give up if FirstOffsetDef is an Add or Sub with constant.</td>
    <td class="lineNumber">1336</td>
    <td class="codeline">  // Give up if FirstOffsetDef is an Add or Sub with constant.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1337</td>
    <td class="codeline">  // Because it may not profitable at all due to constant folding.</td>
    <td class="lineNumber">1337</td>
    <td class="codeline">  // Because it may not profitable at all due to constant folding.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1338</td>
    <td class="codeline">  if (FirstOffsetDef)</td>
    <td class="lineNumber">1338</td>
    <td class="codeline">  if (FirstOffsetDef)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1339</td>
    <td class="codeline">    if (BinaryOperator *BO = dyn_cast<BinaryOperator>(FirstOffsetDef)) {</td>
    <td class="lineNumber">1339</td>
    <td class="codeline">    if (BinaryOperator *BO = dyn_cast<BinaryOperator>(FirstOffsetDef)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1340</td>
    <td class="codeline">      unsigned opc = BO->getOpcode();</td>
    <td class="lineNumber">1340</td>
    <td class="codeline">      unsigned opc = BO->getOpcode();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1341</td>
    <td class="codeline">      if ((opc == Instruction::Add || opc == Instruction::Sub) &&</td>
    <td class="lineNumber">1341</td>
    <td class="codeline">      if ((opc == Instruction::Add || opc == Instruction::Sub) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1342</td>
    <td class="codeline">          (isa<ConstantInt>(BO->getOperand(0)) ||</td>
    <td class="lineNumber">1342</td>
    <td class="codeline">          (isa<ConstantInt>(BO->getOperand(0)) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1343</td>
    <td class="codeline">           isa<ConstantInt>(BO->getOperand(1))))</td>
    <td class="lineNumber">1343</td>
    <td class="codeline">           isa<ConstantInt>(BO->getOperand(1))))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1344</td>
    <td class="codeline">        return false;</td>
    <td class="lineNumber">1344</td>
    <td class="codeline">        return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1345</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1345</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1346</td>
    <td class="codeline">  return true;</td>
    <td class="lineNumber">1346</td>
    <td class="codeline">  return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1347</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1347</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1348</td>
    <td class="codeline"></td>
    <td class="lineNumber">1348</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1349</td>
    <td class="codeline">bool SeparateConstOffsetFromGEP::hasMoreThanOneUseInLoop(Value *V, Loop *L) {</td>
    <td class="lineNumber">1349</td>
    <td class="codeline">bool SeparateConstOffsetFromGEP::hasMoreThanOneUseInLoop(Value *V, Loop *L) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1350</td>
    <td class="codeline">  int UsesInLoop = 0;</td>
    <td class="lineNumber">1350</td>
    <td class="codeline">  int UsesInLoop = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1351</td>
    <td class="codeline">  for (User *U : V->users()) {</td>
    <td class="lineNumber">1351</td>
    <td class="codeline">  for (User *U : V->users()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1352</td>
    <td class="codeline">    if (Instruction *User = dyn_cast<Instruction>(U))</td>
    <td class="lineNumber">1352</td>
    <td class="codeline">    if (Instruction *User = dyn_cast<Instruction>(U))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1353</td>
    <td class="codeline">      if (L->contains(User))</td>
    <td class="lineNumber">1353</td>
    <td class="codeline">      if (L->contains(User))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1354</td>
    <td class="codeline">        if (++UsesInLoop > 1)</td>
    <td class="lineNumber">1354</td>
    <td class="codeline">        if (++UsesInLoop > 1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1355</td>
    <td class="codeline">          return true;</td>
    <td class="lineNumber">1355</td>
    <td class="codeline">          return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1356</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1356</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1357</td>
    <td class="codeline">  return false;</td>
    <td class="lineNumber">1357</td>
    <td class="codeline">  return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1358</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1358</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1359</td>
    <td class="codeline"></td>
    <td class="lineNumber">1359</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1360</td>
    <td class="codeline">void SeparateConstOffsetFromGEP::swapGEPOperand(GetElementPtrInst *First,</td>
    <td class="lineNumber">1360</td>
    <td class="codeline">void SeparateConstOffsetFromGEP::swapGEPOperand(GetElementPtrInst *First,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1361</td>
    <td class="codeline">                                                GetElementPtrInst *Second) {</td>
    <td class="lineNumber">1361</td>
    <td class="codeline">                                                GetElementPtrInst *Second) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1362</td>
    <td class="codeline">  Value *Offset1 = First->getOperand(1);</td>
    <td class="lineNumber">1362</td>
    <td class="codeline">  Value *Offset1 = First->getOperand(1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1363</td>
    <td class="codeline">  Value *Offset2 = Second->getOperand(1);</td>
    <td class="lineNumber">1363</td>
    <td class="codeline">  Value *Offset2 = Second->getOperand(1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1364</td>
    <td class="codeline">  First->setOperand(1, Offset2);</td>
    <td class="lineNumber">1364</td>
    <td class="codeline">  First->setOperand(1, Offset2);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1365</td>
    <td class="codeline">  Second->setOperand(1, Offset1);</td>
    <td class="lineNumber">1365</td>
    <td class="codeline">  Second->setOperand(1, Offset1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1366</td>
    <td class="codeline"></td>
    <td class="lineNumber">1366</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1367</td>
    <td class="codeline">  // We changed p+o+c to p+c+o, p+c may not be inbound anymore.</td>
    <td class="lineNumber">1367</td>
    <td class="codeline">  // We changed p+o+c to p+c+o, p+c may not be inbound anymore.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1368</td>
    <td class="codeline">  const DataLayout &DAL = First->getModule()->getDataLayout();</td>
    <td class="lineNumber">1368</td>
    <td class="codeline">  const DataLayout &DAL = First->getModule()->getDataLayout();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1369</td>
    <td class="codeline">  APInt Offset(DAL.getIndexSizeInBits(</td>
    <td class="lineNumber">1369</td>
    <td class="codeline">  APInt Offset(DAL.getIndexSizeInBits(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1370</td>
    <td class="codeline">                   cast<PointerType>(First->getType())->getAddressSpace()),</td>
    <td class="lineNumber">1370</td>
    <td class="codeline">                   cast<PointerType>(First->getType())->getAddressSpace()),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1371</td>
    <td class="codeline">               0);</td>
    <td class="lineNumber">1371</td>
    <td class="codeline">               0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1372</td>
    <td class="codeline">  Value *NewBase =</td>
    <td class="lineNumber">1372</td>
    <td class="codeline">  Value *NewBase =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1373</td>
    <td class="codeline">      First->stripAndAccumulateInBoundsConstantOffsets(DAL, Offset);</td>
    <td class="lineNumber">1373</td>
    <td class="codeline">      First->stripAndAccumulateInBoundsConstantOffsets(DAL, Offset);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1374</td>
    <td class="codeline">  uint64_t ObjectSize;</td>
    <td class="lineNumber">1374</td>
    <td class="codeline">  uint64_t ObjectSize;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1375</td>
    <td class="codeline">  if (!getObjectSize(NewBase, ObjectSize, DAL, TLI) ||</td>
    <td class="lineNumber">1375</td>
    <td class="codeline">  if (!getObjectSize(NewBase, ObjectSize, DAL, TLI) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1376</td>
    <td class="codeline">     Offset.ugt(ObjectSize)) {</td>
    <td class="lineNumber">1376</td>
    <td class="codeline">     Offset.ugt(ObjectSize)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1377</td>
    <td class="codeline">    First->setIsInBounds(false);</td>
    <td class="lineNumber">1377</td>
    <td class="codeline">    First->setIsInBounds(false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1378</td>
    <td class="codeline">    Second->setIsInBounds(false);</td>
    <td class="lineNumber">1378</td>
    <td class="codeline">    Second->setIsInBounds(false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1379</td>
    <td class="codeline">  } else</td>
    <td class="lineNumber">1379</td>
    <td class="codeline">  } else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1380</td>
    <td class="codeline">    First->setIsInBounds(true);</td>
    <td class="lineNumber">1380</td>
    <td class="codeline">    First->setIsInBounds(true);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1381</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1381</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1382</td>
    <td class="codeline"></td>
    <td class="lineNumber">1382</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1383</td>
    <td class="codeline">void SeparateConstOffsetFromGEPPass::printPipeline(</td>
    <td class="lineNumber">1383</td>
    <td class="codeline">void SeparateConstOffsetFromGEPPass::printPipeline(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1384</td>
    <td class="codeline">    raw_ostream &OS, function_ref<StringRef(StringRef)> MapClassName2PassName) {</td>
    <td class="lineNumber">1384</td>
    <td class="codeline">    raw_ostream &OS, function_ref<StringRef(StringRef)> MapClassName2PassName) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1385</td>
    <td class="codeline">  static_cast<PassInfoMixin<SeparateConstOffsetFromGEPPass> *>(this)</td>
    <td class="lineNumber">1385</td>
    <td class="codeline">  static_cast<PassInfoMixin<SeparateConstOffsetFromGEPPass> *>(this)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1386</td>
    <td class="codeline">      ->printPipeline(OS, MapClassName2PassName);</td>
    <td class="lineNumber">1386</td>
    <td class="codeline">      ->printPipeline(OS, MapClassName2PassName);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1387</td>
    <td class="codeline">  OS << '<';</td>
    <td class="lineNumber">1387</td>
    <td class="codeline">  OS << '<';</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1388</td>
    <td class="codeline">  if (LowerGEP)</td>
    <td class="lineNumber">1388</td>
    <td class="codeline">  if (LowerGEP)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1389</td>
    <td class="codeline">    OS << "lower-gep";</td>
    <td class="lineNumber">1389</td>
    <td class="codeline">    OS << "lower-gep";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1390</td>
    <td class="codeline">  OS << '>';</td>
    <td class="lineNumber">1390</td>
    <td class="codeline">  OS << '>';</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1391</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1391</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1392</td>
    <td class="codeline"></td>
    <td class="lineNumber">1392</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1393</td>
    <td class="codeline">PreservedAnalyses</td>
    <td class="lineNumber">1393</td>
    <td class="codeline">PreservedAnalyses</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1394</td>
    <td class="codeline">SeparateConstOffsetFromGEPPass::run(Function &F, FunctionAnalysisManager &AM) {</td>
    <td class="lineNumber">1394</td>
    <td class="codeline">SeparateConstOffsetFromGEPPass::run(Function &F, FunctionAnalysisManager &AM) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1395</td>
    <td class="codeline">  auto *DT = &AM.getResult<DominatorTreeAnalysis>(F);</td>
    <td class="lineNumber">1395</td>
    <td class="codeline">  auto *DT = &AM.getResult<DominatorTreeAnalysis>(F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1396</td>
    <td class="codeline">  auto *LI = &AM.getResult<LoopAnalysis>(F);</td>
    <td class="lineNumber">1396</td>
    <td class="codeline">  auto *LI = &AM.getResult<LoopAnalysis>(F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1397</td>
    <td class="codeline">  auto *TLI = &AM.getResult<TargetLibraryAnalysis>(F);</td>
    <td class="lineNumber">1397</td>
    <td class="codeline">  auto *TLI = &AM.getResult<TargetLibraryAnalysis>(F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1398</td>
    <td class="codeline">  auto GetTTI = [&AM](Function &F) -> TargetTransformInfo & {</td>
    <td class="lineNumber">1398</td>
    <td class="codeline">  auto GetTTI = [&AM](Function &F) -> TargetTransformInfo & {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1399</td>
    <td class="codeline">    return AM.getResult<TargetIRAnalysis>(F);</td>
    <td class="lineNumber">1399</td>
    <td class="codeline">    return AM.getResult<TargetIRAnalysis>(F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1400</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">1400</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1401</td>
    <td class="codeline">  SeparateConstOffsetFromGEP Impl(DT, LI, TLI, GetTTI, LowerGEP);</td>
    <td class="lineNumber">1401</td>
    <td class="codeline">  SeparateConstOffsetFromGEP Impl(DT, LI, TLI, GetTTI, LowerGEP);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1402</td>
    <td class="codeline">  if (!Impl.run(F))</td>
    <td class="lineNumber">1402</td>
    <td class="codeline">  if (!Impl.run(F))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1403</td>
    <td class="codeline">    return PreservedAnalyses::all();</td>
    <td class="lineNumber">1403</td>
    <td class="codeline">    return PreservedAnalyses::all();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1404</td>
    <td class="codeline">  PreservedAnalyses PA;</td>
    <td class="lineNumber">1404</td>
    <td class="codeline">  PreservedAnalyses PA;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1405</td>
    <td class="codeline">  PA.preserveSet<CFGAnalyses>();</td>
    <td class="lineNumber">1405</td>
    <td class="codeline">  PA.preserveSet<CFGAnalyses>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1406</td>
    <td class="codeline">  return PA;</td>
    <td class="lineNumber">1406</td>
    <td class="codeline">  return PA;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1407</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1407</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1408</td>
    <td class="codeline"></td>
    <td class="lineNumber">1408</td>
    <td class="codeline"></td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Side By Side Comparison</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Side By Side Comparison</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </th>
    <th class="mainTh">Hit count</th>
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </th>
    <th class="mainTh">Hit count</th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="codeLine">//===- SeparateConstOffsetFromGEP.cpp -------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1</td>
    <td class="codeLine">//===- SeparateConstOffsetFromGEP.cpp -------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="codeLine">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3</td>
    <td class="codeLine">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="codeLine">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4</td>
    <td class="codeLine">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="codeLine">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5</td>
    <td class="codeLine">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">6</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">7</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">8</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="codeLine">// Loop unrolling may create many similar GEPs for array accesses.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">9</td>
    <td class="codeLine">// Loop unrolling may create many similar GEPs for array accesses.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="codeLine">// e.g., a 2-level loop</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">10</td>
    <td class="codeLine">// e.g., a 2-level loop</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">11</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="codeLine">// float a[32][32]; // global variable</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">12</td>
    <td class="codeLine">// float a[32][32]; // global variable</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">13</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="codeLine">// for (int i = 0; i < 2; ++i) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">14</td>
    <td class="codeLine">// for (int i = 0; i < 2; ++i) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="codeLine">//   for (int j = 0; j < 2; ++j) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">15</td>
    <td class="codeLine">//   for (int j = 0; j < 2; ++j) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="codeLine">//     ...</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">16</td>
    <td class="codeLine">//     ...</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="codeLine">//     ... = a[x + i][y + j];</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">17</td>
    <td class="codeLine">//     ... = a[x + i][y + j];</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="codeLine">//     ...</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">18</td>
    <td class="codeLine">//     ...</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="codeLine">//   }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">19</td>
    <td class="codeLine">//   }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="codeLine">// }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">20</td>
    <td class="codeLine">// }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">21</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="codeLine">// will probably be unrolled to:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">22</td>
    <td class="codeLine">// will probably be unrolled to:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">23</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="codeLine">// gep %a, 0, %x, %y; load</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">24</td>
    <td class="codeLine">// gep %a, 0, %x, %y; load</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="codeLine">// gep %a, 0, %x, %y + 1; load</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">25</td>
    <td class="codeLine">// gep %a, 0, %x, %y + 1; load</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="codeLine">// gep %a, 0, %x + 1, %y; load</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">26</td>
    <td class="codeLine">// gep %a, 0, %x + 1, %y; load</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="codeLine">// gep %a, 0, %x + 1, %y + 1; load</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">27</td>
    <td class="codeLine">// gep %a, 0, %x + 1, %y + 1; load</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">28</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="codeLine">// LLVM's GVN does not use partial redundancy elimination yet, and is thus</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">29</td>
    <td class="codeLine">// LLVM's GVN does not use partial redundancy elimination yet, and is thus</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="codeLine">// unable to reuse (gep %a, 0, %x, %y). As a result, this misoptimization incurs</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">30</td>
    <td class="codeLine">// unable to reuse (gep %a, 0, %x, %y). As a result, this misoptimization incurs</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="codeLine">// significant slowdown in targets with limited addressing modes. For instance,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">31</td>
    <td class="codeLine">// significant slowdown in targets with limited addressing modes. For instance,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="codeLine">// because the PTX target does not support the reg+reg addressing mode, the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">32</td>
    <td class="codeLine">// because the PTX target does not support the reg+reg addressing mode, the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="codeLine">// NVPTX backend emits PTX code that literally computes the pointer address of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">33</td>
    <td class="codeLine">// NVPTX backend emits PTX code that literally computes the pointer address of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="codeLine">// each GEP, wasting tons of registers. It emits the following PTX for the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">34</td>
    <td class="codeLine">// each GEP, wasting tons of registers. It emits the following PTX for the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="codeLine">// first load and similar PTX for other loads.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">35</td>
    <td class="codeLine">// first load and similar PTX for other loads.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">36</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="codeLine">// mov.u32         %r1, %x;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">37</td>
    <td class="codeLine">// mov.u32         %r1, %x;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="codeLine">// mov.u32         %r2, %y;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">38</td>
    <td class="codeLine">// mov.u32         %r2, %y;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="codeLine">// mul.wide.u32    %rl2, %r1, 128;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">39</td>
    <td class="codeLine">// mul.wide.u32    %rl2, %r1, 128;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="codeLine">// mov.u64         %rl3, a;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">40</td>
    <td class="codeLine">// mov.u64         %rl3, a;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="codeLine">// add.s64         %rl4, %rl3, %rl2;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">41</td>
    <td class="codeLine">// add.s64         %rl4, %rl3, %rl2;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="codeLine">// mul.wide.u32    %rl5, %r2, 4;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">42</td>
    <td class="codeLine">// mul.wide.u32    %rl5, %r2, 4;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="codeLine">// add.s64         %rl6, %rl4, %rl5;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">43</td>
    <td class="codeLine">// add.s64         %rl6, %rl4, %rl5;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="codeLine">// ld.global.f32   %f1, [%rl6];</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">44</td>
    <td class="codeLine">// ld.global.f32   %f1, [%rl6];</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">45</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="codeLine">// To reduce the register pressure, the optimization implemented in this file</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">46</td>
    <td class="codeLine">// To reduce the register pressure, the optimization implemented in this file</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="codeLine">// merges the common part of a group of GEPs, so we can compute each pointer</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">47</td>
    <td class="codeLine">// merges the common part of a group of GEPs, so we can compute each pointer</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="codeLine">// address by adding a simple offset to the common part, saving many registers.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">48</td>
    <td class="codeLine">// address by adding a simple offset to the common part, saving many registers.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">49</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="codeLine">// It works by splitting each GEP into a variadic base and a constant offset.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">50</td>
    <td class="codeLine">// It works by splitting each GEP into a variadic base and a constant offset.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="codeLine">// The variadic base can be computed once and reused by multiple GEPs, and the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">51</td>
    <td class="codeLine">// The variadic base can be computed once and reused by multiple GEPs, and the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="codeLine">// constant offsets can be nicely folded into the reg+immediate addressing mode</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">52</td>
    <td class="codeLine">// constant offsets can be nicely folded into the reg+immediate addressing mode</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="codeLine">// (supported by most targets) without using any extra register.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">53</td>
    <td class="codeLine">// (supported by most targets) without using any extra register.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">54</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="codeLine">// For instance, we transform the four GEPs and four loads in the above example</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">55</td>
    <td class="codeLine">// For instance, we transform the four GEPs and four loads in the above example</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="codeLine">// into:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">56</td>
    <td class="codeLine">// into:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">57</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="codeLine">// base = gep a, 0, x, y</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">58</td>
    <td class="codeLine">// base = gep a, 0, x, y</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="codeLine">// load base</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">59</td>
    <td class="codeLine">// load base</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="codeLine">// laod base + 1  * sizeof(float)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">60</td>
    <td class="codeLine">// laod base + 1  * sizeof(float)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="codeLine">// load base + 32 * sizeof(float)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">61</td>
    <td class="codeLine">// load base + 32 * sizeof(float)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="codeLine">// load base + 33 * sizeof(float)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">62</td>
    <td class="codeLine">// load base + 33 * sizeof(float)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">63</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="codeLine">// Given the transformed IR, a backend that supports the reg+immediate</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">64</td>
    <td class="codeLine">// Given the transformed IR, a backend that supports the reg+immediate</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="codeLine">// addressing mode can easily fold the pointer arithmetics into the loads. For</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">65</td>
    <td class="codeLine">// addressing mode can easily fold the pointer arithmetics into the loads. For</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="codeLine">// example, the NVPTX backend can easily fold the pointer arithmetics into the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">66</td>
    <td class="codeLine">// example, the NVPTX backend can easily fold the pointer arithmetics into the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="codeLine">// ld.global.f32 instructions, and the resultant PTX uses much fewer registers.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">67</td>
    <td class="codeLine">// ld.global.f32 instructions, and the resultant PTX uses much fewer registers.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">68</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="codeLine">// mov.u32         %r1, %tid.x;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">69</td>
    <td class="codeLine">// mov.u32         %r1, %tid.x;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="codeLine">// mov.u32         %r2, %tid.y;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">70</td>
    <td class="codeLine">// mov.u32         %r2, %tid.y;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="codeLine">// mul.wide.u32    %rl2, %r1, 128;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">71</td>
    <td class="codeLine">// mul.wide.u32    %rl2, %r1, 128;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="codeLine">// mov.u64         %rl3, a;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">72</td>
    <td class="codeLine">// mov.u64         %rl3, a;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="codeLine">// add.s64         %rl4, %rl3, %rl2;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">73</td>
    <td class="codeLine">// add.s64         %rl4, %rl3, %rl2;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="codeLine">// mul.wide.u32    %rl5, %r2, 4;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">74</td>
    <td class="codeLine">// mul.wide.u32    %rl5, %r2, 4;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="codeLine">// add.s64         %rl6, %rl4, %rl5;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">75</td>
    <td class="codeLine">// add.s64         %rl6, %rl4, %rl5;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="codeLine">// ld.global.f32   %f1, [%rl6]; // so far the same as unoptimized PTX</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">76</td>
    <td class="codeLine">// ld.global.f32   %f1, [%rl6]; // so far the same as unoptimized PTX</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="codeLine">// ld.global.f32   %f2, [%rl6+4]; // much better</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">77</td>
    <td class="codeLine">// ld.global.f32   %f2, [%rl6+4]; // much better</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="codeLine">// ld.global.f32   %f3, [%rl6+128]; // much better</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">78</td>
    <td class="codeLine">// ld.global.f32   %f3, [%rl6+128]; // much better</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="codeLine">// ld.global.f32   %f4, [%rl6+132]; // much better</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">79</td>
    <td class="codeLine">// ld.global.f32   %f4, [%rl6+132]; // much better</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">80</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="codeLine">// Another improvement enabled by the LowerGEP flag is to lower a GEP with</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">81</td>
    <td class="codeLine">// Another improvement enabled by the LowerGEP flag is to lower a GEP with</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="codeLine">// multiple indices to either multiple GEPs with a single index or arithmetic</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">82</td>
    <td class="codeLine">// multiple indices to either multiple GEPs with a single index or arithmetic</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="codeLine">// operations (depending on whether the target uses alias analysis in codegen).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">83</td>
    <td class="codeLine">// operations (depending on whether the target uses alias analysis in codegen).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="codeLine">// Such transformation can have following benefits:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">84</td>
    <td class="codeLine">// Such transformation can have following benefits:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="codeLine">// (1) It can always extract constants in the indices of structure type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">85</td>
    <td class="codeLine">// (1) It can always extract constants in the indices of structure type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="codeLine">// (2) After such Lowering, there are more optimization opportunities such as</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">86</td>
    <td class="codeLine">// (2) After such Lowering, there are more optimization opportunities such as</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="codeLine">//     CSE, LICM and CGP.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">87</td>
    <td class="codeLine">//     CSE, LICM and CGP.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">88</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="codeLine">// E.g. The following GEPs have multiple indices:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">89</td>
    <td class="codeLine">// E.g. The following GEPs have multiple indices:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="codeLine">//  BB1:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">90</td>
    <td class="codeLine">//  BB1:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="codeLine">//    %p = getelementptr [10 x %struct]* %ptr, i64 %i, i64 %j1, i32 3</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">91</td>
    <td class="codeLine">//    %p = getelementptr [10 x %struct]* %ptr, i64 %i, i64 %j1, i32 3</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="codeLine">//    load %p</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">92</td>
    <td class="codeLine">//    load %p</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="codeLine">//    ...</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">93</td>
    <td class="codeLine">//    ...</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="codeLine">//  BB2:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">94</td>
    <td class="codeLine">//  BB2:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="codeLine">//    %p2 = getelementptr [10 x %struct]* %ptr, i64 %i, i64 %j1, i32 2</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">95</td>
    <td class="codeLine">//    %p2 = getelementptr [10 x %struct]* %ptr, i64 %i, i64 %j1, i32 2</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="codeLine">//    load %p2</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">96</td>
    <td class="codeLine">//    load %p2</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="codeLine">//    ...</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">97</td>
    <td class="codeLine">//    ...</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">98</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="codeLine">// We can not do CSE to the common part related to index "i64 %i". Lowering</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">99</td>
    <td class="codeLine">// We can not do CSE to the common part related to index "i64 %i". Lowering</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="codeLine">// GEPs can achieve such goals.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">100</td>
    <td class="codeLine">// GEPs can achieve such goals.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="codeLine">// If the target does not use alias analysis in codegen, this pass will</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">101</td>
    <td class="codeLine">// If the target does not use alias analysis in codegen, this pass will</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="codeLine">// lower a GEP with multiple indices into arithmetic operations:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">102</td>
    <td class="codeLine">// lower a GEP with multiple indices into arithmetic operations:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="codeLine">//  BB1:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">103</td>
    <td class="codeLine">//  BB1:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="codeLine">//    %1 = ptrtoint [10 x %struct]* %ptr to i64    ; CSE opportunity</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">104</td>
    <td class="codeLine">//    %1 = ptrtoint [10 x %struct]* %ptr to i64    ; CSE opportunity</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="codeLine">//    %2 = mul i64 %i, length_of_10xstruct         ; CSE opportunity</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">105</td>
    <td class="codeLine">//    %2 = mul i64 %i, length_of_10xstruct         ; CSE opportunity</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="codeLine">//    %3 = add i64 %1, %2                          ; CSE opportunity</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">106</td>
    <td class="codeLine">//    %3 = add i64 %1, %2                          ; CSE opportunity</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="codeLine">//    %4 = mul i64 %j1, length_of_struct</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">107</td>
    <td class="codeLine">//    %4 = mul i64 %j1, length_of_struct</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="codeLine">//    %5 = add i64 %3, %4</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">108</td>
    <td class="codeLine">//    %5 = add i64 %3, %4</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="codeLine">//    %6 = add i64 %3, struct_field_3              ; Constant offset</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">109</td>
    <td class="codeLine">//    %6 = add i64 %3, struct_field_3              ; Constant offset</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="codeLine">//    %p = inttoptr i64 %6 to i32*</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">110</td>
    <td class="codeLine">//    %p = inttoptr i64 %6 to i32*</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="codeLine">//    load %p</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">111</td>
    <td class="codeLine">//    load %p</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="codeLine">//    ...</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">112</td>
    <td class="codeLine">//    ...</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="codeLine">//  BB2:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">113</td>
    <td class="codeLine">//  BB2:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="codeLine">//    %7 = ptrtoint [10 x %struct]* %ptr to i64    ; CSE opportunity</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">114</td>
    <td class="codeLine">//    %7 = ptrtoint [10 x %struct]* %ptr to i64    ; CSE opportunity</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="codeLine">//    %8 = mul i64 %i, length_of_10xstruct         ; CSE opportunity</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">115</td>
    <td class="codeLine">//    %8 = mul i64 %i, length_of_10xstruct         ; CSE opportunity</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="codeLine">//    %9 = add i64 %7, %8                          ; CSE opportunity</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">116</td>
    <td class="codeLine">//    %9 = add i64 %7, %8                          ; CSE opportunity</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="codeLine">//    %10 = mul i64 %j2, length_of_struct</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">117</td>
    <td class="codeLine">//    %10 = mul i64 %j2, length_of_struct</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="codeLine">//    %11 = add i64 %9, %10</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">118</td>
    <td class="codeLine">//    %11 = add i64 %9, %10</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="codeLine">//    %12 = add i64 %11, struct_field_2            ; Constant offset</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">119</td>
    <td class="codeLine">//    %12 = add i64 %11, struct_field_2            ; Constant offset</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="codeLine">//    %p = inttoptr i64 %12 to i32*</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">120</td>
    <td class="codeLine">//    %p = inttoptr i64 %12 to i32*</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="codeLine">//    load %p2</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">121</td>
    <td class="codeLine">//    load %p2</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="codeLine">//    ...</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">122</td>
    <td class="codeLine">//    ...</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">123</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="codeLine">// If the target uses alias analysis in codegen, this pass will lower a GEP</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">124</td>
    <td class="codeLine">// If the target uses alias analysis in codegen, this pass will lower a GEP</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="codeLine">// with multiple indices into multiple GEPs with a single index:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">125</td>
    <td class="codeLine">// with multiple indices into multiple GEPs with a single index:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="codeLine">//  BB1:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">126</td>
    <td class="codeLine">//  BB1:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="codeLine">//    %1 = bitcast [10 x %struct]* %ptr to i8*     ; CSE opportunity</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">127</td>
    <td class="codeLine">//    %1 = bitcast [10 x %struct]* %ptr to i8*     ; CSE opportunity</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="codeLine">//    %2 = mul i64 %i, length_of_10xstruct         ; CSE opportunity</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">128</td>
    <td class="codeLine">//    %2 = mul i64 %i, length_of_10xstruct         ; CSE opportunity</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="codeLine">//    %3 = getelementptr i8* %1, i64 %2            ; CSE opportunity</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">129</td>
    <td class="codeLine">//    %3 = getelementptr i8* %1, i64 %2            ; CSE opportunity</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="codeLine">//    %4 = mul i64 %j1, length_of_struct</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">130</td>
    <td class="codeLine">//    %4 = mul i64 %j1, length_of_struct</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="codeLine">//    %5 = getelementptr i8* %3, i64 %4</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">131</td>
    <td class="codeLine">//    %5 = getelementptr i8* %3, i64 %4</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="codeLine">//    %6 = getelementptr i8* %5, struct_field_3    ; Constant offset</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">132</td>
    <td class="codeLine">//    %6 = getelementptr i8* %5, struct_field_3    ; Constant offset</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="codeLine">//    %p = bitcast i8* %6 to i32*</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">133</td>
    <td class="codeLine">//    %p = bitcast i8* %6 to i32*</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="codeLine">//    load %p</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">134</td>
    <td class="codeLine">//    load %p</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="codeLine">//    ...</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">135</td>
    <td class="codeLine">//    ...</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="codeLine">//  BB2:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">136</td>
    <td class="codeLine">//  BB2:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="codeLine">//    %7 = bitcast [10 x %struct]* %ptr to i8*     ; CSE opportunity</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">137</td>
    <td class="codeLine">//    %7 = bitcast [10 x %struct]* %ptr to i8*     ; CSE opportunity</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="codeLine">//    %8 = mul i64 %i, length_of_10xstruct         ; CSE opportunity</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">138</td>
    <td class="codeLine">//    %8 = mul i64 %i, length_of_10xstruct         ; CSE opportunity</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="codeLine">//    %9 = getelementptr i8* %7, i64 %8            ; CSE opportunity</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">139</td>
    <td class="codeLine">//    %9 = getelementptr i8* %7, i64 %8            ; CSE opportunity</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="codeLine">//    %10 = mul i64 %j2, length_of_struct</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">140</td>
    <td class="codeLine">//    %10 = mul i64 %j2, length_of_struct</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="codeLine">//    %11 = getelementptr i8* %9, i64 %10</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">141</td>
    <td class="codeLine">//    %11 = getelementptr i8* %9, i64 %10</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="codeLine">//    %12 = getelementptr i8* %11, struct_field_2  ; Constant offset</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">142</td>
    <td class="codeLine">//    %12 = getelementptr i8* %11, struct_field_2  ; Constant offset</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="codeLine">//    %p2 = bitcast i8* %12 to i32*</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">143</td>
    <td class="codeLine">//    %p2 = bitcast i8* %12 to i32*</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="codeLine">//    load %p2</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">144</td>
    <td class="codeLine">//    load %p2</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="codeLine">//    ...</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">145</td>
    <td class="codeLine">//    ...</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">146</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="codeLine">// Lowering GEPs can also benefit other passes such as LICM and CGP.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">147</td>
    <td class="codeLine">// Lowering GEPs can also benefit other passes such as LICM and CGP.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="codeLine">// LICM (Loop Invariant Code Motion) can not hoist/sink a GEP of multiple</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">148</td>
    <td class="codeLine">// LICM (Loop Invariant Code Motion) can not hoist/sink a GEP of multiple</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="codeLine">// indices if one of the index is variant. If we lower such GEP into invariant</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">149</td>
    <td class="codeLine">// indices if one of the index is variant. If we lower such GEP into invariant</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="codeLine">// parts and variant parts, LICM can hoist/sink those invariant parts.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">150</td>
    <td class="codeLine">// parts and variant parts, LICM can hoist/sink those invariant parts.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="codeLine">// CGP (CodeGen Prepare) tries to sink address calculations that match the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">151</td>
    <td class="codeLine">// CGP (CodeGen Prepare) tries to sink address calculations that match the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="codeLine">// target's addressing modes. A GEP with multiple indices may not match and will</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">152</td>
    <td class="codeLine">// target's addressing modes. A GEP with multiple indices may not match and will</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="codeLine">// not be sunk. If we lower such GEP into smaller parts, CGP may sink some of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">153</td>
    <td class="codeLine">// not be sunk. If we lower such GEP into smaller parts, CGP may sink some of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="codeLine">// them. So we end up with a better addressing mode.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">154</td>
    <td class="codeLine">// them. So we end up with a better addressing mode.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">155</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">156</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">157</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="codeLine">#include "llvm/Transforms/Scalar/SeparateConstOffsetFromGEP.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">158</td>
    <td class="codeLine">#include "llvm/Transforms/Scalar/SeparateConstOffsetFromGEP.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="codeLine">#include "llvm/ADT/APInt.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">159</td>
    <td class="codeLine">#include "llvm/ADT/APInt.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="codeLine">#include "llvm/ADT/DenseMap.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">160</td>
    <td class="codeLine">#include "llvm/ADT/DenseMap.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="codeLine">#include "llvm/ADT/DepthFirstIterator.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">161</td>
    <td class="codeLine">#include "llvm/ADT/DepthFirstIterator.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="codeLine">#include "llvm/ADT/SmallVector.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">162</td>
    <td class="codeLine">#include "llvm/ADT/SmallVector.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="codeLine">#include "llvm/Analysis/LoopInfo.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">163</td>
    <td class="codeLine">#include "llvm/Analysis/LoopInfo.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="codeLine">#include "llvm/Analysis/MemoryBuiltins.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">164</td>
    <td class="codeLine">#include "llvm/Analysis/MemoryBuiltins.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="codeLine">#include "llvm/Analysis/TargetLibraryInfo.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">165</td>
    <td class="codeLine">#include "llvm/Analysis/TargetLibraryInfo.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="codeLine">#include "llvm/Analysis/TargetTransformInfo.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">166</td>
    <td class="codeLine">#include "llvm/Analysis/TargetTransformInfo.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="codeLine">#include "llvm/Analysis/ValueTracking.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">167</td>
    <td class="codeLine">#include "llvm/Analysis/ValueTracking.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="codeLine">#include "llvm/IR/BasicBlock.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">168</td>
    <td class="codeLine">#include "llvm/IR/BasicBlock.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="codeLine">#include "llvm/IR/Constant.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">169</td>
    <td class="codeLine">#include "llvm/IR/Constant.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="codeLine">#include "llvm/IR/Constants.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">170</td>
    <td class="codeLine">#include "llvm/IR/Constants.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="codeLine">#include "llvm/IR/DataLayout.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">171</td>
    <td class="codeLine">#include "llvm/IR/DataLayout.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="codeLine">#include "llvm/IR/DerivedTypes.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">172</td>
    <td class="codeLine">#include "llvm/IR/DerivedTypes.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="codeLine">#include "llvm/IR/Dominators.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">173</td>
    <td class="codeLine">#include "llvm/IR/Dominators.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="codeLine">#include "llvm/IR/Function.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">174</td>
    <td class="codeLine">#include "llvm/IR/Function.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="codeLine">#include "llvm/IR/GetElementPtrTypeIterator.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">175</td>
    <td class="codeLine">#include "llvm/IR/GetElementPtrTypeIterator.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="codeLine">#include "llvm/IR/IRBuilder.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">176</td>
    <td class="codeLine">#include "llvm/IR/IRBuilder.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="codeLine">#include "llvm/IR/Instruction.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">177</td>
    <td class="codeLine">#include "llvm/IR/Instruction.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="codeLine">#include "llvm/IR/Instructions.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">178</td>
    <td class="codeLine">#include "llvm/IR/Instructions.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="codeLine">#include "llvm/IR/Module.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">179</td>
    <td class="codeLine">#include "llvm/IR/Module.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="codeLine">#include "llvm/IR/PassManager.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">180</td>
    <td class="codeLine">#include "llvm/IR/PassManager.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="codeLine">#include "llvm/IR/PatternMatch.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">181</td>
    <td class="codeLine">#include "llvm/IR/PatternMatch.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="codeLine">#include "llvm/IR/Type.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">182</td>
    <td class="codeLine">#include "llvm/IR/Type.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="codeLine">#include "llvm/IR/User.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">183</td>
    <td class="codeLine">#include "llvm/IR/User.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="codeLine">#include "llvm/IR/Value.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">184</td>
    <td class="codeLine">#include "llvm/IR/Value.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="codeLine">#include "llvm/InitializePasses.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">185</td>
    <td class="codeLine">#include "llvm/InitializePasses.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="codeLine">#include "llvm/Pass.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">186</td>
    <td class="codeLine">#include "llvm/Pass.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="codeLine">#include "llvm/Support/Casting.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">187</td>
    <td class="codeLine">#include "llvm/Support/Casting.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="codeLine">#include "llvm/Support/CommandLine.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">188</td>
    <td class="codeLine">#include "llvm/Support/CommandLine.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="codeLine">#include "llvm/Support/ErrorHandling.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">189</td>
    <td class="codeLine">#include "llvm/Support/ErrorHandling.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="codeLine">#include "llvm/Support/raw_ostream.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">190</td>
    <td class="codeLine">#include "llvm/Support/raw_ostream.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="codeLine">#include "llvm/Transforms/Scalar.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">191</td>
    <td class="codeLine">#include "llvm/Transforms/Scalar.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="codeLine">#include "llvm/Transforms/Utils/Local.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">192</td>
    <td class="codeLine">#include "llvm/Transforms/Utils/Local.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="codeLine">#include <cassert></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">193</td>
    <td class="codeLine">#include <cassert></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="codeLine">#include <cstdint></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">194</td>
    <td class="codeLine">#include <cstdint></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="codeLine">#include <string></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">195</td>
    <td class="codeLine">#include <string></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">196</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="codeLine">using namespace llvm;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">197</td>
    <td class="codeLine">using namespace llvm;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="codeLine">using namespace llvm::PatternMatch;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">198</td>
    <td class="codeLine">using namespace llvm::PatternMatch;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">199</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="codeLine">static cl::opt<bool> DisableSeparateConstOffsetFromGEP(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">200</td>
    <td class="codeLine">static cl::opt<bool> DisableSeparateConstOffsetFromGEP(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="codeLine">    "disable-separate-const-offset-from-gep", cl::init(false),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">201</td>
    <td class="codeLine">    "disable-separate-const-offset-from-gep", cl::init(false),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="codeLine">    cl::desc("Do not separate the constant offset from a GEP instruction"),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">202</td>
    <td class="codeLine">    cl::desc("Do not separate the constant offset from a GEP instruction"),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="codeLine">    cl::Hidden);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">203</td>
    <td class="codeLine">    cl::Hidden);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">204</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="codeLine">// Setting this flag may emit false positives when the input module already</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">205</td>
    <td class="codeLine">// Setting this flag may emit false positives when the input module already</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="codeLine">// contains dead instructions. Therefore, we set it only in unit tests that are</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">206</td>
    <td class="codeLine">// contains dead instructions. Therefore, we set it only in unit tests that are</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="codeLine">// free of dead code.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">207</td>
    <td class="codeLine">// free of dead code.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="codeLine">static cl::opt<bool></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">208</td>
    <td class="codeLine">static cl::opt<bool></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="codeLine">    VerifyNoDeadCode("reassociate-geps-verify-no-dead-code", cl::init(false),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">209</td>
    <td class="codeLine">    VerifyNoDeadCode("reassociate-geps-verify-no-dead-code", cl::init(false),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="codeLine">                     cl::desc("Verify this pass produces no dead code"),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">210</td>
    <td class="codeLine">                     cl::desc("Verify this pass produces no dead code"),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="codeLine">                     cl::Hidden);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">211</td>
    <td class="codeLine">                     cl::Hidden);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">212</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="codeLine">namespace {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">213</td>
    <td class="codeLine">namespace {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">214</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="codeLine">/// A helper class for separating a constant offset from a GEP index.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">215</td>
    <td class="codeLine">/// A helper class for separating a constant offset from a GEP index.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">216</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="codeLine">/// In real programs, a GEP index may be more complicated than a simple addition</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">217</td>
    <td class="codeLine">/// In real programs, a GEP index may be more complicated than a simple addition</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="codeLine">/// of something and a constant integer which can be trivially splitted. For</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">218</td>
    <td class="codeLine">/// of something and a constant integer which can be trivially splitted. For</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="codeLine">/// example, to split ((a << 3) | 5) + b, we need to search deeper for the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">219</td>
    <td class="codeLine">/// example, to split ((a << 3) | 5) + b, we need to search deeper for the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="codeLine">/// constant offset, so that we can separate the index to (a << 3) + b and 5.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">220</td>
    <td class="codeLine">/// constant offset, so that we can separate the index to (a << 3) + b and 5.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">221</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="codeLine">/// Therefore, this class looks into the expression that computes a given GEP</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">222</td>
    <td class="codeLine">/// Therefore, this class looks into the expression that computes a given GEP</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="codeLine">/// index, and tries to find a constant integer that can be hoisted to the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">223</td>
    <td class="codeLine">/// index, and tries to find a constant integer that can be hoisted to the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="codeLine">/// outermost level of the expression as an addition. Not every constant in an</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">224</td>
    <td class="codeLine">/// outermost level of the expression as an addition. Not every constant in an</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="codeLine">/// expression can jump out. e.g., we cannot transform (b * (a + 5)) to (b * a +</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">225</td>
    <td class="codeLine">/// expression can jump out. e.g., we cannot transform (b * (a + 5)) to (b * a +</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="codeLine">/// 5); nor can we transform (3 * (a + 5)) to (3 * a + 5), however in this case,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">226</td>
    <td class="codeLine">/// 5); nor can we transform (3 * (a + 5)) to (3 * a + 5), however in this case,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="codeLine">/// -instcombine probably already optimized (3 * (a + 5)) to (3 * a + 15).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">227</td>
    <td class="codeLine">/// -instcombine probably already optimized (3 * (a + 5)) to (3 * a + 15).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="codeLine">class ConstantOffsetExtractor {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">228</td>
    <td class="codeLine">class ConstantOffsetExtractor {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">229</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="codeLine">  /// Extracts a constant offset from the given GEP index. It returns the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">230</td>
    <td class="codeLine">  /// Extracts a constant offset from the given GEP index. It returns the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="codeLine">  /// new index representing the remainder (equal to the original index minus</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">231</td>
    <td class="codeLine">  /// new index representing the remainder (equal to the original index minus</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="codeLine">  /// the constant offset), or nullptr if we cannot extract a constant offset.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">232</td>
    <td class="codeLine">  /// the constant offset), or nullptr if we cannot extract a constant offset.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="codeLine">  /// \p Idx The given GEP index</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">233</td>
    <td class="codeLine">  /// \p Idx The given GEP index</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="codeLine">  /// \p GEP The given GEP</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">234</td>
    <td class="codeLine">  /// \p GEP The given GEP</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="codeLine">  /// \p UserChainTail Outputs the tail of UserChain so that we can</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">235</td>
    <td class="codeLine">  /// \p UserChainTail Outputs the tail of UserChain so that we can</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="codeLine">  ///                  garbage-collect unused instructions in UserChain.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">236</td>
    <td class="codeLine">  ///                  garbage-collect unused instructions in UserChain.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="codeLine">  static Value *Extract(Value *Idx, GetElementPtrInst *GEP,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">237</td>
    <td class="codeLine">  static Value *Extract(Value *Idx, GetElementPtrInst *GEP,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="codeLine">                        User *&UserChainTail, const DominatorTree *DT);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">238</td>
    <td class="codeLine">                        User *&UserChainTail, const DominatorTree *DT);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">239</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="codeLine">  /// Looks for a constant offset from the given GEP index without extracting</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">240</td>
    <td class="codeLine">  /// Looks for a constant offset from the given GEP index without extracting</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="codeLine">  /// it. It returns the numeric value of the extracted constant offset (0 if</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">241</td>
    <td class="codeLine">  /// it. It returns the numeric value of the extracted constant offset (0 if</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="codeLine">  /// failed). The meaning of the arguments are the same as Extract.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">242</td>
    <td class="codeLine">  /// failed). The meaning of the arguments are the same as Extract.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="codeLine">  static int64_t Find(Value *Idx, GetElementPtrInst *GEP,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">243</td>
    <td class="codeLine">  static int64_t Find(Value *Idx, GetElementPtrInst *GEP,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="codeLine">                      const DominatorTree *DT);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">244</td>
    <td class="codeLine">                      const DominatorTree *DT);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">245</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">246</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="codeLine">  ConstantOffsetExtractor(Instruction *InsertionPt, const DominatorTree *DT)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">247</td>
    <td class="codeLine">  ConstantOffsetExtractor(Instruction *InsertionPt, const DominatorTree *DT)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="codeLine">      : IP(InsertionPt), DL(InsertionPt->getModule()->getDataLayout()), DT(DT) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">248</td>
    <td class="codeLine">      : IP(InsertionPt), DL(InsertionPt->getModule()->getDataLayout()), DT(DT) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">249</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">250</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="codeLine">  /// Searches the expression that computes V for a non-zero constant C s.t.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">251</td>
    <td class="codeLine">  /// Searches the expression that computes V for a non-zero constant C s.t.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="codeLine">  /// V can be reassociated into the form V' + C. If the searching is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">252</td>
    <td class="codeLine">  /// V can be reassociated into the form V' + C. If the searching is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="codeLine">  /// successful, returns C and update UserChain as a def-use chain from C to V;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">253</td>
    <td class="codeLine">  /// successful, returns C and update UserChain as a def-use chain from C to V;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="codeLine">  /// otherwise, UserChain is empty.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">254</td>
    <td class="codeLine">  /// otherwise, UserChain is empty.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">255</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="codeLine">  /// \p V            The given expression</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">256</td>
    <td class="codeLine">  /// \p V            The given expression</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="codeLine">  /// \p SignExtended Whether V will be sign-extended in the computation of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">257</td>
    <td class="codeLine">  /// \p SignExtended Whether V will be sign-extended in the computation of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="codeLine">  ///                 GEP index</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">258</td>
    <td class="codeLine">  ///                 GEP index</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="codeLine">  /// \p ZeroExtended Whether V will be zero-extended in the computation of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">259</td>
    <td class="codeLine">  /// \p ZeroExtended Whether V will be zero-extended in the computation of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="codeLine">  ///                 GEP index</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">260</td>
    <td class="codeLine">  ///                 GEP index</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="codeLine">  /// \p NonNegative  Whether V is guaranteed to be non-negative. For example,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">261</td>
    <td class="codeLine">  /// \p NonNegative  Whether V is guaranteed to be non-negative. For example,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="codeLine">  ///                 an index of an inbounds GEP is guaranteed to be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">262</td>
    <td class="codeLine">  ///                 an index of an inbounds GEP is guaranteed to be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="codeLine">  ///                 non-negative. Levaraging this, we can better split</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">263</td>
    <td class="codeLine">  ///                 non-negative. Levaraging this, we can better split</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="codeLine">  ///                 inbounds GEPs.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">264</td>
    <td class="codeLine">  ///                 inbounds GEPs.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="codeLine">  APInt find(Value *V, bool SignExtended, bool ZeroExtended, bool NonNegative);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">265</td>
    <td class="codeLine">  APInt find(Value *V, bool SignExtended, bool ZeroExtended, bool NonNegative);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">266</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="codeLine">  /// A helper function to look into both operands of a binary operator.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">267</td>
    <td class="codeLine">  /// A helper function to look into both operands of a binary operator.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="codeLine">  APInt findInEitherOperand(BinaryOperator *BO, bool SignExtended,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">268</td>
    <td class="codeLine">  APInt findInEitherOperand(BinaryOperator *BO, bool SignExtended,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="codeLine">                            bool ZeroExtended);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">269</td>
    <td class="codeLine">                            bool ZeroExtended);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">270</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="codeLine">  /// After finding the constant offset C from the GEP index I, we build a new</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">271</td>
    <td class="codeLine">  /// After finding the constant offset C from the GEP index I, we build a new</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="codeLine">  /// index I' s.t. I' + C = I. This function builds and returns the new</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">272</td>
    <td class="codeLine">  /// index I' s.t. I' + C = I. This function builds and returns the new</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="codeLine">  /// index I' according to UserChain produced by function "find".</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">273</td>
    <td class="codeLine">  /// index I' according to UserChain produced by function "find".</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">274</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="codeLine">  /// The building conceptually takes two steps:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">275</td>
    <td class="codeLine">  /// The building conceptually takes two steps:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="codeLine">  /// 1) iteratively distribute s/zext towards the leaves of the expression tree</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">276</td>
    <td class="codeLine">  /// 1) iteratively distribute s/zext towards the leaves of the expression tree</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="codeLine">  /// that computes I</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">277</td>
    <td class="codeLine">  /// that computes I</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="codeLine">  /// 2) reassociate the expression tree to the form I' + C.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">278</td>
    <td class="codeLine">  /// 2) reassociate the expression tree to the form I' + C.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">279</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="codeLine">  /// For example, to extract the 5 from sext(a + (b + 5)), we first distribute</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">280</td>
    <td class="codeLine">  /// For example, to extract the 5 from sext(a + (b + 5)), we first distribute</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="codeLine">  /// sext to a, b and 5 so that we have</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">281</td>
    <td class="codeLine">  /// sext to a, b and 5 so that we have</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="codeLine">  ///   sext(a) + (sext(b) + 5).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">282</td>
    <td class="codeLine">  ///   sext(a) + (sext(b) + 5).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="codeLine">  /// Then, we reassociate it to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">283</td>
    <td class="codeLine">  /// Then, we reassociate it to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="codeLine">  ///   (sext(a) + sext(b)) + 5.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">284</td>
    <td class="codeLine">  ///   (sext(a) + sext(b)) + 5.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="codeLine">  /// Given this form, we know I' is sext(a) + sext(b).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">285</td>
    <td class="codeLine">  /// Given this form, we know I' is sext(a) + sext(b).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="codeLine">  Value *rebuildWithoutConstOffset();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">286</td>
    <td class="codeLine">  Value *rebuildWithoutConstOffset();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">287</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="codeLine">  /// After the first step of rebuilding the GEP index without the constant</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">288</td>
    <td class="codeLine">  /// After the first step of rebuilding the GEP index without the constant</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="codeLine">  /// offset, distribute s/zext to the operands of all operators in UserChain.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">289</td>
    <td class="codeLine">  /// offset, distribute s/zext to the operands of all operators in UserChain.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="codeLine">  /// e.g., zext(sext(a + (b + 5)) (assuming no overflow) =></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">290</td>
    <td class="codeLine">  /// e.g., zext(sext(a + (b + 5)) (assuming no overflow) =></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="codeLine">  /// zext(sext(a)) + (zext(sext(b)) + zext(sext(5))).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">291</td>
    <td class="codeLine">  /// zext(sext(a)) + (zext(sext(b)) + zext(sext(5))).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">292</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="codeLine">  /// The function also updates UserChain to point to new subexpressions after</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">293</td>
    <td class="codeLine">  /// The function also updates UserChain to point to new subexpressions after</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="codeLine">  /// distributing s/zext. e.g., the old UserChain of the above example is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">294</td>
    <td class="codeLine">  /// distributing s/zext. e.g., the old UserChain of the above example is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="codeLine">  /// 5 -> b + 5 -> a + (b + 5) -> sext(...) -> zext(sext(...)),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">295</td>
    <td class="codeLine">  /// 5 -> b + 5 -> a + (b + 5) -> sext(...) -> zext(sext(...)),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="codeLine">  /// and the new UserChain is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">296</td>
    <td class="codeLine">  /// and the new UserChain is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="codeLine">  /// zext(sext(5)) -> zext(sext(b)) + zext(sext(5)) -></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">297</td>
    <td class="codeLine">  /// zext(sext(5)) -> zext(sext(b)) + zext(sext(5)) -></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="codeLine">  ///   zext(sext(a)) + (zext(sext(b)) + zext(sext(5))</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">298</td>
    <td class="codeLine">  ///   zext(sext(a)) + (zext(sext(b)) + zext(sext(5))</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">299</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="codeLine">  /// \p ChainIndex The index to UserChain. ChainIndex is initially</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">300</td>
    <td class="codeLine">  /// \p ChainIndex The index to UserChain. ChainIndex is initially</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="codeLine">  ///               UserChain.size() - 1, and is decremented during</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">301</td>
    <td class="codeLine">  ///               UserChain.size() - 1, and is decremented during</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="codeLine">  ///               the recursion.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">302</td>
    <td class="codeLine">  ///               the recursion.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="codeLine">  Value *distributeExtsAndCloneChain(unsigned ChainIndex);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">303</td>
    <td class="codeLine">  Value *distributeExtsAndCloneChain(unsigned ChainIndex);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">304</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="codeLine">  /// Reassociates the GEP index to the form I' + C and returns I'.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">305</td>
    <td class="codeLine">  /// Reassociates the GEP index to the form I' + C and returns I'.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="codeLine">  Value *removeConstOffset(unsigned ChainIndex);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">306</td>
    <td class="codeLine">  Value *removeConstOffset(unsigned ChainIndex);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">307</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="codeLine">  /// A helper function to apply ExtInsts, a list of s/zext, to value V.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">308</td>
    <td class="codeLine">  /// A helper function to apply ExtInsts, a list of s/zext, to value V.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="codeLine">  /// e.g., if ExtInsts = [sext i32 to i64, zext i16 to i32], this function</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">309</td>
    <td class="codeLine">  /// e.g., if ExtInsts = [sext i32 to i64, zext i16 to i32], this function</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="codeLine">  /// returns "sext i32 (zext i16 V to i32) to i64".</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">310</td>
    <td class="codeLine">  /// returns "sext i32 (zext i16 V to i32) to i64".</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="codeLine">  Value *applyExts(Value *V);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">311</td>
    <td class="codeLine">  Value *applyExts(Value *V);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">312</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="codeLine">  /// A helper function that returns whether we can trace into the operands</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">313</td>
    <td class="codeLine">  /// A helper function that returns whether we can trace into the operands</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="codeLine">  /// of binary operator BO for a constant offset.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">314</td>
    <td class="codeLine">  /// of binary operator BO for a constant offset.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">315</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="codeLine">  /// \p SignExtended Whether BO is surrounded by sext</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">316</td>
    <td class="codeLine">  /// \p SignExtended Whether BO is surrounded by sext</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="codeLine">  /// \p ZeroExtended Whether BO is surrounded by zext</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">317</td>
    <td class="codeLine">  /// \p ZeroExtended Whether BO is surrounded by zext</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="codeLine">  /// \p NonNegative Whether BO is known to be non-negative, e.g., an in-bound</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">318</td>
    <td class="codeLine">  /// \p NonNegative Whether BO is known to be non-negative, e.g., an in-bound</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="codeLine">  ///                array index.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">319</td>
    <td class="codeLine">  ///                array index.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="codeLine">  bool CanTraceInto(bool SignExtended, bool ZeroExtended, BinaryOperator *BO,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">320</td>
    <td class="codeLine">  bool CanTraceInto(bool SignExtended, bool ZeroExtended, BinaryOperator *BO,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="codeLine">                    bool NonNegative);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">321</td>
    <td class="codeLine">                    bool NonNegative);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">322</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="codeLine">  /// The path from the constant offset to the old GEP index. e.g., if the GEP</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">323</td>
    <td class="codeLine">  /// The path from the constant offset to the old GEP index. e.g., if the GEP</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="codeLine">  /// index is "a * b + (c + 5)". After running function find, UserChain[0] will</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">324</td>
    <td class="codeLine">  /// index is "a * b + (c + 5)". After running function find, UserChain[0] will</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="codeLine">  /// be the constant 5, UserChain[1] will be the subexpression "c + 5", and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">325</td>
    <td class="codeLine">  /// be the constant 5, UserChain[1] will be the subexpression "c + 5", and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="codeLine">  /// UserChain[2] will be the entire expression "a * b + (c + 5)".</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">326</td>
    <td class="codeLine">  /// UserChain[2] will be the entire expression "a * b + (c + 5)".</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">327</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="codeLine">  /// This path helps to rebuild the new GEP index.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">328</td>
    <td class="codeLine">  /// This path helps to rebuild the new GEP index.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="codeLine">  SmallVector<User *, 8> UserChain;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">329</td>
    <td class="codeLine">  SmallVector<User *, 8> UserChain;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">330</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="codeLine">  /// A data structure used in rebuildWithoutConstOffset. Contains all</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">331</td>
    <td class="codeLine">  /// A data structure used in rebuildWithoutConstOffset. Contains all</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="codeLine">  /// sext/zext instructions along UserChain.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">332</td>
    <td class="codeLine">  /// sext/zext instructions along UserChain.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="codeLine">  SmallVector<CastInst *, 16> ExtInsts;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">333</td>
    <td class="codeLine">  SmallVector<CastInst *, 16> ExtInsts;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">334</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="codeLine">  /// Insertion position of cloned instructions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">335</td>
    <td class="codeLine">  /// Insertion position of cloned instructions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="codeLine">  Instruction *IP;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">336</td>
    <td class="codeLine">  Instruction *IP;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">337</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="codeLine">  const DataLayout &DL;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">338</td>
    <td class="codeLine">  const DataLayout &DL;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="codeLine">  const DominatorTree *DT;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">339</td>
    <td class="codeLine">  const DominatorTree *DT;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">340</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">341</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="codeLine">/// A pass that tries to split every GEP in the function into a variadic</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">342</td>
    <td class="codeLine">/// A pass that tries to split every GEP in the function into a variadic</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="codeLine">/// base and a constant offset. It is a FunctionPass because searching for the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">343</td>
    <td class="codeLine">/// base and a constant offset. It is a FunctionPass because searching for the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="codeLine">/// constant offset may inspect other basic blocks.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">344</td>
    <td class="codeLine">/// constant offset may inspect other basic blocks.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="codeLine">class SeparateConstOffsetFromGEPLegacyPass : public FunctionPass {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">345</td>
    <td class="codeLine">class SeparateConstOffsetFromGEPLegacyPass : public FunctionPass {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">346</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="codeLine">  static char ID;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">347</td>
    <td class="codeLine">  static char ID;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">348</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="codeLine">  SeparateConstOffsetFromGEPLegacyPass(bool LowerGEP = false)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">349</td>
    <td class="codeLine">  SeparateConstOffsetFromGEPLegacyPass(bool LowerGEP = false)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="codeLine">      : FunctionPass(ID), LowerGEP(LowerGEP) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">350</td>
    <td class="codeLine">      : FunctionPass(ID), LowerGEP(LowerGEP) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="codeLine">    initializeSeparateConstOffsetFromGEPLegacyPassPass(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">351</td>
    <td class="codeLine">    initializeSeparateConstOffsetFromGEPLegacyPassPass(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="codeLine">        *PassRegistry::getPassRegistry());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">352</td>
    <td class="codeLine">        *PassRegistry::getPassRegistry());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">353</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">354</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="codeLine">  void getAnalysisUsage(AnalysisUsage &AU) const override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">355</td>
    <td class="codeLine">  void getAnalysisUsage(AnalysisUsage &AU) const override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="codeLine">    AU.addRequired<DominatorTreeWrapperPass>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">356</td>
    <td class="codeLine">    AU.addRequired<DominatorTreeWrapperPass>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="codeLine">    AU.addRequired<TargetTransformInfoWrapperPass>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">357</td>
    <td class="codeLine">    AU.addRequired<TargetTransformInfoWrapperPass>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="codeLine">    AU.addRequired<LoopInfoWrapperPass>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">358</td>
    <td class="codeLine">    AU.addRequired<LoopInfoWrapperPass>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="codeLine">    AU.setPreservesCFG();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">359</td>
    <td class="codeLine">    AU.setPreservesCFG();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="codeLine">    AU.addRequired<TargetLibraryInfoWrapperPass>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">360</td>
    <td class="codeLine">    AU.addRequired<TargetLibraryInfoWrapperPass>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">361</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">362</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="codeLine">  bool runOnFunction(Function &F) override;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">363</td>
    <td class="codeLine">  bool runOnFunction(Function &F) override;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">364</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">365</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="codeLine">  bool LowerGEP;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">366</td>
    <td class="codeLine">  bool LowerGEP;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">367</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">368</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="codeLine">/// A pass that tries to split every GEP in the function into a variadic</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">369</td>
    <td class="codeLine">/// A pass that tries to split every GEP in the function into a variadic</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="codeLine">/// base and a constant offset. It is a FunctionPass because searching for the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">370</td>
    <td class="codeLine">/// base and a constant offset. It is a FunctionPass because searching for the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="codeLine">/// constant offset may inspect other basic blocks.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">371</td>
    <td class="codeLine">/// constant offset may inspect other basic blocks.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="codeLine">class SeparateConstOffsetFromGEP {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">372</td>
    <td class="codeLine">class SeparateConstOffsetFromGEP {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">373</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="codeLine">  SeparateConstOffsetFromGEP(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">374</td>
    <td class="codeLine">  SeparateConstOffsetFromGEP(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="codeLine">      DominatorTree *DT, LoopInfo *LI, TargetLibraryInfo *TLI,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">375</td>
    <td class="codeLine">      DominatorTree *DT, LoopInfo *LI, TargetLibraryInfo *TLI,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="codeLine">      function_ref<TargetTransformInfo &(Function &)> GetTTI, bool LowerGEP)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">376</td>
    <td class="codeLine">      function_ref<TargetTransformInfo &(Function &)> GetTTI, bool LowerGEP)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="codeLine">      : DT(DT), LI(LI), TLI(TLI), GetTTI(GetTTI), LowerGEP(LowerGEP) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">377</td>
    <td class="codeLine">      : DT(DT), LI(LI), TLI(TLI), GetTTI(GetTTI), LowerGEP(LowerGEP) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">378</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="codeLine">  bool run(Function &F);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">379</td>
    <td class="codeLine">  bool run(Function &F);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">380</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">381</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="codeLine">  /// Track the operands of an add or sub.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">382</td>
    <td class="codeLine">  /// Track the operands of an add or sub.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="codeLine">  using ExprKey = std::pair<Value *, Value *>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">383</td>
    <td class="codeLine">  using ExprKey = std::pair<Value *, Value *>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">384</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="codeLine">  /// Create a pair for use as a map key for a commutable operation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">385</td>
    <td class="codeLine">  /// Create a pair for use as a map key for a commutable operation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="codeLine">  static ExprKey createNormalizedCommutablePair(Value *A, Value *B) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">386</td>
    <td class="codeLine">  static ExprKey createNormalizedCommutablePair(Value *A, Value *B) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="codeLine">    if (A < B)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">387</td>
    <td class="codeLine">    if (A < B)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="codeLine">      return {A, B};</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">388</td>
    <td class="codeLine">      return {A, B};</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="codeLine">    return {B, A};</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">389</td>
    <td class="codeLine">    return {B, A};</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">390</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">391</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="codeLine">  /// Tries to split the given GEP into a variadic base and a constant offset,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">392</td>
    <td class="codeLine">  /// Tries to split the given GEP into a variadic base and a constant offset,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="codeLine">  /// and returns true if the splitting succeeds.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">393</td>
    <td class="codeLine">  /// and returns true if the splitting succeeds.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="codeLine">  bool splitGEP(GetElementPtrInst *GEP);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">394</td>
    <td class="codeLine">  bool splitGEP(GetElementPtrInst *GEP);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">395</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="codeLine">  /// Lower a GEP with multiple indices into multiple GEPs with a single index.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">396</td>
    <td class="codeLine">  /// Lower a GEP with multiple indices into multiple GEPs with a single index.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="codeLine">  /// Function splitGEP already split the original GEP into a variadic part and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">397</td>
    <td class="codeLine">  /// Function splitGEP already split the original GEP into a variadic part and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="codeLine">  /// a constant offset (i.e., AccumulativeByteOffset). This function lowers the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">398</td>
    <td class="codeLine">  /// a constant offset (i.e., AccumulativeByteOffset). This function lowers the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="codeLine">  /// variadic part into a set of GEPs with a single index and applies</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">399</td>
    <td class="codeLine">  /// variadic part into a set of GEPs with a single index and applies</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="codeLine">  /// AccumulativeByteOffset to it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">400</td>
    <td class="codeLine">  /// AccumulativeByteOffset to it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="codeLine">  /// \p Variadic                  The variadic part of the original GEP.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">401</td>
    <td class="codeLine">  /// \p Variadic                  The variadic part of the original GEP.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="codeLine">  /// \p AccumulativeByteOffset    The constant offset.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">402</td>
    <td class="codeLine">  /// \p AccumulativeByteOffset    The constant offset.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="codeLine">  void lowerToSingleIndexGEPs(GetElementPtrInst *Variadic,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">403</td>
    <td class="codeLine">  void lowerToSingleIndexGEPs(GetElementPtrInst *Variadic,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="codeLine">                              int64_t AccumulativeByteOffset);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">404</td>
    <td class="codeLine">                              int64_t AccumulativeByteOffset);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">405</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="codeLine">  /// Lower a GEP with multiple indices into ptrtoint+arithmetics+inttoptr form.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">406</td>
    <td class="codeLine">  /// Lower a GEP with multiple indices into ptrtoint+arithmetics+inttoptr form.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="codeLine">  /// Function splitGEP already split the original GEP into a variadic part and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">407</td>
    <td class="codeLine">  /// Function splitGEP already split the original GEP into a variadic part and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="codeLine">  /// a constant offset (i.e., AccumulativeByteOffset). This function lowers the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">408</td>
    <td class="codeLine">  /// a constant offset (i.e., AccumulativeByteOffset). This function lowers the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="codeLine">  /// variadic part into a set of arithmetic operations and applies</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">409</td>
    <td class="codeLine">  /// variadic part into a set of arithmetic operations and applies</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="codeLine">  /// AccumulativeByteOffset to it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">410</td>
    <td class="codeLine">  /// AccumulativeByteOffset to it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="codeLine">  /// \p Variadic                  The variadic part of the original GEP.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">411</td>
    <td class="codeLine">  /// \p Variadic                  The variadic part of the original GEP.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="codeLine">  /// \p AccumulativeByteOffset    The constant offset.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">412</td>
    <td class="codeLine">  /// \p AccumulativeByteOffset    The constant offset.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="codeLine">  void lowerToArithmetics(GetElementPtrInst *Variadic,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">413</td>
    <td class="codeLine">  void lowerToArithmetics(GetElementPtrInst *Variadic,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="codeLine">                          int64_t AccumulativeByteOffset);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">414</td>
    <td class="codeLine">                          int64_t AccumulativeByteOffset);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">415</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="codeLine">  /// Finds the constant offset within each index and accumulates them. If</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">416</td>
    <td class="codeLine">  /// Finds the constant offset within each index and accumulates them. If</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="codeLine">  /// LowerGEP is true, it finds in indices of both sequential and structure</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">417</td>
    <td class="codeLine">  /// LowerGEP is true, it finds in indices of both sequential and structure</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="codeLine">  /// types, otherwise it only finds in sequential indices. The output</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">418</td>
    <td class="codeLine">  /// types, otherwise it only finds in sequential indices. The output</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="codeLine">  /// NeedsExtraction indicates whether we successfully find a non-zero constant</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">419</td>
    <td class="codeLine">  /// NeedsExtraction indicates whether we successfully find a non-zero constant</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="codeLine">  /// offset.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">420</td>
    <td class="codeLine">  /// offset.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="codeLine">  int64_t accumulateByteOffset(GetElementPtrInst *GEP, bool &NeedsExtraction);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">421</td>
    <td class="codeLine">  int64_t accumulateByteOffset(GetElementPtrInst *GEP, bool &NeedsExtraction);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">422</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="codeLine">  /// Canonicalize array indices to pointer-size integers. This helps to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">423</td>
    <td class="codeLine">  /// Canonicalize array indices to pointer-size integers. This helps to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="codeLine">  /// simplify the logic of splitting a GEP. For example, if a + b is a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">424</td>
    <td class="codeLine">  /// simplify the logic of splitting a GEP. For example, if a + b is a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="codeLine">  /// pointer-size integer, we have</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">425</td>
    <td class="codeLine">  /// pointer-size integer, we have</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="codeLine">  ///   gep base, a + b = gep (gep base, a), b</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">426</td>
    <td class="codeLine">  ///   gep base, a + b = gep (gep base, a), b</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="codeLine">  /// However, this equality may not hold if the size of a + b is smaller than</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">427</td>
    <td class="codeLine">  /// However, this equality may not hold if the size of a + b is smaller than</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="codeLine">  /// the pointer size, because LLVM conceptually sign-extends GEP indices to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">428</td>
    <td class="codeLine">  /// the pointer size, because LLVM conceptually sign-extends GEP indices to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="codeLine">  /// pointer size before computing the address</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">429</td>
    <td class="codeLine">  /// pointer size before computing the address</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="codeLine">  /// (http://llvm.org/docs/LangRef.html#id181).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">430</td>
    <td class="codeLine">  /// (http://llvm.org/docs/LangRef.html#id181).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">431</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="codeLine">  /// This canonicalization is very likely already done in clang and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">432</td>
    <td class="codeLine">  /// This canonicalization is very likely already done in clang and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="codeLine">  /// instcombine. Therefore, the program will probably remain the same.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">433</td>
    <td class="codeLine">  /// instcombine. Therefore, the program will probably remain the same.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">434</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="codeLine">  /// Returns true if the module changes.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">435</td>
    <td class="codeLine">  /// Returns true if the module changes.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">436</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="codeLine">  /// Verified in @i32_add in split-gep.ll</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">437</td>
    <td class="codeLine">  /// Verified in @i32_add in split-gep.ll</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="codeLine">  bool canonicalizeArrayIndicesToIndexSize(GetElementPtrInst *GEP);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">438</td>
    <td class="codeLine">  bool canonicalizeArrayIndicesToIndexSize(GetElementPtrInst *GEP);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">439</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="codeLine">  /// Optimize sext(a)+sext(b) to sext(a+b) when a+b can't sign overflow.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">440</td>
    <td class="codeLine">  /// Optimize sext(a)+sext(b) to sext(a+b) when a+b can't sign overflow.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="codeLine">  /// SeparateConstOffsetFromGEP distributes a sext to leaves before extracting</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">441</td>
    <td class="codeLine">  /// SeparateConstOffsetFromGEP distributes a sext to leaves before extracting</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="codeLine">  /// the constant offset. After extraction, it becomes desirable to reunion the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">442</td>
    <td class="codeLine">  /// the constant offset. After extraction, it becomes desirable to reunion the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="codeLine">  /// distributed sexts. For example,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">443</td>
    <td class="codeLine">  /// distributed sexts. For example,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">444</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="codeLine">  ///                              &a[sext(i +nsw (j +nsw 5)]</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">445</td>
    <td class="codeLine">  ///                              &a[sext(i +nsw (j +nsw 5)]</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="codeLine">  ///   => distribute              &a[sext(i) +nsw (sext(j) +nsw 5)]</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">446</td>
    <td class="codeLine">  ///   => distribute              &a[sext(i) +nsw (sext(j) +nsw 5)]</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="codeLine">  ///   => constant extraction     &a[sext(i) + sext(j)] + 5</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">447</td>
    <td class="codeLine">  ///   => constant extraction     &a[sext(i) + sext(j)] + 5</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="codeLine">  ///   => reunion                 &a[sext(i +nsw j)] + 5</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">448</td>
    <td class="codeLine">  ///   => reunion                 &a[sext(i +nsw j)] + 5</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="codeLine">  bool reuniteExts(Function &F);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">449</td>
    <td class="codeLine">  bool reuniteExts(Function &F);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">450</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="codeLine">  /// A helper that reunites sexts in an instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">451</td>
    <td class="codeLine">  /// A helper that reunites sexts in an instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="codeLine">  bool reuniteExts(Instruction *I);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">452</td>
    <td class="codeLine">  bool reuniteExts(Instruction *I);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">453</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="codeLine">  /// Find the closest dominator of <Dominatee> that is equivalent to <Key>.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">454</td>
    <td class="codeLine">  /// Find the closest dominator of <Dominatee> that is equivalent to <Key>.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="codeLine">  Instruction *findClosestMatchingDominator(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">455</td>
    <td class="codeLine">  Instruction *findClosestMatchingDominator(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="codeLine">      ExprKey Key, Instruction *Dominatee,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">456</td>
    <td class="codeLine">      ExprKey Key, Instruction *Dominatee,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="codeLine">      DenseMap<ExprKey, SmallVector<Instruction *, 2>> &DominatingExprs);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">457</td>
    <td class="codeLine">      DenseMap<ExprKey, SmallVector<Instruction *, 2>> &DominatingExprs);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">458</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="codeLine">  /// Verify F is free of dead code.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">459</td>
    <td class="codeLine">  /// Verify F is free of dead code.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="codeLine">  void verifyNoDeadCode(Function &F);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">460</td>
    <td class="codeLine">  void verifyNoDeadCode(Function &F);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">461</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="codeLine">  bool hasMoreThanOneUseInLoop(Value *v, Loop *L);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">462</td>
    <td class="codeLine">  bool hasMoreThanOneUseInLoop(Value *v, Loop *L);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">463</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="codeLine">  // Swap the index operand of two GEP.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">464</td>
    <td class="codeLine">  // Swap the index operand of two GEP.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="codeLine">  void swapGEPOperand(GetElementPtrInst *First, GetElementPtrInst *Second);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">465</td>
    <td class="codeLine">  void swapGEPOperand(GetElementPtrInst *First, GetElementPtrInst *Second);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">466</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="codeLine">  // Check if it is safe to swap operand of two GEP.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">467</td>
    <td class="codeLine">  // Check if it is safe to swap operand of two GEP.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="codeLine">  bool isLegalToSwapOperand(GetElementPtrInst *First, GetElementPtrInst *Second,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">468</td>
    <td class="codeLine">  bool isLegalToSwapOperand(GetElementPtrInst *First, GetElementPtrInst *Second,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="codeLine">                            Loop *CurLoop);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">469</td>
    <td class="codeLine">                            Loop *CurLoop);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">470</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="codeLine">  const DataLayout *DL = nullptr;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">471</td>
    <td class="codeLine">  const DataLayout *DL = nullptr;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="codeLine">  DominatorTree *DT = nullptr;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">472</td>
    <td class="codeLine">  DominatorTree *DT = nullptr;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="codeLine">  LoopInfo *LI;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">473</td>
    <td class="codeLine">  LoopInfo *LI;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="codeLine">  TargetLibraryInfo *TLI;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">474</td>
    <td class="codeLine">  TargetLibraryInfo *TLI;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="codeLine">  // Retrieved lazily since not always used.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">475</td>
    <td class="codeLine">  // Retrieved lazily since not always used.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="codeLine">  function_ref<TargetTransformInfo &(Function &)> GetTTI;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">476</td>
    <td class="codeLine">  function_ref<TargetTransformInfo &(Function &)> GetTTI;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">477</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="codeLine">  /// Whether to lower a GEP with multiple indices into arithmetic operations or</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">478</td>
    <td class="codeLine">  /// Whether to lower a GEP with multiple indices into arithmetic operations or</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="codeLine">  /// multiple GEPs with a single index.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">479</td>
    <td class="codeLine">  /// multiple GEPs with a single index.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="codeLine">  bool LowerGEP;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">480</td>
    <td class="codeLine">  bool LowerGEP;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">481</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="codeLine">  DenseMap<ExprKey, SmallVector<Instruction *, 2>> DominatingAdds;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">482</td>
    <td class="codeLine">  DenseMap<ExprKey, SmallVector<Instruction *, 2>> DominatingAdds;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="codeLine">  DenseMap<ExprKey, SmallVector<Instruction *, 2>> DominatingSubs;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">483</td>
    <td class="codeLine">  DenseMap<ExprKey, SmallVector<Instruction *, 2>> DominatingSubs;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">484</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">485</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="codeLine">} // end anonymous namespace</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">486</td>
    <td class="codeLine">} // end anonymous namespace</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">487</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="codeLine">char SeparateConstOffsetFromGEPLegacyPass::ID = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">488</td>
    <td class="codeLine">char SeparateConstOffsetFromGEPLegacyPass::ID = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">489</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_BEGIN(</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">490</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_BEGIN(</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="codeLine">    SeparateConstOffsetFromGEPLegacyPass, "separate-const-offset-from-gep",</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">491</td>
    <td class="codeLine">    SeparateConstOffsetFromGEPLegacyPass, "separate-const-offset-from-gep",</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="codeLine">    "Split GEPs to a variadic base and a constant offset for better CSE", false,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">492</td>
    <td class="codeLine">    "Split GEPs to a variadic base and a constant offset for better CSE", false,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="codeLine">    false)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">493</td>
    <td class="codeLine">    false)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(DominatorTreeWrapperPass)</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">494</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(DominatorTreeWrapperPass)</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(ScalarEvolutionWrapperPass)</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">495</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(ScalarEvolutionWrapperPass)</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(TargetTransformInfoWrapperPass)</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">496</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(TargetTransformInfoWrapperPass)</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(LoopInfoWrapperPass)</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">497</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(LoopInfoWrapperPass)</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(TargetLibraryInfoWrapperPass)</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">498</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(TargetLibraryInfoWrapperPass)</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_END(</td>
    <td class="lineNumber">2</td>
    <td class="lineNumber">499</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_END(</td>
    <td class="lineNumber">2</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="codeLine">    SeparateConstOffsetFromGEPLegacyPass, "separate-const-offset-from-gep",</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">500</td>
    <td class="codeLine">    SeparateConstOffsetFromGEPLegacyPass, "separate-const-offset-from-gep",</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="codeLine">    "Split GEPs to a variadic base and a constant offset for better CSE", false,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">501</td>
    <td class="codeLine">    "Split GEPs to a variadic base and a constant offset for better CSE", false,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="codeLine">    false)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">502</td>
    <td class="codeLine">    false)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">503</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class="codeLine">FunctionPass *llvm::createSeparateConstOffsetFromGEPPass(bool LowerGEP) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">504</td>
    <td class="codeLine">FunctionPass *llvm::createSeparateConstOffsetFromGEPPass(bool LowerGEP) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="codeLine">  return new SeparateConstOffsetFromGEPLegacyPass(LowerGEP);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">505</td>
    <td class="codeLine">  return new SeparateConstOffsetFromGEPLegacyPass(LowerGEP);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">506</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">507</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="codeLine">bool ConstantOffsetExtractor::CanTraceInto(bool SignExtended,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">508</td>
    <td class="codeLine">bool ConstantOffsetExtractor::CanTraceInto(bool SignExtended,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="codeLine">                                            bool ZeroExtended,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">509</td>
    <td class="codeLine">                                            bool ZeroExtended,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="codeLine">                                            BinaryOperator *BO,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">510</td>
    <td class="codeLine">                                            BinaryOperator *BO,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="codeLine">                                            bool NonNegative) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">511</td>
    <td class="codeLine">                                            bool NonNegative) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="codeLine">  // We only consider ADD, SUB and OR, because a non-zero constant found in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">512</td>
    <td class="codeLine">  // We only consider ADD, SUB and OR, because a non-zero constant found in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class="codeLine">  // expressions composed of these operations can be easily hoisted as a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">513</td>
    <td class="codeLine">  // expressions composed of these operations can be easily hoisted as a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="codeLine">  // constant offset by reassociation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">514</td>
    <td class="codeLine">  // constant offset by reassociation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="codeLine">  if (BO->getOpcode() != Instruction::Add &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">515</td>
    <td class="codeLine">  if (BO->getOpcode() != Instruction::Add &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="codeLine">      BO->getOpcode() != Instruction::Sub &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">516</td>
    <td class="codeLine">      BO->getOpcode() != Instruction::Sub &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class="codeLine">      BO->getOpcode() != Instruction::Or) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">517</td>
    <td class="codeLine">      BO->getOpcode() != Instruction::Or) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">518</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">519</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">520</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="codeLine">  Value *LHS = BO->getOperand(0), *RHS = BO->getOperand(1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">521</td>
    <td class="codeLine">  Value *LHS = BO->getOperand(0), *RHS = BO->getOperand(1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="codeLine">  // Do not trace into "or" unless it is equivalent to "add". If LHS and RHS</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">522</td>
    <td class="codeLine">  // Do not trace into "or" unless it is equivalent to "add". If LHS and RHS</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="codeLine">  // don't have common bits, (LHS | RHS) is equivalent to (LHS + RHS).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">523</td>
    <td class="codeLine">  // don't have common bits, (LHS | RHS) is equivalent to (LHS + RHS).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="codeLine">  // FIXME: this does not appear to be covered by any tests</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">524</td>
    <td class="codeLine">  // FIXME: this does not appear to be covered by any tests</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="codeLine">  //        (with x86/aarch64 backends at least)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">525</td>
    <td class="codeLine">  //        (with x86/aarch64 backends at least)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class="codeLine">  if (BO->getOpcode() == Instruction::Or &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">526</td>
    <td class="codeLine">  if (BO->getOpcode() == Instruction::Or &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="codeLine">      !haveNoCommonBitsSet(LHS, RHS, DL, nullptr, BO, DT))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">527</td>
    <td class="codeLine">      !haveNoCommonBitsSet(LHS, RHS, DL, nullptr, BO, DT))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">528</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">529</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="codeLine">  // FIXME: We don't currently support constants from the RHS of subs,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">530</td>
    <td class="codeLine">  // FIXME: We don't currently support constants from the RHS of subs,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="codeLine">  // when we are zero-extended, because we need a way to zero-extended</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">531</td>
    <td class="codeLine">  // when we are zero-extended, because we need a way to zero-extended</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="codeLine">  // them before they are negated.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">532</td>
    <td class="codeLine">  // them before they are negated.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class="codeLine">  if (ZeroExtended && !SignExtended && BO->getOpcode() == Instruction::Sub)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">533</td>
    <td class="codeLine">  if (ZeroExtended && !SignExtended && BO->getOpcode() == Instruction::Sub)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">534</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">535</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="codeLine">  // In addition, tracing into BO requires that its surrounding s/zext (if</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">536</td>
    <td class="codeLine">  // In addition, tracing into BO requires that its surrounding s/zext (if</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="codeLine">  // any) is distributable to both operands.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">537</td>
    <td class="codeLine">  // any) is distributable to both operands.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">538</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="codeLine">  // Suppose BO = A op B.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">539</td>
    <td class="codeLine">  // Suppose BO = A op B.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class="codeLine">  //  SignExtended | ZeroExtended | Distributable?</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">540</td>
    <td class="codeLine">  //  SignExtended | ZeroExtended | Distributable?</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="codeLine">  // --------------+--------------+----------------------------------</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">541</td>
    <td class="codeLine">  // --------------+--------------+----------------------------------</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="codeLine">  //       0       |      0       | true because no s/zext exists</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">542</td>
    <td class="codeLine">  //       0       |      0       | true because no s/zext exists</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="codeLine">  //       0       |      1       | zext(BO) == zext(A) op zext(B)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">543</td>
    <td class="codeLine">  //       0       |      1       | zext(BO) == zext(A) op zext(B)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="codeLine">  //       1       |      0       | sext(BO) == sext(A) op sext(B)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">544</td>
    <td class="codeLine">  //       1       |      0       | sext(BO) == sext(A) op sext(B)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="codeLine">  //       1       |      1       | zext(sext(BO)) ==</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">545</td>
    <td class="codeLine">  //       1       |      1       | zext(sext(BO)) ==</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="codeLine">  //               |              |     zext(sext(A)) op zext(sext(B))</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">546</td>
    <td class="codeLine">  //               |              |     zext(sext(A)) op zext(sext(B))</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="codeLine">  if (BO->getOpcode() == Instruction::Add && !ZeroExtended && NonNegative) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">547</td>
    <td class="codeLine">  if (BO->getOpcode() == Instruction::Add && !ZeroExtended && NonNegative) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="codeLine">    // If a + b >= 0 and (a >= 0 or b >= 0), then</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">548</td>
    <td class="codeLine">    // If a + b >= 0 and (a >= 0 or b >= 0), then</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="codeLine">    //   sext(a + b) = sext(a) + sext(b)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">549</td>
    <td class="codeLine">    //   sext(a + b) = sext(a) + sext(b)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="codeLine">    // even if the addition is not marked nsw.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">550</td>
    <td class="codeLine">    // even if the addition is not marked nsw.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">551</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="codeLine">    // Leveraging this invariant, we can trace into an sext'ed inbound GEP</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">552</td>
    <td class="codeLine">    // Leveraging this invariant, we can trace into an sext'ed inbound GEP</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="codeLine">    // index if the constant offset is non-negative.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">553</td>
    <td class="codeLine">    // index if the constant offset is non-negative.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">554</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="codeLine">    // Verified in @sext_add in split-gep.ll.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">555</td>
    <td class="codeLine">    // Verified in @sext_add in split-gep.ll.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="codeLine">    if (ConstantInt *ConstLHS = dyn_cast<ConstantInt>(LHS)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">556</td>
    <td class="codeLine">    if (ConstantInt *ConstLHS = dyn_cast<ConstantInt>(LHS)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="codeLine">      if (!ConstLHS->isNegative())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">557</td>
    <td class="codeLine">      if (!ConstLHS->isNegative())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="codeLine">        return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">558</td>
    <td class="codeLine">        return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">559</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="codeLine">    if (ConstantInt *ConstRHS = dyn_cast<ConstantInt>(RHS)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">560</td>
    <td class="codeLine">    if (ConstantInt *ConstRHS = dyn_cast<ConstantInt>(RHS)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="codeLine">      if (!ConstRHS->isNegative())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">561</td>
    <td class="codeLine">      if (!ConstRHS->isNegative())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="codeLine">        return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">562</td>
    <td class="codeLine">        return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">563</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">564</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">565</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="codeLine">  // sext (add/sub nsw A, B) == add/sub nsw (sext A), (sext B)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">566</td>
    <td class="codeLine">  // sext (add/sub nsw A, B) == add/sub nsw (sext A), (sext B)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="codeLine">  // zext (add/sub nuw A, B) == add/sub nuw (zext A), (zext B)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">567</td>
    <td class="codeLine">  // zext (add/sub nuw A, B) == add/sub nuw (zext A), (zext B)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="codeLine">  if (BO->getOpcode() == Instruction::Add ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">568</td>
    <td class="codeLine">  if (BO->getOpcode() == Instruction::Add ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="codeLine">      BO->getOpcode() == Instruction::Sub) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">569</td>
    <td class="codeLine">      BO->getOpcode() == Instruction::Sub) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="codeLine">    if (SignExtended && !BO->hasNoSignedWrap())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">570</td>
    <td class="codeLine">    if (SignExtended && !BO->hasNoSignedWrap())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">571</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="codeLine">    if (ZeroExtended && !BO->hasNoUnsignedWrap())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">572</td>
    <td class="codeLine">    if (ZeroExtended && !BO->hasNoUnsignedWrap())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">573</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">574</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">575</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">576</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">577</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">578</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class="codeLine">APInt ConstantOffsetExtractor::findInEitherOperand(BinaryOperator *BO,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">579</td>
    <td class="codeLine">APInt ConstantOffsetExtractor::findInEitherOperand(BinaryOperator *BO,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="codeLine">                                                   bool SignExtended,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">580</td>
    <td class="codeLine">                                                   bool SignExtended,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="codeLine">                                                   bool ZeroExtended) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">581</td>
    <td class="codeLine">                                                   bool ZeroExtended) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class="codeLine">  // Save off the current height of the chain, in case we need to restore it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">582</td>
    <td class="codeLine">  // Save off the current height of the chain, in case we need to restore it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="codeLine">  size_t ChainLength = UserChain.size();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">583</td>
    <td class="codeLine">  size_t ChainLength = UserChain.size();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">584</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="codeLine">  // BO being non-negative does not shed light on whether its operands are</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">585</td>
    <td class="codeLine">  // BO being non-negative does not shed light on whether its operands are</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="codeLine">  // non-negative. Clear the NonNegative flag here.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">586</td>
    <td class="codeLine">  // non-negative. Clear the NonNegative flag here.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class="codeLine">  APInt ConstantOffset = find(BO->getOperand(0), SignExtended, ZeroExtended,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">587</td>
    <td class="codeLine">  APInt ConstantOffset = find(BO->getOperand(0), SignExtended, ZeroExtended,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="codeLine">                              /* NonNegative */ false);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">588</td>
    <td class="codeLine">                              /* NonNegative */ false);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="codeLine">  // If we found a constant offset in the left operand, stop and return that.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">589</td>
    <td class="codeLine">  // If we found a constant offset in the left operand, stop and return that.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class="codeLine">  // This shortcut might cause us to miss opportunities of combining the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">590</td>
    <td class="codeLine">  // This shortcut might cause us to miss opportunities of combining the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="codeLine">  // constant offsets in both operands, e.g., (a + 4) + (b + 5) => (a + b) + 9.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">591</td>
    <td class="codeLine">  // constant offsets in both operands, e.g., (a + 4) + (b + 5) => (a + b) + 9.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="codeLine">  // However, such cases are probably already handled by -instcombine,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">592</td>
    <td class="codeLine">  // However, such cases are probably already handled by -instcombine,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="codeLine">  // given this pass runs after the standard optimizations.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">593</td>
    <td class="codeLine">  // given this pass runs after the standard optimizations.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="codeLine">  if (ConstantOffset != 0) return ConstantOffset;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">594</td>
    <td class="codeLine">  if (ConstantOffset != 0) return ConstantOffset;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">595</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="codeLine">  // Reset the chain back to where it was when we started exploring this node,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">596</td>
    <td class="codeLine">  // Reset the chain back to where it was when we started exploring this node,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class="codeLine">  // since visiting the LHS didn't pan out.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">597</td>
    <td class="codeLine">  // since visiting the LHS didn't pan out.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="codeLine">  UserChain.resize(ChainLength);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">598</td>
    <td class="codeLine">  UserChain.resize(ChainLength);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">599</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="codeLine">  ConstantOffset = find(BO->getOperand(1), SignExtended, ZeroExtended,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">600</td>
    <td class="codeLine">  ConstantOffset = find(BO->getOperand(1), SignExtended, ZeroExtended,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="codeLine">                        /* NonNegative */ false);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">601</td>
    <td class="codeLine">                        /* NonNegative */ false);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="codeLine">  // If U is a sub operator, negate the constant offset found in the right</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">602</td>
    <td class="codeLine">  // If U is a sub operator, negate the constant offset found in the right</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="codeLine">  // operand.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">603</td>
    <td class="codeLine">  // operand.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="codeLine">  if (BO->getOpcode() == Instruction::Sub)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">604</td>
    <td class="codeLine">  if (BO->getOpcode() == Instruction::Sub)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="codeLine">    ConstantOffset = -ConstantOffset;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">605</td>
    <td class="codeLine">    ConstantOffset = -ConstantOffset;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">606</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="codeLine">  // If RHS wasn't a suitable candidate either, reset the chain again.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">607</td>
    <td class="codeLine">  // If RHS wasn't a suitable candidate either, reset the chain again.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="codeLine">  if (ConstantOffset == 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">608</td>
    <td class="codeLine">  if (ConstantOffset == 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="codeLine">    UserChain.resize(ChainLength);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">609</td>
    <td class="codeLine">    UserChain.resize(ChainLength);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">610</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="codeLine">  return ConstantOffset;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">611</td>
    <td class="codeLine">  return ConstantOffset;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">612</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">613</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class="codeLine">APInt ConstantOffsetExtractor::find(Value *V, bool SignExtended,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">614</td>
    <td class="codeLine">APInt ConstantOffsetExtractor::find(Value *V, bool SignExtended,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="codeLine">                                    bool ZeroExtended, bool NonNegative) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">615</td>
    <td class="codeLine">                                    bool ZeroExtended, bool NonNegative) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="codeLine">  // TODO(jingyue): We could trace into integer/pointer casts, such as</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">616</td>
    <td class="codeLine">  // TODO(jingyue): We could trace into integer/pointer casts, such as</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="codeLine">  // inttoptr, ptrtoint, bitcast, and addrspacecast. We choose to handle only</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">617</td>
    <td class="codeLine">  // inttoptr, ptrtoint, bitcast, and addrspacecast. We choose to handle only</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class="codeLine">  // integers because it gives good enough results for our benchmarks.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">618</td>
    <td class="codeLine">  // integers because it gives good enough results for our benchmarks.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="codeLine">  unsigned BitWidth = cast<IntegerType>(V->getType())->getBitWidth();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">619</td>
    <td class="codeLine">  unsigned BitWidth = cast<IntegerType>(V->getType())->getBitWidth();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">620</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class="codeLine">  // We cannot do much with Values that are not a User, such as an Argument.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">621</td>
    <td class="codeLine">  // We cannot do much with Values that are not a User, such as an Argument.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="codeLine">  User *U = dyn_cast<User>(V);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">622</td>
    <td class="codeLine">  User *U = dyn_cast<User>(V);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="codeLine">  if (U == nullptr) return APInt(BitWidth, 0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">623</td>
    <td class="codeLine">  if (U == nullptr) return APInt(BitWidth, 0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">624</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="codeLine">  APInt ConstantOffset(BitWidth, 0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">625</td>
    <td class="codeLine">  APInt ConstantOffset(BitWidth, 0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="codeLine">  if (ConstantInt *CI = dyn_cast<ConstantInt>(V)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">626</td>
    <td class="codeLine">  if (ConstantInt *CI = dyn_cast<ConstantInt>(V)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="codeLine">    // Hooray, we found it!</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">627</td>
    <td class="codeLine">    // Hooray, we found it!</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class="codeLine">    ConstantOffset = CI->getValue();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">628</td>
    <td class="codeLine">    ConstantOffset = CI->getValue();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="codeLine">  } else if (BinaryOperator *BO = dyn_cast<BinaryOperator>(V)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">629</td>
    <td class="codeLine">  } else if (BinaryOperator *BO = dyn_cast<BinaryOperator>(V)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class="codeLine">    // Trace into subexpressions for more hoisting opportunities.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">630</td>
    <td class="codeLine">    // Trace into subexpressions for more hoisting opportunities.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="codeLine">    if (CanTraceInto(SignExtended, ZeroExtended, BO, NonNegative))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">631</td>
    <td class="codeLine">    if (CanTraceInto(SignExtended, ZeroExtended, BO, NonNegative))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="codeLine">      ConstantOffset = findInEitherOperand(BO, SignExtended, ZeroExtended);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">632</td>
    <td class="codeLine">      ConstantOffset = findInEitherOperand(BO, SignExtended, ZeroExtended);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="codeLine">  } else if (isa<TruncInst>(V)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">633</td>
    <td class="codeLine">  } else if (isa<TruncInst>(V)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="codeLine">    ConstantOffset =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">634</td>
    <td class="codeLine">    ConstantOffset =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="codeLine">        find(U->getOperand(0), SignExtended, ZeroExtended, NonNegative)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">635</td>
    <td class="codeLine">        find(U->getOperand(0), SignExtended, ZeroExtended, NonNegative)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="codeLine">            .trunc(BitWidth);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">636</td>
    <td class="codeLine">            .trunc(BitWidth);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="codeLine">  } else if (isa<SExtInst>(V)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">637</td>
    <td class="codeLine">  } else if (isa<SExtInst>(V)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="codeLine">    ConstantOffset = find(U->getOperand(0), /* SignExtended */ true,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">638</td>
    <td class="codeLine">    ConstantOffset = find(U->getOperand(0), /* SignExtended */ true,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="codeLine">                          ZeroExtended, NonNegative).sext(BitWidth);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">639</td>
    <td class="codeLine">                          ZeroExtended, NonNegative).sext(BitWidth);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="codeLine">  } else if (isa<ZExtInst>(V)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">640</td>
    <td class="codeLine">  } else if (isa<ZExtInst>(V)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="codeLine">    // As an optimization, we can clear the SignExtended flag because</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">641</td>
    <td class="codeLine">    // As an optimization, we can clear the SignExtended flag because</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="codeLine">    // sext(zext(a)) = zext(a). Verified in @sext_zext in split-gep.ll.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">642</td>
    <td class="codeLine">    // sext(zext(a)) = zext(a). Verified in @sext_zext in split-gep.ll.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">643</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class="codeLine">    // Clear the NonNegative flag, because zext(a) >= 0 does not imply a >= 0.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">644</td>
    <td class="codeLine">    // Clear the NonNegative flag, because zext(a) >= 0 does not imply a >= 0.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="codeLine">    ConstantOffset =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">645</td>
    <td class="codeLine">    ConstantOffset =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="codeLine">        find(U->getOperand(0), /* SignExtended */ false,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">646</td>
    <td class="codeLine">        find(U->getOperand(0), /* SignExtended */ false,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="codeLine">             /* ZeroExtended */ true, /* NonNegative */ false).zext(BitWidth);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">647</td>
    <td class="codeLine">             /* ZeroExtended */ true, /* NonNegative */ false).zext(BitWidth);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">648</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">649</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="codeLine">  // If we found a non-zero constant offset, add it to the path for</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">650</td>
    <td class="codeLine">  // If we found a non-zero constant offset, add it to the path for</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="codeLine">  // rebuildWithoutConstOffset. Zero is a valid constant offset, but doesn't</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">651</td>
    <td class="codeLine">  // rebuildWithoutConstOffset. Zero is a valid constant offset, but doesn't</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="codeLine">  // help this optimization.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">652</td>
    <td class="codeLine">  // help this optimization.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="codeLine">  if (ConstantOffset != 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">653</td>
    <td class="codeLine">  if (ConstantOffset != 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="codeLine">    UserChain.push_back(U);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">654</td>
    <td class="codeLine">    UserChain.push_back(U);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="codeLine">  return ConstantOffset;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">655</td>
    <td class="codeLine">  return ConstantOffset;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">656</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">657</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="codeLine">Value *ConstantOffsetExtractor::applyExts(Value *V) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">658</td>
    <td class="codeLine">Value *ConstantOffsetExtractor::applyExts(Value *V) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="codeLine">  Value *Current = V;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">659</td>
    <td class="codeLine">  Value *Current = V;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="codeLine">  // ExtInsts is built in the use-def order. Therefore, we apply them to V</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">660</td>
    <td class="codeLine">  // ExtInsts is built in the use-def order. Therefore, we apply them to V</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="codeLine">  // in the reversed order.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">661</td>
    <td class="codeLine">  // in the reversed order.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="codeLine">  for (CastInst *I : llvm::reverse(ExtInsts)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">662</td>
    <td class="codeLine">  for (CastInst *I : llvm::reverse(ExtInsts)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="codeLine">    if (Constant *C = dyn_cast<Constant>(Current)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">663</td>
    <td class="codeLine">    if (Constant *C = dyn_cast<Constant>(Current)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="codeLine">      // If Current is a constant, apply s/zext using ConstantExpr::getCast.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">664</td>
    <td class="codeLine">      // If Current is a constant, apply s/zext using ConstantExpr::getCast.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="codeLine">      // ConstantExpr::getCast emits a ConstantInt if C is a ConstantInt.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">665</td>
    <td class="codeLine">      // ConstantExpr::getCast emits a ConstantInt if C is a ConstantInt.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="codeLine">      Current = ConstantExpr::getCast(I->getOpcode(), C, I->getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">666</td>
    <td class="codeLine">      Current = ConstantExpr::getCast(I->getOpcode(), C, I->getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">667</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="codeLine">      Instruction *Ext = I->clone();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">668</td>
    <td class="codeLine">      Instruction *Ext = I->clone();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="codeLine">      Ext->setOperand(0, Current);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">669</td>
    <td class="codeLine">      Ext->setOperand(0, Current);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="codeLine">      Ext->insertBefore(IP);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">670</td>
    <td class="codeLine">      Ext->insertBefore(IP);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="codeLine">      Current = Ext;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">671</td>
    <td class="codeLine">      Current = Ext;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">672</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">673</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="codeLine">  return Current;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">674</td>
    <td class="codeLine">  return Current;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">675</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">676</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="codeLine">Value *ConstantOffsetExtractor::rebuildWithoutConstOffset() {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">677</td>
    <td class="codeLine">Value *ConstantOffsetExtractor::rebuildWithoutConstOffset() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="codeLine">  distributeExtsAndCloneChain(UserChain.size() - 1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">678</td>
    <td class="codeLine">  distributeExtsAndCloneChain(UserChain.size() - 1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="codeLine">  // Remove all nullptrs (used to be s/zext) from UserChain.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">679</td>
    <td class="codeLine">  // Remove all nullptrs (used to be s/zext) from UserChain.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="codeLine">  unsigned NewSize = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">680</td>
    <td class="codeLine">  unsigned NewSize = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="codeLine">  for (User *I : UserChain) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">681</td>
    <td class="codeLine">  for (User *I : UserChain) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="codeLine">    if (I != nullptr) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">682</td>
    <td class="codeLine">    if (I != nullptr) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class="codeLine">      UserChain[NewSize] = I;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">683</td>
    <td class="codeLine">      UserChain[NewSize] = I;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="codeLine">      NewSize++;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">684</td>
    <td class="codeLine">      NewSize++;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">685</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">686</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="codeLine">  UserChain.resize(NewSize);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">687</td>
    <td class="codeLine">  UserChain.resize(NewSize);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class="codeLine">  return removeConstOffset(UserChain.size() - 1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">688</td>
    <td class="codeLine">  return removeConstOffset(UserChain.size() - 1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">689</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">690</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class="codeLine">Value *</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">691</td>
    <td class="codeLine">Value *</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="codeLine">ConstantOffsetExtractor::distributeExtsAndCloneChain(unsigned ChainIndex) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">692</td>
    <td class="codeLine">ConstantOffsetExtractor::distributeExtsAndCloneChain(unsigned ChainIndex) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class="codeLine">  User *U = UserChain[ChainIndex];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">693</td>
    <td class="codeLine">  User *U = UserChain[ChainIndex];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class="codeLine">  if (ChainIndex == 0) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">694</td>
    <td class="codeLine">  if (ChainIndex == 0) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="codeLine">    assert(isa<ConstantInt>(U));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">695</td>
    <td class="codeLine">    assert(isa<ConstantInt>(U));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="codeLine">    // If U is a ConstantInt, applyExts will return a ConstantInt as well.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">696</td>
    <td class="codeLine">    // If U is a ConstantInt, applyExts will return a ConstantInt as well.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class="codeLine">    return UserChain[ChainIndex] = cast<ConstantInt>(applyExts(U));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">697</td>
    <td class="codeLine">    return UserChain[ChainIndex] = cast<ConstantInt>(applyExts(U));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">698</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">699</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="codeLine">  if (CastInst *Cast = dyn_cast<CastInst>(U)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">700</td>
    <td class="codeLine">  if (CastInst *Cast = dyn_cast<CastInst>(U)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="codeLine">    assert(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">701</td>
    <td class="codeLine">    assert(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class="codeLine">        (isa<SExtInst>(Cast) || isa<ZExtInst>(Cast) || isa<TruncInst>(Cast)) &&</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">702</td>
    <td class="codeLine">        (isa<SExtInst>(Cast) || isa<ZExtInst>(Cast) || isa<TruncInst>(Cast)) &&</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="codeLine">        "Only following instructions can be traced: sext, zext & trunc");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">703</td>
    <td class="codeLine">        "Only following instructions can be traced: sext, zext & trunc");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class="codeLine">    ExtInsts.push_back(Cast);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">704</td>
    <td class="codeLine">    ExtInsts.push_back(Cast);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="codeLine">    UserChain[ChainIndex] = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">705</td>
    <td class="codeLine">    UserChain[ChainIndex] = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class="codeLine">    return distributeExtsAndCloneChain(ChainIndex - 1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">706</td>
    <td class="codeLine">    return distributeExtsAndCloneChain(ChainIndex - 1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">707</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">708</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class="codeLine">  // Function find only trace into BinaryOperator and CastInst.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">709</td>
    <td class="codeLine">  // Function find only trace into BinaryOperator and CastInst.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="codeLine">  BinaryOperator *BO = cast<BinaryOperator>(U);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">710</td>
    <td class="codeLine">  BinaryOperator *BO = cast<BinaryOperator>(U);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class="codeLine">  // OpNo = which operand of BO is UserChain[ChainIndex - 1]</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">711</td>
    <td class="codeLine">  // OpNo = which operand of BO is UserChain[ChainIndex - 1]</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class="codeLine">  unsigned OpNo = (BO->getOperand(0) == UserChain[ChainIndex - 1] ? 0 : 1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">712</td>
    <td class="codeLine">  unsigned OpNo = (BO->getOperand(0) == UserChain[ChainIndex - 1] ? 0 : 1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="codeLine">  Value *TheOther = applyExts(BO->getOperand(1 - OpNo));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">713</td>
    <td class="codeLine">  Value *TheOther = applyExts(BO->getOperand(1 - OpNo));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="codeLine">  Value *NextInChain = distributeExtsAndCloneChain(ChainIndex - 1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">714</td>
    <td class="codeLine">  Value *NextInChain = distributeExtsAndCloneChain(ChainIndex - 1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">715</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="codeLine">  BinaryOperator *NewBO = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">716</td>
    <td class="codeLine">  BinaryOperator *NewBO = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class="codeLine">  if (OpNo == 0) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">717</td>
    <td class="codeLine">  if (OpNo == 0) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class="codeLine">    NewBO = BinaryOperator::Create(BO->getOpcode(), NextInChain, TheOther,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">718</td>
    <td class="codeLine">    NewBO = BinaryOperator::Create(BO->getOpcode(), NextInChain, TheOther,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class="codeLine">                                   BO->getName(), IP);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">719</td>
    <td class="codeLine">                                   BO->getName(), IP);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">720</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="codeLine">    NewBO = BinaryOperator::Create(BO->getOpcode(), TheOther, NextInChain,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">721</td>
    <td class="codeLine">    NewBO = BinaryOperator::Create(BO->getOpcode(), TheOther, NextInChain,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class="codeLine">                                   BO->getName(), IP);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">722</td>
    <td class="codeLine">                                   BO->getName(), IP);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">723</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class="codeLine">  return UserChain[ChainIndex] = NewBO;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">724</td>
    <td class="codeLine">  return UserChain[ChainIndex] = NewBO;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">725</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">726</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class="codeLine">Value *ConstantOffsetExtractor::removeConstOffset(unsigned ChainIndex) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">727</td>
    <td class="codeLine">Value *ConstantOffsetExtractor::removeConstOffset(unsigned ChainIndex) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class="codeLine">  if (ChainIndex == 0) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">728</td>
    <td class="codeLine">  if (ChainIndex == 0) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="codeLine">    assert(isa<ConstantInt>(UserChain[ChainIndex]));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">729</td>
    <td class="codeLine">    assert(isa<ConstantInt>(UserChain[ChainIndex]));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class="codeLine">    return ConstantInt::getNullValue(UserChain[ChainIndex]->getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">730</td>
    <td class="codeLine">    return ConstantInt::getNullValue(UserChain[ChainIndex]->getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">731</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">732</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="codeLine">  BinaryOperator *BO = cast<BinaryOperator>(UserChain[ChainIndex]);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">733</td>
    <td class="codeLine">  BinaryOperator *BO = cast<BinaryOperator>(UserChain[ChainIndex]);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="codeLine">  assert((BO->use_empty() || BO->hasOneUse()) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">734</td>
    <td class="codeLine">  assert((BO->use_empty() || BO->hasOneUse()) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class="codeLine">         "distributeExtsAndCloneChain clones each BinaryOperator in "</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">735</td>
    <td class="codeLine">         "distributeExtsAndCloneChain clones each BinaryOperator in "</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class="codeLine">         "UserChain, so no one should be used more than "</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">736</td>
    <td class="codeLine">         "UserChain, so no one should be used more than "</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class="codeLine">         "once");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">737</td>
    <td class="codeLine">         "once");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">738</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class="codeLine">  unsigned OpNo = (BO->getOperand(0) == UserChain[ChainIndex - 1] ? 0 : 1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">739</td>
    <td class="codeLine">  unsigned OpNo = (BO->getOperand(0) == UserChain[ChainIndex - 1] ? 0 : 1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="codeLine">  assert(BO->getOperand(OpNo) == UserChain[ChainIndex - 1]);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">740</td>
    <td class="codeLine">  assert(BO->getOperand(OpNo) == UserChain[ChainIndex - 1]);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class="codeLine">  Value *NextInChain = removeConstOffset(ChainIndex - 1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">741</td>
    <td class="codeLine">  Value *NextInChain = removeConstOffset(ChainIndex - 1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class="codeLine">  Value *TheOther = BO->getOperand(1 - OpNo);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">742</td>
    <td class="codeLine">  Value *TheOther = BO->getOperand(1 - OpNo);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">743</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="codeLine">  // If NextInChain is 0 and not the LHS of a sub, we can simplify the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">744</td>
    <td class="codeLine">  // If NextInChain is 0 and not the LHS of a sub, we can simplify the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="codeLine">  // sub-expression to be just TheOther.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">745</td>
    <td class="codeLine">  // sub-expression to be just TheOther.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class="codeLine">  if (ConstantInt *CI = dyn_cast<ConstantInt>(NextInChain)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">746</td>
    <td class="codeLine">  if (ConstantInt *CI = dyn_cast<ConstantInt>(NextInChain)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class="codeLine">    if (CI->isZero() && !(BO->getOpcode() == Instruction::Sub && OpNo == 0))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">747</td>
    <td class="codeLine">    if (CI->isZero() && !(BO->getOpcode() == Instruction::Sub && OpNo == 0))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="codeLine">      return TheOther;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">748</td>
    <td class="codeLine">      return TheOther;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">749</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">750</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class="codeLine">  BinaryOperator::BinaryOps NewOp = BO->getOpcode();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">751</td>
    <td class="codeLine">  BinaryOperator::BinaryOps NewOp = BO->getOpcode();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class="codeLine">  if (BO->getOpcode() == Instruction::Or) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">752</td>
    <td class="codeLine">  if (BO->getOpcode() == Instruction::Or) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class="codeLine">    // Rebuild "or" as "add", because "or" may be invalid for the new</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">753</td>
    <td class="codeLine">    // Rebuild "or" as "add", because "or" may be invalid for the new</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class="codeLine">    // expression.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">754</td>
    <td class="codeLine">    // expression.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">755</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="codeLine">    // For instance, given</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">756</td>
    <td class="codeLine">    // For instance, given</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="codeLine">    //   a | (b + 5) where a and b + 5 have no common bits,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">757</td>
    <td class="codeLine">    //   a | (b + 5) where a and b + 5 have no common bits,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="codeLine">    // we can extract 5 as the constant offset.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">758</td>
    <td class="codeLine">    // we can extract 5 as the constant offset.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">759</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class="codeLine">    // However, reusing the "or" in the new index would give us</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">760</td>
    <td class="codeLine">    // However, reusing the "or" in the new index would give us</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class="codeLine">    //   (a | b) + 5</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">761</td>
    <td class="codeLine">    //   (a | b) + 5</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class="codeLine">    // which does not equal a | (b + 5).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">762</td>
    <td class="codeLine">    // which does not equal a | (b + 5).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">763</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class="codeLine">    // Replacing the "or" with "add" is fine, because</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">764</td>
    <td class="codeLine">    // Replacing the "or" with "add" is fine, because</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class="codeLine">    //   a | (b + 5) = a + (b + 5) = (a + b) + 5</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">765</td>
    <td class="codeLine">    //   a | (b + 5) = a + (b + 5) = (a + b) + 5</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class="codeLine">    NewOp = Instruction::Add;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">766</td>
    <td class="codeLine">    NewOp = Instruction::Add;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">767</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">768</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="codeLine">  BinaryOperator *NewBO;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">769</td>
    <td class="codeLine">  BinaryOperator *NewBO;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="codeLine">  if (OpNo == 0) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">770</td>
    <td class="codeLine">  if (OpNo == 0) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class="codeLine">    NewBO = BinaryOperator::Create(NewOp, NextInChain, TheOther, "", IP);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">771</td>
    <td class="codeLine">    NewBO = BinaryOperator::Create(NewOp, NextInChain, TheOther, "", IP);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">772</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class="codeLine">    NewBO = BinaryOperator::Create(NewOp, TheOther, NextInChain, "", IP);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">773</td>
    <td class="codeLine">    NewBO = BinaryOperator::Create(NewOp, TheOther, NextInChain, "", IP);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">774</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class="codeLine">  NewBO->takeName(BO);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">775</td>
    <td class="codeLine">  NewBO->takeName(BO);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class="codeLine">  return NewBO;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">776</td>
    <td class="codeLine">  return NewBO;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">777</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">778</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="codeLine">Value *ConstantOffsetExtractor::Extract(Value *Idx, GetElementPtrInst *GEP,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">779</td>
    <td class="codeLine">Value *ConstantOffsetExtractor::Extract(Value *Idx, GetElementPtrInst *GEP,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class="codeLine">                                        User *&UserChainTail,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">780</td>
    <td class="codeLine">                                        User *&UserChainTail,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class="codeLine">                                        const DominatorTree *DT) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">781</td>
    <td class="codeLine">                                        const DominatorTree *DT) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="codeLine">  ConstantOffsetExtractor Extractor(GEP, DT);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">782</td>
    <td class="codeLine">  ConstantOffsetExtractor Extractor(GEP, DT);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="codeLine">  // Find a non-zero constant offset first.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">783</td>
    <td class="codeLine">  // Find a non-zero constant offset first.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class="codeLine">  APInt ConstantOffset =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">784</td>
    <td class="codeLine">  APInt ConstantOffset =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class="codeLine">      Extractor.find(Idx, /* SignExtended */ false, /* ZeroExtended */ false,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">785</td>
    <td class="codeLine">      Extractor.find(Idx, /* SignExtended */ false, /* ZeroExtended */ false,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class="codeLine">                     GEP->isInBounds());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">786</td>
    <td class="codeLine">                     GEP->isInBounds());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class="codeLine">  if (ConstantOffset == 0) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">787</td>
    <td class="codeLine">  if (ConstantOffset == 0) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="codeLine">    UserChainTail = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">788</td>
    <td class="codeLine">    UserChainTail = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">789</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">790</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class="codeLine">  // Separates the constant offset from the GEP index.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">791</td>
    <td class="codeLine">  // Separates the constant offset from the GEP index.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class="codeLine">  Value *IdxWithoutConstOffset = Extractor.rebuildWithoutConstOffset();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">792</td>
    <td class="codeLine">  Value *IdxWithoutConstOffset = Extractor.rebuildWithoutConstOffset();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="codeLine">  UserChainTail = Extractor.UserChain.back();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">793</td>
    <td class="codeLine">  UserChainTail = Extractor.UserChain.back();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class="codeLine">  return IdxWithoutConstOffset;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">794</td>
    <td class="codeLine">  return IdxWithoutConstOffset;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">795</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">796</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class="codeLine">int64_t ConstantOffsetExtractor::Find(Value *Idx, GetElementPtrInst *GEP,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">797</td>
    <td class="codeLine">int64_t ConstantOffsetExtractor::Find(Value *Idx, GetElementPtrInst *GEP,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class="codeLine">                                      const DominatorTree *DT) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">798</td>
    <td class="codeLine">                                      const DominatorTree *DT) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class="codeLine">  // If Idx is an index of an inbound GEP, Idx is guaranteed to be non-negative.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">799</td>
    <td class="codeLine">  // If Idx is an index of an inbound GEP, Idx is guaranteed to be non-negative.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class="codeLine">  return ConstantOffsetExtractor(GEP, DT)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">800</td>
    <td class="codeLine">  return ConstantOffsetExtractor(GEP, DT)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class="codeLine">      .find(Idx, /* SignExtended */ false, /* ZeroExtended */ false,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">801</td>
    <td class="codeLine">      .find(Idx, /* SignExtended */ false, /* ZeroExtended */ false,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class="codeLine">            GEP->isInBounds())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">802</td>
    <td class="codeLine">            GEP->isInBounds())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class="codeLine">      .getSExtValue();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">803</td>
    <td class="codeLine">      .getSExtValue();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">804</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">805</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class="codeLine">bool SeparateConstOffsetFromGEP::canonicalizeArrayIndicesToIndexSize(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">806</td>
    <td class="codeLine">bool SeparateConstOffsetFromGEP::canonicalizeArrayIndicesToIndexSize(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class="codeLine">    GetElementPtrInst *GEP) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">807</td>
    <td class="codeLine">    GetElementPtrInst *GEP) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class="codeLine">  bool Changed = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">808</td>
    <td class="codeLine">  bool Changed = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class="codeLine">  Type *PtrIdxTy = DL->getIndexType(GEP->getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">809</td>
    <td class="codeLine">  Type *PtrIdxTy = DL->getIndexType(GEP->getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class="codeLine">  gep_type_iterator GTI = gep_type_begin(*GEP);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">810</td>
    <td class="codeLine">  gep_type_iterator GTI = gep_type_begin(*GEP);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class="codeLine">  for (User::op_iterator I = GEP->op_begin() + 1, E = GEP->op_end();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">811</td>
    <td class="codeLine">  for (User::op_iterator I = GEP->op_begin() + 1, E = GEP->op_end();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class="codeLine">       I != E; ++I, ++GTI) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">812</td>
    <td class="codeLine">       I != E; ++I, ++GTI) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class="codeLine">    // Skip struct member indices which must be i32.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">813</td>
    <td class="codeLine">    // Skip struct member indices which must be i32.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class="codeLine">    if (GTI.isSequential()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">814</td>
    <td class="codeLine">    if (GTI.isSequential()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class="codeLine">      if ((*I)->getType() != PtrIdxTy) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">815</td>
    <td class="codeLine">      if ((*I)->getType() != PtrIdxTy) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class="codeLine">        *I = CastInst::CreateIntegerCast(*I, PtrIdxTy, true, "idxprom", GEP);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">816</td>
    <td class="codeLine">        *I = CastInst::CreateIntegerCast(*I, PtrIdxTy, true, "idxprom", GEP);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class="codeLine">        Changed = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">817</td>
    <td class="codeLine">        Changed = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">818</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">819</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">820</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class="codeLine">  return Changed;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">821</td>
    <td class="codeLine">  return Changed;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">822</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">823</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class="codeLine">int64_t</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">824</td>
    <td class="codeLine">int64_t</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class="codeLine">SeparateConstOffsetFromGEP::accumulateByteOffset(GetElementPtrInst *GEP,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">825</td>
    <td class="codeLine">SeparateConstOffsetFromGEP::accumulateByteOffset(GetElementPtrInst *GEP,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class="codeLine">                                                 bool &NeedsExtraction) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">826</td>
    <td class="codeLine">                                                 bool &NeedsExtraction) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class="codeLine">  NeedsExtraction = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">827</td>
    <td class="codeLine">  NeedsExtraction = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class="codeLine">  int64_t AccumulativeByteOffset = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">828</td>
    <td class="codeLine">  int64_t AccumulativeByteOffset = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class="codeLine">  gep_type_iterator GTI = gep_type_begin(*GEP);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">829</td>
    <td class="codeLine">  gep_type_iterator GTI = gep_type_begin(*GEP);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class="codeLine">  for (unsigned I = 1, E = GEP->getNumOperands(); I != E; ++I, ++GTI) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">830</td>
    <td class="codeLine">  for (unsigned I = 1, E = GEP->getNumOperands(); I != E; ++I, ++GTI) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class="codeLine">    if (GTI.isSequential()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">831</td>
    <td class="codeLine">    if (GTI.isSequential()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class="codeLine">      // Constant offsets of scalable types are not really constant.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">832</td>
    <td class="codeLine">      // Constant offsets of scalable types are not really constant.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class="codeLine">      if (isa<ScalableVectorType>(GTI.getIndexedType()))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">833</td>
    <td class="codeLine">      if (isa<ScalableVectorType>(GTI.getIndexedType()))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">834</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">835</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class="codeLine">      // Tries to extract a constant offset from this GEP index.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">836</td>
    <td class="codeLine">      // Tries to extract a constant offset from this GEP index.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class="codeLine">      int64_t ConstantOffset =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">837</td>
    <td class="codeLine">      int64_t ConstantOffset =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class="codeLine">          ConstantOffsetExtractor::Find(GEP->getOperand(I), GEP, DT);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">838</td>
    <td class="codeLine">          ConstantOffsetExtractor::Find(GEP->getOperand(I), GEP, DT);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class="codeLine">      if (ConstantOffset != 0) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">839</td>
    <td class="codeLine">      if (ConstantOffset != 0) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class="codeLine">        NeedsExtraction = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">840</td>
    <td class="codeLine">        NeedsExtraction = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class="codeLine">        // A GEP may have multiple indices.  We accumulate the extracted</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">841</td>
    <td class="codeLine">        // A GEP may have multiple indices.  We accumulate the extracted</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class="codeLine">        // constant offset to a byte offset, and later offset the remainder of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">842</td>
    <td class="codeLine">        // constant offset to a byte offset, and later offset the remainder of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class="codeLine">        // the original GEP with this byte offset.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">843</td>
    <td class="codeLine">        // the original GEP with this byte offset.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class="codeLine">        AccumulativeByteOffset +=</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">844</td>
    <td class="codeLine">        AccumulativeByteOffset +=</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class="codeLine">            ConstantOffset * DL->getTypeAllocSize(GTI.getIndexedType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">845</td>
    <td class="codeLine">            ConstantOffset * DL->getTypeAllocSize(GTI.getIndexedType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">846</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class="codeLine">    } else if (LowerGEP) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">847</td>
    <td class="codeLine">    } else if (LowerGEP) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class="codeLine">      StructType *StTy = GTI.getStructType();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">848</td>
    <td class="codeLine">      StructType *StTy = GTI.getStructType();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class="codeLine">      uint64_t Field = cast<ConstantInt>(GEP->getOperand(I))->getZExtValue();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">849</td>
    <td class="codeLine">      uint64_t Field = cast<ConstantInt>(GEP->getOperand(I))->getZExtValue();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class="codeLine">      // Skip field 0 as the offset is always 0.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">850</td>
    <td class="codeLine">      // Skip field 0 as the offset is always 0.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class="codeLine">      if (Field != 0) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">851</td>
    <td class="codeLine">      if (Field != 0) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class="codeLine">        NeedsExtraction = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">852</td>
    <td class="codeLine">        NeedsExtraction = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class="codeLine">        AccumulativeByteOffset +=</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">853</td>
    <td class="codeLine">        AccumulativeByteOffset +=</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class="codeLine">            DL->getStructLayout(StTy)->getElementOffset(Field);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">854</td>
    <td class="codeLine">            DL->getStructLayout(StTy)->getElementOffset(Field);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">855</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">856</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">857</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class="codeLine">  return AccumulativeByteOffset;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">858</td>
    <td class="codeLine">  return AccumulativeByteOffset;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">859</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">860</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class="codeLine">void SeparateConstOffsetFromGEP::lowerToSingleIndexGEPs(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">861</td>
    <td class="codeLine">void SeparateConstOffsetFromGEP::lowerToSingleIndexGEPs(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class="codeLine">    GetElementPtrInst *Variadic, int64_t AccumulativeByteOffset) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">862</td>
    <td class="codeLine">    GetElementPtrInst *Variadic, int64_t AccumulativeByteOffset) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class="codeLine">  IRBuilder<> Builder(Variadic);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">863</td>
    <td class="codeLine">  IRBuilder<> Builder(Variadic);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class="codeLine">  Type *PtrIndexTy = DL->getIndexType(Variadic->getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">864</td>
    <td class="codeLine">  Type *PtrIndexTy = DL->getIndexType(Variadic->getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">865</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class="codeLine">  Value *ResultPtr = Variadic->getOperand(0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">866</td>
    <td class="codeLine">  Value *ResultPtr = Variadic->getOperand(0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class="codeLine">  Loop *L = LI->getLoopFor(Variadic->getParent());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">867</td>
    <td class="codeLine">  Loop *L = LI->getLoopFor(Variadic->getParent());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class="codeLine">  // Check if the base is not loop invariant or used more than once.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">868</td>
    <td class="codeLine">  // Check if the base is not loop invariant or used more than once.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class="codeLine">  bool isSwapCandidate =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">869</td>
    <td class="codeLine">  bool isSwapCandidate =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="codeLine">      L && L->isLoopInvariant(ResultPtr) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">870</td>
    <td class="codeLine">      L && L->isLoopInvariant(ResultPtr) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class="codeLine">      !hasMoreThanOneUseInLoop(ResultPtr, L);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">871</td>
    <td class="codeLine">      !hasMoreThanOneUseInLoop(ResultPtr, L);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">872</td>
    <td class="codeLine">  Value *FirstResult = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">872</td>
    <td class="codeLine">  Value *FirstResult = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">873</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">873</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">874</td>
    <td class="codeLine">  gep_type_iterator GTI = gep_type_begin(*Variadic);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">874</td>
    <td class="codeLine">  gep_type_iterator GTI = gep_type_begin(*Variadic);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">875</td>
    <td class="codeLine">  // Create an ugly GEP for each sequential index. We don't create GEPs for</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">875</td>
    <td class="codeLine">  // Create an ugly GEP for each sequential index. We don't create GEPs for</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">876</td>
    <td class="codeLine">  // structure indices, as they are accumulated in the constant offset index.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">876</td>
    <td class="codeLine">  // structure indices, as they are accumulated in the constant offset index.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">877</td>
    <td class="codeLine">  for (unsigned I = 1, E = Variadic->getNumOperands(); I != E; ++I, ++GTI) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">877</td>
    <td class="codeLine">  for (unsigned I = 1, E = Variadic->getNumOperands(); I != E; ++I, ++GTI) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">878</td>
    <td class="codeLine">    if (GTI.isSequential()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">878</td>
    <td class="codeLine">    if (GTI.isSequential()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">879</td>
    <td class="codeLine">      Value *Idx = Variadic->getOperand(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">879</td>
    <td class="codeLine">      Value *Idx = Variadic->getOperand(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">880</td>
    <td class="codeLine">      // Skip zero indices.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">880</td>
    <td class="codeLine">      // Skip zero indices.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">881</td>
    <td class="codeLine">      if (ConstantInt *CI = dyn_cast<ConstantInt>(Idx))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">881</td>
    <td class="codeLine">      if (ConstantInt *CI = dyn_cast<ConstantInt>(Idx))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">882</td>
    <td class="codeLine">        if (CI->isZero())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">882</td>
    <td class="codeLine">        if (CI->isZero())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">883</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">883</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">884</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">884</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">885</td>
    <td class="codeLine">      APInt ElementSize = APInt(PtrIndexTy->getIntegerBitWidth(),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">885</td>
    <td class="codeLine">      APInt ElementSize = APInt(PtrIndexTy->getIntegerBitWidth(),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">886</td>
    <td class="codeLine">                                DL->getTypeAllocSize(GTI.getIndexedType()));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">886</td>
    <td class="codeLine">                                DL->getTypeAllocSize(GTI.getIndexedType()));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">887</td>
    <td class="codeLine">      // Scale the index by element size.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">887</td>
    <td class="codeLine">      // Scale the index by element size.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">888</td>
    <td class="codeLine">      if (ElementSize != 1) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">888</td>
    <td class="codeLine">      if (ElementSize != 1) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">889</td>
    <td class="codeLine">        if (ElementSize.isPowerOf2()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">889</td>
    <td class="codeLine">        if (ElementSize.isPowerOf2()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">890</td>
    <td class="codeLine">          Idx = Builder.CreateShl(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">890</td>
    <td class="codeLine">          Idx = Builder.CreateShl(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">891</td>
    <td class="codeLine">              Idx, ConstantInt::get(PtrIndexTy, ElementSize.logBase2()));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">891</td>
    <td class="codeLine">              Idx, ConstantInt::get(PtrIndexTy, ElementSize.logBase2()));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">892</td>
    <td class="codeLine">        } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">892</td>
    <td class="codeLine">        } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">893</td>
    <td class="codeLine">          Idx =</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">893</td>
    <td class="codeLine">          Idx =</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">894</td>
    <td class="codeLine">              Builder.CreateMul(Idx, ConstantInt::get(PtrIndexTy, ElementSize));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">894</td>
    <td class="codeLine">              Builder.CreateMul(Idx, ConstantInt::get(PtrIndexTy, ElementSize));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">895</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">895</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">896</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">896</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">897</td>
    <td class="codeLine">      // Create an ugly GEP with a single index for each index.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">897</td>
    <td class="codeLine">      // Create an ugly GEP with a single index for each index.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">898</td>
    <td class="codeLine">      ResultPtr =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">898</td>
    <td class="codeLine">      ResultPtr =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">899</td>
    <td class="codeLine">          Builder.CreateGEP(Builder.getInt8Ty(), ResultPtr, Idx, "uglygep");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">899</td>
    <td class="codeLine">          Builder.CreateGEP(Builder.getInt8Ty(), ResultPtr, Idx, "uglygep");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">900</td>
    <td class="codeLine">      if (FirstResult == nullptr)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">900</td>
    <td class="codeLine">      if (FirstResult == nullptr)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">901</td>
    <td class="codeLine">        FirstResult = ResultPtr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">901</td>
    <td class="codeLine">        FirstResult = ResultPtr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">902</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">902</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">903</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">903</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">904</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">904</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">905</td>
    <td class="codeLine">  // Create a GEP with the constant offset index.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">905</td>
    <td class="codeLine">  // Create a GEP with the constant offset index.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">906</td>
    <td class="codeLine">  if (AccumulativeByteOffset != 0) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">906</td>
    <td class="codeLine">  if (AccumulativeByteOffset != 0) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">907</td>
    <td class="codeLine">    Value *Offset = ConstantInt::get(PtrIndexTy, AccumulativeByteOffset);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">907</td>
    <td class="codeLine">    Value *Offset = ConstantInt::get(PtrIndexTy, AccumulativeByteOffset);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">908</td>
    <td class="codeLine">    ResultPtr =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">908</td>
    <td class="codeLine">    ResultPtr =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">909</td>
    <td class="codeLine">        Builder.CreateGEP(Builder.getInt8Ty(), ResultPtr, Offset, "uglygep");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">909</td>
    <td class="codeLine">        Builder.CreateGEP(Builder.getInt8Ty(), ResultPtr, Offset, "uglygep");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">910</td>
    <td class="codeLine">  } else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">910</td>
    <td class="codeLine">  } else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">911</td>
    <td class="codeLine">    isSwapCandidate = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">911</td>
    <td class="codeLine">    isSwapCandidate = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">912</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">912</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">913</td>
    <td class="codeLine">  // If we created a GEP with constant index, and the base is loop invariant,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">913</td>
    <td class="codeLine">  // If we created a GEP with constant index, and the base is loop invariant,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">914</td>
    <td class="codeLine">  // then we swap the first one with it, so LICM can move constant GEP out</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">914</td>
    <td class="codeLine">  // then we swap the first one with it, so LICM can move constant GEP out</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">915</td>
    <td class="codeLine">  // later.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">915</td>
    <td class="codeLine">  // later.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">916</td>
    <td class="codeLine">  auto *FirstGEP = dyn_cast_or_null<GetElementPtrInst>(FirstResult);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">916</td>
    <td class="codeLine">  auto *FirstGEP = dyn_cast_or_null<GetElementPtrInst>(FirstResult);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">917</td>
    <td class="codeLine">  auto *SecondGEP = dyn_cast<GetElementPtrInst>(ResultPtr);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">917</td>
    <td class="codeLine">  auto *SecondGEP = dyn_cast<GetElementPtrInst>(ResultPtr);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">918</td>
    <td class="codeLine">  if (isSwapCandidate && isLegalToSwapOperand(FirstGEP, SecondGEP, L))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">918</td>
    <td class="codeLine">  if (isSwapCandidate && isLegalToSwapOperand(FirstGEP, SecondGEP, L))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">919</td>
    <td class="codeLine">    swapGEPOperand(FirstGEP, SecondGEP);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">919</td>
    <td class="codeLine">    swapGEPOperand(FirstGEP, SecondGEP);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">920</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">920</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">921</td>
    <td class="codeLine">  Variadic->replaceAllUsesWith(ResultPtr);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">921</td>
    <td class="codeLine">  Variadic->replaceAllUsesWith(ResultPtr);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">922</td>
    <td class="codeLine">  Variadic->eraseFromParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">922</td>
    <td class="codeLine">  Variadic->eraseFromParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">923</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">923</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">924</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">924</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">925</td>
    <td class="codeLine">void</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">925</td>
    <td class="codeLine">void</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">926</td>
    <td class="codeLine">SeparateConstOffsetFromGEP::lowerToArithmetics(GetElementPtrInst *Variadic,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">926</td>
    <td class="codeLine">SeparateConstOffsetFromGEP::lowerToArithmetics(GetElementPtrInst *Variadic,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">927</td>
    <td class="codeLine">                                               int64_t AccumulativeByteOffset) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">927</td>
    <td class="codeLine">                                               int64_t AccumulativeByteOffset) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">928</td>
    <td class="codeLine">  IRBuilder<> Builder(Variadic);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">928</td>
    <td class="codeLine">  IRBuilder<> Builder(Variadic);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">929</td>
    <td class="codeLine">  Type *IntPtrTy = DL->getIntPtrType(Variadic->getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">929</td>
    <td class="codeLine">  Type *IntPtrTy = DL->getIntPtrType(Variadic->getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">930</td>
    <td class="codeLine">  assert(IntPtrTy == DL->getIndexType(Variadic->getType()) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">930</td>
    <td class="codeLine">  assert(IntPtrTy == DL->getIndexType(Variadic->getType()) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">931</td>
    <td class="codeLine">         "Pointer type must match index type for arithmetic-based lowering of "</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">931</td>
    <td class="codeLine">         "Pointer type must match index type for arithmetic-based lowering of "</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">932</td>
    <td class="codeLine">         "split GEPs");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">932</td>
    <td class="codeLine">         "split GEPs");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">933</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">933</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">934</td>
    <td class="codeLine">  Value *ResultPtr = Builder.CreatePtrToInt(Variadic->getOperand(0), IntPtrTy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">934</td>
    <td class="codeLine">  Value *ResultPtr = Builder.CreatePtrToInt(Variadic->getOperand(0), IntPtrTy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">935</td>
    <td class="codeLine">  gep_type_iterator GTI = gep_type_begin(*Variadic);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">935</td>
    <td class="codeLine">  gep_type_iterator GTI = gep_type_begin(*Variadic);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">936</td>
    <td class="codeLine">  // Create ADD/SHL/MUL arithmetic operations for each sequential indices. We</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">936</td>
    <td class="codeLine">  // Create ADD/SHL/MUL arithmetic operations for each sequential indices. We</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">937</td>
    <td class="codeLine">  // don't create arithmetics for structure indices, as they are accumulated</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">937</td>
    <td class="codeLine">  // don't create arithmetics for structure indices, as they are accumulated</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">938</td>
    <td class="codeLine">  // in the constant offset index.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">938</td>
    <td class="codeLine">  // in the constant offset index.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">939</td>
    <td class="codeLine">  for (unsigned I = 1, E = Variadic->getNumOperands(); I != E; ++I, ++GTI) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">939</td>
    <td class="codeLine">  for (unsigned I = 1, E = Variadic->getNumOperands(); I != E; ++I, ++GTI) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">940</td>
    <td class="codeLine">    if (GTI.isSequential()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">940</td>
    <td class="codeLine">    if (GTI.isSequential()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">941</td>
    <td class="codeLine">      Value *Idx = Variadic->getOperand(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">941</td>
    <td class="codeLine">      Value *Idx = Variadic->getOperand(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">942</td>
    <td class="codeLine">      // Skip zero indices.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">942</td>
    <td class="codeLine">      // Skip zero indices.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">943</td>
    <td class="codeLine">      if (ConstantInt *CI = dyn_cast<ConstantInt>(Idx))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">943</td>
    <td class="codeLine">      if (ConstantInt *CI = dyn_cast<ConstantInt>(Idx))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">944</td>
    <td class="codeLine">        if (CI->isZero())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">944</td>
    <td class="codeLine">        if (CI->isZero())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">945</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">945</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">946</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">946</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">947</td>
    <td class="codeLine">      APInt ElementSize = APInt(IntPtrTy->getIntegerBitWidth(),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">947</td>
    <td class="codeLine">      APInt ElementSize = APInt(IntPtrTy->getIntegerBitWidth(),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">948</td>
    <td class="codeLine">                                DL->getTypeAllocSize(GTI.getIndexedType()));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">948</td>
    <td class="codeLine">                                DL->getTypeAllocSize(GTI.getIndexedType()));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">949</td>
    <td class="codeLine">      // Scale the index by element size.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">949</td>
    <td class="codeLine">      // Scale the index by element size.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">950</td>
    <td class="codeLine">      if (ElementSize != 1) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">950</td>
    <td class="codeLine">      if (ElementSize != 1) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">951</td>
    <td class="codeLine">        if (ElementSize.isPowerOf2()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">951</td>
    <td class="codeLine">        if (ElementSize.isPowerOf2()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">952</td>
    <td class="codeLine">          Idx = Builder.CreateShl(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">952</td>
    <td class="codeLine">          Idx = Builder.CreateShl(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">953</td>
    <td class="codeLine">              Idx, ConstantInt::get(IntPtrTy, ElementSize.logBase2()));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">953</td>
    <td class="codeLine">              Idx, ConstantInt::get(IntPtrTy, ElementSize.logBase2()));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">954</td>
    <td class="codeLine">        } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">954</td>
    <td class="codeLine">        } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">955</td>
    <td class="codeLine">          Idx = Builder.CreateMul(Idx, ConstantInt::get(IntPtrTy, ElementSize));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">955</td>
    <td class="codeLine">          Idx = Builder.CreateMul(Idx, ConstantInt::get(IntPtrTy, ElementSize));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">956</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">956</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">957</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">957</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">958</td>
    <td class="codeLine">      // Create an ADD for each index.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">958</td>
    <td class="codeLine">      // Create an ADD for each index.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">959</td>
    <td class="codeLine">      ResultPtr = Builder.CreateAdd(ResultPtr, Idx);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">959</td>
    <td class="codeLine">      ResultPtr = Builder.CreateAdd(ResultPtr, Idx);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">960</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">960</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">961</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">961</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">962</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">962</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">963</td>
    <td class="codeLine">  // Create an ADD for the constant offset index.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">963</td>
    <td class="codeLine">  // Create an ADD for the constant offset index.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">964</td>
    <td class="codeLine">  if (AccumulativeByteOffset != 0) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">964</td>
    <td class="codeLine">  if (AccumulativeByteOffset != 0) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">965</td>
    <td class="codeLine">    ResultPtr = Builder.CreateAdd(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">965</td>
    <td class="codeLine">    ResultPtr = Builder.CreateAdd(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">966</td>
    <td class="codeLine">        ResultPtr, ConstantInt::get(IntPtrTy, AccumulativeByteOffset));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">966</td>
    <td class="codeLine">        ResultPtr, ConstantInt::get(IntPtrTy, AccumulativeByteOffset));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">967</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">967</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">968</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">968</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">969</td>
    <td class="codeLine">  ResultPtr = Builder.CreateIntToPtr(ResultPtr, Variadic->getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">969</td>
    <td class="codeLine">  ResultPtr = Builder.CreateIntToPtr(ResultPtr, Variadic->getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">970</td>
    <td class="codeLine">  Variadic->replaceAllUsesWith(ResultPtr);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">970</td>
    <td class="codeLine">  Variadic->replaceAllUsesWith(ResultPtr);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">971</td>
    <td class="codeLine">  Variadic->eraseFromParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">971</td>
    <td class="codeLine">  Variadic->eraseFromParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">972</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">972</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">973</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">973</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">974</td>
    <td class="codeLine">bool SeparateConstOffsetFromGEP::splitGEP(GetElementPtrInst *GEP) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">974</td>
    <td class="codeLine">bool SeparateConstOffsetFromGEP::splitGEP(GetElementPtrInst *GEP) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">975</td>
    <td class="codeLine">  // Skip vector GEPs.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">975</td>
    <td class="codeLine">  // Skip vector GEPs.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">976</td>
    <td class="codeLine">  if (GEP->getType()->isVectorTy())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">976</td>
    <td class="codeLine">  if (GEP->getType()->isVectorTy())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">977</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">977</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">978</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">978</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">979</td>
    <td class="codeLine">  // The backend can already nicely handle the case where all indices are</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">979</td>
    <td class="codeLine">  // The backend can already nicely handle the case where all indices are</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">980</td>
    <td class="codeLine">  // constant.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">980</td>
    <td class="codeLine">  // constant.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">981</td>
    <td class="codeLine">  if (GEP->hasAllConstantIndices())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">981</td>
    <td class="codeLine">  if (GEP->hasAllConstantIndices())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">982</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">982</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">983</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">983</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">984</td>
    <td class="codeLine">  bool Changed = canonicalizeArrayIndicesToIndexSize(GEP);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">984</td>
    <td class="codeLine">  bool Changed = canonicalizeArrayIndicesToIndexSize(GEP);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">985</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">985</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">986</td>
    <td class="codeLine">  bool NeedsExtraction;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">986</td>
    <td class="codeLine">  bool NeedsExtraction;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">987</td>
    <td class="codeLine">  int64_t AccumulativeByteOffset = accumulateByteOffset(GEP, NeedsExtraction);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">987</td>
    <td class="codeLine">  int64_t AccumulativeByteOffset = accumulateByteOffset(GEP, NeedsExtraction);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">988</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">988</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">989</td>
    <td class="codeLine">  if (!NeedsExtraction)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">989</td>
    <td class="codeLine">  if (!NeedsExtraction)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">990</td>
    <td class="codeLine">    return Changed;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">990</td>
    <td class="codeLine">    return Changed;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">991</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">991</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">992</td>
    <td class="codeLine">  TargetTransformInfo &TTI = GetTTI(*GEP->getFunction());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">992</td>
    <td class="codeLine">  TargetTransformInfo &TTI = GetTTI(*GEP->getFunction());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">993</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">993</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">994</td>
    <td class="codeLine">  // If LowerGEP is disabled, before really splitting the GEP, check whether the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">994</td>
    <td class="codeLine">  // If LowerGEP is disabled, before really splitting the GEP, check whether the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">995</td>
    <td class="codeLine">  // backend supports the addressing mode we are about to produce. If no, this</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">995</td>
    <td class="codeLine">  // backend supports the addressing mode we are about to produce. If no, this</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">996</td>
    <td class="codeLine">  // splitting probably won't be beneficial.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">996</td>
    <td class="codeLine">  // splitting probably won't be beneficial.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">997</td>
    <td class="codeLine">  // If LowerGEP is enabled, even the extracted constant offset can not match</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">997</td>
    <td class="codeLine">  // If LowerGEP is enabled, even the extracted constant offset can not match</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">998</td>
    <td class="codeLine">  // the addressing mode, we can still do optimizations to other lowered parts</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">998</td>
    <td class="codeLine">  // the addressing mode, we can still do optimizations to other lowered parts</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">999</td>
    <td class="codeLine">  // of variable indices. Therefore, we don't check for addressing modes in that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">999</td>
    <td class="codeLine">  // of variable indices. Therefore, we don't check for addressing modes in that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1000</td>
    <td class="codeLine">  // case.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1000</td>
    <td class="codeLine">  // case.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1001</td>
    <td class="codeLine">  if (!LowerGEP) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1001</td>
    <td class="codeLine">  if (!LowerGEP) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1002</td>
    <td class="codeLine">    unsigned AddrSpace = GEP->getPointerAddressSpace();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1002</td>
    <td class="codeLine">    unsigned AddrSpace = GEP->getPointerAddressSpace();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1003</td>
    <td class="codeLine">    if (!TTI.isLegalAddressingMode(GEP->getResultElementType(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1003</td>
    <td class="codeLine">    if (!TTI.isLegalAddressingMode(GEP->getResultElementType(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1004</td>
    <td class="codeLine">                                   /*BaseGV=*/nullptr, AccumulativeByteOffset,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1004</td>
    <td class="codeLine">                                   /*BaseGV=*/nullptr, AccumulativeByteOffset,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1005</td>
    <td class="codeLine">                                   /*HasBaseReg=*/true, /*Scale=*/0,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1005</td>
    <td class="codeLine">                                   /*HasBaseReg=*/true, /*Scale=*/0,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1006</td>
    <td class="codeLine">                                   AddrSpace)) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1006</td>
    <td class="codeLine">                                   AddrSpace)) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1007</td>
    <td class="codeLine">      return Changed;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1007</td>
    <td class="codeLine">      return Changed;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1008</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1008</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1009</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1009</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1010</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1010</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1011</td>
    <td class="codeLine">  // Remove the constant offset in each sequential index. The resultant GEP</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1011</td>
    <td class="codeLine">  // Remove the constant offset in each sequential index. The resultant GEP</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1012</td>
    <td class="codeLine">  // computes the variadic base.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1012</td>
    <td class="codeLine">  // computes the variadic base.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1013</td>
    <td class="codeLine">  // Notice that we don't remove struct field indices here. If LowerGEP is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1013</td>
    <td class="codeLine">  // Notice that we don't remove struct field indices here. If LowerGEP is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1014</td>
    <td class="codeLine">  // disabled, a structure index is not accumulated and we still use the old</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1014</td>
    <td class="codeLine">  // disabled, a structure index is not accumulated and we still use the old</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1015</td>
    <td class="codeLine">  // one. If LowerGEP is enabled, a structure index is accumulated in the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1015</td>
    <td class="codeLine">  // one. If LowerGEP is enabled, a structure index is accumulated in the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1016</td>
    <td class="codeLine">  // constant offset. LowerToSingleIndexGEPs or lowerToArithmetics will later</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1016</td>
    <td class="codeLine">  // constant offset. LowerToSingleIndexGEPs or lowerToArithmetics will later</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1017</td>
    <td class="codeLine">  // handle the constant offset and won't need a new structure index.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1017</td>
    <td class="codeLine">  // handle the constant offset and won't need a new structure index.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1018</td>
    <td class="codeLine">  gep_type_iterator GTI = gep_type_begin(*GEP);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1018</td>
    <td class="codeLine">  gep_type_iterator GTI = gep_type_begin(*GEP);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1019</td>
    <td class="codeLine">  for (unsigned I = 1, E = GEP->getNumOperands(); I != E; ++I, ++GTI) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1019</td>
    <td class="codeLine">  for (unsigned I = 1, E = GEP->getNumOperands(); I != E; ++I, ++GTI) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1020</td>
    <td class="codeLine">    if (GTI.isSequential()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1020</td>
    <td class="codeLine">    if (GTI.isSequential()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1021</td>
    <td class="codeLine">      // Constant offsets of scalable types are not really constant.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1021</td>
    <td class="codeLine">      // Constant offsets of scalable types are not really constant.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1022</td>
    <td class="codeLine">      if (isa<ScalableVectorType>(GTI.getIndexedType()))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1022</td>
    <td class="codeLine">      if (isa<ScalableVectorType>(GTI.getIndexedType()))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1023</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1023</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1024</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1024</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1025</td>
    <td class="codeLine">      // Splits this GEP index into a variadic part and a constant offset, and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1025</td>
    <td class="codeLine">      // Splits this GEP index into a variadic part and a constant offset, and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1026</td>
    <td class="codeLine">      // uses the variadic part as the new index.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1026</td>
    <td class="codeLine">      // uses the variadic part as the new index.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1027</td>
    <td class="codeLine">      Value *OldIdx = GEP->getOperand(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1027</td>
    <td class="codeLine">      Value *OldIdx = GEP->getOperand(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1028</td>
    <td class="codeLine">      User *UserChainTail;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1028</td>
    <td class="codeLine">      User *UserChainTail;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1029</td>
    <td class="codeLine">      Value *NewIdx =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1029</td>
    <td class="codeLine">      Value *NewIdx =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1030</td>
    <td class="codeLine">          ConstantOffsetExtractor::Extract(OldIdx, GEP, UserChainTail, DT);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1030</td>
    <td class="codeLine">          ConstantOffsetExtractor::Extract(OldIdx, GEP, UserChainTail, DT);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1031</td>
    <td class="codeLine">      if (NewIdx != nullptr) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1031</td>
    <td class="codeLine">      if (NewIdx != nullptr) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1032</td>
    <td class="codeLine">        // Switches to the index with the constant offset removed.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1032</td>
    <td class="codeLine">        // Switches to the index with the constant offset removed.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1033</td>
    <td class="codeLine">        GEP->setOperand(I, NewIdx);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1033</td>
    <td class="codeLine">        GEP->setOperand(I, NewIdx);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1034</td>
    <td class="codeLine">        // After switching to the new index, we can garbage-collect UserChain</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1034</td>
    <td class="codeLine">        // After switching to the new index, we can garbage-collect UserChain</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1035</td>
    <td class="codeLine">        // and the old index if they are not used.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1035</td>
    <td class="codeLine">        // and the old index if they are not used.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1036</td>
    <td class="codeLine">        RecursivelyDeleteTriviallyDeadInstructions(UserChainTail);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1036</td>
    <td class="codeLine">        RecursivelyDeleteTriviallyDeadInstructions(UserChainTail);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1037</td>
    <td class="codeLine">        RecursivelyDeleteTriviallyDeadInstructions(OldIdx);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1037</td>
    <td class="codeLine">        RecursivelyDeleteTriviallyDeadInstructions(OldIdx);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1038</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1038</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1039</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1039</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1040</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1040</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1041</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1041</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1042</td>
    <td class="codeLine">  // Clear the inbounds attribute because the new index may be off-bound.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1042</td>
    <td class="codeLine">  // Clear the inbounds attribute because the new index may be off-bound.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1043</td>
    <td class="codeLine">  // e.g.,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1043</td>
    <td class="codeLine">  // e.g.,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1044</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1044</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1045</td>
    <td class="codeLine">  //   b     = add i64 a, 5</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1045</td>
    <td class="codeLine">  //   b     = add i64 a, 5</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1046</td>
    <td class="codeLine">  //   addr  = gep inbounds float, float* p, i64 b</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1046</td>
    <td class="codeLine">  //   addr  = gep inbounds float, float* p, i64 b</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1047</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1047</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1048</td>
    <td class="codeLine">  // is transformed to:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1048</td>
    <td class="codeLine">  // is transformed to:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1049</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1049</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1050</td>
    <td class="codeLine">  //   addr2 = gep float, float* p, i64 a ; inbounds removed</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1050</td>
    <td class="codeLine">  //   addr2 = gep float, float* p, i64 a ; inbounds removed</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1051</td>
    <td class="codeLine">  //   addr  = gep inbounds float, float* addr2, i64 5</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1051</td>
    <td class="codeLine">  //   addr  = gep inbounds float, float* addr2, i64 5</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1052</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1052</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1053</td>
    <td class="codeLine">  // If a is -4, although the old index b is in bounds, the new index a is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1053</td>
    <td class="codeLine">  // If a is -4, although the old index b is in bounds, the new index a is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1054</td>
    <td class="codeLine">  // off-bound. http://llvm.org/docs/LangRef.html#id181 says "if the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1054</td>
    <td class="codeLine">  // off-bound. http://llvm.org/docs/LangRef.html#id181 says "if the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1055</td>
    <td class="codeLine">  // inbounds keyword is not present, the offsets are added to the base</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1055</td>
    <td class="codeLine">  // inbounds keyword is not present, the offsets are added to the base</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1056</td>
    <td class="codeLine">  // address with silently-wrapping two's complement arithmetic".</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1056</td>
    <td class="codeLine">  // address with silently-wrapping two's complement arithmetic".</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1057</td>
    <td class="codeLine">  // Therefore, the final code will be a semantically equivalent.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1057</td>
    <td class="codeLine">  // Therefore, the final code will be a semantically equivalent.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1058</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1058</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1059</td>
    <td class="codeLine">  // TODO(jingyue): do some range analysis to keep as many inbounds as</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1059</td>
    <td class="codeLine">  // TODO(jingyue): do some range analysis to keep as many inbounds as</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1060</td>
    <td class="codeLine">  // possible. GEPs with inbounds are more friendly to alias analysis.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1060</td>
    <td class="codeLine">  // possible. GEPs with inbounds are more friendly to alias analysis.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1061</td>
    <td class="codeLine">  bool GEPWasInBounds = GEP->isInBounds();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1061</td>
    <td class="codeLine">  bool GEPWasInBounds = GEP->isInBounds();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1062</td>
    <td class="codeLine">  GEP->setIsInBounds(false);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1062</td>
    <td class="codeLine">  GEP->setIsInBounds(false);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1063</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1063</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1064</td>
    <td class="codeLine">  // Lowers a GEP to either GEPs with a single index or arithmetic operations.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1064</td>
    <td class="codeLine">  // Lowers a GEP to either GEPs with a single index or arithmetic operations.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1065</td>
    <td class="codeLine">  if (LowerGEP) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1065</td>
    <td class="codeLine">  if (LowerGEP) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1066</td>
    <td class="codeLine">    // As currently BasicAA does not analyze ptrtoint/inttoptr, do not lower to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1066</td>
    <td class="codeLine">    // As currently BasicAA does not analyze ptrtoint/inttoptr, do not lower to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1067</td>
    <td class="codeLine">    // arithmetic operations if the target uses alias analysis in codegen.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1067</td>
    <td class="codeLine">    // arithmetic operations if the target uses alias analysis in codegen.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1068</td>
    <td class="codeLine">    // Additionally, pointers that aren't integral (and so can't be safely</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1068</td>
    <td class="codeLine">    // Additionally, pointers that aren't integral (and so can't be safely</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1069</td>
    <td class="codeLine">    // converted to integers) or those whose offset size is different from their</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1069</td>
    <td class="codeLine">    // converted to integers) or those whose offset size is different from their</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1070</td>
    <td class="codeLine">    // pointer size (which means that doing integer arithmetic on them could</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1070</td>
    <td class="codeLine">    // pointer size (which means that doing integer arithmetic on them could</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1071</td>
    <td class="codeLine">    // affect that data) can't be lowered in this way.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1071</td>
    <td class="codeLine">    // affect that data) can't be lowered in this way.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1072</td>
    <td class="codeLine">    unsigned AddrSpace = GEP->getPointerAddressSpace();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1072</td>
    <td class="codeLine">    unsigned AddrSpace = GEP->getPointerAddressSpace();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1073</td>
    <td class="codeLine">    bool PointerHasExtraData = DL->getPointerSizeInBits(AddrSpace) !=</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1073</td>
    <td class="codeLine">    bool PointerHasExtraData = DL->getPointerSizeInBits(AddrSpace) !=</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1074</td>
    <td class="codeLine">                               DL->getIndexSizeInBits(AddrSpace);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1074</td>
    <td class="codeLine">                               DL->getIndexSizeInBits(AddrSpace);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1075</td>
    <td class="codeLine">    if (TTI.useAA() || DL->isNonIntegralAddressSpace(AddrSpace) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1075</td>
    <td class="codeLine">    if (TTI.useAA() || DL->isNonIntegralAddressSpace(AddrSpace) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1076</td>
    <td class="codeLine">        PointerHasExtraData)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1076</td>
    <td class="codeLine">        PointerHasExtraData)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1077</td>
    <td class="codeLine">      lowerToSingleIndexGEPs(GEP, AccumulativeByteOffset);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1077</td>
    <td class="codeLine">      lowerToSingleIndexGEPs(GEP, AccumulativeByteOffset);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1078</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1078</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1079</td>
    <td class="codeLine">      lowerToArithmetics(GEP, AccumulativeByteOffset);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1079</td>
    <td class="codeLine">      lowerToArithmetics(GEP, AccumulativeByteOffset);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1080</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1080</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1081</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1081</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1082</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1082</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1083</td>
    <td class="codeLine">  // No need to create another GEP if the accumulative byte offset is 0.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1083</td>
    <td class="codeLine">  // No need to create another GEP if the accumulative byte offset is 0.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1084</td>
    <td class="codeLine">  if (AccumulativeByteOffset == 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1084</td>
    <td class="codeLine">  if (AccumulativeByteOffset == 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1085</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1085</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1086</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1086</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1087</td>
    <td class="codeLine">  // Offsets the base with the accumulative byte offset.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1087</td>
    <td class="codeLine">  // Offsets the base with the accumulative byte offset.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1088</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1088</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1089</td>
    <td class="codeLine">  //   %gep                        ; the base</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1089</td>
    <td class="codeLine">  //   %gep                        ; the base</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1090</td>
    <td class="codeLine">  //   ... %gep ...</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1090</td>
    <td class="codeLine">  //   ... %gep ...</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1091</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1091</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1092</td>
    <td class="codeLine">  // => add the offset</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1092</td>
    <td class="codeLine">  // => add the offset</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1093</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1093</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1094</td>
    <td class="codeLine">  //   %gep2                       ; clone of %gep</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1094</td>
    <td class="codeLine">  //   %gep2                       ; clone of %gep</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1095</td>
    <td class="codeLine">  //   %new.gep = gep %gep2, <offset / sizeof(*%gep)></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1095</td>
    <td class="codeLine">  //   %new.gep = gep %gep2, <offset / sizeof(*%gep)></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1096</td>
    <td class="codeLine">  //   %gep                        ; will be removed</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1096</td>
    <td class="codeLine">  //   %gep                        ; will be removed</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1097</td>
    <td class="codeLine">  //   ... %gep ...</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1097</td>
    <td class="codeLine">  //   ... %gep ...</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1098</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1098</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1099</td>
    <td class="codeLine">  // => replace all uses of %gep with %new.gep and remove %gep</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1099</td>
    <td class="codeLine">  // => replace all uses of %gep with %new.gep and remove %gep</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1100</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1100</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1101</td>
    <td class="codeLine">  //   %gep2                       ; clone of %gep</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1101</td>
    <td class="codeLine">  //   %gep2                       ; clone of %gep</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1102</td>
    <td class="codeLine">  //   %new.gep = gep %gep2, <offset / sizeof(*%gep)></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1102</td>
    <td class="codeLine">  //   %new.gep = gep %gep2, <offset / sizeof(*%gep)></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1103</td>
    <td class="codeLine">  //   ... %new.gep ...</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1103</td>
    <td class="codeLine">  //   ... %new.gep ...</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1104</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1104</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1105</td>
    <td class="codeLine">  // If AccumulativeByteOffset is not a multiple of sizeof(*%gep), we emit an</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1105</td>
    <td class="codeLine">  // If AccumulativeByteOffset is not a multiple of sizeof(*%gep), we emit an</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1106</td>
    <td class="codeLine">  // uglygep (http://llvm.org/docs/GetElementPtr.html#what-s-an-uglygep):</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1106</td>
    <td class="codeLine">  // uglygep (http://llvm.org/docs/GetElementPtr.html#what-s-an-uglygep):</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1107</td>
    <td class="codeLine">  // bitcast %gep2 to i8*, add the offset, and bitcast the result back to the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1107</td>
    <td class="codeLine">  // bitcast %gep2 to i8*, add the offset, and bitcast the result back to the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1108</td>
    <td class="codeLine">  // type of %gep.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1108</td>
    <td class="codeLine">  // type of %gep.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1109</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1109</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1110</td>
    <td class="codeLine">  //   %gep2                       ; clone of %gep</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1110</td>
    <td class="codeLine">  //   %gep2                       ; clone of %gep</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1111</td>
    <td class="codeLine">  //   %0       = bitcast %gep2 to i8*</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1111</td>
    <td class="codeLine">  //   %0       = bitcast %gep2 to i8*</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1112</td>
    <td class="codeLine">  //   %uglygep = gep %0, <offset></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1112</td>
    <td class="codeLine">  //   %uglygep = gep %0, <offset></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1113</td>
    <td class="codeLine">  //   %new.gep = bitcast %uglygep to <type of %gep></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1113</td>
    <td class="codeLine">  //   %new.gep = bitcast %uglygep to <type of %gep></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1114</td>
    <td class="codeLine">  //   ... %new.gep ...</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1114</td>
    <td class="codeLine">  //   ... %new.gep ...</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1115</td>
    <td class="codeLine">  Instruction *NewGEP = GEP->clone();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1115</td>
    <td class="codeLine">  Instruction *NewGEP = GEP->clone();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1116</td>
    <td class="codeLine">  NewGEP->insertBefore(GEP);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1116</td>
    <td class="codeLine">  NewGEP->insertBefore(GEP);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1117</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1117</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1118</td>
    <td class="codeLine">  // Per ANSI C standard, signed / unsigned = unsigned and signed % unsigned =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1118</td>
    <td class="codeLine">  // Per ANSI C standard, signed / unsigned = unsigned and signed % unsigned =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1119</td>
    <td class="codeLine">  // unsigned.. Therefore, we cast ElementTypeSizeOfGEP to signed because it is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1119</td>
    <td class="codeLine">  // unsigned.. Therefore, we cast ElementTypeSizeOfGEP to signed because it is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1120</td>
    <td class="codeLine">  // used with unsigned integers later.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1120</td>
    <td class="codeLine">  // used with unsigned integers later.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1121</td>
    <td class="codeLine">  int64_t ElementTypeSizeOfGEP = static_cast<int64_t>(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1121</td>
    <td class="codeLine">  int64_t ElementTypeSizeOfGEP = static_cast<int64_t>(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1122</td>
    <td class="codeLine">      DL->getTypeAllocSize(GEP->getResultElementType()));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1122</td>
    <td class="codeLine">      DL->getTypeAllocSize(GEP->getResultElementType()));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1123</td>
    <td class="codeLine">  Type *PtrIdxTy = DL->getIndexType(GEP->getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1123</td>
    <td class="codeLine">  Type *PtrIdxTy = DL->getIndexType(GEP->getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1124</td>
    <td class="codeLine">  if (AccumulativeByteOffset % ElementTypeSizeOfGEP == 0) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1124</td>
    <td class="codeLine">  if (AccumulativeByteOffset % ElementTypeSizeOfGEP == 0) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1125</td>
    <td class="codeLine">    // Very likely. As long as %gep is naturally aligned, the byte offset we</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1125</td>
    <td class="codeLine">    // Very likely. As long as %gep is naturally aligned, the byte offset we</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1126</td>
    <td class="codeLine">    // extracted should be a multiple of sizeof(*%gep).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1126</td>
    <td class="codeLine">    // extracted should be a multiple of sizeof(*%gep).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1127</td>
    <td class="codeLine">    int64_t Index = AccumulativeByteOffset / ElementTypeSizeOfGEP;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1127</td>
    <td class="codeLine">    int64_t Index = AccumulativeByteOffset / ElementTypeSizeOfGEP;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1128</td>
    <td class="codeLine">    NewGEP = GetElementPtrInst::Create(GEP->getResultElementType(), NewGEP,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1128</td>
    <td class="codeLine">    NewGEP = GetElementPtrInst::Create(GEP->getResultElementType(), NewGEP,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1129</td>
    <td class="codeLine">                                       ConstantInt::get(PtrIdxTy, Index, true),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1129</td>
    <td class="codeLine">                                       ConstantInt::get(PtrIdxTy, Index, true),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1130</td>
    <td class="codeLine">                                       GEP->getName(), GEP);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1130</td>
    <td class="codeLine">                                       GEP->getName(), GEP);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1131</td>
    <td class="codeLine">    NewGEP->copyMetadata(*GEP);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1131</td>
    <td class="codeLine">    NewGEP->copyMetadata(*GEP);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1132</td>
    <td class="codeLine">    // Inherit the inbounds attribute of the original GEP.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1132</td>
    <td class="codeLine">    // Inherit the inbounds attribute of the original GEP.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1133</td>
    <td class="codeLine">    cast<GetElementPtrInst>(NewGEP)->setIsInBounds(GEPWasInBounds);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1133</td>
    <td class="codeLine">    cast<GetElementPtrInst>(NewGEP)->setIsInBounds(GEPWasInBounds);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1134</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1134</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1135</td>
    <td class="codeLine">    // Unlikely but possible. For example,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1135</td>
    <td class="codeLine">    // Unlikely but possible. For example,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1136</td>
    <td class="codeLine">    // #pragma pack(1)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1136</td>
    <td class="codeLine">    // #pragma pack(1)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1137</td>
    <td class="codeLine">    // struct S {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1137</td>
    <td class="codeLine">    // struct S {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1138</td>
    <td class="codeLine">    //   int a[3];</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1138</td>
    <td class="codeLine">    //   int a[3];</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1139</td>
    <td class="codeLine">    //   int64 b[8];</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1139</td>
    <td class="codeLine">    //   int64 b[8];</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1140</td>
    <td class="codeLine">    // };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1140</td>
    <td class="codeLine">    // };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1141</td>
    <td class="codeLine">    // #pragma pack()</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1141</td>
    <td class="codeLine">    // #pragma pack()</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1142</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1142</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1143</td>
    <td class="codeLine">    // Suppose the gep before extraction is &s[i + 1].b[j + 3]. After</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1143</td>
    <td class="codeLine">    // Suppose the gep before extraction is &s[i + 1].b[j + 3]. After</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1144</td>
    <td class="codeLine">    // extraction, it becomes &s[i].b[j] and AccumulativeByteOffset is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1144</td>
    <td class="codeLine">    // extraction, it becomes &s[i].b[j] and AccumulativeByteOffset is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1145</td>
    <td class="codeLine">    // sizeof(S) + 3 * sizeof(int64) = 100, which is not a multiple of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1145</td>
    <td class="codeLine">    // sizeof(S) + 3 * sizeof(int64) = 100, which is not a multiple of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1146</td>
    <td class="codeLine">    // sizeof(int64).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1146</td>
    <td class="codeLine">    // sizeof(int64).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1147</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1147</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1148</td>
    <td class="codeLine">    // Emit an uglygep in this case.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1148</td>
    <td class="codeLine">    // Emit an uglygep in this case.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1149</td>
    <td class="codeLine">    IRBuilder<> Builder(GEP);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1149</td>
    <td class="codeLine">    IRBuilder<> Builder(GEP);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1150</td>
    <td class="codeLine">    NewGEP = cast<Instruction>(Builder.CreateGEP(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1150</td>
    <td class="codeLine">    NewGEP = cast<Instruction>(Builder.CreateGEP(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1151</td>
    <td class="codeLine">        Builder.getInt8Ty(), NewGEP,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1151</td>
    <td class="codeLine">        Builder.getInt8Ty(), NewGEP,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1152</td>
    <td class="codeLine">        {ConstantInt::get(PtrIdxTy, AccumulativeByteOffset, true)}, "uglygep",</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1152</td>
    <td class="codeLine">        {ConstantInt::get(PtrIdxTy, AccumulativeByteOffset, true)}, "uglygep",</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1153</td>
    <td class="codeLine">        GEPWasInBounds));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1153</td>
    <td class="codeLine">        GEPWasInBounds));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1154</td>
    <td class="codeLine">    NewGEP->copyMetadata(*GEP);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1154</td>
    <td class="codeLine">    NewGEP->copyMetadata(*GEP);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1155</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1155</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1156</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1156</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1157</td>
    <td class="codeLine">  GEP->replaceAllUsesWith(NewGEP);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1157</td>
    <td class="codeLine">  GEP->replaceAllUsesWith(NewGEP);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1158</td>
    <td class="codeLine">  GEP->eraseFromParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1158</td>
    <td class="codeLine">  GEP->eraseFromParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1159</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1159</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1160</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1160</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1161</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1161</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1162</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1162</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1163</td>
    <td class="codeLine">bool SeparateConstOffsetFromGEPLegacyPass::runOnFunction(Function &F) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1163</td>
    <td class="codeLine">bool SeparateConstOffsetFromGEPLegacyPass::runOnFunction(Function &F) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1164</td>
    <td class="codeLine">  if (skipFunction(F))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1164</td>
    <td class="codeLine">  if (skipFunction(F))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1165</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1165</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1166</td>
    <td class="codeLine">  auto *DT = &getAnalysis<DominatorTreeWrapperPass>().getDomTree();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1166</td>
    <td class="codeLine">  auto *DT = &getAnalysis<DominatorTreeWrapperPass>().getDomTree();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1167</td>
    <td class="codeLine">  auto *LI = &getAnalysis<LoopInfoWrapperPass>().getLoopInfo();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1167</td>
    <td class="codeLine">  auto *LI = &getAnalysis<LoopInfoWrapperPass>().getLoopInfo();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1168</td>
    <td class="codeLine">  auto *TLI = &getAnalysis<TargetLibraryInfoWrapperPass>().getTLI(F);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1168</td>
    <td class="codeLine">  auto *TLI = &getAnalysis<TargetLibraryInfoWrapperPass>().getTLI(F);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1169</td>
    <td class="codeLine">  auto GetTTI = [this](Function &F) -> TargetTransformInfo & {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1169</td>
    <td class="codeLine">  auto GetTTI = [this](Function &F) -> TargetTransformInfo & {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1170</td>
    <td class="codeLine">    return this->getAnalysis<TargetTransformInfoWrapperPass>().getTTI(F);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1170</td>
    <td class="codeLine">    return this->getAnalysis<TargetTransformInfoWrapperPass>().getTTI(F);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1171</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1171</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1172</td>
    <td class="codeLine">  SeparateConstOffsetFromGEP Impl(DT, LI, TLI, GetTTI, LowerGEP);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1172</td>
    <td class="codeLine">  SeparateConstOffsetFromGEP Impl(DT, LI, TLI, GetTTI, LowerGEP);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1173</td>
    <td class="codeLine">  return Impl.run(F);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1173</td>
    <td class="codeLine">  return Impl.run(F);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1174</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1174</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1175</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1175</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1176</td>
    <td class="codeLine">bool SeparateConstOffsetFromGEP::run(Function &F) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1176</td>
    <td class="codeLine">bool SeparateConstOffsetFromGEP::run(Function &F) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1177</td>
    <td class="codeLine">  if (DisableSeparateConstOffsetFromGEP)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1177</td>
    <td class="codeLine">  if (DisableSeparateConstOffsetFromGEP)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1178</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1178</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1179</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1179</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1180</td>
    <td class="codeLine">  DL = &F.getParent()->getDataLayout();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1180</td>
    <td class="codeLine">  DL = &F.getParent()->getDataLayout();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1181</td>
    <td class="codeLine">  bool Changed = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1181</td>
    <td class="codeLine">  bool Changed = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1182</td>
    <td class="codeLine">  for (BasicBlock &B : F) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1182</td>
    <td class="codeLine">  for (BasicBlock &B : F) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1183</td>
    <td class="codeLine">    if (!DT->isReachableFromEntry(&B))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1183</td>
    <td class="codeLine">    if (!DT->isReachableFromEntry(&B))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1184</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1184</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1185</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1185</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1186</td>
    <td class="codeLine">    for (Instruction &I : llvm::make_early_inc_range(B))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1186</td>
    <td class="codeLine">    for (Instruction &I : llvm::make_early_inc_range(B))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1187</td>
    <td class="codeLine">      if (GetElementPtrInst *GEP = dyn_cast<GetElementPtrInst>(&I))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1187</td>
    <td class="codeLine">      if (GetElementPtrInst *GEP = dyn_cast<GetElementPtrInst>(&I))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1188</td>
    <td class="codeLine">        Changed |= splitGEP(GEP);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1188</td>
    <td class="codeLine">        Changed |= splitGEP(GEP);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1189</td>
    <td class="codeLine">    // No need to split GEP ConstantExprs because all its indices are constant</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1189</td>
    <td class="codeLine">    // No need to split GEP ConstantExprs because all its indices are constant</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1190</td>
    <td class="codeLine">    // already.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1190</td>
    <td class="codeLine">    // already.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1191</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1191</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1192</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1192</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1193</td>
    <td class="codeLine">  Changed |= reuniteExts(F);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1193</td>
    <td class="codeLine">  Changed |= reuniteExts(F);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1194</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1194</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1195</td>
    <td class="codeLine">  if (VerifyNoDeadCode)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1195</td>
    <td class="codeLine">  if (VerifyNoDeadCode)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1196</td>
    <td class="codeLine">    verifyNoDeadCode(F);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1196</td>
    <td class="codeLine">    verifyNoDeadCode(F);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1197</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1197</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1198</td>
    <td class="codeLine">  return Changed;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1198</td>
    <td class="codeLine">  return Changed;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1199</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1199</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1200</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1200</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1201</td>
    <td class="codeLine">Instruction *SeparateConstOffsetFromGEP::findClosestMatchingDominator(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1201</td>
    <td class="codeLine">Instruction *SeparateConstOffsetFromGEP::findClosestMatchingDominator(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1202</td>
    <td class="codeLine">    ExprKey Key, Instruction *Dominatee,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1202</td>
    <td class="codeLine">    ExprKey Key, Instruction *Dominatee,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1203</td>
    <td class="codeLine">    DenseMap<ExprKey, SmallVector<Instruction *, 2>> &DominatingExprs) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1203</td>
    <td class="codeLine">    DenseMap<ExprKey, SmallVector<Instruction *, 2>> &DominatingExprs) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1204</td>
    <td class="codeLine">  auto Pos = DominatingExprs.find(Key);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1204</td>
    <td class="codeLine">  auto Pos = DominatingExprs.find(Key);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1205</td>
    <td class="codeLine">  if (Pos == DominatingExprs.end())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1205</td>
    <td class="codeLine">  if (Pos == DominatingExprs.end())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1206</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1206</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1207</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1207</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1208</td>
    <td class="codeLine">  auto &Candidates = Pos->second;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1208</td>
    <td class="codeLine">  auto &Candidates = Pos->second;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1209</td>
    <td class="codeLine">  // Because we process the basic blocks in pre-order of the dominator tree, a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1209</td>
    <td class="codeLine">  // Because we process the basic blocks in pre-order of the dominator tree, a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1210</td>
    <td class="codeLine">  // candidate that doesn't dominate the current instruction won't dominate any</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1210</td>
    <td class="codeLine">  // candidate that doesn't dominate the current instruction won't dominate any</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1211</td>
    <td class="codeLine">  // future instruction either. Therefore, we pop it out of the stack. This</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1211</td>
    <td class="codeLine">  // future instruction either. Therefore, we pop it out of the stack. This</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1212</td>
    <td class="codeLine">  // optimization makes the algorithm O(n).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1212</td>
    <td class="codeLine">  // optimization makes the algorithm O(n).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1213</td>
    <td class="codeLine">  while (!Candidates.empty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1213</td>
    <td class="codeLine">  while (!Candidates.empty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1214</td>
    <td class="codeLine">    Instruction *Candidate = Candidates.back();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1214</td>
    <td class="codeLine">    Instruction *Candidate = Candidates.back();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1215</td>
    <td class="codeLine">    if (DT->dominates(Candidate, Dominatee))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1215</td>
    <td class="codeLine">    if (DT->dominates(Candidate, Dominatee))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1216</td>
    <td class="codeLine">      return Candidate;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1216</td>
    <td class="codeLine">      return Candidate;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1217</td>
    <td class="codeLine">    Candidates.pop_back();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1217</td>
    <td class="codeLine">    Candidates.pop_back();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1218</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1218</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1219</td>
    <td class="codeLine">  return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1219</td>
    <td class="codeLine">  return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1220</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1220</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1221</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1221</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1222</td>
    <td class="codeLine">bool SeparateConstOffsetFromGEP::reuniteExts(Instruction *I) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1222</td>
    <td class="codeLine">bool SeparateConstOffsetFromGEP::reuniteExts(Instruction *I) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1223</td>
    <td class="codeLine">  if (!I->getType()->isIntOrIntVectorTy())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1223</td>
    <td class="codeLine">  if (!I->getType()->isIntOrIntVectorTy())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1224</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1224</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1225</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1225</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1226</td>
    <td class="codeLine">  //   Dom: LHS+RHS</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1226</td>
    <td class="codeLine">  //   Dom: LHS+RHS</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1227</td>
    <td class="codeLine">  //   I: sext(LHS)+sext(RHS)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1227</td>
    <td class="codeLine">  //   I: sext(LHS)+sext(RHS)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1228</td>
    <td class="codeLine">  // If Dom can't sign overflow and Dom dominates I, optimize I to sext(Dom).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1228</td>
    <td class="codeLine">  // If Dom can't sign overflow and Dom dominates I, optimize I to sext(Dom).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1229</td>
    <td class="codeLine">  // TODO: handle zext</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1229</td>
    <td class="codeLine">  // TODO: handle zext</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1230</td>
    <td class="codeLine">  Value *LHS = nullptr, *RHS = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1230</td>
    <td class="codeLine">  Value *LHS = nullptr, *RHS = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1231</td>
    <td class="codeLine">  if (match(I, m_Add(m_SExt(m_Value(LHS)), m_SExt(m_Value(RHS))))) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1231</td>
    <td class="codeLine">  if (match(I, m_Add(m_SExt(m_Value(LHS)), m_SExt(m_Value(RHS))))) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1232</td>
    <td class="codeLine">    if (LHS->getType() == RHS->getType()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1232</td>
    <td class="codeLine">    if (LHS->getType() == RHS->getType()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1233</td>
    <td class="codeLine">      ExprKey Key = createNormalizedCommutablePair(LHS, RHS);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1233</td>
    <td class="codeLine">      ExprKey Key = createNormalizedCommutablePair(LHS, RHS);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1234</td>
    <td class="codeLine">      if (auto *Dom = findClosestMatchingDominator(Key, I, DominatingAdds)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1234</td>
    <td class="codeLine">      if (auto *Dom = findClosestMatchingDominator(Key, I, DominatingAdds)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1235</td>
    <td class="codeLine">        Instruction *NewSExt = new SExtInst(Dom, I->getType(), "", I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1235</td>
    <td class="codeLine">        Instruction *NewSExt = new SExtInst(Dom, I->getType(), "", I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1236</td>
    <td class="codeLine">        NewSExt->takeName(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1236</td>
    <td class="codeLine">        NewSExt->takeName(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1237</td>
    <td class="codeLine">        I->replaceAllUsesWith(NewSExt);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1237</td>
    <td class="codeLine">        I->replaceAllUsesWith(NewSExt);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1238</td>
    <td class="codeLine">        RecursivelyDeleteTriviallyDeadInstructions(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1238</td>
    <td class="codeLine">        RecursivelyDeleteTriviallyDeadInstructions(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1239</td>
    <td class="codeLine">        return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1239</td>
    <td class="codeLine">        return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1240</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1240</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1241</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1241</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1242</td>
    <td class="codeLine">  } else if (match(I, m_Sub(m_SExt(m_Value(LHS)), m_SExt(m_Value(RHS))))) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1242</td>
    <td class="codeLine">  } else if (match(I, m_Sub(m_SExt(m_Value(LHS)), m_SExt(m_Value(RHS))))) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1243</td>
    <td class="codeLine">    if (LHS->getType() == RHS->getType()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1243</td>
    <td class="codeLine">    if (LHS->getType() == RHS->getType()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1244</td>
    <td class="codeLine">      if (auto *Dom =</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1244</td>
    <td class="codeLine">      if (auto *Dom =</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1245</td>
    <td class="codeLine">              findClosestMatchingDominator({LHS, RHS}, I, DominatingSubs)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1245</td>
    <td class="codeLine">              findClosestMatchingDominator({LHS, RHS}, I, DominatingSubs)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1246</td>
    <td class="codeLine">        Instruction *NewSExt = new SExtInst(Dom, I->getType(), "", I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1246</td>
    <td class="codeLine">        Instruction *NewSExt = new SExtInst(Dom, I->getType(), "", I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1247</td>
    <td class="codeLine">        NewSExt->takeName(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1247</td>
    <td class="codeLine">        NewSExt->takeName(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1248</td>
    <td class="codeLine">        I->replaceAllUsesWith(NewSExt);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1248</td>
    <td class="codeLine">        I->replaceAllUsesWith(NewSExt);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1249</td>
    <td class="codeLine">        RecursivelyDeleteTriviallyDeadInstructions(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1249</td>
    <td class="codeLine">        RecursivelyDeleteTriviallyDeadInstructions(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1250</td>
    <td class="codeLine">        return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1250</td>
    <td class="codeLine">        return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1251</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1251</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1252</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1252</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1253</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1253</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1254</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1254</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1255</td>
    <td class="codeLine">  // Add I to DominatingExprs if it's an add/sub that can't sign overflow.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1255</td>
    <td class="codeLine">  // Add I to DominatingExprs if it's an add/sub that can't sign overflow.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1256</td>
    <td class="codeLine">  if (match(I, m_NSWAdd(m_Value(LHS), m_Value(RHS)))) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1256</td>
    <td class="codeLine">  if (match(I, m_NSWAdd(m_Value(LHS), m_Value(RHS)))) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1257</td>
    <td class="codeLine">    if (programUndefinedIfPoison(I)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1257</td>
    <td class="codeLine">    if (programUndefinedIfPoison(I)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1258</td>
    <td class="codeLine">      ExprKey Key = createNormalizedCommutablePair(LHS, RHS);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1258</td>
    <td class="codeLine">      ExprKey Key = createNormalizedCommutablePair(LHS, RHS);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1259</td>
    <td class="codeLine">      DominatingAdds[Key].push_back(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1259</td>
    <td class="codeLine">      DominatingAdds[Key].push_back(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1260</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1260</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1261</td>
    <td class="codeLine">  } else if (match(I, m_NSWSub(m_Value(LHS), m_Value(RHS)))) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1261</td>
    <td class="codeLine">  } else if (match(I, m_NSWSub(m_Value(LHS), m_Value(RHS)))) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1262</td>
    <td class="codeLine">    if (programUndefinedIfPoison(I))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1262</td>
    <td class="codeLine">    if (programUndefinedIfPoison(I))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1263</td>
    <td class="codeLine">      DominatingSubs[{LHS, RHS}].push_back(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1263</td>
    <td class="codeLine">      DominatingSubs[{LHS, RHS}].push_back(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1264</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1264</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1265</td>
    <td class="codeLine">  return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1265</td>
    <td class="codeLine">  return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1266</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1266</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1267</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1267</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1268</td>
    <td class="codeLine">bool SeparateConstOffsetFromGEP::reuniteExts(Function &F) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1268</td>
    <td class="codeLine">bool SeparateConstOffsetFromGEP::reuniteExts(Function &F) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1269</td>
    <td class="codeLine">  bool Changed = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1269</td>
    <td class="codeLine">  bool Changed = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1270</td>
    <td class="codeLine">  DominatingAdds.clear();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1270</td>
    <td class="codeLine">  DominatingAdds.clear();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1271</td>
    <td class="codeLine">  DominatingSubs.clear();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1271</td>
    <td class="codeLine">  DominatingSubs.clear();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1272</td>
    <td class="codeLine">  for (const auto Node : depth_first(DT)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1272</td>
    <td class="codeLine">  for (const auto Node : depth_first(DT)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1273</td>
    <td class="codeLine">    BasicBlock *BB = Node->getBlock();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1273</td>
    <td class="codeLine">    BasicBlock *BB = Node->getBlock();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1274</td>
    <td class="codeLine">    for (Instruction &I : llvm::make_early_inc_range(*BB))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1274</td>
    <td class="codeLine">    for (Instruction &I : llvm::make_early_inc_range(*BB))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1275</td>
    <td class="codeLine">      Changed |= reuniteExts(&I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1275</td>
    <td class="codeLine">      Changed |= reuniteExts(&I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1276</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1276</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1277</td>
    <td class="codeLine">  return Changed;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1277</td>
    <td class="codeLine">  return Changed;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1278</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1278</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1279</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1279</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1280</td>
    <td class="codeLine">void SeparateConstOffsetFromGEP::verifyNoDeadCode(Function &F) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1280</td>
    <td class="codeLine">void SeparateConstOffsetFromGEP::verifyNoDeadCode(Function &F) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1281</td>
    <td class="codeLine">  for (BasicBlock &B : F) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1281</td>
    <td class="codeLine">  for (BasicBlock &B : F) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1282</td>
    <td class="codeLine">    for (Instruction &I : B) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1282</td>
    <td class="codeLine">    for (Instruction &I : B) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1283</td>
    <td class="codeLine">      if (isInstructionTriviallyDead(&I)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1283</td>
    <td class="codeLine">      if (isInstructionTriviallyDead(&I)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1284</td>
    <td class="codeLine">        std::string ErrMessage;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1284</td>
    <td class="codeLine">        std::string ErrMessage;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1285</td>
    <td class="codeLine">        raw_string_ostream RSO(ErrMessage);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1285</td>
    <td class="codeLine">        raw_string_ostream RSO(ErrMessage);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1286</td>
    <td class="codeLine">        RSO << "Dead instruction detected!\n" << I << "\n";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1286</td>
    <td class="codeLine">        RSO << "Dead instruction detected!\n" << I << "\n";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1287</td>
    <td class="codeLine">        llvm_unreachable(RSO.str().c_str());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1287</td>
    <td class="codeLine">        llvm_unreachable(RSO.str().c_str());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1288</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1288</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1289</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1289</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1290</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1290</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1291</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1291</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1292</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1292</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1293</td>
    <td class="codeLine">bool SeparateConstOffsetFromGEP::isLegalToSwapOperand(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1293</td>
    <td class="codeLine">bool SeparateConstOffsetFromGEP::isLegalToSwapOperand(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1294</td>
    <td class="codeLine">    GetElementPtrInst *FirstGEP, GetElementPtrInst *SecondGEP, Loop *CurLoop) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1294</td>
    <td class="codeLine">    GetElementPtrInst *FirstGEP, GetElementPtrInst *SecondGEP, Loop *CurLoop) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1295</td>
    <td class="codeLine">  if (!FirstGEP || !FirstGEP->hasOneUse())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1295</td>
    <td class="codeLine">  if (!FirstGEP || !FirstGEP->hasOneUse())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1296</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1296</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1297</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1297</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1298</td>
    <td class="codeLine">  if (!SecondGEP || FirstGEP->getParent() != SecondGEP->getParent())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1298</td>
    <td class="codeLine">  if (!SecondGEP || FirstGEP->getParent() != SecondGEP->getParent())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1299</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1299</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1300</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1300</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1301</td>
    <td class="codeLine">  if (FirstGEP == SecondGEP)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1301</td>
    <td class="codeLine">  if (FirstGEP == SecondGEP)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1302</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1302</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1303</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1303</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1304</td>
    <td class="codeLine">  unsigned FirstNum = FirstGEP->getNumOperands();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1304</td>
    <td class="codeLine">  unsigned FirstNum = FirstGEP->getNumOperands();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1305</td>
    <td class="codeLine">  unsigned SecondNum = SecondGEP->getNumOperands();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1305</td>
    <td class="codeLine">  unsigned SecondNum = SecondGEP->getNumOperands();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1306</td>
    <td class="codeLine">  // Give up if the number of operands are not 2.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1306</td>
    <td class="codeLine">  // Give up if the number of operands are not 2.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1307</td>
    <td class="codeLine">  if (FirstNum != SecondNum || FirstNum != 2)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1307</td>
    <td class="codeLine">  if (FirstNum != SecondNum || FirstNum != 2)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1308</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1308</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1309</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1309</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1310</td>
    <td class="codeLine">  Value *FirstBase = FirstGEP->getOperand(0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1310</td>
    <td class="codeLine">  Value *FirstBase = FirstGEP->getOperand(0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1311</td>
    <td class="codeLine">  Value *SecondBase = SecondGEP->getOperand(0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1311</td>
    <td class="codeLine">  Value *SecondBase = SecondGEP->getOperand(0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1312</td>
    <td class="codeLine">  Value *FirstOffset = FirstGEP->getOperand(1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1312</td>
    <td class="codeLine">  Value *FirstOffset = FirstGEP->getOperand(1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1313</td>
    <td class="codeLine">  // Give up if the index of the first GEP is loop invariant.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1313</td>
    <td class="codeLine">  // Give up if the index of the first GEP is loop invariant.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1314</td>
    <td class="codeLine">  if (CurLoop->isLoopInvariant(FirstOffset))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1314</td>
    <td class="codeLine">  if (CurLoop->isLoopInvariant(FirstOffset))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1315</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1315</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1316</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1316</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1317</td>
    <td class="codeLine">  // Give up if base doesn't have same type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1317</td>
    <td class="codeLine">  // Give up if base doesn't have same type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1318</td>
    <td class="codeLine">  if (FirstBase->getType() != SecondBase->getType())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1318</td>
    <td class="codeLine">  if (FirstBase->getType() != SecondBase->getType())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1319</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1319</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1320</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1320</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1321</td>
    <td class="codeLine">  Instruction *FirstOffsetDef = dyn_cast<Instruction>(FirstOffset);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1321</td>
    <td class="codeLine">  Instruction *FirstOffsetDef = dyn_cast<Instruction>(FirstOffset);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1322</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1322</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1323</td>
    <td class="codeLine">  // Check if the second operand of first GEP has constant coefficient.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1323</td>
    <td class="codeLine">  // Check if the second operand of first GEP has constant coefficient.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1324</td>
    <td class="codeLine">  // For an example, for the following code,  we won't gain anything by</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1324</td>
    <td class="codeLine">  // For an example, for the following code,  we won't gain anything by</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1325</td>
    <td class="codeLine">  // hoisting the second GEP out because the second GEP can be folded away.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1325</td>
    <td class="codeLine">  // hoisting the second GEP out because the second GEP can be folded away.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1326</td>
    <td class="codeLine">  //   %scevgep.sum.ur159 = add i64 %idxprom48.ur, 256</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1326</td>
    <td class="codeLine">  //   %scevgep.sum.ur159 = add i64 %idxprom48.ur, 256</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1327</td>
    <td class="codeLine">  //   %67 = shl i64 %scevgep.sum.ur159, 2</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1327</td>
    <td class="codeLine">  //   %67 = shl i64 %scevgep.sum.ur159, 2</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1328</td>
    <td class="codeLine">  //   %uglygep160 = getelementptr i8* %65, i64 %67</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1328</td>
    <td class="codeLine">  //   %uglygep160 = getelementptr i8* %65, i64 %67</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1329</td>
    <td class="codeLine">  //   %uglygep161 = getelementptr i8* %uglygep160, i64 -1024</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1329</td>
    <td class="codeLine">  //   %uglygep161 = getelementptr i8* %uglygep160, i64 -1024</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1330</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1330</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1331</td>
    <td class="codeLine">  // Skip constant shift instruction which may be generated by Splitting GEPs.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1331</td>
    <td class="codeLine">  // Skip constant shift instruction which may be generated by Splitting GEPs.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1332</td>
    <td class="codeLine">  if (FirstOffsetDef && FirstOffsetDef->isShift() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1332</td>
    <td class="codeLine">  if (FirstOffsetDef && FirstOffsetDef->isShift() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1333</td>
    <td class="codeLine">      isa<ConstantInt>(FirstOffsetDef->getOperand(1)))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1333</td>
    <td class="codeLine">      isa<ConstantInt>(FirstOffsetDef->getOperand(1)))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1334</td>
    <td class="codeLine">    FirstOffsetDef = dyn_cast<Instruction>(FirstOffsetDef->getOperand(0));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1334</td>
    <td class="codeLine">    FirstOffsetDef = dyn_cast<Instruction>(FirstOffsetDef->getOperand(0));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1335</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1335</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1336</td>
    <td class="codeLine">  // Give up if FirstOffsetDef is an Add or Sub with constant.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1336</td>
    <td class="codeLine">  // Give up if FirstOffsetDef is an Add or Sub with constant.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1337</td>
    <td class="codeLine">  // Because it may not profitable at all due to constant folding.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1337</td>
    <td class="codeLine">  // Because it may not profitable at all due to constant folding.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1338</td>
    <td class="codeLine">  if (FirstOffsetDef)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1338</td>
    <td class="codeLine">  if (FirstOffsetDef)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1339</td>
    <td class="codeLine">    if (BinaryOperator *BO = dyn_cast<BinaryOperator>(FirstOffsetDef)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1339</td>
    <td class="codeLine">    if (BinaryOperator *BO = dyn_cast<BinaryOperator>(FirstOffsetDef)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1340</td>
    <td class="codeLine">      unsigned opc = BO->getOpcode();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1340</td>
    <td class="codeLine">      unsigned opc = BO->getOpcode();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1341</td>
    <td class="codeLine">      if ((opc == Instruction::Add || opc == Instruction::Sub) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1341</td>
    <td class="codeLine">      if ((opc == Instruction::Add || opc == Instruction::Sub) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1342</td>
    <td class="codeLine">          (isa<ConstantInt>(BO->getOperand(0)) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1342</td>
    <td class="codeLine">          (isa<ConstantInt>(BO->getOperand(0)) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1343</td>
    <td class="codeLine">           isa<ConstantInt>(BO->getOperand(1))))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1343</td>
    <td class="codeLine">           isa<ConstantInt>(BO->getOperand(1))))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1344</td>
    <td class="codeLine">        return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1344</td>
    <td class="codeLine">        return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1345</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1345</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1346</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1346</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1347</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1347</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1348</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1348</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1349</td>
    <td class="codeLine">bool SeparateConstOffsetFromGEP::hasMoreThanOneUseInLoop(Value *V, Loop *L) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1349</td>
    <td class="codeLine">bool SeparateConstOffsetFromGEP::hasMoreThanOneUseInLoop(Value *V, Loop *L) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1350</td>
    <td class="codeLine">  int UsesInLoop = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1350</td>
    <td class="codeLine">  int UsesInLoop = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1351</td>
    <td class="codeLine">  for (User *U : V->users()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1351</td>
    <td class="codeLine">  for (User *U : V->users()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1352</td>
    <td class="codeLine">    if (Instruction *User = dyn_cast<Instruction>(U))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1352</td>
    <td class="codeLine">    if (Instruction *User = dyn_cast<Instruction>(U))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1353</td>
    <td class="codeLine">      if (L->contains(User))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1353</td>
    <td class="codeLine">      if (L->contains(User))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1354</td>
    <td class="codeLine">        if (++UsesInLoop > 1)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1354</td>
    <td class="codeLine">        if (++UsesInLoop > 1)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1355</td>
    <td class="codeLine">          return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1355</td>
    <td class="codeLine">          return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1356</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1356</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1357</td>
    <td class="codeLine">  return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1357</td>
    <td class="codeLine">  return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1358</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1358</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1359</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1359</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1360</td>
    <td class="codeLine">void SeparateConstOffsetFromGEP::swapGEPOperand(GetElementPtrInst *First,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1360</td>
    <td class="codeLine">void SeparateConstOffsetFromGEP::swapGEPOperand(GetElementPtrInst *First,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1361</td>
    <td class="codeLine">                                                GetElementPtrInst *Second) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1361</td>
    <td class="codeLine">                                                GetElementPtrInst *Second) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1362</td>
    <td class="codeLine">  Value *Offset1 = First->getOperand(1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1362</td>
    <td class="codeLine">  Value *Offset1 = First->getOperand(1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1363</td>
    <td class="codeLine">  Value *Offset2 = Second->getOperand(1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1363</td>
    <td class="codeLine">  Value *Offset2 = Second->getOperand(1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1364</td>
    <td class="codeLine">  First->setOperand(1, Offset2);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1364</td>
    <td class="codeLine">  First->setOperand(1, Offset2);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1365</td>
    <td class="codeLine">  Second->setOperand(1, Offset1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1365</td>
    <td class="codeLine">  Second->setOperand(1, Offset1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1366</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1366</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1367</td>
    <td class="codeLine">  // We changed p+o+c to p+c+o, p+c may not be inbound anymore.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1367</td>
    <td class="codeLine">  // We changed p+o+c to p+c+o, p+c may not be inbound anymore.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1368</td>
    <td class="codeLine">  const DataLayout &DAL = First->getModule()->getDataLayout();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1368</td>
    <td class="codeLine">  const DataLayout &DAL = First->getModule()->getDataLayout();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1369</td>
    <td class="codeLine">  APInt Offset(DAL.getIndexSizeInBits(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1369</td>
    <td class="codeLine">  APInt Offset(DAL.getIndexSizeInBits(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1370</td>
    <td class="codeLine">                   cast<PointerType>(First->getType())->getAddressSpace()),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1370</td>
    <td class="codeLine">                   cast<PointerType>(First->getType())->getAddressSpace()),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1371</td>
    <td class="codeLine">               0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1371</td>
    <td class="codeLine">               0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1372</td>
    <td class="codeLine">  Value *NewBase =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1372</td>
    <td class="codeLine">  Value *NewBase =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1373</td>
    <td class="codeLine">      First->stripAndAccumulateInBoundsConstantOffsets(DAL, Offset);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1373</td>
    <td class="codeLine">      First->stripAndAccumulateInBoundsConstantOffsets(DAL, Offset);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1374</td>
    <td class="codeLine">  uint64_t ObjectSize;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1374</td>
    <td class="codeLine">  uint64_t ObjectSize;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1375</td>
    <td class="codeLine">  if (!getObjectSize(NewBase, ObjectSize, DAL, TLI) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1375</td>
    <td class="codeLine">  if (!getObjectSize(NewBase, ObjectSize, DAL, TLI) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1376</td>
    <td class="codeLine">     Offset.ugt(ObjectSize)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1376</td>
    <td class="codeLine">     Offset.ugt(ObjectSize)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1377</td>
    <td class="codeLine">    First->setIsInBounds(false);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1377</td>
    <td class="codeLine">    First->setIsInBounds(false);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1378</td>
    <td class="codeLine">    Second->setIsInBounds(false);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1378</td>
    <td class="codeLine">    Second->setIsInBounds(false);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1379</td>
    <td class="codeLine">  } else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1379</td>
    <td class="codeLine">  } else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1380</td>
    <td class="codeLine">    First->setIsInBounds(true);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1380</td>
    <td class="codeLine">    First->setIsInBounds(true);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1381</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1381</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1382</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1382</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1383</td>
    <td class="codeLine">void SeparateConstOffsetFromGEPPass::printPipeline(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1383</td>
    <td class="codeLine">void SeparateConstOffsetFromGEPPass::printPipeline(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1384</td>
    <td class="codeLine">    raw_ostream &OS, function_ref<StringRef(StringRef)> MapClassName2PassName) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1384</td>
    <td class="codeLine">    raw_ostream &OS, function_ref<StringRef(StringRef)> MapClassName2PassName) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1385</td>
    <td class="codeLine">  static_cast<PassInfoMixin<SeparateConstOffsetFromGEPPass> *>(this)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1385</td>
    <td class="codeLine">  static_cast<PassInfoMixin<SeparateConstOffsetFromGEPPass> *>(this)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1386</td>
    <td class="codeLine">      ->printPipeline(OS, MapClassName2PassName);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1386</td>
    <td class="codeLine">      ->printPipeline(OS, MapClassName2PassName);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1387</td>
    <td class="codeLine">  OS << '<';</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1387</td>
    <td class="codeLine">  OS << '<';</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1388</td>
    <td class="codeLine">  if (LowerGEP)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1388</td>
    <td class="codeLine">  if (LowerGEP)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1389</td>
    <td class="codeLine">    OS << "lower-gep";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1389</td>
    <td class="codeLine">    OS << "lower-gep";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1390</td>
    <td class="codeLine">  OS << '>';</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1390</td>
    <td class="codeLine">  OS << '>';</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1391</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1391</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1392</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1392</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1393</td>
    <td class="codeLine">PreservedAnalyses</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1393</td>
    <td class="codeLine">PreservedAnalyses</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1394</td>
    <td class="codeLine">SeparateConstOffsetFromGEPPass::run(Function &F, FunctionAnalysisManager &AM) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1394</td>
    <td class="codeLine">SeparateConstOffsetFromGEPPass::run(Function &F, FunctionAnalysisManager &AM) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1395</td>
    <td class="codeLine">  auto *DT = &AM.getResult<DominatorTreeAnalysis>(F);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1395</td>
    <td class="codeLine">  auto *DT = &AM.getResult<DominatorTreeAnalysis>(F);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1396</td>
    <td class="codeLine">  auto *LI = &AM.getResult<LoopAnalysis>(F);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1396</td>
    <td class="codeLine">  auto *LI = &AM.getResult<LoopAnalysis>(F);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1397</td>
    <td class="codeLine">  auto *TLI = &AM.getResult<TargetLibraryAnalysis>(F);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1397</td>
    <td class="codeLine">  auto *TLI = &AM.getResult<TargetLibraryAnalysis>(F);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1398</td>
    <td class="codeLine">  auto GetTTI = [&AM](Function &F) -> TargetTransformInfo & {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1398</td>
    <td class="codeLine">  auto GetTTI = [&AM](Function &F) -> TargetTransformInfo & {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1399</td>
    <td class="codeLine">    return AM.getResult<TargetIRAnalysis>(F);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1399</td>
    <td class="codeLine">    return AM.getResult<TargetIRAnalysis>(F);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1400</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1400</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1401</td>
    <td class="codeLine">  SeparateConstOffsetFromGEP Impl(DT, LI, TLI, GetTTI, LowerGEP);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1401</td>
    <td class="codeLine">  SeparateConstOffsetFromGEP Impl(DT, LI, TLI, GetTTI, LowerGEP);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1402</td>
    <td class="codeLine">  if (!Impl.run(F))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1402</td>
    <td class="codeLine">  if (!Impl.run(F))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1403</td>
    <td class="codeLine">    return PreservedAnalyses::all();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1403</td>
    <td class="codeLine">    return PreservedAnalyses::all();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1404</td>
    <td class="codeLine">  PreservedAnalyses PA;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1404</td>
    <td class="codeLine">  PreservedAnalyses PA;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1405</td>
    <td class="codeLine">  PA.preserveSet<CFGAnalyses>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1405</td>
    <td class="codeLine">  PA.preserveSet<CFGAnalyses>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1406</td>
    <td class="codeLine">  return PA;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1406</td>
    <td class="codeLine">  return PA;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1407</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1407</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1408</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1408</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
</table>
    </div>
    <button id="myBtn" onclick="topFunction()" title="Go to top" type="button">Top</button>
    <script src="../Javascript/drop_down.js"></script>
    <script src="../Javascript/top_button.js"></script>
  </body>
</html>