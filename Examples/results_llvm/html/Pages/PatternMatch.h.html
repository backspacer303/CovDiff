<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>PatternMatch.h</title>
    <link rel="stylesheet" href="../Style/style.css" />
  </head>
  <body>
    <div class="headerDiv">
      <h1>
        Code Coverage
      </h1>
      <p>
        Source file: /home/nikola/Desktop/llvm-project/llvm/include/llvm/IR/PatternMatch.h
      </p>
    </div>
    <button class="collapsible" type="button">Open Summary Report</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Summary Report</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line number</th>
    <th class="mainTh">Line</th>
    <th class="mainTh">Number of hits</th>
    <th class="mainTh">Tests that cover line</th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="">//===- PatternMatch.h - Match on the LLVM IR --------------------*- C++ -*-===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="">// This file provides a simple and efficient mechanism for performing general</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="">// tree-based pattern matches on the LLVM IR. The power of these routines is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="">// that it allows you to write concise patterns that are expressive and easy to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="">// understand. The other major advantage of this is that it allows you to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="">// trivially capture/bind elements in the pattern to variables. For example,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="">// you can do something like this:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="">//  Value *Exp = ...</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="">//  Value *X, *Y;  ConstantInt *C1, *C2;      // (X & C1) | (Y & C2)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="">//  if (match(Exp, m_Or(m_And(m_Value(X), m_ConstantInt(C1)),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="">//                      m_And(m_Value(Y), m_ConstantInt(C2))))) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="">//    ... Pattern is matched and variables are bound ...</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="">//  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="">// This is primarily useful to things like the instruction combiner, but can</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="">// also be useful for static analysis tools or code generators.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="">#ifndef LLVM_IR_PATTERNMATCH_H</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="">#define LLVM_IR_PATTERNMATCH_H</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="">#include "llvm/ADT/APFloat.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="">#include "llvm/ADT/APInt.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="">#include "llvm/IR/Constant.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="">#include "llvm/IR/Constants.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="">#include "llvm/IR/DataLayout.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="">#include "llvm/IR/InstrTypes.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="">#include "llvm/IR/Instruction.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="">#include "llvm/IR/Instructions.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="">#include "llvm/IR/IntrinsicInst.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="">#include "llvm/IR/Intrinsics.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="">#include "llvm/IR/Operator.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="">#include "llvm/IR/Value.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="">#include "llvm/Support/Casting.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="">#include <cstdint></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="">namespace llvm {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="">namespace PatternMatch {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="coveredLine">template <typename Val, typename Pattern> bool match(Val *V, const Pattern &P) {</td>
    <td>0</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="coveredLine">  return const_cast<Pattern &>(P).match(V);</td>
    <td>0</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="">template <typename Pattern> bool match(ArrayRef<int> Mask, const Pattern &P) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="">  return const_cast<Pattern &>(P).match(Mask);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="">template <typename SubPattern_t> struct OneUse_match {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="">  SubPattern_t SubPattern;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="uncoveredLine">  OneUse_match(const SubPattern_t &SP) : SubPattern(SP) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="uncoveredLine">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="uncoveredLine">    return V->hasOneUse() && SubPattern.match(V);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="uncoveredLine">template <typename T> inline OneUse_match<T> m_OneUse(const T &SubPattern) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="uncoveredLine">  return SubPattern;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="">template <typename Class> struct class_match {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="uncoveredLine">  template <typename ITy> bool match(ITy *V) { return isa<Class>(V); }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="">/// Match an arbitrary value and ignore it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="uncoveredLine">inline class_match<Value> m_Value() { return class_match<Value>(); }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="">/// Match an arbitrary unary operation and ignore it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="">inline class_match<UnaryOperator> m_UnOp() {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="">  return class_match<UnaryOperator>();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="">/// Match an arbitrary binary operation and ignore it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="">inline class_match<BinaryOperator> m_BinOp() {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="">  return class_match<BinaryOperator>();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="">/// Matches any compare instruction and ignore it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="">inline class_match<CmpInst> m_Cmp() { return class_match<CmpInst>(); }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="">struct undef_match {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="">  static bool check(const Value *V) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="">    if (isa<UndefValue>(V))</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="">      return true;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="">    const auto *CA = dyn_cast<ConstantAggregate>(V);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="">    if (!CA)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="">      return false;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="">    SmallPtrSet<const ConstantAggregate *, 8> Seen;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="">    SmallVector<const ConstantAggregate *, 8> Worklist;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="">    // Either UndefValue, PoisonValue, or an aggregate that only contains</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="">    // these is accepted by matcher.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="">    // CheckValue returns false if CA cannot satisfy this constraint.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="">    auto CheckValue = [&](const ConstantAggregate *CA) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="">      for (const Value *Op : CA->operand_values()) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="">        if (isa<UndefValue>(Op))</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="">          continue;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="">        const auto *CA = dyn_cast<ConstantAggregate>(Op);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="">        if (!CA)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="">          return false;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="">        if (Seen.insert(CA).second)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="">          Worklist.emplace_back(CA);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="">      return true;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="">    };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="">    if (!CheckValue(CA))</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="">      return false;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="">    while (!Worklist.empty()) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="">      if (!CheckValue(Worklist.pop_back_val()))</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="">        return false;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="">    return true;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="">  template <typename ITy> bool match(ITy *V) { return check(V); }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="">/// Match an arbitrary undef constant. This matches poison as well.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="">/// If this is an aggregate and contains a non-aggregate element that is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="">/// neither undef nor poison, the aggregate is not matched.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="">inline auto m_Undef() { return undef_match(); }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="">/// Match an arbitrary poison constant.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="">inline class_match<PoisonValue> m_Poison() {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="">  return class_match<PoisonValue>();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="">/// Match an arbitrary Constant and ignore it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="">inline class_match<Constant> m_Constant() { return class_match<Constant>(); }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="">/// Match an arbitrary ConstantInt and ignore it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="">inline class_match<ConstantInt> m_ConstantInt() {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="">  return class_match<ConstantInt>();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="">/// Match an arbitrary ConstantFP and ignore it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="">inline class_match<ConstantFP> m_ConstantFP() {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="">  return class_match<ConstantFP>();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="">struct constantexpr_match {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="">  template <typename ITy> bool match(ITy *V) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="">    auto *C = dyn_cast<Constant>(V);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="">    return C && (isa<ConstantExpr>(C) || C->containsConstantExpression());</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="">/// Match a constant expression or a constant that contains a constant</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="">/// expression.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="">inline constantexpr_match m_ConstantExpr() { return constantexpr_match(); }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="">/// Match an arbitrary basic block value and ignore it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="">inline class_match<BasicBlock> m_BasicBlock() {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="">  return class_match<BasicBlock>();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="">/// Inverting matcher</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="">template <typename Ty> struct match_unless {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="">  Ty M;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="">  match_unless(const Ty &Matcher) : M(Matcher) {}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="">  template <typename ITy> bool match(ITy *V) { return !M.match(V); }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="">/// Match if the inner matcher does *NOT* match.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="">template <typename Ty> inline match_unless<Ty> m_Unless(const Ty &M) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="">  return match_unless<Ty>(M);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="">/// Matching combinators</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="">template <typename LTy, typename RTy> struct match_combine_or {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="">  LTy L;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="">  RTy R;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="uncoveredLine">  match_combine_or(const LTy &Left, const RTy &Right) : L(Left), R(Right) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="uncoveredLine">  template <typename ITy> bool match(ITy *V) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="uncoveredLine">    if (L.match(V))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="uncoveredLine">      return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="uncoveredLine">    if (R.match(V))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="uncoveredLine">      return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="">template <typename LTy, typename RTy> struct match_combine_and {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="">  LTy L;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="">  RTy R;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="uncoveredLine">  match_combine_and(const LTy &Left, const RTy &Right) : L(Left), R(Right) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="uncoveredLine">  template <typename ITy> bool match(ITy *V) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="uncoveredLine">    if (L.match(V))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="uncoveredLine">      if (R.match(V))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="uncoveredLine">        return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="">/// Combine two pattern matchers matching L || R</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="">template <typename LTy, typename RTy></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="uncoveredLine">inline match_combine_or<LTy, RTy> m_CombineOr(const LTy &L, const RTy &R) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="uncoveredLine">  return match_combine_or<LTy, RTy>(L, R);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="">/// Combine two pattern matchers matching L && R</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="">template <typename LTy, typename RTy></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="uncoveredLine">inline match_combine_and<LTy, RTy> m_CombineAnd(const LTy &L, const RTy &R) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="uncoveredLine">  return match_combine_and<LTy, RTy>(L, R);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="">struct apint_match {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="">  const APInt *&Res;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="">  bool AllowUndef;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="uncoveredLine">  apint_match(const APInt *&Res, bool AllowUndef)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="uncoveredLine">      : Res(Res), AllowUndef(AllowUndef) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="uncoveredLine">  template <typename ITy> bool match(ITy *V) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="uncoveredLine">    if (auto *CI = dyn_cast<ConstantInt>(V)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="uncoveredLine">      Res = &CI->getValue();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="uncoveredLine">      return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="uncoveredLine">    if (V->getType()->isVectorTy())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="uncoveredLine">      if (const auto *C = dyn_cast<Constant>(V))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="uncoveredLine">        if (auto *CI =</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="uncoveredLine">                dyn_cast_or_null<ConstantInt>(C->getSplatValue(AllowUndef))) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="uncoveredLine">          Res = &CI->getValue();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="uncoveredLine">          return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="">// Either constexpr if or renaming ConstantFP::getValueAPF to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="">// ConstantFP::getValue is needed to do it via single template</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="">// function for both apint/apfloat.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="">struct apfloat_match {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="">  const APFloat *&Res;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="">  bool AllowUndef;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="uncoveredLine">  apfloat_match(const APFloat *&Res, bool AllowUndef)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="uncoveredLine">      : Res(Res), AllowUndef(AllowUndef) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="uncoveredLine">  template <typename ITy> bool match(ITy *V) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="uncoveredLine">    if (auto *CI = dyn_cast<ConstantFP>(V)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="uncoveredLine">      Res = &CI->getValueAPF();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="uncoveredLine">      return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="uncoveredLine">    if (V->getType()->isVectorTy())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="uncoveredLine">      if (const auto *C = dyn_cast<Constant>(V))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="uncoveredLine">        if (auto *CI =</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="uncoveredLine">                dyn_cast_or_null<ConstantFP>(C->getSplatValue(AllowUndef))) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="uncoveredLine">          Res = &CI->getValueAPF();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="uncoveredLine">          return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="">/// Match a ConstantInt or splatted ConstantVector, binding the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="">/// specified pointer to the contained APInt.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="uncoveredLine">inline apint_match m_APInt(const APInt *&Res) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="">  // Forbid undefs by default to maintain previous behavior.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="uncoveredLine">  return apint_match(Res, /* AllowUndef */ false);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="">/// Match APInt while allowing undefs in splat vector constants.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="">inline apint_match m_APIntAllowUndef(const APInt *&Res) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="">  return apint_match(Res, /* AllowUndef */ true);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="">/// Match APInt while forbidding undefs in splat vector constants.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="">inline apint_match m_APIntForbidUndef(const APInt *&Res) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="">  return apint_match(Res, /* AllowUndef */ false);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="">/// Match a ConstantFP or splatted ConstantVector, binding the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="">/// specified pointer to the contained APFloat.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="uncoveredLine">inline apfloat_match m_APFloat(const APFloat *&Res) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="">  // Forbid undefs by default to maintain previous behavior.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="uncoveredLine">  return apfloat_match(Res, /* AllowUndef */ false);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="">/// Match APFloat while allowing undefs in splat vector constants.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="">inline apfloat_match m_APFloatAllowUndef(const APFloat *&Res) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="">  return apfloat_match(Res, /* AllowUndef */ true);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="">/// Match APFloat while forbidding undefs in splat vector constants.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="">inline apfloat_match m_APFloatForbidUndef(const APFloat *&Res) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="">  return apfloat_match(Res, /* AllowUndef */ false);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="">template <int64_t Val> struct constantint_match {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="">  template <typename ITy> bool match(ITy *V) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="">    if (const auto *CI = dyn_cast<ConstantInt>(V)) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="">      const APInt &CIV = CI->getValue();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="">      if (Val >= 0)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="">        return CIV == static_cast<uint64_t>(Val);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="">      // If Val is negative, and CI is shorter than it, truncate to the right</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="">      // number of bits.  If it is larger, then we have to sign extend.  Just</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="">      // compare their negated values.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="">      return -CIV == -Val;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="">    return false;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="">/// Match a ConstantInt with a specific value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="">template <int64_t Val> inline constantint_match<Val> m_ConstantInt() {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="">  return constantint_match<Val>();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="">/// This helper class is used to match constant scalars, vector splats,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="">/// and fixed width vectors that satisfy a specified predicate.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="">/// For fixed width vector constants, undefined elements are ignored.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="">template <typename Predicate, typename ConstantVal></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="">struct cstval_pred_ty : public Predicate {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="uncoveredLine">  template <typename ITy> bool match(ITy *V) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="uncoveredLine">    if (const auto *CV = dyn_cast<ConstantVal>(V))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="uncoveredLine">      return this->isValue(CV->getValue());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="uncoveredLine">    if (const auto *VTy = dyn_cast<VectorType>(V->getType())) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="uncoveredLine">      if (const auto *C = dyn_cast<Constant>(V)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="uncoveredLine">        if (const auto *CV = dyn_cast_or_null<ConstantVal>(C->getSplatValue()))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="uncoveredLine">          return this->isValue(CV->getValue());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="">        // Number of elements of a scalable vector unknown at compile time</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="uncoveredLine">        auto *FVTy = dyn_cast<FixedVectorType>(VTy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="uncoveredLine">        if (!FVTy)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="uncoveredLine">          return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="">        // Non-splat vector constant: check each element for a match.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="uncoveredLine">        unsigned NumElts = FVTy->getNumElements();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="uncoveredLine">        assert(NumElts != 0 && "Constant vector with no elements?");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="uncoveredLine">        bool HasNonUndefElements = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="uncoveredLine">        for (unsigned i = 0; i != NumElts; ++i) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="uncoveredLine">          Constant *Elt = C->getAggregateElement(i);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="uncoveredLine">          if (!Elt)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="uncoveredLine">            return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="uncoveredLine">          if (isa<UndefValue>(Elt))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="uncoveredLine">            continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="uncoveredLine">          auto *CV = dyn_cast<ConstantVal>(Elt);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="uncoveredLine">          if (!CV || !this->isValue(CV->getValue()))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="uncoveredLine">            return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="uncoveredLine">          HasNonUndefElements = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="uncoveredLine">        return HasNonUndefElements;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="">/// specialization of cstval_pred_ty for ConstantInt</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="">template <typename Predicate></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="">using cst_pred_ty = cstval_pred_ty<Predicate, ConstantInt>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="">/// specialization of cstval_pred_ty for ConstantFP</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="">template <typename Predicate></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="">using cstfp_pred_ty = cstval_pred_ty<Predicate, ConstantFP>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="">/// This helper class is used to match scalar and vector constants that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="">/// satisfy a specified predicate, and bind them to an APInt.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="">template <typename Predicate> struct api_pred_ty : public Predicate {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="">  const APInt *&Res;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="uncoveredLine">  api_pred_ty(const APInt *&R) : Res(R) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="uncoveredLine">  template <typename ITy> bool match(ITy *V) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="uncoveredLine">    if (const auto *CI = dyn_cast<ConstantInt>(V))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="uncoveredLine">      if (this->isValue(CI->getValue())) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="uncoveredLine">        Res = &CI->getValue();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="uncoveredLine">        return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="uncoveredLine">    if (V->getType()->isVectorTy())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="uncoveredLine">      if (const auto *C = dyn_cast<Constant>(V))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="uncoveredLine">        if (auto *CI = dyn_cast_or_null<ConstantInt>(C->getSplatValue()))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="uncoveredLine">          if (this->isValue(CI->getValue())) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="uncoveredLine">            Res = &CI->getValue();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="uncoveredLine">            return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="">          }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="">/// This helper class is used to match scalar and vector constants that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="">/// satisfy a specified predicate, and bind them to an APFloat.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="">/// Undefs are allowed in splat vector constants.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="">template <typename Predicate> struct apf_pred_ty : public Predicate {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="">  const APFloat *&Res;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="">  apf_pred_ty(const APFloat *&R) : Res(R) {}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="">  template <typename ITy> bool match(ITy *V) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="">    if (const auto *CI = dyn_cast<ConstantFP>(V))</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="">      if (this->isValue(CI->getValue())) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="">        Res = &CI->getValue();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="">        return true;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="">    if (V->getType()->isVectorTy())</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="">      if (const auto *C = dyn_cast<Constant>(V))</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="">        if (auto *CI = dyn_cast_or_null<ConstantFP>(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="">                C->getSplatValue(/* AllowUndef */ true)))</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="">          if (this->isValue(CI->getValue())) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="">            Res = &CI->getValue();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="">            return true;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="">          }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="">    return false;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="">///////////////////////////////////////////////////////////////////////////////</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="">// Encapsulate constant value queries for use in templated predicate matchers.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="">// This allows checking if constants match using compound predicates and works</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="">// with vector constants, possibly with relaxed constraints. For example, ignore</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="">// undef values.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="">///////////////////////////////////////////////////////////////////////////////</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="">struct is_any_apint {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="">  bool isValue(const APInt &C) { return true; }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="">/// Match an integer or vector with any integral constant.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="">/// For vectors, this includes constants with undefined elements.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="">inline cst_pred_ty<is_any_apint> m_AnyIntegralConstant() {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="">  return cst_pred_ty<is_any_apint>();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="">struct is_shifted_mask {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="">  bool isValue(const APInt &C) { return C.isShiftedMask(); }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="">inline cst_pred_ty<is_shifted_mask> m_ShiftedMask() {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="">  return cst_pred_ty<is_shifted_mask>();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="">struct is_all_ones {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="uncoveredLine">  bool isValue(const APInt &C) { return C.isAllOnes(); }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="">/// Match an integer or vector with all bits set.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="">/// For vectors, this includes constants with undefined elements.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="uncoveredLine">inline cst_pred_ty<is_all_ones> m_AllOnes() {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="uncoveredLine">  return cst_pred_ty<is_all_ones>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="">struct is_maxsignedvalue {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="">  bool isValue(const APInt &C) { return C.isMaxSignedValue(); }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="">/// Match an integer or vector with values having all bits except for the high</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="">/// bit set (0x7f...).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="">/// For vectors, this includes constants with undefined elements.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="">inline cst_pred_ty<is_maxsignedvalue> m_MaxSignedValue() {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="">  return cst_pred_ty<is_maxsignedvalue>();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="">inline api_pred_ty<is_maxsignedvalue> m_MaxSignedValue(const APInt *&V) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="">  return V;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="">struct is_negative {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="">  bool isValue(const APInt &C) { return C.isNegative(); }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="">/// Match an integer or vector of negative values.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="">/// For vectors, this includes constants with undefined elements.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="">inline cst_pred_ty<is_negative> m_Negative() {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="">  return cst_pred_ty<is_negative>();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="">inline api_pred_ty<is_negative> m_Negative(const APInt *&V) { return V; }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="">struct is_nonnegative {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="">  bool isValue(const APInt &C) { return C.isNonNegative(); }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="">/// Match an integer or vector of non-negative values.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="">/// For vectors, this includes constants with undefined elements.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="">inline cst_pred_ty<is_nonnegative> m_NonNegative() {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="">  return cst_pred_ty<is_nonnegative>();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="">inline api_pred_ty<is_nonnegative> m_NonNegative(const APInt *&V) { return V; }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="">struct is_strictlypositive {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="">  bool isValue(const APInt &C) { return C.isStrictlyPositive(); }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="">/// Match an integer or vector of strictly positive values.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="">/// For vectors, this includes constants with undefined elements.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="">inline cst_pred_ty<is_strictlypositive> m_StrictlyPositive() {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class="">  return cst_pred_ty<is_strictlypositive>();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="">inline api_pred_ty<is_strictlypositive> m_StrictlyPositive(const APInt *&V) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="">  return V;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="">struct is_nonpositive {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="">  bool isValue(const APInt &C) { return C.isNonPositive(); }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class="">/// Match an integer or vector of non-positive values.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="">/// For vectors, this includes constants with undefined elements.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="">inline cst_pred_ty<is_nonpositive> m_NonPositive() {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="">  return cst_pred_ty<is_nonpositive>();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="">inline api_pred_ty<is_nonpositive> m_NonPositive(const APInt *&V) { return V; }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class="">struct is_one {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="uncoveredLine">  bool isValue(const APInt &C) { return C.isOne(); }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="">/// Match an integer 1 or a vector with all elements equal to 1.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="">/// For vectors, this includes constants with undefined elements.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="uncoveredLine">inline cst_pred_ty<is_one> m_One() { return cst_pred_ty<is_one>(); }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="">struct is_zero_int {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="uncoveredLine">  bool isValue(const APInt &C) { return C.isZero(); }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="">/// Match an integer 0 or a vector with all elements equal to 0.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="">/// For vectors, this includes constants with undefined elements.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="uncoveredLine">inline cst_pred_ty<is_zero_int> m_ZeroInt() {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class="uncoveredLine">  return cst_pred_ty<is_zero_int>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="">struct is_zero {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="uncoveredLine">  template <typename ITy> bool match(ITy *V) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="uncoveredLine">    auto *C = dyn_cast<Constant>(V);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="">    // FIXME: this should be able to do something for scalable vectors</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class="uncoveredLine">    return C && (C->isNullValue() || cst_pred_ty<is_zero_int>().match(C));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="">/// Match any null constant or a vector with all elements equal to 0.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="">/// For vectors, this includes constants with undefined elements.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="uncoveredLine">inline is_zero m_Zero() { return is_zero(); }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="">struct is_power2 {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="uncoveredLine">  bool isValue(const APInt &C) { return C.isPowerOf2(); }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="">/// Match an integer or vector power-of-2.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="">/// For vectors, this includes constants with undefined elements.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="uncoveredLine">inline cst_pred_ty<is_power2> m_Power2() { return cst_pred_ty<is_power2>(); }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="uncoveredLine">inline api_pred_ty<is_power2> m_Power2(const APInt *&V) { return V; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="">struct is_negated_power2 {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="">  bool isValue(const APInt &C) { return C.isNegatedPowerOf2(); }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="">/// Match a integer or vector negated power-of-2.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="">/// For vectors, this includes constants with undefined elements.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="">inline cst_pred_ty<is_negated_power2> m_NegatedPower2() {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="">  return cst_pred_ty<is_negated_power2>();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="">inline api_pred_ty<is_negated_power2> m_NegatedPower2(const APInt *&V) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="">  return V;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="">struct is_power2_or_zero {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="uncoveredLine">  bool isValue(const APInt &C) { return !C || C.isPowerOf2(); }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="">/// Match an integer or vector of 0 or power-of-2 values.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="">/// For vectors, this includes constants with undefined elements.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="uncoveredLine">inline cst_pred_ty<is_power2_or_zero> m_Power2OrZero() {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="uncoveredLine">  return cst_pred_ty<is_power2_or_zero>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="">inline api_pred_ty<is_power2_or_zero> m_Power2OrZero(const APInt *&V) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="">  return V;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class="">struct is_sign_mask {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="uncoveredLine">  bool isValue(const APInt &C) { return C.isSignMask(); }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class="">/// Match an integer or vector with only the sign bit(s) set.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="">/// For vectors, this includes constants with undefined elements.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="uncoveredLine">inline cst_pred_ty<is_sign_mask> m_SignMask() {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="uncoveredLine">  return cst_pred_ty<is_sign_mask>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="">struct is_lowbit_mask {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="">  bool isValue(const APInt &C) { return C.isMask(); }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="">/// Match an integer or vector with only the low bit(s) set.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="">/// For vectors, this includes constants with undefined elements.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="">inline cst_pred_ty<is_lowbit_mask> m_LowBitMask() {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="">  return cst_pred_ty<is_lowbit_mask>();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="">inline api_pred_ty<is_lowbit_mask> m_LowBitMask(const APInt *&V) { return V; }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="">struct icmp_pred_with_threshold {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="">  ICmpInst::Predicate Pred;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="">  const APInt *Thr;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="">  bool isValue(const APInt &C) { return ICmpInst::compare(C, *Thr, Pred); }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="">/// Match an integer or vector with every element comparing 'pred' (eg/ne/...)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="">/// to Threshold. For vectors, this includes constants with undefined elements.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="">inline cst_pred_ty<icmp_pred_with_threshold></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="">m_SpecificInt_ICMP(ICmpInst::Predicate Predicate, const APInt &Threshold) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="">  cst_pred_ty<icmp_pred_with_threshold> P;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="">  P.Pred = Predicate;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="">  P.Thr = &Threshold;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="">  return P;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class="">struct is_nan {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class="">  bool isValue(const APFloat &C) { return C.isNaN(); }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="">/// Match an arbitrary NaN constant. This includes quiet and signalling nans.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="">/// For vectors, this includes constants with undefined elements.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class="">inline cstfp_pred_ty<is_nan> m_NaN() { return cstfp_pred_ty<is_nan>(); }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="">struct is_nonnan {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class="">  bool isValue(const APFloat &C) { return !C.isNaN(); }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="">/// Match a non-NaN FP constant.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="">/// For vectors, this includes constants with undefined elements.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="">inline cstfp_pred_ty<is_nonnan> m_NonNaN() {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="">  return cstfp_pred_ty<is_nonnan>();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="">struct is_inf {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class="">  bool isValue(const APFloat &C) { return C.isInfinity(); }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="">/// Match a positive or negative infinity FP constant.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="">/// For vectors, this includes constants with undefined elements.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="">inline cstfp_pred_ty<is_inf> m_Inf() { return cstfp_pred_ty<is_inf>(); }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="">struct is_noninf {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="">  bool isValue(const APFloat &C) { return !C.isInfinity(); }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="">/// Match a non-infinity FP constant, i.e. finite or NaN.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="">/// For vectors, this includes constants with undefined elements.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="">inline cstfp_pred_ty<is_noninf> m_NonInf() {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="">  return cstfp_pred_ty<is_noninf>();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="">struct is_finite {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="">  bool isValue(const APFloat &C) { return C.isFinite(); }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="">/// Match a finite FP constant, i.e. not infinity or NaN.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="">/// For vectors, this includes constants with undefined elements.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="">inline cstfp_pred_ty<is_finite> m_Finite() {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="">  return cstfp_pred_ty<is_finite>();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="">inline apf_pred_ty<is_finite> m_Finite(const APFloat *&V) { return V; }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="">struct is_finitenonzero {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="">  bool isValue(const APFloat &C) { return C.isFiniteNonZero(); }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="">/// Match a finite non-zero FP constant.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="">/// For vectors, this includes constants with undefined elements.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="">inline cstfp_pred_ty<is_finitenonzero> m_FiniteNonZero() {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="">  return cstfp_pred_ty<is_finitenonzero>();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="">inline apf_pred_ty<is_finitenonzero> m_FiniteNonZero(const APFloat *&V) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="">  return V;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="">struct is_any_zero_fp {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="uncoveredLine">  bool isValue(const APFloat &C) { return C.isZero(); }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="">/// Match a floating-point negative zero or positive zero.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="">/// For vectors, this includes constants with undefined elements.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class="uncoveredLine">inline cstfp_pred_ty<is_any_zero_fp> m_AnyZeroFP() {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="uncoveredLine">  return cstfp_pred_ty<is_any_zero_fp>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class="">struct is_pos_zero_fp {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="">  bool isValue(const APFloat &C) { return C.isPosZero(); }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="">/// Match a floating-point positive zero.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="">/// For vectors, this includes constants with undefined elements.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="">inline cstfp_pred_ty<is_pos_zero_fp> m_PosZeroFP() {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="">  return cstfp_pred_ty<is_pos_zero_fp>();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class="">struct is_neg_zero_fp {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="">  bool isValue(const APFloat &C) { return C.isNegZero(); }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class="">/// Match a floating-point negative zero.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class="">/// For vectors, this includes constants with undefined elements.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class="">inline cstfp_pred_ty<is_neg_zero_fp> m_NegZeroFP() {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class="">  return cstfp_pred_ty<is_neg_zero_fp>();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class="">struct is_non_zero_fp {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="">  bool isValue(const APFloat &C) { return C.isNonZero(); }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class="">/// Match a floating-point non-zero.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class="">/// For vectors, this includes constants with undefined elements.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class="">inline cstfp_pred_ty<is_non_zero_fp> m_NonZeroFP() {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="">  return cstfp_pred_ty<is_non_zero_fp>();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="">///////////////////////////////////////////////////////////////////////////////</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="">template <typename Class> struct bind_ty {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class="">  Class *&VR;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class="coveredLine">  bind_ty(Class *&V) : VR(V) {}</td>
    <td>8</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="uncoveredLine">  template <typename ITy> bool match(ITy *V) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class="uncoveredLine">    if (auto *CV = dyn_cast<Class>(V)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class="uncoveredLine">      VR = CV;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="uncoveredLine">      return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class="">/// Match a value, capturing it if we match.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class="uncoveredLine">inline bind_ty<Value> m_Value(Value *&V) { return V; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="coveredLine">inline bind_ty<const Value> m_Value(const Value *&V) { return V; }</td>
    <td>8</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="">/// Match an instruction, capturing it if we match.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class="">inline bind_ty<Instruction> m_Instruction(Instruction *&I) { return I; }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="">/// Match a unary operator, capturing it if we match.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class="">inline bind_ty<UnaryOperator> m_UnOp(UnaryOperator *&I) { return I; }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class="">/// Match a binary operator, capturing it if we match.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class="">inline bind_ty<BinaryOperator> m_BinOp(BinaryOperator *&I) { return I; }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="">/// Match a with overflow intrinsic, capturing it if we match.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class="">inline bind_ty<WithOverflowInst> m_WithOverflowInst(WithOverflowInst *&I) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class="">  return I;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="">inline bind_ty<const WithOverflowInst></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="uncoveredLine">m_WithOverflowInst(const WithOverflowInst *&I) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class="uncoveredLine">  return I;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class="">/// Match a Constant, capturing the value if we match.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class="uncoveredLine">inline bind_ty<Constant> m_Constant(Constant *&C) { return C; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class="">/// Match a ConstantInt, capturing the value if we match.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class="">inline bind_ty<ConstantInt> m_ConstantInt(ConstantInt *&CI) { return CI; }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="">/// Match a ConstantFP, capturing the value if we match.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="">inline bind_ty<ConstantFP> m_ConstantFP(ConstantFP *&C) { return C; }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class="">/// Match a ConstantExpr, capturing the value if we match.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="">inline bind_ty<ConstantExpr> m_ConstantExpr(ConstantExpr *&C) { return C; }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="">/// Match a basic block value, capturing it if we match.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class="uncoveredLine">inline bind_ty<BasicBlock> m_BasicBlock(BasicBlock *&V) { return V; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class="">inline bind_ty<const BasicBlock> m_BasicBlock(const BasicBlock *&V) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class="">  return V;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="">/// Match an arbitrary immediate Constant and ignore it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="">inline match_combine_and<class_match<Constant>,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="">                         match_unless<constantexpr_match>></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="">m_ImmConstant() {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class="">  return m_CombineAnd(m_Constant(), m_Unless(m_ConstantExpr()));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="">/// Match an immediate Constant, capturing the value if we match.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class="">inline match_combine_and<bind_ty<Constant>,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class="">                         match_unless<constantexpr_match>></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class="">m_ImmConstant(Constant *&C) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="">  return m_CombineAnd(m_Constant(C), m_Unless(m_ConstantExpr()));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="">/// Match a specified Value*.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class="">struct specificval_ty {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="">  const Value *Val;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="uncoveredLine">  specificval_ty(const Value *V) : Val(V) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class="uncoveredLine">  template <typename ITy> bool match(ITy *V) { return V == Val; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="">/// Match if we have a specific specified value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class="uncoveredLine">inline specificval_ty m_Specific(const Value *V) { return V; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="">/// Stores a reference to the Value *, not the Value * itself,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="">/// thus can be used in commutative matchers.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class="">template <typename Class> struct deferredval_ty {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class="">  Class *const &Val;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class="uncoveredLine">  deferredval_ty(Class *const &V) : Val(V) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class="uncoveredLine">  template <typename ITy> bool match(ITy *const V) { return V == Val; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class="">/// Like m_Specific(), but works if the specific value to match is determined</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="">/// as part of the same match() expression. For example:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class="">/// m_Add(m_Value(X), m_Specific(X)) is incorrect, because m_Specific() will</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="">/// bind X before the pattern match starts.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class="">/// m_Add(m_Value(X), m_Deferred(X)) is correct, and will check against</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class="">/// whichever value m_Value(X) populated.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class="uncoveredLine">inline deferredval_ty<Value> m_Deferred(Value *const &V) { return V; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class="">inline deferredval_ty<const Value> m_Deferred(const Value *const &V) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class="">  return V;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class="">/// Match a specified floating point value or vector of all elements of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class="">/// that value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class="">struct specific_fpval {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class="">  double Val;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class="">  specific_fpval(double V) : Val(V) {}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class="">  template <typename ITy> bool match(ITy *V) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class="">    if (const auto *CFP = dyn_cast<ConstantFP>(V))</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class="">      return CFP->isExactlyValue(Val);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class="">    if (V->getType()->isVectorTy())</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class="">      if (const auto *C = dyn_cast<Constant>(V))</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class="">        if (auto *CFP = dyn_cast_or_null<ConstantFP>(C->getSplatValue()))</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class="">          return CFP->isExactlyValue(Val);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class="">    return false;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class="">/// Match a specific floating point value or vector with all elements</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class="">/// equal to the value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class="">inline specific_fpval m_SpecificFP(double V) { return specific_fpval(V); }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class="">/// Match a float 1.0 or vector with all elements equal to 1.0.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class="">inline specific_fpval m_FPOne() { return m_SpecificFP(1.0); }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class="">struct bind_const_intval_ty {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class="">  uint64_t &VR;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class="uncoveredLine">  bind_const_intval_ty(uint64_t &V) : VR(V) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class="uncoveredLine">  template <typename ITy> bool match(ITy *V) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class="uncoveredLine">    if (const auto *CV = dyn_cast<ConstantInt>(V))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class="uncoveredLine">      if (CV->getValue().ule(UINT64_MAX)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class="uncoveredLine">        VR = CV->getZExtValue();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class="uncoveredLine">        return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class="">/// Match a specified integer value or vector of all elements of that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class="">/// value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class="">template <bool AllowUndefs> struct specific_intval {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class="">  APInt Val;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class="uncoveredLine">  specific_intval(APInt V) : Val(std::move(V)) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class="uncoveredLine">  template <typename ITy> bool match(ITy *V) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class="uncoveredLine">    const auto *CI = dyn_cast<ConstantInt>(V);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class="uncoveredLine">    if (!CI && V->getType()->isVectorTy())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class="uncoveredLine">      if (const auto *C = dyn_cast<Constant>(V))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class="uncoveredLine">        CI = dyn_cast_or_null<ConstantInt>(C->getSplatValue(AllowUndefs));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class="uncoveredLine">    return CI && APInt::isSameValue(CI->getValue(), Val);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class="">/// Match a specific integer value or vector with all elements equal to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class="">/// the value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class="uncoveredLine">inline specific_intval<false> m_SpecificInt(APInt V) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class="uncoveredLine">  return specific_intval<false>(std::move(V));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class="uncoveredLine">inline specific_intval<false> m_SpecificInt(uint64_t V) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class="uncoveredLine">  return m_SpecificInt(APInt(64, V));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="">inline specific_intval<true> m_SpecificIntAllowUndef(APInt V) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class="">  return specific_intval<true>(std::move(V));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">872</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">873</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">874</td>
    <td class="">inline specific_intval<true> m_SpecificIntAllowUndef(uint64_t V) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">875</td>
    <td class="">  return m_SpecificIntAllowUndef(APInt(64, V));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">876</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">877</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">878</td>
    <td class="">/// Match a ConstantInt and bind to its value.  This does not match</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">879</td>
    <td class="">/// ConstantInts wider than 64-bits.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">880</td>
    <td class="uncoveredLine">inline bind_const_intval_ty m_ConstantInt(uint64_t &V) { return V; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">881</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">882</td>
    <td class="">/// Match a specified basic block value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">883</td>
    <td class="">struct specific_bbval {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">884</td>
    <td class="">  BasicBlock *Val;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">885</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">886</td>
    <td class="">  specific_bbval(BasicBlock *Val) : Val(Val) {}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">887</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">888</td>
    <td class="">  template <typename ITy> bool match(ITy *V) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">889</td>
    <td class="">    const auto *BB = dyn_cast<BasicBlock>(V);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">890</td>
    <td class="">    return BB && BB == Val;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">891</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">892</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">893</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">894</td>
    <td class="">/// Match a specific basic block value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">895</td>
    <td class="">inline specific_bbval m_SpecificBB(BasicBlock *BB) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">896</td>
    <td class="">  return specific_bbval(BB);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">897</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">898</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">899</td>
    <td class="">/// A commutative-friendly version of m_Specific().</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">900</td>
    <td class="">inline deferredval_ty<BasicBlock> m_Deferred(BasicBlock *const &BB) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">901</td>
    <td class="">  return BB;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">902</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">903</td>
    <td class="">inline deferredval_ty<const BasicBlock></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">904</td>
    <td class="">m_Deferred(const BasicBlock *const &BB) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">905</td>
    <td class="">  return BB;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">906</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">907</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">908</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">909</td>
    <td class="">// Matcher for any binary operator.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">910</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">911</td>
    <td class="">template <typename LHS_t, typename RHS_t, bool Commutable = false></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">912</td>
    <td class="">struct AnyBinaryOp_match {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">913</td>
    <td class="">  LHS_t L;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">914</td>
    <td class="">  RHS_t R;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">915</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">916</td>
    <td class="">  // The evaluation order is always stable, regardless of Commutability.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">917</td>
    <td class="">  // The LHS is always matched first.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">918</td>
    <td class="uncoveredLine">  AnyBinaryOp_match(const LHS_t &LHS, const RHS_t &RHS) : L(LHS), R(RHS) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">919</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">920</td>
    <td class="uncoveredLine">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">921</td>
    <td class="uncoveredLine">    if (auto *I = dyn_cast<BinaryOperator>(V))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">922</td>
    <td class="uncoveredLine">      return (L.match(I->getOperand(0)) && R.match(I->getOperand(1))) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">923</td>
    <td class="uncoveredLine">             (Commutable && L.match(I->getOperand(1)) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">924</td>
    <td class="uncoveredLine">              R.match(I->getOperand(0)));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">925</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">926</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">927</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">928</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">929</td>
    <td class="">template <typename LHS, typename RHS></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">930</td>
    <td class="">inline AnyBinaryOp_match<LHS, RHS> m_BinOp(const LHS &L, const RHS &R) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">931</td>
    <td class="">  return AnyBinaryOp_match<LHS, RHS>(L, R);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">932</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">933</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">934</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">935</td>
    <td class="">// Matcher for any unary operator.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">936</td>
    <td class="">// TODO fuse unary, binary matcher into n-ary matcher</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">937</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">938</td>
    <td class="">template <typename OP_t> struct AnyUnaryOp_match {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">939</td>
    <td class="">  OP_t X;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">940</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">941</td>
    <td class="">  AnyUnaryOp_match(const OP_t &X) : X(X) {}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">942</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">943</td>
    <td class="">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">944</td>
    <td class="">    if (auto *I = dyn_cast<UnaryOperator>(V))</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">945</td>
    <td class="">      return X.match(I->getOperand(0));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">946</td>
    <td class="">    return false;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">947</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">948</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">949</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">950</td>
    <td class="">template <typename OP_t> inline AnyUnaryOp_match<OP_t> m_UnOp(const OP_t &X) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">951</td>
    <td class="">  return AnyUnaryOp_match<OP_t>(X);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">952</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">953</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">954</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">955</td>
    <td class="">// Matchers for specific binary operators.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">956</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">957</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">958</td>
    <td class="">template <typename LHS_t, typename RHS_t, unsigned Opcode,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">959</td>
    <td class="">          bool Commutable = false></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">960</td>
    <td class="">struct BinaryOp_match {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">961</td>
    <td class="">  LHS_t L;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">962</td>
    <td class="">  RHS_t R;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">963</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">964</td>
    <td class="">  // The evaluation order is always stable, regardless of Commutability.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">965</td>
    <td class="">  // The LHS is always matched first.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">966</td>
    <td class="uncoveredLine">  BinaryOp_match(const LHS_t &LHS, const RHS_t &RHS) : L(LHS), R(RHS) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">967</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">968</td>
    <td class="uncoveredLine">  template <typename OpTy> inline bool match(unsigned Opc, OpTy *V) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">969</td>
    <td class="uncoveredLine">    if (V->getValueID() == Value::InstructionVal + Opc) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">970</td>
    <td class="uncoveredLine">      auto *I = cast<BinaryOperator>(V);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">971</td>
    <td class="uncoveredLine">      return (L.match(I->getOperand(0)) && R.match(I->getOperand(1))) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">972</td>
    <td class="uncoveredLine">             (Commutable && L.match(I->getOperand(1)) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">973</td>
    <td class="uncoveredLine">              R.match(I->getOperand(0)));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">974</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">975</td>
    <td class="uncoveredLine">    if (auto *CE = dyn_cast<ConstantExpr>(V))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">976</td>
    <td class="uncoveredLine">      return CE->getOpcode() == Opc &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">977</td>
    <td class="uncoveredLine">             ((L.match(CE->getOperand(0)) && R.match(CE->getOperand(1))) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">978</td>
    <td class="uncoveredLine">              (Commutable && L.match(CE->getOperand(1)) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">979</td>
    <td class="uncoveredLine">               R.match(CE->getOperand(0))));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">980</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">981</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">982</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">983</td>
    <td class="uncoveredLine">  template <typename OpTy> bool match(OpTy *V) { return match(Opcode, V); }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">984</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">985</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">986</td>
    <td class="">template <typename LHS, typename RHS></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">987</td>
    <td class="uncoveredLine">inline BinaryOp_match<LHS, RHS, Instruction::Add> m_Add(const LHS &L,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">988</td>
    <td class="">                                                        const RHS &R) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">989</td>
    <td class="uncoveredLine">  return BinaryOp_match<LHS, RHS, Instruction::Add>(L, R);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">990</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">991</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">992</td>
    <td class="">template <typename LHS, typename RHS></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">993</td>
    <td class="">inline BinaryOp_match<LHS, RHS, Instruction::FAdd> m_FAdd(const LHS &L,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">994</td>
    <td class="">                                                          const RHS &R) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">995</td>
    <td class="">  return BinaryOp_match<LHS, RHS, Instruction::FAdd>(L, R);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">996</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">997</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">998</td>
    <td class="">template <typename LHS, typename RHS></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">999</td>
    <td class="uncoveredLine">inline BinaryOp_match<LHS, RHS, Instruction::Sub> m_Sub(const LHS &L,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1000</td>
    <td class="">                                                        const RHS &R) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1001</td>
    <td class="uncoveredLine">  return BinaryOp_match<LHS, RHS, Instruction::Sub>(L, R);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1002</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1003</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1004</td>
    <td class="">template <typename LHS, typename RHS></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1005</td>
    <td class="">inline BinaryOp_match<LHS, RHS, Instruction::FSub> m_FSub(const LHS &L,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1006</td>
    <td class="">                                                          const RHS &R) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1007</td>
    <td class="">  return BinaryOp_match<LHS, RHS, Instruction::FSub>(L, R);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1008</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1009</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1010</td>
    <td class="">template <typename Op_t> struct FNeg_match {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1011</td>
    <td class="">  Op_t X;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1012</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1013</td>
    <td class="">  FNeg_match(const Op_t &Op) : X(Op) {}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1014</td>
    <td class="">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1015</td>
    <td class="">    auto *FPMO = dyn_cast<FPMathOperator>(V);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1016</td>
    <td class="">    if (!FPMO)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1017</td>
    <td class="">      return false;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1018</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1019</td>
    <td class="">    if (FPMO->getOpcode() == Instruction::FNeg)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1020</td>
    <td class="">      return X.match(FPMO->getOperand(0));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1021</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1022</td>
    <td class="">    if (FPMO->getOpcode() == Instruction::FSub) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1023</td>
    <td class="">      if (FPMO->hasNoSignedZeros()) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1024</td>
    <td class="">        // With 'nsz', any zero goes.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1025</td>
    <td class="">        if (!cstfp_pred_ty<is_any_zero_fp>().match(FPMO->getOperand(0)))</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1026</td>
    <td class="">          return false;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1027</td>
    <td class="">      } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1028</td>
    <td class="">        // Without 'nsz', we need fsub -0.0, X exactly.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1029</td>
    <td class="">        if (!cstfp_pred_ty<is_neg_zero_fp>().match(FPMO->getOperand(0)))</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1030</td>
    <td class="">          return false;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1031</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1032</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1033</td>
    <td class="">      return X.match(FPMO->getOperand(1));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1034</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1035</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1036</td>
    <td class="">    return false;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1037</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1038</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1039</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1040</td>
    <td class="">/// Match 'fneg X' as 'fsub -0.0, X'.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1041</td>
    <td class="">template <typename OpTy> inline FNeg_match<OpTy> m_FNeg(const OpTy &X) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1042</td>
    <td class="">  return FNeg_match<OpTy>(X);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1043</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1044</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1045</td>
    <td class="">/// Match 'fneg X' as 'fsub +-0.0, X'.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1046</td>
    <td class="">template <typename RHS></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1047</td>
    <td class="">inline BinaryOp_match<cstfp_pred_ty<is_any_zero_fp>, RHS, Instruction::FSub></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1048</td>
    <td class="">m_FNegNSZ(const RHS &X) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1049</td>
    <td class="">  return m_FSub(m_AnyZeroFP(), X);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1050</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1051</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1052</td>
    <td class="">template <typename LHS, typename RHS></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1053</td>
    <td class="uncoveredLine">inline BinaryOp_match<LHS, RHS, Instruction::Mul> m_Mul(const LHS &L,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1054</td>
    <td class="">                                                        const RHS &R) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1055</td>
    <td class="uncoveredLine">  return BinaryOp_match<LHS, RHS, Instruction::Mul>(L, R);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1056</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1057</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1058</td>
    <td class="">template <typename LHS, typename RHS></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1059</td>
    <td class="">inline BinaryOp_match<LHS, RHS, Instruction::FMul> m_FMul(const LHS &L,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1060</td>
    <td class="">                                                          const RHS &R) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1061</td>
    <td class="">  return BinaryOp_match<LHS, RHS, Instruction::FMul>(L, R);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1062</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1063</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1064</td>
    <td class="">template <typename LHS, typename RHS></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1065</td>
    <td class="uncoveredLine">inline BinaryOp_match<LHS, RHS, Instruction::UDiv> m_UDiv(const LHS &L,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1066</td>
    <td class="">                                                          const RHS &R) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1067</td>
    <td class="uncoveredLine">  return BinaryOp_match<LHS, RHS, Instruction::UDiv>(L, R);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1068</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1069</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1070</td>
    <td class="">template <typename LHS, typename RHS></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1071</td>
    <td class="">inline BinaryOp_match<LHS, RHS, Instruction::SDiv> m_SDiv(const LHS &L,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1072</td>
    <td class="">                                                          const RHS &R) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1073</td>
    <td class="">  return BinaryOp_match<LHS, RHS, Instruction::SDiv>(L, R);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1074</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1075</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1076</td>
    <td class="">template <typename LHS, typename RHS></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1077</td>
    <td class="">inline BinaryOp_match<LHS, RHS, Instruction::FDiv> m_FDiv(const LHS &L,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1078</td>
    <td class="">                                                          const RHS &R) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1079</td>
    <td class="">  return BinaryOp_match<LHS, RHS, Instruction::FDiv>(L, R);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1080</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1081</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1082</td>
    <td class="">template <typename LHS, typename RHS></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1083</td>
    <td class="uncoveredLine">inline BinaryOp_match<LHS, RHS, Instruction::URem> m_URem(const LHS &L,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1084</td>
    <td class="">                                                          const RHS &R) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1085</td>
    <td class="uncoveredLine">  return BinaryOp_match<LHS, RHS, Instruction::URem>(L, R);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1086</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1087</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1088</td>
    <td class="">template <typename LHS, typename RHS></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1089</td>
    <td class="uncoveredLine">inline BinaryOp_match<LHS, RHS, Instruction::SRem> m_SRem(const LHS &L,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1090</td>
    <td class="">                                                          const RHS &R) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1091</td>
    <td class="uncoveredLine">  return BinaryOp_match<LHS, RHS, Instruction::SRem>(L, R);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1092</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1093</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1094</td>
    <td class="">template <typename LHS, typename RHS></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1095</td>
    <td class="">inline BinaryOp_match<LHS, RHS, Instruction::FRem> m_FRem(const LHS &L,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1096</td>
    <td class="">                                                          const RHS &R) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1097</td>
    <td class="">  return BinaryOp_match<LHS, RHS, Instruction::FRem>(L, R);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1098</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1099</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1100</td>
    <td class="">template <typename LHS, typename RHS></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1101</td>
    <td class="uncoveredLine">inline BinaryOp_match<LHS, RHS, Instruction::And> m_And(const LHS &L,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1102</td>
    <td class="">                                                        const RHS &R) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1103</td>
    <td class="uncoveredLine">  return BinaryOp_match<LHS, RHS, Instruction::And>(L, R);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1104</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1105</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1106</td>
    <td class="">template <typename LHS, typename RHS></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1107</td>
    <td class="uncoveredLine">inline BinaryOp_match<LHS, RHS, Instruction::Or> m_Or(const LHS &L,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1108</td>
    <td class="">                                                      const RHS &R) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1109</td>
    <td class="uncoveredLine">  return BinaryOp_match<LHS, RHS, Instruction::Or>(L, R);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1110</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1111</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1112</td>
    <td class="">template <typename LHS, typename RHS></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1113</td>
    <td class="">inline BinaryOp_match<LHS, RHS, Instruction::Xor> m_Xor(const LHS &L,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1114</td>
    <td class="">                                                        const RHS &R) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1115</td>
    <td class="">  return BinaryOp_match<LHS, RHS, Instruction::Xor>(L, R);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1116</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1117</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1118</td>
    <td class="">template <typename LHS, typename RHS></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1119</td>
    <td class="uncoveredLine">inline BinaryOp_match<LHS, RHS, Instruction::Shl> m_Shl(const LHS &L,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1120</td>
    <td class="">                                                        const RHS &R) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1121</td>
    <td class="uncoveredLine">  return BinaryOp_match<LHS, RHS, Instruction::Shl>(L, R);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1122</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1123</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1124</td>
    <td class="">template <typename LHS, typename RHS></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1125</td>
    <td class="uncoveredLine">inline BinaryOp_match<LHS, RHS, Instruction::LShr> m_LShr(const LHS &L,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1126</td>
    <td class="">                                                          const RHS &R) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1127</td>
    <td class="uncoveredLine">  return BinaryOp_match<LHS, RHS, Instruction::LShr>(L, R);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1128</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1129</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1130</td>
    <td class="">template <typename LHS, typename RHS></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1131</td>
    <td class="">inline BinaryOp_match<LHS, RHS, Instruction::AShr> m_AShr(const LHS &L,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1132</td>
    <td class="">                                                          const RHS &R) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1133</td>
    <td class="">  return BinaryOp_match<LHS, RHS, Instruction::AShr>(L, R);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1134</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1135</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1136</td>
    <td class="">template <typename LHS_t, typename RHS_t, unsigned Opcode,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1137</td>
    <td class="">          unsigned WrapFlags = 0></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1138</td>
    <td class="">struct OverflowingBinaryOp_match {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1139</td>
    <td class="">  LHS_t L;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1140</td>
    <td class="">  RHS_t R;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1141</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1142</td>
    <td class="uncoveredLine">  OverflowingBinaryOp_match(const LHS_t &LHS, const RHS_t &RHS)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1143</td>
    <td class="uncoveredLine">      : L(LHS), R(RHS) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1144</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1145</td>
    <td class="uncoveredLine">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1146</td>
    <td class="uncoveredLine">    if (auto *Op = dyn_cast<OverflowingBinaryOperator>(V)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1147</td>
    <td class="uncoveredLine">      if (Op->getOpcode() != Opcode)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1148</td>
    <td class="uncoveredLine">        return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1149</td>
    <td class="uncoveredLine">      if ((WrapFlags & OverflowingBinaryOperator::NoUnsignedWrap) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1150</td>
    <td class="uncoveredLine">          !Op->hasNoUnsignedWrap())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1151</td>
    <td class="uncoveredLine">        return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1152</td>
    <td class="uncoveredLine">      if ((WrapFlags & OverflowingBinaryOperator::NoSignedWrap) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1153</td>
    <td class="uncoveredLine">          !Op->hasNoSignedWrap())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1154</td>
    <td class="uncoveredLine">        return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1155</td>
    <td class="uncoveredLine">      return L.match(Op->getOperand(0)) && R.match(Op->getOperand(1));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1156</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1157</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1158</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1159</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1160</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1161</td>
    <td class="">template <typename LHS, typename RHS></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1162</td>
    <td class="">inline OverflowingBinaryOp_match<LHS, RHS, Instruction::Add,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1163</td>
    <td class="">                                 OverflowingBinaryOperator::NoSignedWrap></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1164</td>
    <td class="uncoveredLine">m_NSWAdd(const LHS &L, const RHS &R) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1165</td>
    <td class="">  return OverflowingBinaryOp_match<LHS, RHS, Instruction::Add,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1166</td>
    <td class="">                                   OverflowingBinaryOperator::NoSignedWrap>(L,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1167</td>
    <td class="uncoveredLine">                                                                            R);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1168</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1169</td>
    <td class="">template <typename LHS, typename RHS></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1170</td>
    <td class="">inline OverflowingBinaryOp_match<LHS, RHS, Instruction::Sub,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1171</td>
    <td class="">                                 OverflowingBinaryOperator::NoSignedWrap></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1172</td>
    <td class="uncoveredLine">m_NSWSub(const LHS &L, const RHS &R) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1173</td>
    <td class="uncoveredLine">  return OverflowingBinaryOp_match<LHS, RHS, Instruction::Sub,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1174</td>
    <td class="">                                   OverflowingBinaryOperator::NoSignedWrap>(L,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1175</td>
    <td class="uncoveredLine">                                                                            R);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1176</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1177</td>
    <td class="">template <typename LHS, typename RHS></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1178</td>
    <td class="">inline OverflowingBinaryOp_match<LHS, RHS, Instruction::Mul,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1179</td>
    <td class="">                                 OverflowingBinaryOperator::NoSignedWrap></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1180</td>
    <td class="">m_NSWMul(const LHS &L, const RHS &R) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1181</td>
    <td class="">  return OverflowingBinaryOp_match<LHS, RHS, Instruction::Mul,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1182</td>
    <td class="">                                   OverflowingBinaryOperator::NoSignedWrap>(L,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1183</td>
    <td class="">                                                                            R);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1184</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1185</td>
    <td class="">template <typename LHS, typename RHS></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1186</td>
    <td class="">inline OverflowingBinaryOp_match<LHS, RHS, Instruction::Shl,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1187</td>
    <td class="">                                 OverflowingBinaryOperator::NoSignedWrap></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1188</td>
    <td class="">m_NSWShl(const LHS &L, const RHS &R) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1189</td>
    <td class="">  return OverflowingBinaryOp_match<LHS, RHS, Instruction::Shl,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1190</td>
    <td class="">                                   OverflowingBinaryOperator::NoSignedWrap>(L,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1191</td>
    <td class="">                                                                            R);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1192</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1193</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1194</td>
    <td class="">template <typename LHS, typename RHS></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1195</td>
    <td class="">inline OverflowingBinaryOp_match<LHS, RHS, Instruction::Add,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1196</td>
    <td class="">                                 OverflowingBinaryOperator::NoUnsignedWrap></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1197</td>
    <td class="uncoveredLine">m_NUWAdd(const LHS &L, const RHS &R) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1198</td>
    <td class="">  return OverflowingBinaryOp_match<LHS, RHS, Instruction::Add,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1199</td>
    <td class="">                                   OverflowingBinaryOperator::NoUnsignedWrap>(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1200</td>
    <td class="uncoveredLine">      L, R);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1201</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1202</td>
    <td class="">template <typename LHS, typename RHS></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1203</td>
    <td class="">inline OverflowingBinaryOp_match<LHS, RHS, Instruction::Sub,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1204</td>
    <td class="">                                 OverflowingBinaryOperator::NoUnsignedWrap></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1205</td>
    <td class="uncoveredLine">m_NUWSub(const LHS &L, const RHS &R) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1206</td>
    <td class="uncoveredLine">  return OverflowingBinaryOp_match<LHS, RHS, Instruction::Sub,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1207</td>
    <td class="">                                   OverflowingBinaryOperator::NoUnsignedWrap>(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1208</td>
    <td class="uncoveredLine">      L, R);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1209</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1210</td>
    <td class="">template <typename LHS, typename RHS></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1211</td>
    <td class="">inline OverflowingBinaryOp_match<LHS, RHS, Instruction::Mul,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1212</td>
    <td class="">                                 OverflowingBinaryOperator::NoUnsignedWrap></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1213</td>
    <td class="">m_NUWMul(const LHS &L, const RHS &R) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1214</td>
    <td class="">  return OverflowingBinaryOp_match<LHS, RHS, Instruction::Mul,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1215</td>
    <td class="">                                   OverflowingBinaryOperator::NoUnsignedWrap>(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1216</td>
    <td class="">      L, R);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1217</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1218</td>
    <td class="">template <typename LHS, typename RHS></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1219</td>
    <td class="">inline OverflowingBinaryOp_match<LHS, RHS, Instruction::Shl,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1220</td>
    <td class="">                                 OverflowingBinaryOperator::NoUnsignedWrap></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1221</td>
    <td class="">m_NUWShl(const LHS &L, const RHS &R) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1222</td>
    <td class="">  return OverflowingBinaryOp_match<LHS, RHS, Instruction::Shl,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1223</td>
    <td class="">                                   OverflowingBinaryOperator::NoUnsignedWrap>(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1224</td>
    <td class="">      L, R);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1225</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1226</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1227</td>
    <td class="">template <typename LHS_t, typename RHS_t, bool Commutable = false></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1228</td>
    <td class="">struct SpecificBinaryOp_match</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1229</td>
    <td class="">    : public BinaryOp_match<LHS_t, RHS_t, 0, Commutable> {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1230</td>
    <td class="">  unsigned Opcode;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1231</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1232</td>
    <td class="">  SpecificBinaryOp_match(unsigned Opcode, const LHS_t &LHS, const RHS_t &RHS)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1233</td>
    <td class="">      : BinaryOp_match<LHS_t, RHS_t, 0, Commutable>(LHS, RHS), Opcode(Opcode) {}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1234</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1235</td>
    <td class="">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1236</td>
    <td class="">    return BinaryOp_match<LHS_t, RHS_t, 0, Commutable>::match(Opcode, V);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1237</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1238</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1239</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1240</td>
    <td class="">/// Matches a specific opcode.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1241</td>
    <td class="">template <typename LHS, typename RHS></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1242</td>
    <td class="">inline SpecificBinaryOp_match<LHS, RHS> m_BinOp(unsigned Opcode, const LHS &L,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1243</td>
    <td class="">                                                const RHS &R) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1244</td>
    <td class="">  return SpecificBinaryOp_match<LHS, RHS>(Opcode, L, R);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1245</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1246</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1247</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1248</td>
    <td class="">// Class that matches a group of binary opcodes.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1249</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1250</td>
    <td class="">template <typename LHS_t, typename RHS_t, typename Predicate></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1251</td>
    <td class="">struct BinOpPred_match : Predicate {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1252</td>
    <td class="">  LHS_t L;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1253</td>
    <td class="">  RHS_t R;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1254</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1255</td>
    <td class="uncoveredLine">  BinOpPred_match(const LHS_t &LHS, const RHS_t &RHS) : L(LHS), R(RHS) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1256</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1257</td>
    <td class="uncoveredLine">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1258</td>
    <td class="uncoveredLine">    if (auto *I = dyn_cast<Instruction>(V))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1259</td>
    <td class="uncoveredLine">      return this->isOpType(I->getOpcode()) && L.match(I->getOperand(0)) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1260</td>
    <td class="uncoveredLine">             R.match(I->getOperand(1));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1261</td>
    <td class="uncoveredLine">    if (auto *CE = dyn_cast<ConstantExpr>(V))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1262</td>
    <td class="uncoveredLine">      return this->isOpType(CE->getOpcode()) && L.match(CE->getOperand(0)) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1263</td>
    <td class="uncoveredLine">             R.match(CE->getOperand(1));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1264</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1265</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1266</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1267</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1268</td>
    <td class="">struct is_shift_op {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1269</td>
    <td class="">  bool isOpType(unsigned Opcode) { return Instruction::isShift(Opcode); }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1270</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1271</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1272</td>
    <td class="">struct is_right_shift_op {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1273</td>
    <td class="uncoveredLine">  bool isOpType(unsigned Opcode) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1274</td>
    <td class="uncoveredLine">    return Opcode == Instruction::LShr || Opcode == Instruction::AShr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1275</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1276</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1277</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1278</td>
    <td class="">struct is_logical_shift_op {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1279</td>
    <td class="">  bool isOpType(unsigned Opcode) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1280</td>
    <td class="">    return Opcode == Instruction::LShr || Opcode == Instruction::Shl;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1281</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1282</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1283</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1284</td>
    <td class="">struct is_bitwiselogic_op {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1285</td>
    <td class="">  bool isOpType(unsigned Opcode) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1286</td>
    <td class="">    return Instruction::isBitwiseLogicOp(Opcode);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1287</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1288</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1289</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1290</td>
    <td class="">struct is_idiv_op {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1291</td>
    <td class="">  bool isOpType(unsigned Opcode) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1292</td>
    <td class="">    return Opcode == Instruction::SDiv || Opcode == Instruction::UDiv;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1293</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1294</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1295</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1296</td>
    <td class="">struct is_irem_op {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1297</td>
    <td class="">  bool isOpType(unsigned Opcode) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1298</td>
    <td class="">    return Opcode == Instruction::SRem || Opcode == Instruction::URem;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1299</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1300</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1301</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1302</td>
    <td class="">/// Matches shift operations.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1303</td>
    <td class="">template <typename LHS, typename RHS></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1304</td>
    <td class="">inline BinOpPred_match<LHS, RHS, is_shift_op> m_Shift(const LHS &L,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1305</td>
    <td class="">                                                      const RHS &R) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1306</td>
    <td class="">  return BinOpPred_match<LHS, RHS, is_shift_op>(L, R);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1307</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1308</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1309</td>
    <td class="">/// Matches logical shift operations.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1310</td>
    <td class="">template <typename LHS, typename RHS></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1311</td>
    <td class="uncoveredLine">inline BinOpPred_match<LHS, RHS, is_right_shift_op> m_Shr(const LHS &L,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1312</td>
    <td class="">                                                          const RHS &R) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1313</td>
    <td class="uncoveredLine">  return BinOpPred_match<LHS, RHS, is_right_shift_op>(L, R);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1314</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1315</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1316</td>
    <td class="">/// Matches logical shift operations.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1317</td>
    <td class="">template <typename LHS, typename RHS></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1318</td>
    <td class="">inline BinOpPred_match<LHS, RHS, is_logical_shift_op></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1319</td>
    <td class="">m_LogicalShift(const LHS &L, const RHS &R) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1320</td>
    <td class="">  return BinOpPred_match<LHS, RHS, is_logical_shift_op>(L, R);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1321</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1322</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1323</td>
    <td class="">/// Matches bitwise logic operations.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1324</td>
    <td class="">template <typename LHS, typename RHS></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1325</td>
    <td class="">inline BinOpPred_match<LHS, RHS, is_bitwiselogic_op></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1326</td>
    <td class="">m_BitwiseLogic(const LHS &L, const RHS &R) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1327</td>
    <td class="">  return BinOpPred_match<LHS, RHS, is_bitwiselogic_op>(L, R);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1328</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1329</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1330</td>
    <td class="">/// Matches integer division operations.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1331</td>
    <td class="">template <typename LHS, typename RHS></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1332</td>
    <td class="">inline BinOpPred_match<LHS, RHS, is_idiv_op> m_IDiv(const LHS &L,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1333</td>
    <td class="">                                                    const RHS &R) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1334</td>
    <td class="">  return BinOpPred_match<LHS, RHS, is_idiv_op>(L, R);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1335</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1336</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1337</td>
    <td class="">/// Matches integer remainder operations.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1338</td>
    <td class="">template <typename LHS, typename RHS></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1339</td>
    <td class="">inline BinOpPred_match<LHS, RHS, is_irem_op> m_IRem(const LHS &L,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1340</td>
    <td class="">                                                    const RHS &R) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1341</td>
    <td class="">  return BinOpPred_match<LHS, RHS, is_irem_op>(L, R);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1342</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1343</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1344</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1345</td>
    <td class="">// Class that matches exact binary ops.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1346</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1347</td>
    <td class="">template <typename SubPattern_t> struct Exact_match {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1348</td>
    <td class="">  SubPattern_t SubPattern;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1349</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1350</td>
    <td class="uncoveredLine">  Exact_match(const SubPattern_t &SP) : SubPattern(SP) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1351</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1352</td>
    <td class="uncoveredLine">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1353</td>
    <td class="uncoveredLine">    if (auto *PEO = dyn_cast<PossiblyExactOperator>(V))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1354</td>
    <td class="uncoveredLine">      return PEO->isExact() && SubPattern.match(V);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1355</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1356</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1357</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1358</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1359</td>
    <td class="uncoveredLine">template <typename T> inline Exact_match<T> m_Exact(const T &SubPattern) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1360</td>
    <td class="uncoveredLine">  return SubPattern;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1361</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1362</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1363</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1364</td>
    <td class="">// Matchers for CmpInst classes</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1365</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1366</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1367</td>
    <td class="">template <typename LHS_t, typename RHS_t, typename Class, typename PredicateTy,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1368</td>
    <td class="">          bool Commutable = false></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1369</td>
    <td class="">struct CmpClass_match {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1370</td>
    <td class="">  PredicateTy &Predicate;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1371</td>
    <td class="">  LHS_t L;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1372</td>
    <td class="">  RHS_t R;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1373</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1374</td>
    <td class="">  // The evaluation order is always stable, regardless of Commutability.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1375</td>
    <td class="">  // The LHS is always matched first.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1376</td>
    <td class="uncoveredLine">  CmpClass_match(PredicateTy &Pred, const LHS_t &LHS, const RHS_t &RHS)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1377</td>
    <td class="uncoveredLine">      : Predicate(Pred), L(LHS), R(RHS) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1378</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1379</td>
    <td class="uncoveredLine">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1380</td>
    <td class="uncoveredLine">    if (auto *I = dyn_cast<Class>(V)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1381</td>
    <td class="uncoveredLine">      if (L.match(I->getOperand(0)) && R.match(I->getOperand(1))) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1382</td>
    <td class="uncoveredLine">        Predicate = I->getPredicate();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1383</td>
    <td class="uncoveredLine">        return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1384</td>
    <td class="uncoveredLine">      } else if (Commutable && L.match(I->getOperand(1)) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1385</td>
    <td class="uncoveredLine">                 R.match(I->getOperand(0))) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1386</td>
    <td class="uncoveredLine">        Predicate = I->getSwappedPredicate();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1387</td>
    <td class="uncoveredLine">        return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1388</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1389</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1390</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1391</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1392</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1393</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1394</td>
    <td class="">template <typename LHS, typename RHS></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1395</td>
    <td class="">inline CmpClass_match<LHS, RHS, CmpInst, CmpInst::Predicate></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1396</td>
    <td class="">m_Cmp(CmpInst::Predicate &Pred, const LHS &L, const RHS &R) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1397</td>
    <td class="">  return CmpClass_match<LHS, RHS, CmpInst, CmpInst::Predicate>(Pred, L, R);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1398</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1399</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1400</td>
    <td class="">template <typename LHS, typename RHS></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1401</td>
    <td class="">inline CmpClass_match<LHS, RHS, ICmpInst, ICmpInst::Predicate></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1402</td>
    <td class="uncoveredLine">m_ICmp(ICmpInst::Predicate &Pred, const LHS &L, const RHS &R) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1403</td>
    <td class="uncoveredLine">  return CmpClass_match<LHS, RHS, ICmpInst, ICmpInst::Predicate>(Pred, L, R);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1404</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1405</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1406</td>
    <td class="">template <typename LHS, typename RHS></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1407</td>
    <td class="">inline CmpClass_match<LHS, RHS, FCmpInst, FCmpInst::Predicate></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1408</td>
    <td class="uncoveredLine">m_FCmp(FCmpInst::Predicate &Pred, const LHS &L, const RHS &R) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1409</td>
    <td class="uncoveredLine">  return CmpClass_match<LHS, RHS, FCmpInst, FCmpInst::Predicate>(Pred, L, R);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1410</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1411</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1412</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1413</td>
    <td class="">// Matchers for instructions with a given opcode and number of operands.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1414</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1415</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1416</td>
    <td class="">/// Matches instructions with Opcode and three operands.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1417</td>
    <td class="">template <typename T0, unsigned Opcode> struct OneOps_match {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1418</td>
    <td class="">  T0 Op1;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1419</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1420</td>
    <td class="">  OneOps_match(const T0 &Op1) : Op1(Op1) {}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1421</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1422</td>
    <td class="">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1423</td>
    <td class="">    if (V->getValueID() == Value::InstructionVal + Opcode) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1424</td>
    <td class="">      auto *I = cast<Instruction>(V);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1425</td>
    <td class="">      return Op1.match(I->getOperand(0));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1426</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1427</td>
    <td class="">    return false;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1428</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1429</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1430</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1431</td>
    <td class="">/// Matches instructions with Opcode and three operands.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1432</td>
    <td class="">template <typename T0, typename T1, unsigned Opcode> struct TwoOps_match {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1433</td>
    <td class="">  T0 Op1;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1434</td>
    <td class="">  T1 Op2;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1435</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1436</td>
    <td class="">  TwoOps_match(const T0 &Op1, const T1 &Op2) : Op1(Op1), Op2(Op2) {}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1437</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1438</td>
    <td class="">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1439</td>
    <td class="">    if (V->getValueID() == Value::InstructionVal + Opcode) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1440</td>
    <td class="">      auto *I = cast<Instruction>(V);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1441</td>
    <td class="">      return Op1.match(I->getOperand(0)) && Op2.match(I->getOperand(1));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1442</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1443</td>
    <td class="">    return false;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1444</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1445</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1446</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1447</td>
    <td class="">/// Matches instructions with Opcode and three operands.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1448</td>
    <td class="">template <typename T0, typename T1, typename T2, unsigned Opcode></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1449</td>
    <td class="">struct ThreeOps_match {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1450</td>
    <td class="">  T0 Op1;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1451</td>
    <td class="">  T1 Op2;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1452</td>
    <td class="">  T2 Op3;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1453</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1454</td>
    <td class="uncoveredLine">  ThreeOps_match(const T0 &Op1, const T1 &Op2, const T2 &Op3)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1455</td>
    <td class="uncoveredLine">      : Op1(Op1), Op2(Op2), Op3(Op3) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1456</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1457</td>
    <td class="uncoveredLine">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1458</td>
    <td class="uncoveredLine">    if (V->getValueID() == Value::InstructionVal + Opcode) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1459</td>
    <td class="uncoveredLine">      auto *I = cast<Instruction>(V);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1460</td>
    <td class="uncoveredLine">      return Op1.match(I->getOperand(0)) && Op2.match(I->getOperand(1)) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1461</td>
    <td class="uncoveredLine">             Op3.match(I->getOperand(2));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1462</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1463</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1464</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1465</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1466</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1467</td>
    <td class="">/// Matches SelectInst.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1468</td>
    <td class="">template <typename Cond, typename LHS, typename RHS></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1469</td>
    <td class="">inline ThreeOps_match<Cond, LHS, RHS, Instruction::Select></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1470</td>
    <td class="uncoveredLine">m_Select(const Cond &C, const LHS &L, const RHS &R) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1471</td>
    <td class="uncoveredLine">  return ThreeOps_match<Cond, LHS, RHS, Instruction::Select>(C, L, R);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1472</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1473</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1474</td>
    <td class="">/// This matches a select of two constants, e.g.:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1475</td>
    <td class="">/// m_SelectCst<-1, 0>(m_Value(V))</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1476</td>
    <td class="">template <int64_t L, int64_t R, typename Cond></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1477</td>
    <td class="">inline ThreeOps_match<Cond, constantint_match<L>, constantint_match<R>,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1478</td>
    <td class="">                      Instruction::Select></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1479</td>
    <td class="">m_SelectCst(const Cond &C) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1480</td>
    <td class="">  return m_Select(C, m_ConstantInt<L>(), m_ConstantInt<R>());</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1481</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1482</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1483</td>
    <td class="">/// Matches FreezeInst.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1484</td>
    <td class="">template <typename OpTy></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1485</td>
    <td class="">inline OneOps_match<OpTy, Instruction::Freeze> m_Freeze(const OpTy &Op) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1486</td>
    <td class="">  return OneOps_match<OpTy, Instruction::Freeze>(Op);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1487</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1488</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1489</td>
    <td class="">/// Matches InsertElementInst.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1490</td>
    <td class="">template <typename Val_t, typename Elt_t, typename Idx_t></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1491</td>
    <td class="">inline ThreeOps_match<Val_t, Elt_t, Idx_t, Instruction::InsertElement></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1492</td>
    <td class="">m_InsertElt(const Val_t &Val, const Elt_t &Elt, const Idx_t &Idx) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1493</td>
    <td class="">  return ThreeOps_match<Val_t, Elt_t, Idx_t, Instruction::InsertElement>(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1494</td>
    <td class="">      Val, Elt, Idx);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1495</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1496</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1497</td>
    <td class="">/// Matches ExtractElementInst.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1498</td>
    <td class="">template <typename Val_t, typename Idx_t></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1499</td>
    <td class="">inline TwoOps_match<Val_t, Idx_t, Instruction::ExtractElement></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1500</td>
    <td class="">m_ExtractElt(const Val_t &Val, const Idx_t &Idx) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1501</td>
    <td class="">  return TwoOps_match<Val_t, Idx_t, Instruction::ExtractElement>(Val, Idx);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1502</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1503</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1504</td>
    <td class="">/// Matches shuffle.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1505</td>
    <td class="">template <typename T0, typename T1, typename T2> struct Shuffle_match {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1506</td>
    <td class="">  T0 Op1;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1507</td>
    <td class="">  T1 Op2;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1508</td>
    <td class="">  T2 Mask;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1509</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1510</td>
    <td class="">  Shuffle_match(const T0 &Op1, const T1 &Op2, const T2 &Mask)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1511</td>
    <td class="">      : Op1(Op1), Op2(Op2), Mask(Mask) {}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1512</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1513</td>
    <td class="">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1514</td>
    <td class="">    if (auto *I = dyn_cast<ShuffleVectorInst>(V)) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1515</td>
    <td class="">      return Op1.match(I->getOperand(0)) && Op2.match(I->getOperand(1)) &&</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1516</td>
    <td class="">             Mask.match(I->getShuffleMask());</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1517</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1518</td>
    <td class="">    return false;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1519</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1520</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1521</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1522</td>
    <td class="">struct m_Mask {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1523</td>
    <td class="">  ArrayRef<int> &MaskRef;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1524</td>
    <td class="">  m_Mask(ArrayRef<int> &MaskRef) : MaskRef(MaskRef) {}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1525</td>
    <td class="">  bool match(ArrayRef<int> Mask) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1526</td>
    <td class="">    MaskRef = Mask;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1527</td>
    <td class="">    return true;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1528</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1529</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1530</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1531</td>
    <td class="">struct m_ZeroMask {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1532</td>
    <td class="">  bool match(ArrayRef<int> Mask) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1533</td>
    <td class="">    return all_of(Mask, [](int Elem) { return Elem == 0 || Elem == -1; });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1534</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1535</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1536</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1537</td>
    <td class="">struct m_SpecificMask {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1538</td>
    <td class="">  ArrayRef<int> &MaskRef;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1539</td>
    <td class="">  m_SpecificMask(ArrayRef<int> &MaskRef) : MaskRef(MaskRef) {}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1540</td>
    <td class="">  bool match(ArrayRef<int> Mask) { return MaskRef == Mask; }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1541</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1542</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1543</td>
    <td class="">struct m_SplatOrUndefMask {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1544</td>
    <td class="">  int &SplatIndex;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1545</td>
    <td class="">  m_SplatOrUndefMask(int &SplatIndex) : SplatIndex(SplatIndex) {}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1546</td>
    <td class="">  bool match(ArrayRef<int> Mask) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1547</td>
    <td class="">    const auto *First = find_if(Mask, [](int Elem) { return Elem != -1; });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1548</td>
    <td class="">    if (First == Mask.end())</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1549</td>
    <td class="">      return false;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1550</td>
    <td class="">    SplatIndex = *First;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1551</td>
    <td class="">    return all_of(Mask,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1552</td>
    <td class="">                  [First](int Elem) { return Elem == *First || Elem == -1; });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1553</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1554</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1555</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1556</td>
    <td class="">/// Matches ShuffleVectorInst independently of mask value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1557</td>
    <td class="">template <typename V1_t, typename V2_t></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1558</td>
    <td class="">inline TwoOps_match<V1_t, V2_t, Instruction::ShuffleVector></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1559</td>
    <td class="">m_Shuffle(const V1_t &v1, const V2_t &v2) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1560</td>
    <td class="">  return TwoOps_match<V1_t, V2_t, Instruction::ShuffleVector>(v1, v2);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1561</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1562</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1563</td>
    <td class="">template <typename V1_t, typename V2_t, typename Mask_t></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1564</td>
    <td class="">inline Shuffle_match<V1_t, V2_t, Mask_t></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1565</td>
    <td class="">m_Shuffle(const V1_t &v1, const V2_t &v2, const Mask_t &mask) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1566</td>
    <td class="">  return Shuffle_match<V1_t, V2_t, Mask_t>(v1, v2, mask);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1567</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1568</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1569</td>
    <td class="">/// Matches LoadInst.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1570</td>
    <td class="">template <typename OpTy></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1571</td>
    <td class="">inline OneOps_match<OpTy, Instruction::Load> m_Load(const OpTy &Op) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1572</td>
    <td class="">  return OneOps_match<OpTy, Instruction::Load>(Op);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1573</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1574</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1575</td>
    <td class="">/// Matches StoreInst.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1576</td>
    <td class="">template <typename ValueOpTy, typename PointerOpTy></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1577</td>
    <td class="">inline TwoOps_match<ValueOpTy, PointerOpTy, Instruction::Store></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1578</td>
    <td class="">m_Store(const ValueOpTy &ValueOp, const PointerOpTy &PointerOp) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1579</td>
    <td class="">  return TwoOps_match<ValueOpTy, PointerOpTy, Instruction::Store>(ValueOp,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1580</td>
    <td class="">                                                                  PointerOp);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1581</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1582</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1583</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1584</td>
    <td class="">// Matchers for CastInst classes</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1585</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1586</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1587</td>
    <td class="">template <typename Op_t, unsigned Opcode> struct CastClass_match {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1588</td>
    <td class="">  Op_t Op;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1589</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1590</td>
    <td class="uncoveredLine">  CastClass_match(const Op_t &OpMatch) : Op(OpMatch) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1591</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1592</td>
    <td class="uncoveredLine">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1593</td>
    <td class="uncoveredLine">    if (auto *O = dyn_cast<Operator>(V))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1594</td>
    <td class="uncoveredLine">      return O->getOpcode() == Opcode && Op.match(O->getOperand(0));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1595</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1596</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1597</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1598</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1599</td>
    <td class="">template <typename Op_t> struct PtrToIntSameSize_match {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1600</td>
    <td class="">  const DataLayout &DL;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1601</td>
    <td class="">  Op_t Op;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1602</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1603</td>
    <td class="uncoveredLine">  PtrToIntSameSize_match(const DataLayout &DL, const Op_t &OpMatch)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1604</td>
    <td class="uncoveredLine">      : DL(DL), Op(OpMatch) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1605</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1606</td>
    <td class="uncoveredLine">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1607</td>
    <td class="uncoveredLine">    if (auto *O = dyn_cast<Operator>(V))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1608</td>
    <td class="uncoveredLine">      return O->getOpcode() == Instruction::PtrToInt &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1609</td>
    <td class="uncoveredLine">             DL.getTypeSizeInBits(O->getType()) ==</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1610</td>
    <td class="uncoveredLine">                 DL.getTypeSizeInBits(O->getOperand(0)->getType()) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1611</td>
    <td class="uncoveredLine">             Op.match(O->getOperand(0));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1612</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1613</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1614</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1615</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1616</td>
    <td class="">/// Matches BitCast.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1617</td>
    <td class="">template <typename OpTy></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1618</td>
    <td class="">inline CastClass_match<OpTy, Instruction::BitCast> m_BitCast(const OpTy &Op) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1619</td>
    <td class="">  return CastClass_match<OpTy, Instruction::BitCast>(Op);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1620</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1621</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1622</td>
    <td class="">/// Matches PtrToInt.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1623</td>
    <td class="">template <typename OpTy></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1624</td>
    <td class="uncoveredLine">inline CastClass_match<OpTy, Instruction::PtrToInt> m_PtrToInt(const OpTy &Op) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1625</td>
    <td class="uncoveredLine">  return CastClass_match<OpTy, Instruction::PtrToInt>(Op);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1626</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1627</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1628</td>
    <td class="">template <typename OpTy></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1629</td>
    <td class="uncoveredLine">inline PtrToIntSameSize_match<OpTy> m_PtrToIntSameSize(const DataLayout &DL,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1630</td>
    <td class="">                                                       const OpTy &Op) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1631</td>
    <td class="uncoveredLine">  return PtrToIntSameSize_match<OpTy>(DL, Op);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1632</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1633</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1634</td>
    <td class="">/// Matches IntToPtr.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1635</td>
    <td class="">template <typename OpTy></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1636</td>
    <td class="">inline CastClass_match<OpTy, Instruction::IntToPtr> m_IntToPtr(const OpTy &Op) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1637</td>
    <td class="">  return CastClass_match<OpTy, Instruction::IntToPtr>(Op);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1638</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1639</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1640</td>
    <td class="">/// Matches Trunc.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1641</td>
    <td class="">template <typename OpTy></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1642</td>
    <td class="">inline CastClass_match<OpTy, Instruction::Trunc> m_Trunc(const OpTy &Op) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1643</td>
    <td class="">  return CastClass_match<OpTy, Instruction::Trunc>(Op);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1644</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1645</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1646</td>
    <td class="">template <typename OpTy></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1647</td>
    <td class="">inline match_combine_or<CastClass_match<OpTy, Instruction::Trunc>, OpTy></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1648</td>
    <td class="">m_TruncOrSelf(const OpTy &Op) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1649</td>
    <td class="">  return m_CombineOr(m_Trunc(Op), Op);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1650</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1651</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1652</td>
    <td class="">/// Matches SExt.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1653</td>
    <td class="">template <typename OpTy></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1654</td>
    <td class="uncoveredLine">inline CastClass_match<OpTy, Instruction::SExt> m_SExt(const OpTy &Op) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1655</td>
    <td class="uncoveredLine">  return CastClass_match<OpTy, Instruction::SExt>(Op);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1656</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1657</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1658</td>
    <td class="">/// Matches ZExt.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1659</td>
    <td class="">template <typename OpTy></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1660</td>
    <td class="uncoveredLine">inline CastClass_match<OpTy, Instruction::ZExt> m_ZExt(const OpTy &Op) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1661</td>
    <td class="uncoveredLine">  return CastClass_match<OpTy, Instruction::ZExt>(Op);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1662</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1663</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1664</td>
    <td class="">template <typename OpTy></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1665</td>
    <td class="">inline match_combine_or<CastClass_match<OpTy, Instruction::ZExt>, OpTy></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1666</td>
    <td class="">m_ZExtOrSelf(const OpTy &Op) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1667</td>
    <td class="">  return m_CombineOr(m_ZExt(Op), Op);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1668</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1669</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1670</td>
    <td class="">template <typename OpTy></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1671</td>
    <td class="">inline match_combine_or<CastClass_match<OpTy, Instruction::SExt>, OpTy></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1672</td>
    <td class="">m_SExtOrSelf(const OpTy &Op) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1673</td>
    <td class="">  return m_CombineOr(m_SExt(Op), Op);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1674</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1675</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1676</td>
    <td class="">template <typename OpTy></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1677</td>
    <td class="">inline match_combine_or<CastClass_match<OpTy, Instruction::ZExt>,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1678</td>
    <td class="">                        CastClass_match<OpTy, Instruction::SExt>></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1679</td>
    <td class="uncoveredLine">m_ZExtOrSExt(const OpTy &Op) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1680</td>
    <td class="uncoveredLine">  return m_CombineOr(m_ZExt(Op), m_SExt(Op));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1681</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1682</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1683</td>
    <td class="">template <typename OpTy></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1684</td>
    <td class="">inline match_combine_or<</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1685</td>
    <td class="">    match_combine_or<CastClass_match<OpTy, Instruction::ZExt>,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1686</td>
    <td class="">                     CastClass_match<OpTy, Instruction::SExt>>,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1687</td>
    <td class="">    OpTy></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1688</td>
    <td class="">m_ZExtOrSExtOrSelf(const OpTy &Op) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1689</td>
    <td class="">  return m_CombineOr(m_ZExtOrSExt(Op), Op);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1690</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1691</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1692</td>
    <td class="">template <typename OpTy></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1693</td>
    <td class="">inline CastClass_match<OpTy, Instruction::UIToFP> m_UIToFP(const OpTy &Op) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1694</td>
    <td class="">  return CastClass_match<OpTy, Instruction::UIToFP>(Op);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1695</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1696</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1697</td>
    <td class="">template <typename OpTy></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1698</td>
    <td class="">inline CastClass_match<OpTy, Instruction::SIToFP> m_SIToFP(const OpTy &Op) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1699</td>
    <td class="">  return CastClass_match<OpTy, Instruction::SIToFP>(Op);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1700</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1701</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1702</td>
    <td class="">template <typename OpTy></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1703</td>
    <td class="">inline CastClass_match<OpTy, Instruction::FPToUI> m_FPToUI(const OpTy &Op) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1704</td>
    <td class="">  return CastClass_match<OpTy, Instruction::FPToUI>(Op);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1705</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1706</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1707</td>
    <td class="">template <typename OpTy></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1708</td>
    <td class="">inline CastClass_match<OpTy, Instruction::FPToSI> m_FPToSI(const OpTy &Op) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1709</td>
    <td class="">  return CastClass_match<OpTy, Instruction::FPToSI>(Op);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1710</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1711</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1712</td>
    <td class="">template <typename OpTy></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1713</td>
    <td class="">inline CastClass_match<OpTy, Instruction::FPTrunc> m_FPTrunc(const OpTy &Op) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1714</td>
    <td class="">  return CastClass_match<OpTy, Instruction::FPTrunc>(Op);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1715</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1716</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1717</td>
    <td class="">template <typename OpTy></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1718</td>
    <td class="">inline CastClass_match<OpTy, Instruction::FPExt> m_FPExt(const OpTy &Op) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1719</td>
    <td class="">  return CastClass_match<OpTy, Instruction::FPExt>(Op);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1720</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1721</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1722</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1723</td>
    <td class="">// Matchers for control flow.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1724</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1725</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1726</td>
    <td class="">struct br_match {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1727</td>
    <td class="">  BasicBlock *&Succ;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1728</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1729</td>
    <td class="">  br_match(BasicBlock *&Succ) : Succ(Succ) {}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1730</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1731</td>
    <td class="">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1732</td>
    <td class="">    if (auto *BI = dyn_cast<BranchInst>(V))</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1733</td>
    <td class="">      if (BI->isUnconditional()) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1734</td>
    <td class="">        Succ = BI->getSuccessor(0);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1735</td>
    <td class="">        return true;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1736</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1737</td>
    <td class="">    return false;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1738</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1739</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1740</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1741</td>
    <td class="">inline br_match m_UnconditionalBr(BasicBlock *&Succ) { return br_match(Succ); }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1742</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1743</td>
    <td class="">template <typename Cond_t, typename TrueBlock_t, typename FalseBlock_t></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1744</td>
    <td class="">struct brc_match {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1745</td>
    <td class="">  Cond_t Cond;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1746</td>
    <td class="">  TrueBlock_t T;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1747</td>
    <td class="">  FalseBlock_t F;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1748</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1749</td>
    <td class="uncoveredLine">  brc_match(const Cond_t &C, const TrueBlock_t &t, const FalseBlock_t &f)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1750</td>
    <td class="uncoveredLine">      : Cond(C), T(t), F(f) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1751</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1752</td>
    <td class="uncoveredLine">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1753</td>
    <td class="uncoveredLine">    if (auto *BI = dyn_cast<BranchInst>(V))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1754</td>
    <td class="uncoveredLine">      if (BI->isConditional() && Cond.match(BI->getCondition()))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1755</td>
    <td class="uncoveredLine">        return T.match(BI->getSuccessor(0)) && F.match(BI->getSuccessor(1));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1756</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1757</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1758</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1759</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1760</td>
    <td class="">template <typename Cond_t></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1761</td>
    <td class="">inline brc_match<Cond_t, bind_ty<BasicBlock>, bind_ty<BasicBlock>></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1762</td>
    <td class="uncoveredLine">m_Br(const Cond_t &C, BasicBlock *&T, BasicBlock *&F) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1763</td>
    <td class="">  return brc_match<Cond_t, bind_ty<BasicBlock>, bind_ty<BasicBlock>>(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1764</td>
    <td class="uncoveredLine">      C, m_BasicBlock(T), m_BasicBlock(F));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1765</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1766</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1767</td>
    <td class="">template <typename Cond_t, typename TrueBlock_t, typename FalseBlock_t></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1768</td>
    <td class="">inline brc_match<Cond_t, TrueBlock_t, FalseBlock_t></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1769</td>
    <td class="uncoveredLine">m_Br(const Cond_t &C, const TrueBlock_t &T, const FalseBlock_t &F) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1770</td>
    <td class="uncoveredLine">  return brc_match<Cond_t, TrueBlock_t, FalseBlock_t>(C, T, F);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1771</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1772</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1773</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1774</td>
    <td class="">// Matchers for max/min idioms, eg: "select (sgt x, y), x, y" -> smax(x,y).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1775</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1776</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1777</td>
    <td class="">template <typename CmpInst_t, typename LHS_t, typename RHS_t, typename Pred_t,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1778</td>
    <td class="">          bool Commutable = false></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1779</td>
    <td class="">struct MaxMin_match {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1780</td>
    <td class="">  using PredType = Pred_t;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1781</td>
    <td class="">  LHS_t L;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1782</td>
    <td class="">  RHS_t R;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1783</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1784</td>
    <td class="">  // The evaluation order is always stable, regardless of Commutability.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1785</td>
    <td class="">  // The LHS is always matched first.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1786</td>
    <td class="uncoveredLine">  MaxMin_match(const LHS_t &LHS, const RHS_t &RHS) : L(LHS), R(RHS) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1787</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1788</td>
    <td class="uncoveredLine">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1789</td>
    <td class="uncoveredLine">    if (auto *II = dyn_cast<IntrinsicInst>(V)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1790</td>
    <td class="uncoveredLine">      Intrinsic::ID IID = II->getIntrinsicID();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1791</td>
    <td class="uncoveredLine">      if ((IID == Intrinsic::smax && Pred_t::match(ICmpInst::ICMP_SGT)) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1792</td>
    <td class="uncoveredLine">          (IID == Intrinsic::smin && Pred_t::match(ICmpInst::ICMP_SLT)) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1793</td>
    <td class="uncoveredLine">          (IID == Intrinsic::umax && Pred_t::match(ICmpInst::ICMP_UGT)) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1794</td>
    <td class="uncoveredLine">          (IID == Intrinsic::umin && Pred_t::match(ICmpInst::ICMP_ULT))) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1795</td>
    <td class="uncoveredLine">        Value *LHS = II->getOperand(0), *RHS = II->getOperand(1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1796</td>
    <td class="uncoveredLine">        return (L.match(LHS) && R.match(RHS)) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1797</td>
    <td class="uncoveredLine">               (Commutable && L.match(RHS) && R.match(LHS));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1798</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1799</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1800</td>
    <td class="">    // Look for "(x pred y) ? x : y" or "(x pred y) ? y : x".</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1801</td>
    <td class="uncoveredLine">    auto *SI = dyn_cast<SelectInst>(V);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1802</td>
    <td class="uncoveredLine">    if (!SI)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1803</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1804</td>
    <td class="uncoveredLine">    auto *Cmp = dyn_cast<CmpInst_t>(SI->getCondition());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1805</td>
    <td class="uncoveredLine">    if (!Cmp)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1806</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1807</td>
    <td class="">    // At this point we have a select conditioned on a comparison.  Check that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1808</td>
    <td class="">    // it is the values returned by the select that are being compared.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1809</td>
    <td class="uncoveredLine">    auto *TrueVal = SI->getTrueValue();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1810</td>
    <td class="uncoveredLine">    auto *FalseVal = SI->getFalseValue();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1811</td>
    <td class="uncoveredLine">    auto *LHS = Cmp->getOperand(0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1812</td>
    <td class="uncoveredLine">    auto *RHS = Cmp->getOperand(1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1813</td>
    <td class="uncoveredLine">    if ((TrueVal != LHS || FalseVal != RHS) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1814</td>
    <td class="uncoveredLine">        (TrueVal != RHS || FalseVal != LHS))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1815</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1816</td>
    <td class="uncoveredLine">    typename CmpInst_t::Predicate Pred =</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1817</td>
    <td class="uncoveredLine">        LHS == TrueVal ? Cmp->getPredicate() : Cmp->getInversePredicate();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1818</td>
    <td class="">    // Does "(x pred y) ? x : y" represent the desired max/min operation?</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1819</td>
    <td class="uncoveredLine">    if (!Pred_t::match(Pred))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1820</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1821</td>
    <td class="">    // It does!  Bind the operands.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1822</td>
    <td class="uncoveredLine">    return (L.match(LHS) && R.match(RHS)) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1823</td>
    <td class="uncoveredLine">           (Commutable && L.match(RHS) && R.match(LHS));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1824</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1825</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1826</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1827</td>
    <td class="">/// Helper class for identifying signed max predicates.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1828</td>
    <td class="">struct smax_pred_ty {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1829</td>
    <td class="uncoveredLine">  static bool match(ICmpInst::Predicate Pred) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1830</td>
    <td class="uncoveredLine">    return Pred == CmpInst::ICMP_SGT || Pred == CmpInst::ICMP_SGE;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1831</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1832</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1833</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1834</td>
    <td class="">/// Helper class for identifying signed min predicates.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1835</td>
    <td class="">struct smin_pred_ty {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1836</td>
    <td class="uncoveredLine">  static bool match(ICmpInst::Predicate Pred) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1837</td>
    <td class="uncoveredLine">    return Pred == CmpInst::ICMP_SLT || Pred == CmpInst::ICMP_SLE;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1838</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1839</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1840</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1841</td>
    <td class="">/// Helper class for identifying unsigned max predicates.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1842</td>
    <td class="">struct umax_pred_ty {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1843</td>
    <td class="uncoveredLine">  static bool match(ICmpInst::Predicate Pred) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1844</td>
    <td class="uncoveredLine">    return Pred == CmpInst::ICMP_UGT || Pred == CmpInst::ICMP_UGE;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1845</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1846</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1847</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1848</td>
    <td class="">/// Helper class for identifying unsigned min predicates.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1849</td>
    <td class="">struct umin_pred_ty {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1850</td>
    <td class="uncoveredLine">  static bool match(ICmpInst::Predicate Pred) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1851</td>
    <td class="uncoveredLine">    return Pred == CmpInst::ICMP_ULT || Pred == CmpInst::ICMP_ULE;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1852</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1853</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1854</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1855</td>
    <td class="">/// Helper class for identifying ordered max predicates.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1856</td>
    <td class="">struct ofmax_pred_ty {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1857</td>
    <td class="uncoveredLine">  static bool match(FCmpInst::Predicate Pred) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1858</td>
    <td class="uncoveredLine">    return Pred == CmpInst::FCMP_OGT || Pred == CmpInst::FCMP_OGE;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1859</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1860</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1861</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1862</td>
    <td class="">/// Helper class for identifying ordered min predicates.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1863</td>
    <td class="">struct ofmin_pred_ty {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1864</td>
    <td class="uncoveredLine">  static bool match(FCmpInst::Predicate Pred) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1865</td>
    <td class="uncoveredLine">    return Pred == CmpInst::FCMP_OLT || Pred == CmpInst::FCMP_OLE;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1866</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1867</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1868</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1869</td>
    <td class="">/// Helper class for identifying unordered max predicates.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1870</td>
    <td class="">struct ufmax_pred_ty {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1871</td>
    <td class="uncoveredLine">  static bool match(FCmpInst::Predicate Pred) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1872</td>
    <td class="uncoveredLine">    return Pred == CmpInst::FCMP_UGT || Pred == CmpInst::FCMP_UGE;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1873</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1874</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1875</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1876</td>
    <td class="">/// Helper class for identifying unordered min predicates.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1877</td>
    <td class="">struct ufmin_pred_ty {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1878</td>
    <td class="uncoveredLine">  static bool match(FCmpInst::Predicate Pred) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1879</td>
    <td class="uncoveredLine">    return Pred == CmpInst::FCMP_ULT || Pred == CmpInst::FCMP_ULE;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1880</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1881</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1882</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1883</td>
    <td class="">template <typename LHS, typename RHS></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1884</td>
    <td class="uncoveredLine">inline MaxMin_match<ICmpInst, LHS, RHS, smax_pred_ty> m_SMax(const LHS &L,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1885</td>
    <td class="">                                                             const RHS &R) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1886</td>
    <td class="uncoveredLine">  return MaxMin_match<ICmpInst, LHS, RHS, smax_pred_ty>(L, R);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1887</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1888</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1889</td>
    <td class="">template <typename LHS, typename RHS></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1890</td>
    <td class="uncoveredLine">inline MaxMin_match<ICmpInst, LHS, RHS, smin_pred_ty> m_SMin(const LHS &L,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1891</td>
    <td class="">                                                             const RHS &R) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1892</td>
    <td class="uncoveredLine">  return MaxMin_match<ICmpInst, LHS, RHS, smin_pred_ty>(L, R);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1893</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1894</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1895</td>
    <td class="">template <typename LHS, typename RHS></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1896</td>
    <td class="uncoveredLine">inline MaxMin_match<ICmpInst, LHS, RHS, umax_pred_ty> m_UMax(const LHS &L,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1897</td>
    <td class="">                                                             const RHS &R) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1898</td>
    <td class="uncoveredLine">  return MaxMin_match<ICmpInst, LHS, RHS, umax_pred_ty>(L, R);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1899</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1900</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1901</td>
    <td class="">template <typename LHS, typename RHS></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1902</td>
    <td class="uncoveredLine">inline MaxMin_match<ICmpInst, LHS, RHS, umin_pred_ty> m_UMin(const LHS &L,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1903</td>
    <td class="">                                                             const RHS &R) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1904</td>
    <td class="uncoveredLine">  return MaxMin_match<ICmpInst, LHS, RHS, umin_pred_ty>(L, R);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1905</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1906</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1907</td>
    <td class="">template <typename LHS, typename RHS></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1908</td>
    <td class="">inline match_combine_or<</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1909</td>
    <td class="">    match_combine_or<MaxMin_match<ICmpInst, LHS, RHS, smax_pred_ty>,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1910</td>
    <td class="">                     MaxMin_match<ICmpInst, LHS, RHS, smin_pred_ty>>,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1911</td>
    <td class="">    match_combine_or<MaxMin_match<ICmpInst, LHS, RHS, umax_pred_ty>,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1912</td>
    <td class="">                     MaxMin_match<ICmpInst, LHS, RHS, umin_pred_ty>>></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1913</td>
    <td class="uncoveredLine">m_MaxOrMin(const LHS &L, const RHS &R) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1914</td>
    <td class="uncoveredLine">  return m_CombineOr(m_CombineOr(m_SMax(L, R), m_SMin(L, R)),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1915</td>
    <td class="uncoveredLine">                     m_CombineOr(m_UMax(L, R), m_UMin(L, R)));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1916</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1917</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1918</td>
    <td class="">/// Match an 'ordered' floating point maximum function.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1919</td>
    <td class="">/// Floating point has one special value 'NaN'. Therefore, there is no total</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1920</td>
    <td class="">/// order. However, if we can ignore the 'NaN' value (for example, because of a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1921</td>
    <td class="">/// 'no-nans-float-math' flag) a combination of a fcmp and select has 'maximum'</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1922</td>
    <td class="">/// semantics. In the presence of 'NaN' we have to preserve the original</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1923</td>
    <td class="">/// select(fcmp(ogt/ge, L, R), L, R) semantics matched by this predicate.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1924</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1925</td>
    <td class="">///                         max(L, R)  iff L and R are not NaN</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1926</td>
    <td class="">///  m_OrdFMax(L, R) =      R          iff L or R are NaN</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1927</td>
    <td class="">template <typename LHS, typename RHS></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1928</td>
    <td class="uncoveredLine">inline MaxMin_match<FCmpInst, LHS, RHS, ofmax_pred_ty> m_OrdFMax(const LHS &L,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1929</td>
    <td class="">                                                                 const RHS &R) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1930</td>
    <td class="uncoveredLine">  return MaxMin_match<FCmpInst, LHS, RHS, ofmax_pred_ty>(L, R);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1931</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1932</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1933</td>
    <td class="">/// Match an 'ordered' floating point minimum function.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1934</td>
    <td class="">/// Floating point has one special value 'NaN'. Therefore, there is no total</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1935</td>
    <td class="">/// order. However, if we can ignore the 'NaN' value (for example, because of a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1936</td>
    <td class="">/// 'no-nans-float-math' flag) a combination of a fcmp and select has 'minimum'</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1937</td>
    <td class="">/// semantics. In the presence of 'NaN' we have to preserve the original</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1938</td>
    <td class="">/// select(fcmp(olt/le, L, R), L, R) semantics matched by this predicate.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1939</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1940</td>
    <td class="">///                         min(L, R)  iff L and R are not NaN</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1941</td>
    <td class="">///  m_OrdFMin(L, R) =      R          iff L or R are NaN</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1942</td>
    <td class="">template <typename LHS, typename RHS></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1943</td>
    <td class="uncoveredLine">inline MaxMin_match<FCmpInst, LHS, RHS, ofmin_pred_ty> m_OrdFMin(const LHS &L,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1944</td>
    <td class="">                                                                 const RHS &R) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1945</td>
    <td class="uncoveredLine">  return MaxMin_match<FCmpInst, LHS, RHS, ofmin_pred_ty>(L, R);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1946</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1947</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1948</td>
    <td class="">/// Match an 'unordered' floating point maximum function.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1949</td>
    <td class="">/// Floating point has one special value 'NaN'. Therefore, there is no total</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1950</td>
    <td class="">/// order. However, if we can ignore the 'NaN' value (for example, because of a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1951</td>
    <td class="">/// 'no-nans-float-math' flag) a combination of a fcmp and select has 'maximum'</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1952</td>
    <td class="">/// semantics. In the presence of 'NaN' we have to preserve the original</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1953</td>
    <td class="">/// select(fcmp(ugt/ge, L, R), L, R) semantics matched by this predicate.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1954</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1955</td>
    <td class="">///                         max(L, R)  iff L and R are not NaN</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1956</td>
    <td class="">///  m_UnordFMax(L, R) =    L          iff L or R are NaN</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1957</td>
    <td class="">template <typename LHS, typename RHS></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1958</td>
    <td class="">inline MaxMin_match<FCmpInst, LHS, RHS, ufmax_pred_ty></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1959</td>
    <td class="uncoveredLine">m_UnordFMax(const LHS &L, const RHS &R) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1960</td>
    <td class="uncoveredLine">  return MaxMin_match<FCmpInst, LHS, RHS, ufmax_pred_ty>(L, R);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1961</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1962</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1963</td>
    <td class="">/// Match an 'unordered' floating point minimum function.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1964</td>
    <td class="">/// Floating point has one special value 'NaN'. Therefore, there is no total</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1965</td>
    <td class="">/// order. However, if we can ignore the 'NaN' value (for example, because of a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1966</td>
    <td class="">/// 'no-nans-float-math' flag) a combination of a fcmp and select has 'minimum'</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1967</td>
    <td class="">/// semantics. In the presence of 'NaN' we have to preserve the original</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1968</td>
    <td class="">/// select(fcmp(ult/le, L, R), L, R) semantics matched by this predicate.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1969</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1970</td>
    <td class="">///                          min(L, R)  iff L and R are not NaN</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1971</td>
    <td class="">///  m_UnordFMin(L, R) =     L          iff L or R are NaN</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1972</td>
    <td class="">template <typename LHS, typename RHS></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1973</td>
    <td class="">inline MaxMin_match<FCmpInst, LHS, RHS, ufmin_pred_ty></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1974</td>
    <td class="uncoveredLine">m_UnordFMin(const LHS &L, const RHS &R) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1975</td>
    <td class="uncoveredLine">  return MaxMin_match<FCmpInst, LHS, RHS, ufmin_pred_ty>(L, R);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1976</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1977</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1978</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1979</td>
    <td class="">// Matchers for overflow check patterns: e.g. (a + b) u< a, (a ^ -1) <u b</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1980</td>
    <td class="">// Note that S might be matched to other instructions than AddInst.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1981</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1982</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1983</td>
    <td class="">template <typename LHS_t, typename RHS_t, typename Sum_t></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1984</td>
    <td class="">struct UAddWithOverflow_match {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1985</td>
    <td class="">  LHS_t L;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1986</td>
    <td class="">  RHS_t R;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1987</td>
    <td class="">  Sum_t S;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1988</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1989</td>
    <td class="">  UAddWithOverflow_match(const LHS_t &L, const RHS_t &R, const Sum_t &S)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1990</td>
    <td class="">      : L(L), R(R), S(S) {}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1991</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1992</td>
    <td class="">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1993</td>
    <td class="">    Value *ICmpLHS, *ICmpRHS;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1994</td>
    <td class="">    ICmpInst::Predicate Pred;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1995</td>
    <td class="">    if (!m_ICmp(Pred, m_Value(ICmpLHS), m_Value(ICmpRHS)).match(V))</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1996</td>
    <td class="">      return false;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1997</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1998</td>
    <td class="">    Value *AddLHS, *AddRHS;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1999</td>
    <td class="">    auto AddExpr = m_Add(m_Value(AddLHS), m_Value(AddRHS));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2000</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2001</td>
    <td class="">    // (a + b) u< a, (a + b) u< b</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2002</td>
    <td class="">    if (Pred == ICmpInst::ICMP_ULT)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2003</td>
    <td class="">      if (AddExpr.match(ICmpLHS) && (ICmpRHS == AddLHS || ICmpRHS == AddRHS))</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2004</td>
    <td class="">        return L.match(AddLHS) && R.match(AddRHS) && S.match(ICmpLHS);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2005</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2006</td>
    <td class="">    // a >u (a + b), b >u (a + b)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2007</td>
    <td class="">    if (Pred == ICmpInst::ICMP_UGT)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2008</td>
    <td class="">      if (AddExpr.match(ICmpRHS) && (ICmpLHS == AddLHS || ICmpLHS == AddRHS))</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2009</td>
    <td class="">        return L.match(AddLHS) && R.match(AddRHS) && S.match(ICmpRHS);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2010</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2011</td>
    <td class="">    Value *Op1;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2012</td>
    <td class="">    auto XorExpr = m_OneUse(m_Xor(m_Value(Op1), m_AllOnes()));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2013</td>
    <td class="">    // (a ^ -1) <u b</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2014</td>
    <td class="">    if (Pred == ICmpInst::ICMP_ULT) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2015</td>
    <td class="">      if (XorExpr.match(ICmpLHS))</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2016</td>
    <td class="">        return L.match(Op1) && R.match(ICmpRHS) && S.match(ICmpLHS);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2017</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2018</td>
    <td class="">    //  b > u (a ^ -1)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2019</td>
    <td class="">    if (Pred == ICmpInst::ICMP_UGT) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2020</td>
    <td class="">      if (XorExpr.match(ICmpRHS))</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2021</td>
    <td class="">        return L.match(Op1) && R.match(ICmpLHS) && S.match(ICmpRHS);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2022</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2023</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2024</td>
    <td class="">    // Match special-case for increment-by-1.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2025</td>
    <td class="">    if (Pred == ICmpInst::ICMP_EQ) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2026</td>
    <td class="">      // (a + 1) == 0</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2027</td>
    <td class="">      // (1 + a) == 0</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2028</td>
    <td class="">      if (AddExpr.match(ICmpLHS) && m_ZeroInt().match(ICmpRHS) &&</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2029</td>
    <td class="">          (m_One().match(AddLHS) || m_One().match(AddRHS)))</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2030</td>
    <td class="">        return L.match(AddLHS) && R.match(AddRHS) && S.match(ICmpLHS);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2031</td>
    <td class="">      // 0 == (a + 1)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2032</td>
    <td class="">      // 0 == (1 + a)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2033</td>
    <td class="">      if (m_ZeroInt().match(ICmpLHS) && AddExpr.match(ICmpRHS) &&</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2034</td>
    <td class="">          (m_One().match(AddLHS) || m_One().match(AddRHS)))</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2035</td>
    <td class="">        return L.match(AddLHS) && R.match(AddRHS) && S.match(ICmpRHS);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2036</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2037</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2038</td>
    <td class="">    return false;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2039</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2040</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2041</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2042</td>
    <td class="">/// Match an icmp instruction checking for unsigned overflow on addition.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2043</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2044</td>
    <td class="">/// S is matched to the addition whose result is being checked for overflow, and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2045</td>
    <td class="">/// L and R are matched to the LHS and RHS of S.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2046</td>
    <td class="">template <typename LHS_t, typename RHS_t, typename Sum_t></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2047</td>
    <td class="">UAddWithOverflow_match<LHS_t, RHS_t, Sum_t></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2048</td>
    <td class="">m_UAddWithOverflow(const LHS_t &L, const RHS_t &R, const Sum_t &S) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2049</td>
    <td class="">  return UAddWithOverflow_match<LHS_t, RHS_t, Sum_t>(L, R, S);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2050</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2051</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2052</td>
    <td class="">template <typename Opnd_t> struct Argument_match {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2053</td>
    <td class="">  unsigned OpI;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2054</td>
    <td class="">  Opnd_t Val;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2055</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2056</td>
    <td class="uncoveredLine">  Argument_match(unsigned OpIdx, const Opnd_t &V) : OpI(OpIdx), Val(V) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2057</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2058</td>
    <td class="uncoveredLine">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2059</td>
    <td class="">    // FIXME: Should likely be switched to use `CallBase`.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2060</td>
    <td class="uncoveredLine">    if (const auto *CI = dyn_cast<CallInst>(V))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2061</td>
    <td class="uncoveredLine">      return Val.match(CI->getArgOperand(OpI));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2062</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2063</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2064</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2065</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2066</td>
    <td class="">/// Match an argument.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2067</td>
    <td class="">template <unsigned OpI, typename Opnd_t></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2068</td>
    <td class="uncoveredLine">inline Argument_match<Opnd_t> m_Argument(const Opnd_t &Op) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2069</td>
    <td class="uncoveredLine">  return Argument_match<Opnd_t>(OpI, Op);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2070</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2071</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2072</td>
    <td class="">/// Intrinsic matchers.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2073</td>
    <td class="">struct IntrinsicID_match {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2074</td>
    <td class="">  unsigned ID;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2075</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2076</td>
    <td class="uncoveredLine">  IntrinsicID_match(Intrinsic::ID IntrID) : ID(IntrID) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2077</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2078</td>
    <td class="uncoveredLine">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2079</td>
    <td class="uncoveredLine">    if (const auto *CI = dyn_cast<CallInst>(V))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2080</td>
    <td class="uncoveredLine">      if (const auto *F = CI->getCalledFunction())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2081</td>
    <td class="uncoveredLine">        return F->getIntrinsicID() == ID;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2082</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2083</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2084</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2085</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2086</td>
    <td class="">/// Intrinsic matches are combinations of ID matchers, and argument</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2087</td>
    <td class="">/// matchers. Higher arity matcher are defined recursively in terms of and-ing</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2088</td>
    <td class="">/// them with lower arity matchers. Here's some convenient typedefs for up to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2089</td>
    <td class="">/// several arguments, and more can be added as needed</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2090</td>
    <td class="">template <typename T0 = void, typename T1 = void, typename T2 = void,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2091</td>
    <td class="">          typename T3 = void, typename T4 = void, typename T5 = void,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2092</td>
    <td class="">          typename T6 = void, typename T7 = void, typename T8 = void,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2093</td>
    <td class="">          typename T9 = void, typename T10 = void></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2094</td>
    <td class="">struct m_Intrinsic_Ty;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2095</td>
    <td class="">template <typename T0> struct m_Intrinsic_Ty<T0> {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2096</td>
    <td class="">  using Ty = match_combine_and<IntrinsicID_match, Argument_match<T0>>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2097</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2098</td>
    <td class="">template <typename T0, typename T1> struct m_Intrinsic_Ty<T0, T1> {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2099</td>
    <td class="">  using Ty =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2100</td>
    <td class="">      match_combine_and<typename m_Intrinsic_Ty<T0>::Ty, Argument_match<T1>>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2101</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2102</td>
    <td class="">template <typename T0, typename T1, typename T2></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2103</td>
    <td class="">struct m_Intrinsic_Ty<T0, T1, T2> {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2104</td>
    <td class="">  using Ty = match_combine_and<typename m_Intrinsic_Ty<T0, T1>::Ty,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2105</td>
    <td class="">                               Argument_match<T2>>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2106</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2107</td>
    <td class="">template <typename T0, typename T1, typename T2, typename T3></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2108</td>
    <td class="">struct m_Intrinsic_Ty<T0, T1, T2, T3> {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2109</td>
    <td class="">  using Ty = match_combine_and<typename m_Intrinsic_Ty<T0, T1, T2>::Ty,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2110</td>
    <td class="">                               Argument_match<T3>>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2111</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2112</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2113</td>
    <td class="">template <typename T0, typename T1, typename T2, typename T3, typename T4></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2114</td>
    <td class="">struct m_Intrinsic_Ty<T0, T1, T2, T3, T4> {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2115</td>
    <td class="">  using Ty = match_combine_and<typename m_Intrinsic_Ty<T0, T1, T2, T3>::Ty,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2116</td>
    <td class="">                               Argument_match<T4>>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2117</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2118</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2119</td>
    <td class="">template <typename T0, typename T1, typename T2, typename T3, typename T4,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2120</td>
    <td class="">          typename T5></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2121</td>
    <td class="">struct m_Intrinsic_Ty<T0, T1, T2, T3, T4, T5> {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2122</td>
    <td class="">  using Ty = match_combine_and<typename m_Intrinsic_Ty<T0, T1, T2, T3, T4>::Ty,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2123</td>
    <td class="">                               Argument_match<T5>>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2124</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2125</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2126</td>
    <td class="">/// Match intrinsic calls like this:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2127</td>
    <td class="">/// m_Intrinsic<Intrinsic::fabs>(m_Value(X))</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2128</td>
    <td class="uncoveredLine">template <Intrinsic::ID IntrID> inline IntrinsicID_match m_Intrinsic() {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2129</td>
    <td class="uncoveredLine">  return IntrinsicID_match(IntrID);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2130</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2131</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2132</td>
    <td class="">/// Matches MaskedLoad Intrinsic.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2133</td>
    <td class="">template <typename Opnd0, typename Opnd1, typename Opnd2, typename Opnd3></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2134</td>
    <td class="">inline typename m_Intrinsic_Ty<Opnd0, Opnd1, Opnd2, Opnd3>::Ty</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2135</td>
    <td class="">m_MaskedLoad(const Opnd0 &Op0, const Opnd1 &Op1, const Opnd2 &Op2,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2136</td>
    <td class="">             const Opnd3 &Op3) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2137</td>
    <td class="">  return m_Intrinsic<Intrinsic::masked_load>(Op0, Op1, Op2, Op3);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2138</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2139</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2140</td>
    <td class="">/// Matches MaskedGather Intrinsic.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2141</td>
    <td class="">template <typename Opnd0, typename Opnd1, typename Opnd2, typename Opnd3></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2142</td>
    <td class="">inline typename m_Intrinsic_Ty<Opnd0, Opnd1, Opnd2, Opnd3>::Ty</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2143</td>
    <td class="">m_MaskedGather(const Opnd0 &Op0, const Opnd1 &Op1, const Opnd2 &Op2,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2144</td>
    <td class="">               const Opnd3 &Op3) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2145</td>
    <td class="">  return m_Intrinsic<Intrinsic::masked_gather>(Op0, Op1, Op2, Op3);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2146</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2147</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2148</td>
    <td class="">template <Intrinsic::ID IntrID, typename T0></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2149</td>
    <td class="uncoveredLine">inline typename m_Intrinsic_Ty<T0>::Ty m_Intrinsic(const T0 &Op0) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2150</td>
    <td class="uncoveredLine">  return m_CombineAnd(m_Intrinsic<IntrID>(), m_Argument<0>(Op0));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2151</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2152</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2153</td>
    <td class="">template <Intrinsic::ID IntrID, typename T0, typename T1></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2154</td>
    <td class="uncoveredLine">inline typename m_Intrinsic_Ty<T0, T1>::Ty m_Intrinsic(const T0 &Op0,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2155</td>
    <td class="">                                                       const T1 &Op1) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2156</td>
    <td class="uncoveredLine">  return m_CombineAnd(m_Intrinsic<IntrID>(Op0), m_Argument<1>(Op1));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2157</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2158</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2159</td>
    <td class="">template <Intrinsic::ID IntrID, typename T0, typename T1, typename T2></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2160</td>
    <td class="">inline typename m_Intrinsic_Ty<T0, T1, T2>::Ty</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2161</td>
    <td class="">m_Intrinsic(const T0 &Op0, const T1 &Op1, const T2 &Op2) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2162</td>
    <td class="">  return m_CombineAnd(m_Intrinsic<IntrID>(Op0, Op1), m_Argument<2>(Op2));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2163</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2164</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2165</td>
    <td class="">template <Intrinsic::ID IntrID, typename T0, typename T1, typename T2,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2166</td>
    <td class="">          typename T3></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2167</td>
    <td class="">inline typename m_Intrinsic_Ty<T0, T1, T2, T3>::Ty</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2168</td>
    <td class="">m_Intrinsic(const T0 &Op0, const T1 &Op1, const T2 &Op2, const T3 &Op3) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2169</td>
    <td class="">  return m_CombineAnd(m_Intrinsic<IntrID>(Op0, Op1, Op2), m_Argument<3>(Op3));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2170</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2171</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2172</td>
    <td class="">template <Intrinsic::ID IntrID, typename T0, typename T1, typename T2,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2173</td>
    <td class="">          typename T3, typename T4></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2174</td>
    <td class="">inline typename m_Intrinsic_Ty<T0, T1, T2, T3, T4>::Ty</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2175</td>
    <td class="">m_Intrinsic(const T0 &Op0, const T1 &Op1, const T2 &Op2, const T3 &Op3,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2176</td>
    <td class="">            const T4 &Op4) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2177</td>
    <td class="">  return m_CombineAnd(m_Intrinsic<IntrID>(Op0, Op1, Op2, Op3),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2178</td>
    <td class="">                      m_Argument<4>(Op4));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2179</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2180</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2181</td>
    <td class="">template <Intrinsic::ID IntrID, typename T0, typename T1, typename T2,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2182</td>
    <td class="">          typename T3, typename T4, typename T5></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2183</td>
    <td class="">inline typename m_Intrinsic_Ty<T0, T1, T2, T3, T4, T5>::Ty</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2184</td>
    <td class="">m_Intrinsic(const T0 &Op0, const T1 &Op1, const T2 &Op2, const T3 &Op3,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2185</td>
    <td class="">            const T4 &Op4, const T5 &Op5) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2186</td>
    <td class="">  return m_CombineAnd(m_Intrinsic<IntrID>(Op0, Op1, Op2, Op3, Op4),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2187</td>
    <td class="">                      m_Argument<5>(Op5));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2188</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2189</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2190</td>
    <td class="">// Helper intrinsic matching specializations.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2191</td>
    <td class="">template <typename Opnd0></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2192</td>
    <td class="">inline typename m_Intrinsic_Ty<Opnd0>::Ty m_BitReverse(const Opnd0 &Op0) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2193</td>
    <td class="">  return m_Intrinsic<Intrinsic::bitreverse>(Op0);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2194</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2195</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2196</td>
    <td class="">template <typename Opnd0></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2197</td>
    <td class="">inline typename m_Intrinsic_Ty<Opnd0>::Ty m_BSwap(const Opnd0 &Op0) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2198</td>
    <td class="">  return m_Intrinsic<Intrinsic::bswap>(Op0);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2199</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2200</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2201</td>
    <td class="">template <typename Opnd0></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2202</td>
    <td class="uncoveredLine">inline typename m_Intrinsic_Ty<Opnd0>::Ty m_FAbs(const Opnd0 &Op0) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2203</td>
    <td class="uncoveredLine">  return m_Intrinsic<Intrinsic::fabs>(Op0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2204</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2205</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2206</td>
    <td class="">template <typename Opnd0></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2207</td>
    <td class="">inline typename m_Intrinsic_Ty<Opnd0>::Ty m_FCanonicalize(const Opnd0 &Op0) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2208</td>
    <td class="">  return m_Intrinsic<Intrinsic::canonicalize>(Op0);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2209</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2210</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2211</td>
    <td class="">template <typename Opnd0, typename Opnd1></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2212</td>
    <td class="">inline typename m_Intrinsic_Ty<Opnd0, Opnd1>::Ty m_FMin(const Opnd0 &Op0,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2213</td>
    <td class="">                                                        const Opnd1 &Op1) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2214</td>
    <td class="">  return m_Intrinsic<Intrinsic::minnum>(Op0, Op1);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2215</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2216</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2217</td>
    <td class="">template <typename Opnd0, typename Opnd1></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2218</td>
    <td class="">inline typename m_Intrinsic_Ty<Opnd0, Opnd1>::Ty m_FMax(const Opnd0 &Op0,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2219</td>
    <td class="">                                                        const Opnd1 &Op1) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2220</td>
    <td class="">  return m_Intrinsic<Intrinsic::maxnum>(Op0, Op1);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2221</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2222</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2223</td>
    <td class="">template <typename Opnd0, typename Opnd1, typename Opnd2></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2224</td>
    <td class="">inline typename m_Intrinsic_Ty<Opnd0, Opnd1, Opnd2>::Ty</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2225</td>
    <td class="">m_FShl(const Opnd0 &Op0, const Opnd1 &Op1, const Opnd2 &Op2) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2226</td>
    <td class="">  return m_Intrinsic<Intrinsic::fshl>(Op0, Op1, Op2);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2227</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2228</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2229</td>
    <td class="">template <typename Opnd0, typename Opnd1, typename Opnd2></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2230</td>
    <td class="">inline typename m_Intrinsic_Ty<Opnd0, Opnd1, Opnd2>::Ty</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2231</td>
    <td class="">m_FShr(const Opnd0 &Op0, const Opnd1 &Op1, const Opnd2 &Op2) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2232</td>
    <td class="">  return m_Intrinsic<Intrinsic::fshr>(Op0, Op1, Op2);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2233</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2234</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2235</td>
    <td class="">template <typename Opnd0></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2236</td>
    <td class="">inline typename m_Intrinsic_Ty<Opnd0>::Ty m_Sqrt(const Opnd0 &Op0) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2237</td>
    <td class="">  return m_Intrinsic<Intrinsic::sqrt>(Op0);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2238</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2239</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2240</td>
    <td class="">template <typename Opnd0, typename Opnd1></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2241</td>
    <td class="">inline typename m_Intrinsic_Ty<Opnd0, Opnd1>::Ty m_CopySign(const Opnd0 &Op0,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2242</td>
    <td class="">                                                            const Opnd1 &Op1) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2243</td>
    <td class="">  return m_Intrinsic<Intrinsic::copysign>(Op0, Op1);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2244</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2245</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2246</td>
    <td class="">template <typename Opnd0></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2247</td>
    <td class="">inline typename m_Intrinsic_Ty<Opnd0>::Ty m_VecReverse(const Opnd0 &Op0) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2248</td>
    <td class="">  return m_Intrinsic<Intrinsic::experimental_vector_reverse>(Op0);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2249</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2250</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2251</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2252</td>
    <td class="">// Matchers for two-operands operators with the operators in either order</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2253</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2254</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2255</td>
    <td class="">/// Matches a BinaryOperator with LHS and RHS in either order.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2256</td>
    <td class="">template <typename LHS, typename RHS></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2257</td>
    <td class="uncoveredLine">inline AnyBinaryOp_match<LHS, RHS, true> m_c_BinOp(const LHS &L, const RHS &R) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2258</td>
    <td class="uncoveredLine">  return AnyBinaryOp_match<LHS, RHS, true>(L, R);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2259</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2260</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2261</td>
    <td class="">/// Matches an ICmp with a predicate over LHS and RHS in either order.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2262</td>
    <td class="">/// Swaps the predicate if operands are commuted.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2263</td>
    <td class="">template <typename LHS, typename RHS></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2264</td>
    <td class="">inline CmpClass_match<LHS, RHS, ICmpInst, ICmpInst::Predicate, true></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2265</td>
    <td class="uncoveredLine">m_c_ICmp(ICmpInst::Predicate &Pred, const LHS &L, const RHS &R) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2266</td>
    <td class="">  return CmpClass_match<LHS, RHS, ICmpInst, ICmpInst::Predicate, true>(Pred, L,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2267</td>
    <td class="uncoveredLine">                                                                       R);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2268</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2269</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2270</td>
    <td class="">/// Matches a specific opcode with LHS and RHS in either order.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2271</td>
    <td class="">template <typename LHS, typename RHS></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2272</td>
    <td class="">inline SpecificBinaryOp_match<LHS, RHS, true></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2273</td>
    <td class="">m_c_BinOp(unsigned Opcode, const LHS &L, const RHS &R) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2274</td>
    <td class="">  return SpecificBinaryOp_match<LHS, RHS, true>(Opcode, L, R);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2275</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2276</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2277</td>
    <td class="">/// Matches a Add with LHS and RHS in either order.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2278</td>
    <td class="">template <typename LHS, typename RHS></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2279</td>
    <td class="uncoveredLine">inline BinaryOp_match<LHS, RHS, Instruction::Add, true> m_c_Add(const LHS &L,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2280</td>
    <td class="">                                                                const RHS &R) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2281</td>
    <td class="uncoveredLine">  return BinaryOp_match<LHS, RHS, Instruction::Add, true>(L, R);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2282</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2283</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2284</td>
    <td class="">/// Matches a Mul with LHS and RHS in either order.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2285</td>
    <td class="">template <typename LHS, typename RHS></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2286</td>
    <td class="">inline BinaryOp_match<LHS, RHS, Instruction::Mul, true> m_c_Mul(const LHS &L,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2287</td>
    <td class="">                                                                const RHS &R) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2288</td>
    <td class="">  return BinaryOp_match<LHS, RHS, Instruction::Mul, true>(L, R);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2289</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2290</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2291</td>
    <td class="">/// Matches an And with LHS and RHS in either order.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2292</td>
    <td class="">template <typename LHS, typename RHS></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2293</td>
    <td class="uncoveredLine">inline BinaryOp_match<LHS, RHS, Instruction::And, true> m_c_And(const LHS &L,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2294</td>
    <td class="">                                                                const RHS &R) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2295</td>
    <td class="uncoveredLine">  return BinaryOp_match<LHS, RHS, Instruction::And, true>(L, R);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2296</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2297</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2298</td>
    <td class="">/// Matches an Or with LHS and RHS in either order.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2299</td>
    <td class="">template <typename LHS, typename RHS></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2300</td>
    <td class="uncoveredLine">inline BinaryOp_match<LHS, RHS, Instruction::Or, true> m_c_Or(const LHS &L,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2301</td>
    <td class="">                                                              const RHS &R) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2302</td>
    <td class="uncoveredLine">  return BinaryOp_match<LHS, RHS, Instruction::Or, true>(L, R);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2303</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2304</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2305</td>
    <td class="">/// Matches an Xor with LHS and RHS in either order.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2306</td>
    <td class="">template <typename LHS, typename RHS></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2307</td>
    <td class="uncoveredLine">inline BinaryOp_match<LHS, RHS, Instruction::Xor, true> m_c_Xor(const LHS &L,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2308</td>
    <td class="">                                                                const RHS &R) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2309</td>
    <td class="uncoveredLine">  return BinaryOp_match<LHS, RHS, Instruction::Xor, true>(L, R);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2310</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2311</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2312</td>
    <td class="">/// Matches a 'Neg' as 'sub 0, V'.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2313</td>
    <td class="">template <typename ValTy></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2314</td>
    <td class="">inline BinaryOp_match<cst_pred_ty<is_zero_int>, ValTy, Instruction::Sub></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2315</td>
    <td class="uncoveredLine">m_Neg(const ValTy &V) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2316</td>
    <td class="uncoveredLine">  return m_Sub(m_ZeroInt(), V);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2317</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2318</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2319</td>
    <td class="">/// Matches a 'Neg' as 'sub nsw 0, V'.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2320</td>
    <td class="">template <typename ValTy></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2321</td>
    <td class="">inline OverflowingBinaryOp_match<cst_pred_ty<is_zero_int>, ValTy,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2322</td>
    <td class="">                                 Instruction::Sub,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2323</td>
    <td class="">                                 OverflowingBinaryOperator::NoSignedWrap></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2324</td>
    <td class="">m_NSWNeg(const ValTy &V) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2325</td>
    <td class="">  return m_NSWSub(m_ZeroInt(), V);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2326</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2327</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2328</td>
    <td class="">/// Matches a 'Not' as 'xor V, -1' or 'xor -1, V'.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2329</td>
    <td class="">/// NOTE: we first match the 'Not' (by matching '-1'),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2330</td>
    <td class="">/// and only then match the inner matcher!</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2331</td>
    <td class="">template <typename ValTy></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2332</td>
    <td class="">inline BinaryOp_match<cst_pred_ty<is_all_ones>, ValTy, Instruction::Xor, true></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2333</td>
    <td class="uncoveredLine">m_Not(const ValTy &V) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2334</td>
    <td class="uncoveredLine">  return m_c_Xor(m_AllOnes(), V);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2335</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2336</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2337</td>
    <td class="">template <typename ValTy> struct NotForbidUndef_match {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2338</td>
    <td class="">  ValTy Val;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2339</td>
    <td class="">  NotForbidUndef_match(const ValTy &V) : Val(V) {}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2340</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2341</td>
    <td class="">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2342</td>
    <td class="">    // We do not use m_c_Xor because that could match an arbitrary APInt that is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2343</td>
    <td class="">    // not -1 as C and then fail to match the other operand if it is -1.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2344</td>
    <td class="">    // This code should still work even when both operands are constants.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2345</td>
    <td class="">    Value *X;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2346</td>
    <td class="">    const APInt *C;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2347</td>
    <td class="">    if (m_Xor(m_Value(X), m_APIntForbidUndef(C)).match(V) && C->isAllOnes())</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2348</td>
    <td class="">      return Val.match(X);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2349</td>
    <td class="">    if (m_Xor(m_APIntForbidUndef(C), m_Value(X)).match(V) && C->isAllOnes())</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2350</td>
    <td class="">      return Val.match(X);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2351</td>
    <td class="">    return false;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2352</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2353</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2354</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2355</td>
    <td class="">/// Matches a bitwise 'not' as 'xor V, -1' or 'xor -1, V'. For vectors, the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2356</td>
    <td class="">/// constant value must be composed of only -1 scalar elements.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2357</td>
    <td class="">template <typename ValTy></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2358</td>
    <td class="">inline NotForbidUndef_match<ValTy> m_NotForbidUndef(const ValTy &V) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2359</td>
    <td class="">  return NotForbidUndef_match<ValTy>(V);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2360</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2361</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2362</td>
    <td class="">/// Matches an SMin with LHS and RHS in either order.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2363</td>
    <td class="">template <typename LHS, typename RHS></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2364</td>
    <td class="">inline MaxMin_match<ICmpInst, LHS, RHS, smin_pred_ty, true></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2365</td>
    <td class="">m_c_SMin(const LHS &L, const RHS &R) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2366</td>
    <td class="">  return MaxMin_match<ICmpInst, LHS, RHS, smin_pred_ty, true>(L, R);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2367</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2368</td>
    <td class="">/// Matches an SMax with LHS and RHS in either order.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2369</td>
    <td class="">template <typename LHS, typename RHS></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2370</td>
    <td class="">inline MaxMin_match<ICmpInst, LHS, RHS, smax_pred_ty, true></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2371</td>
    <td class="">m_c_SMax(const LHS &L, const RHS &R) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2372</td>
    <td class="">  return MaxMin_match<ICmpInst, LHS, RHS, smax_pred_ty, true>(L, R);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2373</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2374</td>
    <td class="">/// Matches a UMin with LHS and RHS in either order.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2375</td>
    <td class="">template <typename LHS, typename RHS></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2376</td>
    <td class="">inline MaxMin_match<ICmpInst, LHS, RHS, umin_pred_ty, true></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2377</td>
    <td class="">m_c_UMin(const LHS &L, const RHS &R) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2378</td>
    <td class="">  return MaxMin_match<ICmpInst, LHS, RHS, umin_pred_ty, true>(L, R);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2379</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2380</td>
    <td class="">/// Matches a UMax with LHS and RHS in either order.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2381</td>
    <td class="">template <typename LHS, typename RHS></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2382</td>
    <td class="">inline MaxMin_match<ICmpInst, LHS, RHS, umax_pred_ty, true></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2383</td>
    <td class="">m_c_UMax(const LHS &L, const RHS &R) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2384</td>
    <td class="">  return MaxMin_match<ICmpInst, LHS, RHS, umax_pred_ty, true>(L, R);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2385</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2386</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2387</td>
    <td class="">template <typename LHS, typename RHS></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2388</td>
    <td class="">inline match_combine_or<</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2389</td>
    <td class="">    match_combine_or<MaxMin_match<ICmpInst, LHS, RHS, smax_pred_ty, true>,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2390</td>
    <td class="">                     MaxMin_match<ICmpInst, LHS, RHS, smin_pred_ty, true>>,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2391</td>
    <td class="">    match_combine_or<MaxMin_match<ICmpInst, LHS, RHS, umax_pred_ty, true>,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2392</td>
    <td class="">                     MaxMin_match<ICmpInst, LHS, RHS, umin_pred_ty, true>>></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2393</td>
    <td class="">m_c_MaxOrMin(const LHS &L, const RHS &R) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2394</td>
    <td class="">  return m_CombineOr(m_CombineOr(m_c_SMax(L, R), m_c_SMin(L, R)),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2395</td>
    <td class="">                     m_CombineOr(m_c_UMax(L, R), m_c_UMin(L, R)));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2396</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2397</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2398</td>
    <td class="">template <Intrinsic::ID IntrID, typename T0, typename T1></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2399</td>
    <td class="">inline match_combine_or<typename m_Intrinsic_Ty<T0, T1>::Ty,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2400</td>
    <td class="">                        typename m_Intrinsic_Ty<T1, T0>::Ty></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2401</td>
    <td class="">m_c_Intrinsic(const T0 &Op0, const T1 &Op1) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2402</td>
    <td class="">  return m_CombineOr(m_Intrinsic<IntrID>(Op0, Op1),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2403</td>
    <td class="">                     m_Intrinsic<IntrID>(Op1, Op0));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2404</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2405</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2406</td>
    <td class="">/// Matches FAdd with LHS and RHS in either order.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2407</td>
    <td class="">template <typename LHS, typename RHS></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2408</td>
    <td class="">inline BinaryOp_match<LHS, RHS, Instruction::FAdd, true></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2409</td>
    <td class="">m_c_FAdd(const LHS &L, const RHS &R) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2410</td>
    <td class="">  return BinaryOp_match<LHS, RHS, Instruction::FAdd, true>(L, R);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2411</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2412</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2413</td>
    <td class="">/// Matches FMul with LHS and RHS in either order.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2414</td>
    <td class="">template <typename LHS, typename RHS></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2415</td>
    <td class="">inline BinaryOp_match<LHS, RHS, Instruction::FMul, true></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2416</td>
    <td class="">m_c_FMul(const LHS &L, const RHS &R) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2417</td>
    <td class="">  return BinaryOp_match<LHS, RHS, Instruction::FMul, true>(L, R);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2418</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2419</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2420</td>
    <td class="">template <typename Opnd_t> struct Signum_match {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2421</td>
    <td class="">  Opnd_t Val;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2422</td>
    <td class="">  Signum_match(const Opnd_t &V) : Val(V) {}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2423</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2424</td>
    <td class="">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2425</td>
    <td class="">    unsigned TypeSize = V->getType()->getScalarSizeInBits();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2426</td>
    <td class="">    if (TypeSize == 0)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2427</td>
    <td class="">      return false;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2428</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2429</td>
    <td class="">    unsigned ShiftWidth = TypeSize - 1;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2430</td>
    <td class="">    Value *OpL = nullptr, *OpR = nullptr;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2431</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2432</td>
    <td class="">    // This is the representation of signum we match:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2433</td>
    <td class="">    //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2434</td>
    <td class="">    //  signum(x) == (x >> 63) | (-x >>u 63)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2435</td>
    <td class="">    //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2436</td>
    <td class="">    // An i1 value is its own signum, so it's correct to match</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2437</td>
    <td class="">    //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2438</td>
    <td class="">    //  signum(x) == (x >> 0)  | (-x >>u 0)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2439</td>
    <td class="">    //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2440</td>
    <td class="">    // for i1 values.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2441</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2442</td>
    <td class="">    auto LHS = m_AShr(m_Value(OpL), m_SpecificInt(ShiftWidth));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2443</td>
    <td class="">    auto RHS = m_LShr(m_Neg(m_Value(OpR)), m_SpecificInt(ShiftWidth));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2444</td>
    <td class="">    auto Signum = m_Or(LHS, RHS);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2445</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2446</td>
    <td class="">    return Signum.match(V) && OpL == OpR && Val.match(OpL);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2447</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2448</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2449</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2450</td>
    <td class="">/// Matches a signum pattern.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2451</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2452</td>
    <td class="">/// signum(x) =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2453</td>
    <td class="">///      x >  0  ->  1</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2454</td>
    <td class="">///      x == 0  ->  0</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2455</td>
    <td class="">///      x <  0  -> -1</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2456</td>
    <td class="">template <typename Val_t> inline Signum_match<Val_t> m_Signum(const Val_t &V) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2457</td>
    <td class="">  return Signum_match<Val_t>(V);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2458</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2459</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2460</td>
    <td class="">template <int Ind, typename Opnd_t> struct ExtractValue_match {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2461</td>
    <td class="">  Opnd_t Val;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2462</td>
    <td class="uncoveredLine">  ExtractValue_match(const Opnd_t &V) : Val(V) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2463</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2464</td>
    <td class="uncoveredLine">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2465</td>
    <td class="uncoveredLine">    if (auto *I = dyn_cast<ExtractValueInst>(V)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2466</td>
    <td class="">      // If Ind is -1, don't inspect indices</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2467</td>
    <td class="">      if (Ind != -1 &&</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2468</td>
    <td class="">          !(I->getNumIndices() == 1 && I->getIndices()[0] == (unsigned)Ind))</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2469</td>
    <td class="">        return false;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2470</td>
    <td class="uncoveredLine">      return Val.match(I->getAggregateOperand());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2471</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2472</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2473</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2474</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2475</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2476</td>
    <td class="">/// Match a single index ExtractValue instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2477</td>
    <td class="">/// For example m_ExtractValue<1>(...)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2478</td>
    <td class="">template <int Ind, typename Val_t></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2479</td>
    <td class="">inline ExtractValue_match<Ind, Val_t> m_ExtractValue(const Val_t &V) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2480</td>
    <td class="">  return ExtractValue_match<Ind, Val_t>(V);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2481</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2482</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2483</td>
    <td class="">/// Match an ExtractValue instruction with any index.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2484</td>
    <td class="">/// For example m_ExtractValue(...)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2485</td>
    <td class="">template <typename Val_t></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2486</td>
    <td class="uncoveredLine">inline ExtractValue_match<-1, Val_t> m_ExtractValue(const Val_t &V) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2487</td>
    <td class="uncoveredLine">  return ExtractValue_match<-1, Val_t>(V);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2488</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2489</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2490</td>
    <td class="">/// Matcher for a single index InsertValue instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2491</td>
    <td class="">template <int Ind, typename T0, typename T1> struct InsertValue_match {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2492</td>
    <td class="">  T0 Op0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2493</td>
    <td class="">  T1 Op1;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2494</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2495</td>
    <td class="">  InsertValue_match(const T0 &Op0, const T1 &Op1) : Op0(Op0), Op1(Op1) {}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2496</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2497</td>
    <td class="">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2498</td>
    <td class="">    if (auto *I = dyn_cast<InsertValueInst>(V)) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2499</td>
    <td class="">      return Op0.match(I->getOperand(0)) && Op1.match(I->getOperand(1)) &&</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2500</td>
    <td class="">             I->getNumIndices() == 1 && Ind == I->getIndices()[0];</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2501</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2502</td>
    <td class="">    return false;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2503</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2504</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2505</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2506</td>
    <td class="">/// Matches a single index InsertValue instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2507</td>
    <td class="">template <int Ind, typename Val_t, typename Elt_t></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2508</td>
    <td class="">inline InsertValue_match<Ind, Val_t, Elt_t> m_InsertValue(const Val_t &Val,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2509</td>
    <td class="">                                                          const Elt_t &Elt) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2510</td>
    <td class="">  return InsertValue_match<Ind, Val_t, Elt_t>(Val, Elt);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2511</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2512</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2513</td>
    <td class="">/// Matches patterns for `vscale`. This can either be a call to `llvm.vscale` or</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2514</td>
    <td class="">/// the constant expression</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2515</td>
    <td class="">///  `ptrtoint(gep <vscale x 1 x i8>, <vscale x 1 x i8>* null, i32 1>`</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2516</td>
    <td class="">/// under the right conditions determined by DataLayout.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2517</td>
    <td class="">struct VScaleVal_match {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2518</td>
    <td class="uncoveredLine">  template <typename ITy> bool match(ITy *V) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2519</td>
    <td class="uncoveredLine">    if (m_Intrinsic<Intrinsic::vscale>().match(V))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2520</td>
    <td class="uncoveredLine">      return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2521</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2522</td>
    <td class="">    Value *Ptr;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2523</td>
    <td class="uncoveredLine">    if (m_PtrToInt(m_Value(Ptr)).match(V)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2524</td>
    <td class="uncoveredLine">      if (auto *GEP = dyn_cast<GEPOperator>(Ptr)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2525</td>
    <td class="">        auto *DerefTy =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2526</td>
    <td class="uncoveredLine">            dyn_cast<ScalableVectorType>(GEP->getSourceElementType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2527</td>
    <td class="uncoveredLine">        if (GEP->getNumIndices() == 1 && DerefTy &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2528</td>
    <td class="uncoveredLine">            DerefTy->getElementType()->isIntegerTy(8) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2529</td>
    <td class="uncoveredLine">            m_Zero().match(GEP->getPointerOperand()) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2530</td>
    <td class="uncoveredLine">            m_SpecificInt(1).match(GEP->idx_begin()->get()))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2531</td>
    <td class="uncoveredLine">          return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2532</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2533</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2534</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2535</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2536</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2537</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2538</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2539</td>
    <td class="uncoveredLine">inline VScaleVal_match m_VScale() {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2540</td>
    <td class="uncoveredLine">  return VScaleVal_match();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2541</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2542</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2543</td>
    <td class="">template <typename LHS, typename RHS, unsigned Opcode, bool Commutable = false></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2544</td>
    <td class="">struct LogicalOp_match {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2545</td>
    <td class="">  LHS L;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2546</td>
    <td class="">  RHS R;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2547</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2548</td>
    <td class="coveredLine">  LogicalOp_match(const LHS &L, const RHS &R) : L(L), R(R) {}</td>
    <td>0</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2549</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2550</td>
    <td class="coveredLine">  template <typename T> bool match(T *V) {</td>
    <td>0</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2551</td>
    <td class="coveredLine">    auto *I = dyn_cast<Instruction>(V);</td>
    <td>0</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2552</td>
    <td class="coveredLine">    if (!I || !I->getType()->isIntOrIntVectorTy(1))</td>
    <td>0</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2553</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2554</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2555</td>
    <td class="coveredLine">    if (I->getOpcode() == Opcode) {</td>
    <td>0</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2556</td>
    <td class="uncoveredLine">      auto *Op0 = I->getOperand(0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2557</td>
    <td class="uncoveredLine">      auto *Op1 = I->getOperand(1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2558</td>
    <td class="uncoveredLine">      return (L.match(Op0) && R.match(Op1)) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2559</td>
    <td class="uncoveredLine">             (Commutable && L.match(Op1) && R.match(Op0));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2560</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2561</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2562</td>
    <td class="coveredLine">    if (auto *Select = dyn_cast<SelectInst>(I)) {</td>
    <td>0</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2563</td>
    <td class="uncoveredLine">      auto *Cond = Select->getCondition();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2564</td>
    <td class="uncoveredLine">      auto *TVal = Select->getTrueValue();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2565</td>
    <td class="uncoveredLine">      auto *FVal = Select->getFalseValue();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2566</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2567</td>
    <td class="">      // Don't match a scalar select of bool vectors.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2568</td>
    <td class="">      // Transforms expect a single type for operands if this matches.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2569</td>
    <td class="uncoveredLine">      if (Cond->getType() != Select->getType())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2570</td>
    <td class="uncoveredLine">        return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2571</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2572</td>
    <td class="">      if (Opcode == Instruction::And) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2573</td>
    <td class="uncoveredLine">        auto *C = dyn_cast<Constant>(FVal);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2574</td>
    <td class="uncoveredLine">        if (C && C->isNullValue())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2575</td>
    <td class="uncoveredLine">          return (L.match(Cond) && R.match(TVal)) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2576</td>
    <td class="uncoveredLine">                 (Commutable && L.match(TVal) && R.match(Cond));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2577</td>
    <td class="">      } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2578</td>
    <td class="">        assert(Opcode == Instruction::Or);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2579</td>
    <td class="uncoveredLine">        auto *C = dyn_cast<Constant>(TVal);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2580</td>
    <td class="uncoveredLine">        if (C && C->isOneValue())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2581</td>
    <td class="uncoveredLine">          return (L.match(Cond) && R.match(FVal)) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2582</td>
    <td class="uncoveredLine">                 (Commutable && L.match(FVal) && R.match(Cond));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2583</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2584</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2585</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2586</td>
    <td class="coveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2587</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2588</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2589</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2590</td>
    <td class="">/// Matches L && R either in the form of L & R or L ? R : false.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2591</td>
    <td class="">/// Note that the latter form is poison-blocking.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2592</td>
    <td class="">template <typename LHS, typename RHS></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2593</td>
    <td class="coveredLine">inline LogicalOp_match<LHS, RHS, Instruction::And> m_LogicalAnd(const LHS &L,</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2594</td>
    <td class="">                                                                const RHS &R) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2595</td>
    <td class="coveredLine">  return LogicalOp_match<LHS, RHS, Instruction::And>(L, R);</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2596</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2597</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2598</td>
    <td class="">/// Matches L && R where L and R are arbitrary values.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2599</td>
    <td class="">inline auto m_LogicalAnd() { return m_LogicalAnd(m_Value(), m_Value()); }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2600</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2601</td>
    <td class="">/// Matches L && R with LHS and RHS in either order.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2602</td>
    <td class="">template <typename LHS, typename RHS></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2603</td>
    <td class="">inline LogicalOp_match<LHS, RHS, Instruction::And, true></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2604</td>
    <td class="">m_c_LogicalAnd(const LHS &L, const RHS &R) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2605</td>
    <td class="">  return LogicalOp_match<LHS, RHS, Instruction::And, true>(L, R);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2606</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2607</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2608</td>
    <td class="">/// Matches L || R either in the form of L | R or L ? true : R.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2609</td>
    <td class="">/// Note that the latter form is poison-blocking.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2610</td>
    <td class="">template <typename LHS, typename RHS></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2611</td>
    <td class="coveredLine">inline LogicalOp_match<LHS, RHS, Instruction::Or> m_LogicalOr(const LHS &L,</td>
    <td>0</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2612</td>
    <td class="">                                                              const RHS &R) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2613</td>
    <td class="coveredLine">  return LogicalOp_match<LHS, RHS, Instruction::Or>(L, R);</td>
    <td>0</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2614</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2615</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2616</td>
    <td class="">/// Matches L || R where L and R are arbitrary values.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2617</td>
    <td class="uncoveredLine">inline auto m_LogicalOr() { return m_LogicalOr(m_Value(), m_Value()); }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2618</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2619</td>
    <td class="">/// Matches L || R with LHS and RHS in either order.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2620</td>
    <td class="">template <typename LHS, typename RHS></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2621</td>
    <td class="">inline LogicalOp_match<LHS, RHS, Instruction::Or, true></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2622</td>
    <td class="">m_c_LogicalOr(const LHS &L, const RHS &R) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2623</td>
    <td class="">  return LogicalOp_match<LHS, RHS, Instruction::Or, true>(L, R);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2624</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2625</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2626</td>
    <td class="">/// Matches either L && R or L || R,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2627</td>
    <td class="">/// either one being in the either binary or logical form.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2628</td>
    <td class="">/// Note that the latter form is poison-blocking.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2629</td>
    <td class="">template <typename LHS, typename RHS, bool Commutable = false></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2630</td>
    <td class="">inline auto m_LogicalOp(const LHS &L, const RHS &R) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2631</td>
    <td class="">  return m_CombineOr(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2632</td>
    <td class="">      LogicalOp_match<LHS, RHS, Instruction::And, Commutable>(L, R),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2633</td>
    <td class="">      LogicalOp_match<LHS, RHS, Instruction::Or, Commutable>(L, R));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2634</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2635</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2636</td>
    <td class="">/// Matches either L && R or L || R where L and R are arbitrary values.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2637</td>
    <td class="">inline auto m_LogicalOp() { return m_LogicalOp(m_Value(), m_Value()); }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2638</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2639</td>
    <td class="">/// Matches either L && R or L || R with LHS and RHS in either order.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2640</td>
    <td class="">template <typename LHS, typename RHS></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2641</td>
    <td class="">inline auto m_c_LogicalOp(const LHS &L, const RHS &R) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2642</td>
    <td class="">  return m_LogicalOp<LHS, RHS, /*Commutable=*/true>(L, R);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2643</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2644</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2645</td>
    <td class="">} // end namespace PatternMatch</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2646</td>
    <td class="">} // end namespace llvm</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2647</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2648</td>
    <td class="">#endif // LLVM_IR_PATTERNMATCH_H</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2649</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Functions Report</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Functions Report</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Function name</th>
    <th class="mainTh">Number of hits</th>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchIKNS_4UserENS0_15LogicalOp_matchINS0_7bind_tyIKNS_5ValueEEES8_Lj28ELb0EEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchIKNS_4UserENS0_15LogicalOp_matchINS0_7bind_tyIKNS_5ValueEEES8_Lj29ELb0EEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchIKNS_4UserENS0_15LogicalOp_matchINS0_11class_matchINS_5ValueEEES7_Lj29ELb0EEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch11class_matchINS_5ValueEE5matchIS2_EEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch11class_matchINS_5ValueEE5matchIKS2_EEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch7m_ValueEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch7bind_tyIKNS_5ValueEEC2ERPS3_</td>
    <td class="numberOfCalls">8</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch7bind_tyIKNS_5ValueEE5matchIS2_EEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch7bind_tyIKNS_5ValueEE5matchIS3_EEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch7m_ValueERPKNS_5ValueE</td>
    <td class="numberOfCalls">8</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch15LogicalOp_matchINS0_7bind_tyIKNS_5ValueEEES5_Lj29ELb0EEC2ERKS5_S8_</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch15LogicalOp_matchINS0_7bind_tyIKNS_5ValueEEES5_Lj28ELb0EEC2ERKS5_S8_</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch15LogicalOp_matchINS0_11class_matchINS_5ValueEEES4_Lj29ELb0EEC2ERKS4_S7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch15LogicalOp_matchINS0_11class_matchINS_5ValueEEES4_Lj29ELb0EE5matchIKNS_4UserEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch15LogicalOp_matchINS0_7bind_tyIKNS_5ValueEEES5_Lj29ELb0EE5matchIKNS_4UserEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch15LogicalOp_matchINS0_7bind_tyIKNS_5ValueEEES5_Lj28ELb0EE5matchIKNS_4UserEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch12m_LogicalAndINS0_7bind_tyIKNS_5ValueEEES5_EENS0_15LogicalOp_matchIT_T0_Lj28ELb0EEERKS7_RKS8_</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch11m_LogicalOrINS0_7bind_tyIKNS_5ValueEEES5_EENS0_15LogicalOp_matchIT_T0_Lj29ELb0EEERKS7_RKS8_</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch11m_LogicalOrINS0_11class_matchINS_5ValueEEES4_EENS0_15LogicalOp_matchIT_T0_Lj29ELb0EEERKS6_RKS7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch11m_LogicalOrEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchIKNS_4UserENS0_14CmpClass_matchINS0_11class_matchINS_5ValueEEENS0_7is_zeroENS_8ICmpInstENS_7CmpInst9PredicateELb0EEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchIKNS_8ICmpInstENS0_14CmpClass_matchINS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS6_EEEENS0_7bind_tyINS_5ValueEEES2_NS_7CmpInst9PredicateELb1EEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchIKNS_5ValueENS0_14cstval_pred_tyINS0_9is_power2ENS_11ConstantIntEEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchIKNS_5ValueENS0_15VScaleVal_matchEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchIKNS_5ValueENS0_14BinaryOp_matchINS0_14cstval_pred_tyINS0_6is_oneENS_11ConstantIntEEENS0_11class_matchIS2_EELj25ELb0EEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchINS_5ValueENS0_14CmpClass_matchINS0_16match_combine_orINS0_14specificval_tyENS0_15CastClass_matchIS5_Lj47EEEEENS0_7bind_tyIS2_EENS_8ICmpInstENS_7CmpInst9PredicateELb1EEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchIKNS_5ValueENS0_14BinaryOp_matchINS0_14cstval_pred_tyINS0_12is_sign_maskENS_11ConstantIntEEENS0_11class_matchIS2_EELj26ELb0EEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchIKNS_5ValueENS0_14BinaryOp_matchINS0_7bind_tyIS2_EENS0_11class_matchIS2_EELj25ELb0EEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchIKNS_5ValueENS0_11apint_matchEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchIKNS_5ValueENS0_14BinaryOp_matchINS0_7bind_tyIS2_EENS0_11class_matchIS2_EELj26ELb0EEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchIKNS_5ValueENS0_16match_combine_orINS4_INS0_12MaxMin_matchINS_8ICmpInstENS0_7bind_tyIS2_EES8_NS0_12smax_pred_tyELb0EEENS5_IS6_S8_S8_NS0_12smin_pred_tyELb0EEEEENS4_INS5_IS6_S8_S8_NS0_12umax_pred_tyELb0EEENS5_IS6_S8_S8_NS0_12umin_pred_tyELb0EEEEEEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchIKNS_5ValueENS0_7is_zeroEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchINS_5ValueENS0_14BinaryOp_matchINS0_14cstval_pred_tyINS0_11is_zero_intENS_11ConstantIntEEENS0_14specificval_tyELj15ELb0EEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchIKNS_8ICmpInstENS0_14CmpClass_matchINS0_14BinaryOp_matchINS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS7_EEEENS0_7bind_tyINS_5ValueEEELj28ELb1EEESD_S2_NS_7CmpInst9PredicateELb1EEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchIKNS_5ValueENS0_14BinaryOp_matchINS0_7bind_tyIS2_EES6_Lj13ELb0EEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchIKNS_5ValueENS0_14BinaryOp_matchINS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEENS4_INS0_14specificval_tyES9_Lj29ELb1EEELj30ELb1EEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchIKNS_5ValueENS0_14BinaryOp_matchINS0_7bind_tyIS2_EES6_Lj28ELb0EEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchIKNS_5ValueENS0_16match_combine_orINS0_15CastClass_matchINS0_14BinaryOp_matchINS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEENS0_14specificval_tyELj30ELb1EEELj39EEENS5_ISC_Lj40EEEEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchIKNS_5ValueENS0_16match_combine_orINS0_15CastClass_matchINS0_7bind_tyIS2_EELj39EEENS5_IS7_Lj40EEEEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchIKNS_5ValueENS0_14BinaryOp_matchINS4_INS0_14specificval_tyENS0_7bind_tyIS2_EELj28ELb1EEENS0_14deferredval_tyIS2_EELj30ELb1EEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchIKNS_5ValueENS0_14BinaryOp_matchINS4_INS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEENS0_14specificval_tyELj30ELb1EEENS0_11class_matchIS2_EELj28ELb1EEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchIKNS_5ValueENS0_14BinaryOp_matchINS0_14specificval_tyENS0_11class_matchIS2_EELj28ELb1EEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchIKNS_5ValueENS0_14BinaryOp_matchINS4_INS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEENS0_7bind_tyIS2_EELj30ELb1EEENS0_11class_matchIS2_EELj28ELb1EEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchINS_5ValueENS0_14BinaryOp_matchINS0_14specificval_tyENS0_11class_matchIS2_EELj28ELb0EEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchIKNS_5ValueENS0_11Exact_matchINS0_14BinaryOp_matchINS0_11class_matchIS2_EES7_Lj26ELb0EEEEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchINS_5ValueENS0_14cstval_pred_tyINS0_9is_power2ENS_11ConstantIntEEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchIKNS_8OperatorENS0_17AnyBinaryOp_matchINS0_7bind_tyINS_5ValueEEENS0_14BinaryOp_matchINS0_14deferredval_tyIS6_EES7_Lj15ELb0EEELb1EEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchIKNS_8OperatorENS0_17AnyBinaryOp_matchINS0_7bind_tyINS_5ValueEEENS0_14BinaryOp_matchINS0_14deferredval_tyIS6_EES7_Lj13ELb1EEELb1EEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchIKNS_8OperatorENS0_14BinaryOp_matchINS0_7bind_tyINS_5ValueEEENS4_INS0_14deferredval_tyIS6_EENS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEELj13ELb1EEELj30ELb1EEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchIKNS_8OperatorENS0_14BinaryOp_matchINS0_7bind_tyINS_5ValueEEENS4_INS0_14cstval_pred_tyINS0_11is_zero_intENS_11ConstantIntEEENS0_14deferredval_tyIS6_EELj15ELb0EEELj28ELb1EEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchINS_5ValueENS0_14BinaryOp_matchINS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEENS0_14specificval_tyELj30ELb1EEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchIKNS_8OperatorENS0_17AnyBinaryOp_matchINS0_7bind_tyINS_5ValueEEENS0_14BinaryOp_matchIS7_NS0_14deferredval_tyIS6_EELj15ELb0EEELb1EEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchIKNS_8ICmpInstENS0_14CmpClass_matchINS0_16match_combine_orINS5_INS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS6_EEEENS0_14BinaryOp_matchIS9_NS0_11apint_matchELj13ELb0EEEEENS0_7bind_tyINS_5ValueEEES2_NS_7CmpInst9PredicateELb0EEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchIKNS_5ValueENS0_14BinaryOp_matchINS0_14cstval_pred_tyINS0_11is_zero_intENS_11ConstantIntEEENS0_14specificval_tyELj15ELb0EEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchINS_5ValueENS0_11apint_matchEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchIKNS_11InstructionENS0_9brc_matchINS0_14CmpClass_matchINS0_14specificval_tyENS0_11apint_matchENS_8ICmpInstENS_7CmpInst9PredicateELb1EEENS0_7bind_tyINS_10BasicBlockEEESE_EEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchIKNS_8ICmpInstENS0_14CmpClass_matchINS0_14BinaryOp_matchINS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS7_EEEENS0_11api_pred_tyINS0_9is_power2EEELj28ELb1EEENS0_7is_zeroES2_NS_7CmpInst9PredicateELb0EEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchINS_5ValueENS0_14cstval_pred_tyINS0_6is_oneENS_11ConstantIntEEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchINS_5ValueENS0_14BinaryOp_matchINS0_11class_matchIS2_EENS0_14specificval_tyELj28ELb0EEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchIKNS_8ICmpInstENS0_14CmpClass_matchINS0_14BinaryOp_matchINS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEENS0_15BinOpPred_matchINS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchISC_EEEENS0_20bind_const_intval_tyENS0_17is_right_shift_opEEELj30ELb1EEENS0_7bind_tyINS_5ValueEEES2_NS_7CmpInst9PredicateELb1EEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchIKNS_8ICmpInstENS0_14CmpClass_matchINS0_15BinOpPred_matchINS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS7_EEEENS0_20bind_const_intval_tyENS0_17is_right_shift_opEEENS0_7bind_tyINS_5ValueEEES2_NS_7CmpInst9PredicateELb1EEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchIKNS_8ICmpInstENS0_14CmpClass_matchINS0_14BinaryOp_matchINS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEENS5_INS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchISB_EEEENS0_20bind_const_intval_tyELj25ELb0EEELj30ELb1EEENS0_7bind_tyINS_5ValueEEES2_NS_7CmpInst9PredicateELb1EEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchIKNS_8ICmpInstENS0_14CmpClass_matchINS0_14BinaryOp_matchINS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS7_EEEENS0_20bind_const_intval_tyELj25ELb0EEENS0_7bind_tyINS_5ValueEEES2_NS_7CmpInst9PredicateELb1EEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchIKNS_8ICmpInstENS0_14CmpClass_matchINS0_14BinaryOp_matchINS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEENS5_INS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchISB_EEEENS0_7bind_tyINS_5ValueEEELj30ELb1EEELj30ELb1EEESH_S2_NS_7CmpInst9PredicateELb1EEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchINS_5ValueENS0_14cstval_pred_tyINS0_12is_sign_maskENS_11ConstantIntEEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchIKNS_8ICmpInstENS0_14CmpClass_matchINS0_14BinaryOp_matchINS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS7_EEEENS0_7bind_tyINS_5ValueEEELj30ELb1EEESD_S2_NS_7CmpInst9PredicateELb1EEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchIKNS_8ICmpInstENS0_14CmpClass_matchINS0_14BinaryOp_matchINS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEENS5_INS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchISB_EEEENS0_7bind_tyINS_5ValueEEELj29ELb1EEELj30ELb1EEESH_S2_NS_7CmpInst9PredicateELb1EEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchIKNS_8ICmpInstENS0_14CmpClass_matchINS0_14BinaryOp_matchINS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS7_EEEENS0_7bind_tyINS_5ValueEEELj29ELb1EEESD_S2_NS_7CmpInst9PredicateELb1EEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchIKNS_8ICmpInstENS0_14CmpClass_matchINS0_14BinaryOp_matchINS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEENS5_INS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchISB_EEEENS0_7bind_tyINS_5ValueEEELj28ELb1EEELj30ELb1EEESH_S2_NS_7CmpInst9PredicateELb1EEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchIKNS_5ValueENS0_14cstval_pred_tyINS0_17is_power2_or_zeroENS_11ConstantIntEEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchINS_5ValueENS0_16match_combine_orINS0_14specificval_tyENS0_15CastClass_matchIS4_Lj40EEEEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchIKNS_5ValueENS0_15LogicalOp_matchINS0_7bind_tyIS3_EES6_Lj28ELb0EEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchINS_5ValueENS0_12MaxMin_matchINS_8ICmpInstENS0_14specificval_tyENS0_11apint_matchENS0_12umax_pred_tyELb0EEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchINS_5ValueENS0_14BinaryOp_matchINS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEENS0_7bind_tyIS2_EELj30ELb1EEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchIKNS_5ValueENS0_25OverflowingBinaryOp_matchINS0_14cstval_pred_tyINS0_11is_zero_intENS_11ConstantIntEEENS0_14specificval_tyELj15ELj2EEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchIKNS_5ValueENS0_14BinaryOp_matchINS0_7bind_tyIS2_EES6_Lj15ELb0EEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchIKNS_5ValueENS0_15LogicalOp_matchINS0_7bind_tyIS3_EES6_Lj29ELb0EEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchIKNS_11InstructionENS0_15LogicalOp_matchINS0_7bind_tyIKNS_5ValueEEES8_Lj28ELb0EEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchIKNS_5ValueENS0_14BinaryOp_matchINS0_14specificval_tyES5_Lj15ELb0EEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchIKNS_5ValueENS0_25OverflowingBinaryOp_matchINS0_7bind_tyIS2_EES6_Lj15ELj2EEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchIKNS_5ValueENS0_25OverflowingBinaryOp_matchINS0_14specificval_tyES5_Lj15ELj2EEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchINS_5ValueENS0_14cstval_pred_tyINS0_14is_any_zero_fpENS_10ConstantFPEEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchINS_5ValueENS0_12MaxMin_matchINS_8ICmpInstENS0_14specificval_tyENS0_11apint_matchENS0_12umin_pred_tyELb0EEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchINS_5ValueENS0_16match_combine_orINS0_14cstval_pred_tyINS0_11is_zero_intENS_11ConstantIntEEENS4_INS0_11is_all_onesES6_EEEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchINS_5ValueENS0_16match_combine_orINS0_14cstval_pred_tyINS0_11is_zero_intENS_11ConstantIntEEENS4_INS0_6is_oneES6_EEEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchINS_5ValueENS0_7bind_tyINS_8ConstantEEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchIKNS_11InstructionENS0_15LogicalOp_matchINS0_7bind_tyIKNS_5ValueEEES8_Lj29ELb0EEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchINS_5ValueENS0_14ThreeOps_matchINS0_12OneUse_matchINS0_11class_matchIS2_EEEES6_S6_Lj57EEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchIKNS_5ValueENS0_25OverflowingBinaryOp_matchINS0_14specificval_tyENS0_11apint_matchELj13ELj2EEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchIKNS_5ValueENS0_25OverflowingBinaryOp_matchINS0_14specificval_tyENS0_11apint_matchELj13ELj1EEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchIKNS_5ValueENS0_14BinaryOp_matchINS0_14specificval_tyENS0_11class_matchIS2_EELj26ELb0EEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchIKNS_5ValueENS0_25OverflowingBinaryOp_matchINS0_7bind_tyIS3_EENS0_11apint_matchELj13ELj1EEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchIKNS_5ValueENS0_14BinaryOp_matchINS0_7bind_tyIS3_EENS0_11apint_matchELj29ELb0EEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchIKNS_5ValueENS0_14BinaryOp_matchINS0_14specificval_tyENS0_11apint_matchELj29ELb0EEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchIKNS_5ValueENS0_25OverflowingBinaryOp_matchINS0_14specificval_tyENS0_11class_matchIS2_EELj15ELj1EEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchIKNS_5ValueENS0_11Exact_matchINS0_14BinaryOp_matchINS0_11class_matchIS2_EES7_Lj19ELb0EEEEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchIKNS_4UserENS0_14CmpClass_matchINS0_14specificval_tyENS0_7bind_tyINS_5ValueEEENS_8ICmpInstENS_7CmpInst9PredicateELb1EEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchIKNS_4UserENS0_15LogicalOp_matchINS0_11class_matchINS_5ValueEEES7_Lj28ELb0EEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchINS_5ValueENS0_14CmpClass_matchINS0_14specificval_tyENS0_7bind_tyIS2_EENS_8ICmpInstENS_7CmpInst9PredicateELb1EEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchIKNS_25OverflowingBinaryOperatorENS0_14BinaryOp_matchINS0_14specificval_tyENS0_11apint_matchELj17ELb0EEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchIKNS_25OverflowingBinaryOperatorENS0_14BinaryOp_matchINS0_14specificval_tyENS0_11apint_matchELj25ELb0EEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchINS_5ValueENS0_13apfloat_matchEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchINS_5ValueENS0_17match_combine_andINS0_17IntrinsicID_matchENS0_14Argument_matchINS0_7bind_tyIS2_EEEEEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchINS_5ValueENS0_14CmpClass_matchINS0_7bind_tyIS2_EES5_NS_8FCmpInstENS_7CmpInst9PredicateELb0EEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchINS_5ValueENS0_17match_combine_andINS3_INS0_17IntrinsicID_matchENS0_14Argument_matchINS0_7bind_tyIS2_EEEEEENS5_INS0_20bind_const_intval_tyEEEEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchIKNS_5ValueENS0_14BinaryOp_matchINS0_14specificval_tyENS0_11class_matchIS2_EELj22ELb0EEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchIKNS_11InstructionENS0_17match_combine_andINS4_INS0_17IntrinsicID_matchENS0_14Argument_matchINS0_11class_matchINS_5ValueEEEEEEESA_EEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchIKNS_5ValueENS0_14BinaryOp_matchINS0_14specificval_tyENS0_11class_matchIS2_EELj23ELb0EEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchIKNS_5ValueENS0_25OverflowingBinaryOp_matchINS0_14specificval_tyENS0_11class_matchIS2_EELj15ELj2EEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchIKNS_11InstructionENS0_18ExtractValue_matchILin1ENS0_7bind_tyIKNS_16WithOverflowInstEEEEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchIKNS_5ValueENS0_18ExtractValue_matchILin1ENS0_14specificval_tyEEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchINS_5ValueENS0_16match_combine_orINS0_12MaxMin_matchINS_8FCmpInstENS0_14specificval_tyENS0_13apfloat_matchENS0_13ofmin_pred_tyELb0EEENS4_IS5_S6_S7_NS0_13ufmin_pred_tyELb0EEEEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchINS_5ValueENS0_16match_combine_orINS0_12MaxMin_matchINS_8FCmpInstENS0_14specificval_tyENS0_13apfloat_matchENS0_13ofmax_pred_tyELb0EEENS4_IS5_S6_S7_NS0_13ufmax_pred_tyELb0EEEEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchINS_5ValueENS0_12MaxMin_matchINS_8ICmpInstENS0_14specificval_tyENS0_11apint_matchENS0_12smin_pred_tyELb0EEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchINS_5ValueENS0_12MaxMin_matchINS_8ICmpInstENS0_14specificval_tyENS0_11apint_matchENS0_12smax_pred_tyELb0EEEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5matchIKNS_11InstructionENS0_9brc_matchINS0_7bind_tyINS_5ValueEEENS5_INS_10BasicBlockEEES9_EEEEbPT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch12OneUse_matchINS0_11class_matchINS_5ValueEEEEC2ERKS4_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch12OneUse_matchINS0_11class_matchINS_5ValueEEEE5matchIS3_EEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch8m_OneUseINS0_11class_matchINS_5ValueEEEEENS0_12OneUse_matchIT_EERKS6_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch11class_matchINS_5ValueEE5matchINS_8ConstantEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch16match_combine_orINS0_15CastClass_matchINS0_7bind_tyINS_5ValueEEELj39EEENS2_IS5_Lj40EEEEC2ERKS6_RKS7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch16match_combine_orINS0_14specificval_tyENS0_15CastClass_matchIS2_Lj47EEEEC2ERKS2_RKS4_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS2_EEEC2ERKS2_RKS4_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch16match_combine_orINS1_INS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS2_EEEENS0_14BinaryOp_matchIS5_NS0_11apint_matchELj13ELb0EEEEC2ERKS5_RKS8_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch16match_combine_orINS0_12MaxMin_matchINS_8FCmpInstENS0_14specificval_tyENS0_13apfloat_matchENS0_13ofmax_pred_tyELb0EEENS2_IS3_S4_S5_NS0_13ufmax_pred_tyELb0EEEEC2ERKS7_RKS9_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch16match_combine_orINS0_12MaxMin_matchINS_8FCmpInstENS0_14specificval_tyENS0_13apfloat_matchENS0_13ofmin_pred_tyELb0EEENS2_IS3_S4_S5_NS0_13ufmin_pred_tyELb0EEEEC2ERKS7_RKS9_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch16match_combine_orINS0_14specificval_tyENS0_15CastClass_matchIS2_Lj40EEEEC2ERKS2_RKS4_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch16match_combine_orINS0_14cstval_pred_tyINS0_11is_zero_intENS_11ConstantIntEEENS2_INS0_11is_all_onesES4_EEEC2ERKS5_RKS7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch16match_combine_orINS0_14cstval_pred_tyINS0_11is_zero_intENS_11ConstantIntEEENS2_INS0_6is_oneES4_EEEC2ERKS5_RKS7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch16match_combine_orINS0_12MaxMin_matchINS_8ICmpInstENS0_7bind_tyINS_5ValueEEES6_NS0_12smax_pred_tyELb0EEENS2_IS3_S6_S6_NS0_12smin_pred_tyELb0EEEEC2ERKS8_RKSA_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch16match_combine_orINS0_12MaxMin_matchINS_8ICmpInstENS0_7bind_tyINS_5ValueEEES6_NS0_12umax_pred_tyELb0EEENS2_IS3_S6_S6_NS0_12umin_pred_tyELb0EEEEC2ERKS8_RKSA_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch16match_combine_orINS1_INS0_12MaxMin_matchINS_8ICmpInstENS0_7bind_tyINS_5ValueEEES6_NS0_12smax_pred_tyELb0EEENS2_IS3_S6_S6_NS0_12smin_pred_tyELb0EEEEENS1_INS2_IS3_S6_S6_NS0_12umax_pred_tyELb0EEENS2_IS3_S6_S6_NS0_12umin_pred_tyELb0EEEEEEC2ERKSB_RKSG_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch16match_combine_orINS0_15CastClass_matchINS0_14BinaryOp_matchINS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEENS0_14specificval_tyELj30ELb1EEELj39EEENS2_IS9_Lj40EEEEC2ERKSA_RKSB_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch16match_combine_orINS0_14cstval_pred_tyINS0_11is_zero_intENS_11ConstantIntEEENS2_INS0_6is_oneES4_EEE5matchINS_5ValueEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch16match_combine_orINS0_15CastClass_matchINS0_14BinaryOp_matchINS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEENS0_14specificval_tyELj30ELb1EEELj39EEENS2_IS9_Lj40EEEE5matchIKNS_5ValueEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch16match_combine_orINS0_12MaxMin_matchINS_8FCmpInstENS0_14specificval_tyENS0_13apfloat_matchENS0_13ofmax_pred_tyELb0EEENS2_IS3_S4_S5_NS0_13ufmax_pred_tyELb0EEEE5matchINS_5ValueEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch16match_combine_orINS0_12MaxMin_matchINS_8FCmpInstENS0_14specificval_tyENS0_13apfloat_matchENS0_13ofmin_pred_tyELb0EEENS2_IS3_S4_S5_NS0_13ufmin_pred_tyELb0EEEE5matchINS_5ValueEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch16match_combine_orINS1_INS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS2_EEEENS0_14BinaryOp_matchIS5_NS0_11apint_matchELj13ELb0EEEE5matchINS_5ValueEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch16match_combine_orINS0_15CastClass_matchINS0_7bind_tyINS_5ValueEEELj39EEENS2_IS5_Lj40EEEE5matchIKS4_EEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS2_EEE5matchINS_8ConstantEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch16match_combine_orINS1_INS0_12MaxMin_matchINS_8ICmpInstENS0_7bind_tyINS_5ValueEEES6_NS0_12smax_pred_tyELb0EEENS2_IS3_S6_S6_NS0_12smin_pred_tyELb0EEEEENS1_INS2_IS3_S6_S6_NS0_12umax_pred_tyELb0EEENS2_IS3_S6_S6_NS0_12umin_pred_tyELb0EEEEEE5matchIKS5_EEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch16match_combine_orINS0_14specificval_tyENS0_15CastClass_matchIS2_Lj47EEEE5matchINS_5ValueEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS2_EEE5matchINS_5ValueEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch16match_combine_orINS0_12MaxMin_matchINS_8ICmpInstENS0_7bind_tyINS_5ValueEEES6_NS0_12smax_pred_tyELb0EEENS2_IS3_S6_S6_NS0_12smin_pred_tyELb0EEEE5matchIKS5_EEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch16match_combine_orINS0_12MaxMin_matchINS_8ICmpInstENS0_7bind_tyINS_5ValueEEES6_NS0_12umax_pred_tyELb0EEENS2_IS3_S6_S6_NS0_12umin_pred_tyELb0EEEE5matchIKS5_EEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch16match_combine_orINS0_14specificval_tyENS0_15CastClass_matchIS2_Lj40EEEE5matchINS_5ValueEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch16match_combine_orINS0_14cstval_pred_tyINS0_11is_zero_intENS_11ConstantIntEEENS2_INS0_11is_all_onesES4_EEE5matchINS_5ValueEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch17match_combine_andINS1_INS0_17IntrinsicID_matchENS0_14Argument_matchINS0_11class_matchINS_5ValueEEEEEEES7_EC2ERKS8_RKS7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch17match_combine_andINS0_17IntrinsicID_matchENS0_14Argument_matchINS0_11class_matchINS_5ValueEEEEEEC2ERKS2_RKS7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch17match_combine_andINS0_17IntrinsicID_matchENS0_14Argument_matchINS0_7bind_tyINS_5ValueEEEEEEC2ERKS2_RKS7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch17match_combine_andINS1_INS0_17IntrinsicID_matchENS0_14Argument_matchINS0_7bind_tyINS_5ValueEEEEEEENS3_INS0_20bind_const_intval_tyEEEEC2ERKS8_RKSA_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch17match_combine_andINS1_INS0_17IntrinsicID_matchENS0_14Argument_matchINS0_7bind_tyINS_5ValueEEEEEEENS3_INS0_20bind_const_intval_tyEEEE5matchIS5_EEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch17match_combine_andINS0_17IntrinsicID_matchENS0_14Argument_matchINS0_11class_matchINS_5ValueEEEEEE5matchIKNS_11InstructionEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch17match_combine_andINS0_17IntrinsicID_matchENS0_14Argument_matchINS0_7bind_tyINS_5ValueEEEEEE5matchIS5_EEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch17match_combine_andINS1_INS0_17IntrinsicID_matchENS0_14Argument_matchINS0_11class_matchINS_5ValueEEEEEEES7_E5matchIKNS_11InstructionEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch11m_CombineOrINS0_14cstval_pred_tyINS0_11is_zero_intENS_11ConstantIntEEENS2_INS0_6is_oneES4_EEEENS0_16match_combine_orIT_T0_EERKS9_RKSA_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch11m_CombineOrINS0_14cstval_pred_tyINS0_11is_zero_intENS_11ConstantIntEEENS2_INS0_11is_all_onesES4_EEEENS0_16match_combine_orIT_T0_EERKS9_RKSA_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch11m_CombineOrINS0_15CastClass_matchINS0_14BinaryOp_matchINS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEENS0_14specificval_tyELj30ELb1EEELj39EEENS2_IS9_Lj40EEEEENS0_16match_combine_orIT_T0_EERKSD_RKSE_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch11m_CombineOrINS0_15CastClass_matchINS0_7bind_tyINS_5ValueEEELj39EEENS2_IS5_Lj40EEEEENS0_16match_combine_orIT_T0_EERKS9_RKSA_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch11m_CombineOrINS0_12MaxMin_matchINS_8FCmpInstENS0_14specificval_tyENS0_13apfloat_matchENS0_13ofmin_pred_tyELb0EEENS2_IS3_S4_S5_NS0_13ufmin_pred_tyELb0EEEEENS0_16match_combine_orIT_T0_EERKSB_RKSC_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch11m_CombineOrINS0_12MaxMin_matchINS_8FCmpInstENS0_14specificval_tyENS0_13apfloat_matchENS0_13ofmax_pred_tyELb0EEENS2_IS3_S4_S5_NS0_13ufmax_pred_tyELb0EEEEENS0_16match_combine_orIT_T0_EERKSB_RKSC_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch11m_CombineOrINS0_14specificval_tyENS0_15CastClass_matchIS2_Lj40EEEEENS0_16match_combine_orIT_T0_EERKS6_RKS7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch11m_CombineOrINS0_16match_combine_orINS0_12MaxMin_matchINS_8ICmpInstENS0_7bind_tyINS_5ValueEEES7_NS0_12smax_pred_tyELb0EEENS3_IS4_S7_S7_NS0_12smin_pred_tyELb0EEEEENS2_INS3_IS4_S7_S7_NS0_12umax_pred_tyELb0EEENS3_IS4_S7_S7_NS0_12umin_pred_tyELb0EEEEEEENS2_IT_T0_EERKSI_RKSJ_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch11m_CombineOrINS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS3_EEEENS0_14BinaryOp_matchIS6_NS0_11apint_matchELj13ELb0EEEEENS2_IT_T0_EERKSA_RKSB_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch11m_CombineOrINS0_12MaxMin_matchINS_8ICmpInstENS0_7bind_tyINS_5ValueEEES6_NS0_12umax_pred_tyELb0EEENS2_IS3_S6_S6_NS0_12umin_pred_tyELb0EEEEENS0_16match_combine_orIT_T0_EERKSC_RKSD_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch11m_CombineOrINS0_12MaxMin_matchINS_8ICmpInstENS0_7bind_tyINS_5ValueEEES6_NS0_12smax_pred_tyELb0EEENS2_IS3_S6_S6_NS0_12smin_pred_tyELb0EEEEENS0_16match_combine_orIT_T0_EERKSC_RKSD_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch11m_CombineOrINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS2_EEEENS0_16match_combine_orIT_T0_EERKS6_RKS7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch11m_CombineOrINS0_14specificval_tyENS0_15CastClass_matchIS2_Lj47EEEEENS0_16match_combine_orIT_T0_EERKS6_RKS7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch12m_CombineAndINS0_17match_combine_andINS0_17IntrinsicID_matchENS0_14Argument_matchINS0_11class_matchINS_5ValueEEEEEEES8_EENS2_IT_T0_EERKSA_RKSB_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch12m_CombineAndINS0_17IntrinsicID_matchENS0_14Argument_matchINS0_7bind_tyINS_5ValueEEEEEEENS0_17match_combine_andIT_T0_EERKS9_RKSA_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch12m_CombineAndINS0_17IntrinsicID_matchENS0_14Argument_matchINS0_11class_matchINS_5ValueEEEEEEENS0_17match_combine_andIT_T0_EERKS9_RKSA_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch12m_CombineAndINS0_17match_combine_andINS0_17IntrinsicID_matchENS0_14Argument_matchINS0_7bind_tyINS_5ValueEEEEEEENS4_INS0_20bind_const_intval_tyEEEEENS2_IT_T0_EERKSC_RKSD_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch11apint_matchC2ERPKNS_5APIntEb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch11apint_match5matchIKNS_5ValueEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch11apint_match5matchINS_8ConstantEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch11apint_match5matchINS_5ValueEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch13apfloat_matchC2ERPKNS_7APFloatEb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch13apfloat_match5matchINS_5ValueEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch7m_APIntERPKNS_5APIntE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch9m_APFloatERPKNS_7APFloatE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14cstval_pred_tyINS0_14is_any_zero_fpENS_10ConstantFPEE5matchINS_5ValueEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14cstval_pred_tyINS0_11is_zero_intENS_11ConstantIntEE5matchINS_5ValueEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEE5matchINS_5ValueEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14cstval_pred_tyINS0_6is_oneENS_11ConstantIntEE5matchINS_8ConstantEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14cstval_pred_tyINS0_12is_sign_maskENS_11ConstantIntEE5matchINS_8ConstantEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14cstval_pred_tyINS0_6is_oneENS_11ConstantIntEE5matchINS_5ValueEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14cstval_pred_tyINS0_11is_zero_intENS_11ConstantIntEE5matchIKNS_8ConstantEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEE5matchINS_8ConstantEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14cstval_pred_tyINS0_9is_power2ENS_11ConstantIntEE5matchINS_5ValueEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14cstval_pred_tyINS0_12is_sign_maskENS_11ConstantIntEE5matchINS_5ValueEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14cstval_pred_tyINS0_17is_power2_or_zeroENS_11ConstantIntEE5matchIKNS_5ValueEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14cstval_pred_tyINS0_11is_zero_intENS_11ConstantIntEE5matchINS_8ConstantEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14cstval_pred_tyINS0_9is_power2ENS_11ConstantIntEE5matchIKNS_5ValueEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch11api_pred_tyINS0_9is_power2EEC2ERPKNS_5APIntE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch11api_pred_tyINS0_9is_power2EE5matchINS_5ValueEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch11api_pred_tyINS0_9is_power2EE5matchINS_8ConstantEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch11is_all_ones7isValueERKNS_5APIntE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch9m_AllOnesEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch6is_one7isValueERKNS_5APIntE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5m_OneEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch11is_zero_int7isValueERKNS_5APIntE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch9m_ZeroIntEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch7is_zero5matchINS_5ValueEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch7is_zero5matchIKNS_5ValueEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch6m_ZeroEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch9is_power27isValueERKNS_5APIntE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch8m_Power2Ev</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch8m_Power2ERPKNS_5APIntE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch17is_power2_or_zero7isValueERKNS_5APIntE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14m_Power2OrZeroEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch12is_sign_mask7isValueERKNS_5APIntE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch10m_SignMaskEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14is_any_zero_fp7isValueERKNS_7APFloatE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch11m_AnyZeroFPEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch7bind_tyINS_10BasicBlockEEC2ERPS2_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch7bind_tyINS_8ConstantEEC2ERPS2_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch7bind_tyINS_5ValueEEC2ERPS2_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch7bind_tyIKNS_16WithOverflowInstEEC2ERPS3_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch7bind_tyINS_5ValueEE5matchIS2_EEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch7bind_tyIKNS_16WithOverflowInstEE5matchIKNS_5ValueEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch7bind_tyINS_5ValueEE5matchINS_8ConstantEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch7bind_tyINS_10BasicBlockEE5matchIS2_EEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch7bind_tyIKNS_5ValueEE5matchINS_8ConstantEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch7bind_tyINS_8ConstantEE5matchINS_5ValueEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch7m_ValueERPNS_5ValueE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch18m_WithOverflowInstERPKNS_16WithOverflowInstE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch10m_ConstantERPNS_8ConstantE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch12m_BasicBlockERPNS_10BasicBlockE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14specificval_tyC2EPKNS_5ValueE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14specificval_ty5matchINS_8ConstantEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14specificval_ty5matchINS_5ValueEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14specificval_ty5matchIKNS_5ValueEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch10m_SpecificEPKNS_5ValueE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14deferredval_tyINS_5ValueEEC2ERKPS2_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14deferredval_tyINS_5ValueEE5matchIS2_EEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14deferredval_tyINS_5ValueEE5matchINS_8ConstantEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch10m_DeferredERKPNS_5ValueE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch20bind_const_intval_tyC2ERm</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch20bind_const_intval_ty5matchINS_5ValueEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch20bind_const_intval_ty5matchINS_8ConstantEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch15specific_intvalILb0EEC2ENS_5APIntE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch15specific_intvalILb0EE5matchINS_5ValueEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch13m_SpecificIntENS_5APIntE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch13m_SpecificIntEm</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch13m_ConstantIntERm</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch17AnyBinaryOp_matchINS0_7bind_tyINS_5ValueEEENS0_14BinaryOp_matchINS0_14deferredval_tyIS3_EES4_Lj13ELb1EEELb1EEC2ERKS4_RKS8_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch17AnyBinaryOp_matchINS0_7bind_tyINS_5ValueEEENS0_14BinaryOp_matchIS4_NS0_14deferredval_tyIS3_EELj15ELb0EEELb1EEC2ERKS4_RKS8_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch17AnyBinaryOp_matchINS0_7bind_tyINS_5ValueEEENS0_14BinaryOp_matchINS0_14deferredval_tyIS3_EES4_Lj15ELb0EEELb1EEC2ERKS4_RKS8_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch17AnyBinaryOp_matchINS0_7bind_tyINS_5ValueEEENS0_14BinaryOp_matchINS0_14deferredval_tyIS3_EES4_Lj13ELb1EEELb1EE5matchIKNS_8OperatorEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch17AnyBinaryOp_matchINS0_7bind_tyINS_5ValueEEENS0_14BinaryOp_matchINS0_14deferredval_tyIS3_EES4_Lj15ELb0EEELb1EE5matchIKNS_8OperatorEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch17AnyBinaryOp_matchINS0_7bind_tyINS_5ValueEEENS0_14BinaryOp_matchIS4_NS0_14deferredval_tyIS3_EELj15ELb0EEELb1EE5matchIKNS_8OperatorEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14specificval_tyENS0_11apint_matchELj17ELb0EEC2ERKS2_RKS3_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_11class_matchINS_5ValueEEES4_Lj19ELb0EEC2ERKS4_S7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_11class_matchINS_5ValueEEES4_Lj26ELb0EEC2ERKS4_S7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_11class_matchINS_5ValueEEENS0_14specificval_tyELj28ELb0EEC2ERKS4_RKS5_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14specificval_tyENS0_11class_matchINS_5ValueEEELj28ELb0EEC2ERKS2_RKS5_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_7bind_tyINS_5ValueEEENS0_14deferredval_tyIS3_EELj15ELb0EEC2ERKS4_RKS6_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_7bind_tyINS_5ValueEEES4_Lj13ELb0EEC2ERKS4_S7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14specificval_tyENS0_11class_matchINS_5ValueEEELj22ELb0EEC2ERKS2_RKS5_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14specificval_tyENS0_11apint_matchELj25ELb0EEC2ERKS2_RKS3_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_7bind_tyINS_5ValueEEENS0_11class_matchIS3_EELj26ELb0EEC2ERKS4_RKS6_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14specificval_tyENS0_11class_matchINS_5ValueEEELj23ELb0EEC2ERKS2_RKS5_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_7bind_tyINS_5ValueEEENS0_11class_matchIS3_EELj25ELb0EEC2ERKS4_RKS6_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14cstval_pred_tyINS0_12is_sign_maskENS_11ConstantIntEEENS0_11class_matchINS_5ValueEEELj26ELb0EEC2ERKS5_RKS8_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14cstval_pred_tyINS0_6is_oneENS_11ConstantIntEEENS0_11class_matchINS_5ValueEEELj25ELb0EEC2ERKS5_RKS8_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS1_INS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEENS0_7bind_tyINS_5ValueEEELj30ELb1EEENS0_11class_matchIS7_EELj28ELb1EEC2ERKS9_RKSB_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14deferredval_tyINS_5ValueEEENS0_7bind_tyIS3_EELj15ELb0EEC2ERKS4_RKS6_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEENS1_INS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS7_EEEENS0_20bind_const_intval_tyELj25ELb0EEELj30ELb1EEC2ERKS5_RKSC_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEENS1_INS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS7_EEEENS0_7bind_tyINS_5ValueEEELj30ELb1EEELj30ELb1EEC2ERKS5_RKSE_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEENS1_INS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS7_EEEENS0_7bind_tyINS_5ValueEEELj29ELb1EEELj30ELb1EEC2ERKS5_RKSE_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS1_INS0_14specificval_tyENS0_7bind_tyINS_5ValueEEELj28ELb1EEENS0_14deferredval_tyIS4_EELj30ELb1EEC2ERKS6_RKS8_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14specificval_tyENS0_7bind_tyINS_5ValueEEELj28ELb1EEC2ERKS2_RKS5_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS1_INS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEENS0_14specificval_tyELj30ELb1EEENS0_11class_matchINS_5ValueEEELj28ELb1EEC2ERKS7_RKSA_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14specificval_tyENS0_11class_matchINS_5ValueEEELj28ELb1EEC2ERKS2_RKS5_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEENS0_15BinOpPred_matchINS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS8_EEEENS0_20bind_const_intval_tyENS0_17is_right_shift_opEEELj30ELb1EEC2ERKS5_RKSE_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14specificval_tyENS0_11class_matchINS_5ValueEEELj26ELb0EEC2ERKS2_RKS5_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEENS1_INS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS7_EEEENS0_7bind_tyINS_5ValueEEELj28ELb1EEELj30ELb1EEC2ERKS5_RKSE_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_7bind_tyIKNS_5ValueEEENS0_11apint_matchELj29ELb0EEC2ERKS5_RKS6_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14specificval_tyENS0_11apint_matchELj29ELb0EEC2ERKS2_RKS3_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEENS1_INS0_14specificval_tyES6_Lj29ELb1EEELj30ELb1EEC2ERKS5_RKS7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEENS0_7bind_tyINS_5ValueEEELj30ELb1EEC2ERKS5_RKS8_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEENS0_14specificval_tyELj30ELb1EEC2ERKS5_RKS6_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS3_EEEENS0_7bind_tyINS_5ValueEEELj29ELb1EEC2ERKS6_RKS9_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14deferredval_tyINS_5ValueEEENS0_7bind_tyIS3_EELj13ELb1EEC2ERKS4_RKS6_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_7bind_tyINS_5ValueEEENS1_INS0_14deferredval_tyIS3_EENS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEELj13ELb1EEELj30ELb1EEC2ERKS4_RKSB_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14deferredval_tyINS_5ValueEEENS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEELj13ELb1EEC2ERKS4_RKS8_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_7bind_tyINS_5ValueEEENS1_INS0_14cstval_pred_tyINS0_11is_zero_intENS_11ConstantIntEEENS0_14deferredval_tyIS3_EELj15ELb0EEELj28ELb1EEC2ERKS4_RKSB_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS3_EEEENS0_11apint_matchELj13ELb0EEC2ERKS6_RKS7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS3_EEEENS0_11api_pred_tyINS0_9is_power2EEELj28ELb1EEC2ERKS6_RKS9_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS3_EEEENS0_20bind_const_intval_tyELj25ELb0EEC2ERKS6_RKS7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS3_EEEENS0_7bind_tyINS_5ValueEEELj30ELb1EEC2ERKS6_RKS9_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14cstval_pred_tyINS0_11is_zero_intENS_11ConstantIntEEENS0_14deferredval_tyINS_5ValueEEELj15ELb0EEC2ERKS5_RKS8_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS3_EEEENS0_7bind_tyINS_5ValueEEELj28ELb1EEC2ERKS6_RKS9_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14cstval_pred_tyINS0_11is_zero_intENS_11ConstantIntEEENS0_14specificval_tyELj15ELb0EEC2ERKS5_RKS6_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_7bind_tyINS_5ValueEEES4_Lj15ELb0EEC2ERKS4_S7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14specificval_tyES2_Lj15ELb0EEC2ERKS2_S5_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14specificval_tyES2_Lj29ELb1EEC2ERKS2_S5_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_7bind_tyINS_5ValueEEES4_Lj28ELb0EEC2ERKS4_S7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS3_EEEENS0_7bind_tyINS_5ValueEEELj30ELb1EE5matchINS_8ConstantEEEbjPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14cstval_pred_tyINS0_11is_zero_intENS_11ConstantIntEEENS0_14specificval_tyELj15ELb0EE5matchINS_5ValueEEEbjPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS3_EEEENS0_7bind_tyINS_5ValueEEELj28ELb1EE5matchIS8_EEbjPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14specificval_tyENS0_11apint_matchELj29ELb0EE5matchIKNS_5ValueEEEbjPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_7bind_tyIKNS_5ValueEEENS0_11apint_matchELj29ELb0EE5matchIS4_EEbjPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14specificval_tyENS0_11class_matchINS_5ValueEEELj26ELb0EE5matchIKS4_EEbjPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14specificval_tyES2_Lj15ELb0EE5matchIKNS_5ValueEEEbjPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_7bind_tyINS_5ValueEEES4_Lj15ELb0EE5matchIKS3_EEbjPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEENS0_7bind_tyINS_5ValueEEELj30ELb1EE5matchIS7_EEbjPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14specificval_tyENS0_11class_matchINS_5ValueEEELj23ELb0EE5matchIKS4_EEbjPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14specificval_tyENS0_11class_matchINS_5ValueEEELj22ELb0EE5matchIKS4_EEbjPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14specificval_tyENS0_11apint_matchELj25ELb0EE5matchIKNS_25OverflowingBinaryOperatorEEEbjPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14specificval_tyENS0_11apint_matchELj17ELb0EE5matchIKNS_25OverflowingBinaryOperatorEEEbjPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_11class_matchINS_5ValueEEENS0_14specificval_tyELj28ELb0EE5matchIS3_EEbjPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14specificval_tyENS0_11class_matchINS_5ValueEEELj28ELb0EE5matchIS4_EEbjPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_7bind_tyINS_5ValueEEES4_Lj13ELb0EE5matchIKS3_EEbjPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEENS1_INS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS7_EEEENS0_7bind_tyINS_5ValueEEELj28ELb1EEELj30ELb1EE5matchISC_EEbjPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_7bind_tyINS_5ValueEEENS0_11class_matchIS3_EELj26ELb0EE5matchIKS3_EEbjPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_7bind_tyINS_5ValueEEENS0_11class_matchIS3_EELj25ELb0EE5matchIKS3_EEbjPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14cstval_pred_tyINS0_12is_sign_maskENS_11ConstantIntEEENS0_11class_matchINS_5ValueEEELj26ELb0EE5matchIKS7_EEbjPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14cstval_pred_tyINS0_6is_oneENS_11ConstantIntEEENS0_11class_matchINS_5ValueEEELj25ELb0EE5matchIKS7_EEbjPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14cstval_pred_tyINS0_11is_zero_intENS_11ConstantIntEEENS0_14specificval_tyELj15ELb0EE5matchIKNS_5ValueEEEbjPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_7bind_tyINS_5ValueEEENS1_INS0_14deferredval_tyIS3_EENS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEELj13ELb1EEELj30ELb1EE5matchIKNS_8OperatorEEEbjPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_7bind_tyINS_5ValueEEENS1_INS0_14cstval_pred_tyINS0_11is_zero_intENS_11ConstantIntEEENS0_14deferredval_tyIS3_EELj15ELb0EEELj28ELb1EE5matchIKNS_8OperatorEEEbjPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEENS1_INS0_14specificval_tyES6_Lj29ELb1EEELj30ELb1EE5matchIKNS_5ValueEEEbjPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_7bind_tyINS_5ValueEEES4_Lj28ELb0EE5matchIKS3_EEbjPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS1_INS0_14specificval_tyENS0_7bind_tyINS_5ValueEEELj28ELb1EEENS0_14deferredval_tyIS4_EELj30ELb1EE5matchIKS4_EEbjPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS1_INS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEENS0_14specificval_tyELj30ELb1EEENS0_11class_matchINS_5ValueEEELj28ELb1EE5matchIKS9_EEbjPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14specificval_tyENS0_11class_matchINS_5ValueEEELj28ELb1EE5matchIKS4_EEbjPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS1_INS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEENS0_7bind_tyINS_5ValueEEELj30ELb1EEENS0_11class_matchIS7_EELj28ELb1EE5matchIKS7_EEbjPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEENS0_7bind_tyINS_5ValueEEELj30ELb1EE5matchINS_8ConstantEEEbjPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS3_EEEENS0_20bind_const_intval_tyELj25ELb0EE5matchINS_8ConstantEEEbjPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS3_EEEENS0_7bind_tyINS_5ValueEEELj29ELb1EE5matchINS_8ConstantEEEbjPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS3_EEEENS0_7bind_tyINS_5ValueEEELj28ELb1EE5matchINS_8ConstantEEEbjPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14deferredval_tyINS_5ValueEEENS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEELj13ELb1EE5matchINS_8ConstantEEEbjPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14deferredval_tyINS_5ValueEEENS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEELj13ELb1EE5matchIS3_EEbjPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14cstval_pred_tyINS0_11is_zero_intENS_11ConstantIntEEENS0_14deferredval_tyINS_5ValueEEELj15ELb0EE5matchINS_8ConstantEEEbjPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14cstval_pred_tyINS0_11is_zero_intENS_11ConstantIntEEENS0_14deferredval_tyINS_5ValueEEELj15ELb0EE5matchIS7_EEbjPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS3_EEEENS0_11apint_matchELj13ELb0EE5matchINS_5ValueEEEbjPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14specificval_tyES2_Lj29ELb1EE5matchINS_8ConstantEEEbjPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14specificval_tyES2_Lj29ELb1EE5matchINS_5ValueEEEbjPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14specificval_tyENS0_7bind_tyINS_5ValueEEELj28ELb1EE5matchINS_8ConstantEEEbjPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14specificval_tyENS0_7bind_tyINS_5ValueEEELj28ELb1EE5matchIS4_EEbjPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEENS0_14specificval_tyELj30ELb1EE5matchINS_8ConstantEEEbjPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEENS0_14specificval_tyELj30ELb1EE5matchINS_5ValueEEEbjPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_11class_matchINS_5ValueEEES4_Lj19ELb0EE5matchIKS3_EEbjPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_11class_matchINS_5ValueEEES4_Lj26ELb0EE5matchIKS3_EEbjPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_7bind_tyINS_5ValueEEENS0_14deferredval_tyIS3_EELj15ELb0EE5matchIS3_EEbjPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14deferredval_tyINS_5ValueEEENS0_7bind_tyIS3_EELj15ELb0EE5matchIS3_EEbjPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14deferredval_tyINS_5ValueEEENS0_7bind_tyIS3_EELj13ELb1EE5matchIS3_EEbjPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS3_EEEENS0_11api_pred_tyINS0_9is_power2EEELj28ELb1EE5matchINS_5ValueEEEbjPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEENS0_15BinOpPred_matchINS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS8_EEEENS0_20bind_const_intval_tyENS0_17is_right_shift_opEEELj30ELb1EE5matchINS_5ValueEEEbjPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEENS1_INS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS7_EEEENS0_20bind_const_intval_tyELj25ELb0EEELj30ELb1EE5matchINS_5ValueEEEbjPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS3_EEEENS0_20bind_const_intval_tyELj25ELb0EE5matchINS_5ValueEEEbjPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEENS1_INS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS7_EEEENS0_7bind_tyINS_5ValueEEELj30ELb1EEELj30ELb1EE5matchISC_EEbjPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS3_EEEENS0_7bind_tyINS_5ValueEEELj30ELb1EE5matchIS8_EEbjPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEENS1_INS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS7_EEEENS0_7bind_tyINS_5ValueEEELj29ELb1EEELj30ELb1EE5matchISC_EEbjPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS3_EEEENS0_7bind_tyINS_5ValueEEELj29ELb1EE5matchIS8_EEbjPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_7bind_tyINS_5ValueEEES4_Lj28ELb0EE5matchIKS3_EEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_7bind_tyIKNS_5ValueEEENS0_11apint_matchELj29ELb0EE5matchIS4_EEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14specificval_tyENS0_11class_matchINS_5ValueEEELj26ELb0EE5matchIKS4_EEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS1_INS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEENS0_7bind_tyINS_5ValueEEELj30ELb1EEENS0_11class_matchIS7_EELj28ELb1EE5matchIKS7_EEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14specificval_tyENS0_11class_matchINS_5ValueEEELj28ELb1EE5matchIKS4_EEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_11class_matchINS_5ValueEEES4_Lj26ELb0EE5matchIKS3_EEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_11class_matchINS_5ValueEEES4_Lj19ELb0EE5matchIKS3_EEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS1_INS0_14specificval_tyENS0_7bind_tyINS_5ValueEEELj28ELb1EEENS0_14deferredval_tyIS4_EELj30ELb1EE5matchIKS4_EEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14specificval_tyENS0_11class_matchINS_5ValueEEELj23ELb0EE5matchIKS4_EEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14specificval_tyENS0_11apint_matchELj29ELb0EE5matchIKNS_5ValueEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14specificval_tyES2_Lj15ELb0EE5matchIKNS_5ValueEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14cstval_pred_tyINS0_11is_zero_intENS_11ConstantIntEEENS0_14specificval_tyELj15ELb0EE5matchIKNS_5ValueEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEENS1_INS0_14specificval_tyES6_Lj29ELb1EEELj30ELb1EE5matchIKNS_5ValueEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_7bind_tyINS_5ValueEEES4_Lj15ELb0EE5matchIKS3_EEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEENS0_7bind_tyINS_5ValueEEELj30ELb1EE5matchINS_8ConstantEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEENS0_14specificval_tyELj30ELb1EE5matchINS_8ConstantEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEENS0_7bind_tyINS_5ValueEEELj30ELb1EE5matchIS7_EEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEENS0_14specificval_tyELj30ELb1EE5matchINS_5ValueEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEENS1_INS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS7_EEEENS0_7bind_tyINS_5ValueEEELj29ELb1EEELj30ELb1EE5matchISC_EEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS3_EEEENS0_7bind_tyINS_5ValueEEELj30ELb1EE5matchIS8_EEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS3_EEEENS0_7bind_tyINS_5ValueEEELj29ELb1EE5matchIS8_EEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEENS1_INS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS7_EEEENS0_7bind_tyINS_5ValueEEELj30ELb1EEELj30ELb1EE5matchISC_EEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEENS1_INS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS7_EEEENS0_7bind_tyINS_5ValueEEELj28ELb1EEELj30ELb1EE5matchISC_EEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS3_EEEENS0_20bind_const_intval_tyELj25ELb0EE5matchINS_5ValueEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS3_EEEENS0_7bind_tyINS_5ValueEEELj28ELb1EE5matchIS8_EEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEENS1_INS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS7_EEEENS0_20bind_const_intval_tyELj25ELb0EEELj30ELb1EE5matchINS_5ValueEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS1_INS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEENS0_14specificval_tyELj30ELb1EEENS0_11class_matchINS_5ValueEEELj28ELb1EE5matchIKS9_EEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEENS0_15BinOpPred_matchINS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS8_EEEENS0_20bind_const_intval_tyENS0_17is_right_shift_opEEELj30ELb1EE5matchINS_5ValueEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS3_EEEENS0_11api_pred_tyINS0_9is_power2EEELj28ELb1EE5matchINS_5ValueEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_7bind_tyINS_5ValueEEENS1_INS0_14cstval_pred_tyINS0_11is_zero_intENS_11ConstantIntEEENS0_14deferredval_tyIS3_EELj15ELb0EEELj28ELb1EE5matchIKNS_8OperatorEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14deferredval_tyINS_5ValueEEENS0_7bind_tyIS3_EELj13ELb1EE5matchIS3_EEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14deferredval_tyINS_5ValueEEENS0_7bind_tyIS3_EELj15ELb0EE5matchIS3_EEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_7bind_tyINS_5ValueEEENS0_14deferredval_tyIS3_EELj15ELb0EE5matchIS3_EEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_7bind_tyINS_5ValueEEENS1_INS0_14deferredval_tyIS3_EENS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEELj13ELb1EEELj30ELb1EE5matchIKNS_8OperatorEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14specificval_tyENS0_7bind_tyINS_5ValueEEELj28ELb1EE5matchINS_8ConstantEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14deferredval_tyINS_5ValueEEENS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEELj13ELb1EE5matchINS_8ConstantEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_7bind_tyINS_5ValueEEENS0_11class_matchIS3_EELj26ELb0EE5matchIKS3_EEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14specificval_tyENS0_7bind_tyINS_5ValueEEELj28ELb1EE5matchIS4_EEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14specificval_tyENS0_11apint_matchELj25ELb0EE5matchIKNS_25OverflowingBinaryOperatorEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14deferredval_tyINS_5ValueEEENS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEELj13ELb1EE5matchIS3_EEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14cstval_pred_tyINS0_11is_zero_intENS_11ConstantIntEEENS0_14deferredval_tyINS_5ValueEEELj15ELb0EE5matchINS_8ConstantEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14cstval_pred_tyINS0_11is_zero_intENS_11ConstantIntEEENS0_14deferredval_tyINS_5ValueEEELj15ELb0EE5matchIS7_EEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14specificval_tyENS0_11apint_matchELj17ELb0EE5matchIKNS_25OverflowingBinaryOperatorEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS3_EEEENS0_11apint_matchELj13ELb0EE5matchINS_5ValueEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14cstval_pred_tyINS0_11is_zero_intENS_11ConstantIntEEENS0_14specificval_tyELj15ELb0EE5matchINS_5ValueEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_7bind_tyINS_5ValueEEENS0_11class_matchIS3_EELj25ELb0EE5matchIKS3_EEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS3_EEEENS0_7bind_tyINS_5ValueEEELj28ELb1EE5matchINS_8ConstantEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS3_EEEENS0_7bind_tyINS_5ValueEEELj29ELb1EE5matchINS_8ConstantEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS3_EEEENS0_7bind_tyINS_5ValueEEELj30ELb1EE5matchINS_8ConstantEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS3_EEEENS0_20bind_const_intval_tyELj25ELb0EE5matchINS_8ConstantEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14specificval_tyENS0_11class_matchINS_5ValueEEELj28ELb0EE5matchIS4_EEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_11class_matchINS_5ValueEEENS0_14specificval_tyELj28ELb0EE5matchIS3_EEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_7bind_tyINS_5ValueEEES4_Lj13ELb0EE5matchIKS3_EEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14specificval_tyENS0_11class_matchINS_5ValueEEELj22ELb0EE5matchIKS4_EEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14specificval_tyES2_Lj29ELb1EE5matchINS_8ConstantEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14cstval_pred_tyINS0_6is_oneENS_11ConstantIntEEENS0_11class_matchINS_5ValueEEELj25ELb0EE5matchIKS7_EEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14specificval_tyES2_Lj29ELb1EE5matchINS_5ValueEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14BinaryOp_matchINS0_14cstval_pred_tyINS0_12is_sign_maskENS_11ConstantIntEEENS0_11class_matchINS_5ValueEEELj26ELb0EE5matchIKS7_EEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5m_AddINS0_7bind_tyINS_5ValueEEES4_EENS0_14BinaryOp_matchIT_T0_Lj13ELb0EEERKS6_RKS7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5m_AddINS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS3_EEEENS0_11apint_matchEEENS0_14BinaryOp_matchIT_T0_Lj13ELb0EEERKS9_RKSA_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5m_SubINS0_14deferredval_tyINS_5ValueEEENS0_7bind_tyIS3_EEEENS0_14BinaryOp_matchIT_T0_Lj15ELb0EEERKS8_RKS9_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5m_SubINS0_7bind_tyINS_5ValueEEENS0_14deferredval_tyIS3_EEEENS0_14BinaryOp_matchIT_T0_Lj15ELb0EEERKS8_RKS9_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5m_SubINS0_7bind_tyINS_5ValueEEES4_EENS0_14BinaryOp_matchIT_T0_Lj15ELb0EEERKS6_RKS7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5m_SubINS0_14cstval_pred_tyINS0_11is_zero_intENS_11ConstantIntEEENS0_14specificval_tyEEENS0_14BinaryOp_matchIT_T0_Lj15ELb0EEERKS8_RKS9_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5m_SubINS0_14specificval_tyES2_EENS0_14BinaryOp_matchIT_T0_Lj15ELb0EEERKS4_RKS5_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5m_SubINS0_14cstval_pred_tyINS0_11is_zero_intENS_11ConstantIntEEENS0_14deferredval_tyINS_5ValueEEEEENS0_14BinaryOp_matchIT_T0_Lj15ELb0EEERKSA_RKSB_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5m_MulINS0_14specificval_tyENS0_11apint_matchEEENS0_14BinaryOp_matchIT_T0_Lj17ELb0EEERKS5_RKS6_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch6m_UDivINS0_11class_matchINS_5ValueEEES4_EENS0_14BinaryOp_matchIT_T0_Lj19ELb0EEERKS6_RKS7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch6m_URemINS0_14specificval_tyENS0_11class_matchINS_5ValueEEEEENS0_14BinaryOp_matchIT_T0_Lj22ELb0EEERKS7_RKS8_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch6m_SRemINS0_14specificval_tyENS0_11class_matchINS_5ValueEEEEENS0_14BinaryOp_matchIT_T0_Lj23ELb0EEERKS7_RKS8_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5m_AndINS0_11class_matchINS_5ValueEEENS0_14specificval_tyEEENS0_14BinaryOp_matchIT_T0_Lj28ELb0EEERKS7_RKS8_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5m_AndINS0_14specificval_tyENS0_11class_matchINS_5ValueEEEEENS0_14BinaryOp_matchIT_T0_Lj28ELb0EEERKS7_RKS8_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5m_AndINS0_7bind_tyINS_5ValueEEES4_EENS0_14BinaryOp_matchIT_T0_Lj28ELb0EEERKS6_RKS7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch4m_OrINS0_7bind_tyIKNS_5ValueEEENS0_11apint_matchEEENS0_14BinaryOp_matchIT_T0_Lj29ELb0EEERKS8_RKS9_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch4m_OrINS0_14specificval_tyENS0_11apint_matchEEENS0_14BinaryOp_matchIT_T0_Lj29ELb0EEERKS5_RKS6_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5m_ShlINS0_14specificval_tyENS0_11apint_matchEEENS0_14BinaryOp_matchIT_T0_Lj25ELb0EEERKS5_RKS6_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5m_ShlINS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS3_EEEENS0_20bind_const_intval_tyEEENS0_14BinaryOp_matchIT_T0_Lj25ELb0EEERKS9_RKSA_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5m_ShlINS0_7bind_tyINS_5ValueEEENS0_11class_matchIS3_EEEENS0_14BinaryOp_matchIT_T0_Lj25ELb0EEERKS8_RKS9_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5m_ShlINS0_14cstval_pred_tyINS0_6is_oneENS_11ConstantIntEEENS0_11class_matchINS_5ValueEEEEENS0_14BinaryOp_matchIT_T0_Lj25ELb0EEERKSA_RKSB_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch6m_LShrINS0_7bind_tyINS_5ValueEEENS0_11class_matchIS3_EEEENS0_14BinaryOp_matchIT_T0_Lj26ELb0EEERKS8_RKS9_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch6m_LShrINS0_11class_matchINS_5ValueEEES4_EENS0_14BinaryOp_matchIT_T0_Lj26ELb0EEERKS6_RKS7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch6m_LShrINS0_14specificval_tyENS0_11class_matchINS_5ValueEEEEENS0_14BinaryOp_matchIT_T0_Lj26ELb0EEERKS7_RKS8_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch6m_LShrINS0_14cstval_pred_tyINS0_12is_sign_maskENS_11ConstantIntEEENS0_11class_matchINS_5ValueEEEEENS0_14BinaryOp_matchIT_T0_Lj26ELb0EEERKSA_RKSB_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch25OverflowingBinaryOp_matchINS0_7bind_tyINS_5ValueEEES4_Lj15ELj2EEC2ERKS4_S7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch25OverflowingBinaryOp_matchINS0_14specificval_tyENS0_11class_matchINS_5ValueEEELj15ELj1EEC2ERKS2_RKS5_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch25OverflowingBinaryOp_matchINS0_14specificval_tyES2_Lj15ELj2EEC2ERKS2_S5_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch25OverflowingBinaryOp_matchINS0_7bind_tyIKNS_5ValueEEENS0_11apint_matchELj13ELj1EEC2ERKS5_RKS6_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch25OverflowingBinaryOp_matchINS0_14cstval_pred_tyINS0_11is_zero_intENS_11ConstantIntEEENS0_14specificval_tyELj15ELj2EEC2ERKS5_RKS6_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch25OverflowingBinaryOp_matchINS0_14specificval_tyENS0_11apint_matchELj13ELj1EEC2ERKS2_RKS3_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch25OverflowingBinaryOp_matchINS0_14specificval_tyENS0_11class_matchINS_5ValueEEELj15ELj2EEC2ERKS2_RKS5_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch25OverflowingBinaryOp_matchINS0_14specificval_tyENS0_11apint_matchELj13ELj2EEC2ERKS2_RKS3_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch25OverflowingBinaryOp_matchINS0_7bind_tyINS_5ValueEEES4_Lj15ELj2EE5matchIKS3_EEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch25OverflowingBinaryOp_matchINS0_14specificval_tyES2_Lj15ELj2EE5matchIKNS_5ValueEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch25OverflowingBinaryOp_matchINS0_14cstval_pred_tyINS0_11is_zero_intENS_11ConstantIntEEENS0_14specificval_tyELj15ELj2EE5matchIKNS_5ValueEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch25OverflowingBinaryOp_matchINS0_14specificval_tyENS0_11class_matchINS_5ValueEEELj15ELj2EE5matchIKS4_EEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch25OverflowingBinaryOp_matchINS0_14specificval_tyENS0_11class_matchINS_5ValueEEELj15ELj1EE5matchIKS4_EEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch25OverflowingBinaryOp_matchINS0_14specificval_tyENS0_11apint_matchELj13ELj2EE5matchIKNS_5ValueEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch25OverflowingBinaryOp_matchINS0_7bind_tyIKNS_5ValueEEENS0_11apint_matchELj13ELj1EE5matchIS4_EEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch25OverflowingBinaryOp_matchINS0_14specificval_tyENS0_11apint_matchELj13ELj1EE5matchIKNS_5ValueEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch8m_NSWAddINS0_14specificval_tyENS0_11apint_matchEEENS0_25OverflowingBinaryOp_matchIT_T0_Lj13ELj2EEERKS5_RKS6_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch8m_NSWSubINS0_7bind_tyINS_5ValueEEES4_EENS0_25OverflowingBinaryOp_matchIT_T0_Lj15ELj2EEERKS6_RKS7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch8m_NSWSubINS0_14cstval_pred_tyINS0_11is_zero_intENS_11ConstantIntEEENS0_14specificval_tyEEENS0_25OverflowingBinaryOp_matchIT_T0_Lj15ELj2EEERKS8_RKS9_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch8m_NSWSubINS0_14specificval_tyENS0_11class_matchINS_5ValueEEEEENS0_25OverflowingBinaryOp_matchIT_T0_Lj15ELj2EEERKS7_RKS8_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch8m_NSWSubINS0_14specificval_tyES2_EENS0_25OverflowingBinaryOp_matchIT_T0_Lj15ELj2EEERKS4_RKS5_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch8m_NUWAddINS0_7bind_tyIKNS_5ValueEEENS0_11apint_matchEEENS0_25OverflowingBinaryOp_matchIT_T0_Lj13ELj1EEERKS8_RKS9_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch8m_NUWAddINS0_14specificval_tyENS0_11apint_matchEEENS0_25OverflowingBinaryOp_matchIT_T0_Lj13ELj1EEERKS5_RKS6_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch8m_NUWSubINS0_14specificval_tyENS0_11class_matchINS_5ValueEEEEENS0_25OverflowingBinaryOp_matchIT_T0_Lj15ELj1EEERKS7_RKS8_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch15BinOpPred_matchINS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS3_EEEENS0_20bind_const_intval_tyENS0_17is_right_shift_opEEC2ERKS6_RKS7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch15BinOpPred_matchINS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS3_EEEENS0_20bind_const_intval_tyENS0_17is_right_shift_opEE5matchINS_5ValueEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch15BinOpPred_matchINS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS3_EEEENS0_20bind_const_intval_tyENS0_17is_right_shift_opEE5matchINS_8ConstantEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch17is_right_shift_op8isOpTypeEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5m_ShrINS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS3_EEEENS0_20bind_const_intval_tyEEENS0_15BinOpPred_matchIT_T0_NS0_17is_right_shift_opEEERKS9_RKSA_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch11Exact_matchINS0_14BinaryOp_matchINS0_11class_matchINS_5ValueEEES5_Lj26ELb0EEEEC2ERKS6_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch11Exact_matchINS0_14BinaryOp_matchINS0_11class_matchINS_5ValueEEES5_Lj19ELb0EEEEC2ERKS6_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch11Exact_matchINS0_14BinaryOp_matchINS0_11class_matchINS_5ValueEEES5_Lj26ELb0EEEE5matchIKS4_EEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch11Exact_matchINS0_14BinaryOp_matchINS0_11class_matchINS_5ValueEEES5_Lj19ELb0EEEE5matchIKS4_EEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch7m_ExactINS0_14BinaryOp_matchINS0_11class_matchINS_5ValueEEES5_Lj19ELb0EEEEENS0_11Exact_matchIT_EERKS8_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch7m_ExactINS0_14BinaryOp_matchINS0_11class_matchINS_5ValueEEES5_Lj26ELb0EEEEENS0_11Exact_matchIT_EERKS8_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14CmpClass_matchINS0_14specificval_tyENS0_11apint_matchENS_8ICmpInstENS_7CmpInst9PredicateELb1EEC2ERS6_RKS2_RKS3_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14CmpClass_matchINS0_14specificval_tyENS0_7bind_tyINS_5ValueEEENS_8ICmpInstENS_7CmpInst9PredicateELb1EEC2ERS8_RKS2_RKS5_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14CmpClass_matchINS0_7bind_tyINS_5ValueEEES4_NS_8FCmpInstENS_7CmpInst9PredicateELb0EEC2ERS7_RKS4_SB_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14CmpClass_matchINS0_14BinaryOp_matchINS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS4_EEEENS0_11api_pred_tyINS0_9is_power2EEELj28ELb1EEENS0_7is_zeroENS_8ICmpInstENS_7CmpInst9PredicateELb0EEC2ERSF_RKSB_RKSC_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14CmpClass_matchINS0_14BinaryOp_matchINS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS4_EEEENS0_7bind_tyINS_5ValueEEELj30ELb1EEESA_NS_8ICmpInstENS_7CmpInst9PredicateELb1EEC2ERSE_RKSB_RKSA_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14CmpClass_matchINS0_11class_matchINS_5ValueEEENS0_7is_zeroENS_8ICmpInstENS_7CmpInst9PredicateELb0EEC2ERS8_RKS4_RKS5_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14CmpClass_matchINS0_16match_combine_orINS0_14specificval_tyENS0_15CastClass_matchIS3_Lj47EEEEENS0_7bind_tyINS_5ValueEEENS_8ICmpInstENS_7CmpInst9PredicateELb1EEC2ERSC_RKS6_RKS9_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14CmpClass_matchINS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS3_EEEENS0_7bind_tyINS_5ValueEEENS_8ICmpInstENS_7CmpInst9PredicateELb1EEC2ERSC_RKS6_RKS9_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14CmpClass_matchINS0_14BinaryOp_matchINS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS4_EEEENS0_7bind_tyINS_5ValueEEELj28ELb1EEESA_NS_8ICmpInstENS_7CmpInst9PredicateELb1EEC2ERSE_RKSB_RKSA_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14CmpClass_matchINS0_16match_combine_orINS2_INS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS3_EEEENS0_14BinaryOp_matchIS6_NS0_11apint_matchELj13ELb0EEEEENS0_7bind_tyINS_5ValueEEENS_8ICmpInstENS_7CmpInst9PredicateELb0EEC2ERSG_RKSA_RKSD_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14CmpClass_matchINS0_14BinaryOp_matchINS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEENS2_INS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS8_EEEENS0_7bind_tyINS_5ValueEEELj28ELb1EEELj30ELb1EEESE_NS_8ICmpInstENS_7CmpInst9PredicateELb1EEC2ERSJ_RKSG_RKSE_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14CmpClass_matchINS0_14BinaryOp_matchINS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS4_EEEENS0_7bind_tyINS_5ValueEEELj29ELb1EEESA_NS_8ICmpInstENS_7CmpInst9PredicateELb1EEC2ERSE_RKSB_RKSA_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14CmpClass_matchINS0_14BinaryOp_matchINS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEENS2_INS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS8_EEEENS0_7bind_tyINS_5ValueEEELj29ELb1EEELj30ELb1EEESE_NS_8ICmpInstENS_7CmpInst9PredicateELb1EEC2ERSJ_RKSG_RKSE_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14CmpClass_matchINS0_14BinaryOp_matchINS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEENS2_INS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS8_EEEENS0_7bind_tyINS_5ValueEEELj30ELb1EEELj30ELb1EEESE_NS_8ICmpInstENS_7CmpInst9PredicateELb1EEC2ERSJ_RKSG_RKSE_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14CmpClass_matchINS0_14BinaryOp_matchINS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEENS0_15BinOpPred_matchINS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS9_EEEENS0_20bind_const_intval_tyENS0_17is_right_shift_opEEELj30ELb1EEENS0_7bind_tyINS_5ValueEEENS_8ICmpInstENS_7CmpInst9PredicateELb1EEC2ERSM_RKSG_RKSJ_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14CmpClass_matchINS0_14BinaryOp_matchINS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEENS2_INS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS8_EEEENS0_20bind_const_intval_tyELj25ELb0EEELj30ELb1EEENS0_7bind_tyINS_5ValueEEENS_8ICmpInstENS_7CmpInst9PredicateELb1EEC2ERSK_RKSE_RKSH_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14CmpClass_matchINS0_15BinOpPred_matchINS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS4_EEEENS0_20bind_const_intval_tyENS0_17is_right_shift_opEEENS0_7bind_tyINS_5ValueEEENS_8ICmpInstENS_7CmpInst9PredicateELb1EEC2ERSG_RKSA_RKSD_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14CmpClass_matchINS0_14BinaryOp_matchINS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS4_EEEENS0_20bind_const_intval_tyELj25ELb0EEENS0_7bind_tyINS_5ValueEEENS_8ICmpInstENS_7CmpInst9PredicateELb1EEC2ERSF_RKS9_RKSC_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14CmpClass_matchINS0_7bind_tyINS_5ValueEEES4_NS_8FCmpInstENS_7CmpInst9PredicateELb0EE5matchIS3_EEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14CmpClass_matchINS0_14BinaryOp_matchINS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS4_EEEENS0_11api_pred_tyINS0_9is_power2EEELj28ELb1EEENS0_7is_zeroENS_8ICmpInstENS_7CmpInst9PredicateELb0EE5matchIKSD_EEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14CmpClass_matchINS0_14BinaryOp_matchINS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEENS0_15BinOpPred_matchINS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS9_EEEENS0_20bind_const_intval_tyENS0_17is_right_shift_opEEELj30ELb1EEENS0_7bind_tyINS_5ValueEEENS_8ICmpInstENS_7CmpInst9PredicateELb1EE5matchIKSK_EEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14CmpClass_matchINS0_16match_combine_orINS0_14specificval_tyENS0_15CastClass_matchIS3_Lj47EEEEENS0_7bind_tyINS_5ValueEEENS_8ICmpInstENS_7CmpInst9PredicateELb1EE5matchIS8_EEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14CmpClass_matchINS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS3_EEEENS0_7bind_tyINS_5ValueEEENS_8ICmpInstENS_7CmpInst9PredicateELb1EE5matchIKSA_EEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14CmpClass_matchINS0_15BinOpPred_matchINS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS4_EEEENS0_20bind_const_intval_tyENS0_17is_right_shift_opEEENS0_7bind_tyINS_5ValueEEENS_8ICmpInstENS_7CmpInst9PredicateELb1EE5matchIKSE_EEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14CmpClass_matchINS0_14BinaryOp_matchINS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS4_EEEENS0_7bind_tyINS_5ValueEEELj28ELb1EEESA_NS_8ICmpInstENS_7CmpInst9PredicateELb1EE5matchIKSC_EEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14CmpClass_matchINS0_14specificval_tyENS0_7bind_tyINS_5ValueEEENS_8ICmpInstENS_7CmpInst9PredicateELb1EE5matchIKNS_4UserEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14CmpClass_matchINS0_14BinaryOp_matchINS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEENS2_INS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS8_EEEENS0_7bind_tyINS_5ValueEEELj28ELb1EEELj30ELb1EEESE_NS_8ICmpInstENS_7CmpInst9PredicateELb1EE5matchIKSH_EEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14CmpClass_matchINS0_14BinaryOp_matchINS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEENS2_INS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS8_EEEENS0_20bind_const_intval_tyELj25ELb0EEELj30ELb1EEENS0_7bind_tyINS_5ValueEEENS_8ICmpInstENS_7CmpInst9PredicateELb1EE5matchIKSI_EEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14CmpClass_matchINS0_14BinaryOp_matchINS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS4_EEEENS0_7bind_tyINS_5ValueEEELj29ELb1EEESA_NS_8ICmpInstENS_7CmpInst9PredicateELb1EE5matchIKSC_EEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14CmpClass_matchINS0_14BinaryOp_matchINS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEENS2_INS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS8_EEEENS0_7bind_tyINS_5ValueEEELj29ELb1EEELj30ELb1EEESE_NS_8ICmpInstENS_7CmpInst9PredicateELb1EE5matchIKSH_EEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14CmpClass_matchINS0_11class_matchINS_5ValueEEENS0_7is_zeroENS_8ICmpInstENS_7CmpInst9PredicateELb0EE5matchIKNS_4UserEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14CmpClass_matchINS0_14BinaryOp_matchINS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS4_EEEENS0_7bind_tyINS_5ValueEEELj30ELb1EEESA_NS_8ICmpInstENS_7CmpInst9PredicateELb1EE5matchIKSC_EEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14CmpClass_matchINS0_14BinaryOp_matchINS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS4_EEEENS0_20bind_const_intval_tyELj25ELb0EEENS0_7bind_tyINS_5ValueEEENS_8ICmpInstENS_7CmpInst9PredicateELb1EE5matchIKSD_EEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14CmpClass_matchINS0_14BinaryOp_matchINS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEENS2_INS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS8_EEEENS0_7bind_tyINS_5ValueEEELj30ELb1EEELj30ELb1EEESE_NS_8ICmpInstENS_7CmpInst9PredicateELb1EE5matchIKSH_EEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14CmpClass_matchINS0_14specificval_tyENS0_7bind_tyINS_5ValueEEENS_8ICmpInstENS_7CmpInst9PredicateELb1EE5matchIS4_EEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14CmpClass_matchINS0_16match_combine_orINS2_INS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS3_EEEENS0_14BinaryOp_matchIS6_NS0_11apint_matchELj13ELb0EEEEENS0_7bind_tyINS_5ValueEEENS_8ICmpInstENS_7CmpInst9PredicateELb0EE5matchIKSE_EEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14CmpClass_matchINS0_14specificval_tyENS0_11apint_matchENS_8ICmpInstENS_7CmpInst9PredicateELb1EE5matchINS_5ValueEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch6m_ICmpINS0_11class_matchINS_5ValueEEENS0_7is_zeroEEENS0_14CmpClass_matchIT_T0_NS_8ICmpInstENS_7CmpInst9PredicateELb0EEERSB_RKS7_RKS8_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch6m_ICmpINS0_16match_combine_orINS2_INS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS3_EEEENS0_14BinaryOp_matchIS6_NS0_11apint_matchELj13ELb0EEEEENS0_7bind_tyINS_5ValueEEEEENS0_14CmpClass_matchIT_T0_NS_8ICmpInstENS_7CmpInst9PredicateELb0EEERSJ_RKSF_RKSG_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch6m_ICmpINS0_14BinaryOp_matchINS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS4_EEEENS0_11api_pred_tyINS0_9is_power2EEELj28ELb1EEENS0_7is_zeroEEENS0_14CmpClass_matchIT_T0_NS_8ICmpInstENS_7CmpInst9PredicateELb0EEERSI_RKSE_RKSF_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch6m_FCmpINS0_7bind_tyINS_5ValueEEES4_EENS0_14CmpClass_matchIT_T0_NS_8FCmpInstENS_7CmpInst9PredicateELb0EEERSA_RKS6_RKS7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14ThreeOps_matchINS0_12OneUse_matchINS0_11class_matchINS_5ValueEEEEES5_S5_Lj57EEC2ERKS6_RKS5_SB_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14ThreeOps_matchINS0_12OneUse_matchINS0_11class_matchINS_5ValueEEEEES5_S5_Lj57EE5matchIS4_EEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch8m_SelectINS0_12OneUse_matchINS0_11class_matchINS_5ValueEEEEES5_S5_EENS0_14ThreeOps_matchIT_T0_T1_Lj57EEERKS8_RKS9_RKSA_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch15CastClass_matchINS0_14BinaryOp_matchINS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEENS0_14specificval_tyELj30ELb1EEELj39EEC2ERKS8_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch15CastClass_matchINS0_7bind_tyINS_5ValueEEELj40EEC2ERKS4_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch15CastClass_matchINS0_7bind_tyINS_5ValueEEELj47EEC2ERKS4_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch15CastClass_matchINS0_14specificval_tyELj47EEC2ERKS2_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch15CastClass_matchINS0_14BinaryOp_matchINS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEENS0_14specificval_tyELj30ELb1EEELj40EEC2ERKS8_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch15CastClass_matchINS0_7bind_tyINS_5ValueEEELj39EEC2ERKS4_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch15CastClass_matchINS0_14specificval_tyELj40EEC2ERKS2_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch15CastClass_matchINS0_7bind_tyINS_5ValueEEELj39EE5matchIKS3_EEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch15CastClass_matchINS0_14BinaryOp_matchINS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEENS0_14specificval_tyELj30ELb1EEELj40EE5matchIKNS_5ValueEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch15CastClass_matchINS0_7bind_tyINS_5ValueEEELj40EE5matchIKS3_EEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch15CastClass_matchINS0_14BinaryOp_matchINS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEENS0_14specificval_tyELj30ELb1EEELj39EE5matchIKNS_5ValueEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch15CastClass_matchINS0_14specificval_tyELj40EE5matchINS_5ValueEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch15CastClass_matchINS0_7bind_tyINS_5ValueEEELj47EE5matchIKS3_EEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch15CastClass_matchINS0_14specificval_tyELj47EE5matchINS_5ValueEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch22PtrToIntSameSize_matchINS0_14specificval_tyEEC2ERKNS_10DataLayoutERKS2_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch22PtrToIntSameSize_matchINS0_14specificval_tyEE5matchINS_8ConstantEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch22PtrToIntSameSize_matchINS0_14specificval_tyEE5matchINS_5ValueEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch10m_PtrToIntINS0_7bind_tyINS_5ValueEEEEENS0_15CastClass_matchIT_Lj47EEERKS6_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch10m_PtrToIntINS0_14specificval_tyEEENS0_15CastClass_matchIT_Lj47EEERKS4_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch18m_PtrToIntSameSizeINS0_14specificval_tyEEENS0_22PtrToIntSameSize_matchIT_EERKNS_10DataLayoutERKS4_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch6m_SExtINS0_14specificval_tyEEENS0_15CastClass_matchIT_Lj40EEERKS4_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch6m_SExtINS0_7bind_tyINS_5ValueEEEEENS0_15CastClass_matchIT_Lj40EEERKS6_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch6m_SExtINS0_14BinaryOp_matchINS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEENS0_14specificval_tyELj30ELb1EEEEENS0_15CastClass_matchIT_Lj40EEERKSA_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch6m_ZExtINS0_7bind_tyINS_5ValueEEEEENS0_15CastClass_matchIT_Lj39EEERKS6_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch6m_ZExtINS0_14BinaryOp_matchINS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEENS0_14specificval_tyELj30ELb1EEEEENS0_15CastClass_matchIT_Lj39EEERKSA_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch12m_ZExtOrSExtINS0_14BinaryOp_matchINS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEENS0_14specificval_tyELj30ELb1EEEEENS0_16match_combine_orINS0_15CastClass_matchIT_Lj39EEENSA_ISB_Lj40EEEEERKSB_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch12m_ZExtOrSExtINS0_7bind_tyINS_5ValueEEEEENS0_16match_combine_orINS0_15CastClass_matchIT_Lj39EEENS6_IS7_Lj40EEEEERKS7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch9brc_matchINS0_14CmpClass_matchINS0_14specificval_tyENS0_11apint_matchENS_8ICmpInstENS_7CmpInst9PredicateELb1EEENS0_7bind_tyINS_10BasicBlockEEESB_EC2ERKS8_RKSB_SG_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch9brc_matchINS0_7bind_tyINS_5ValueEEENS2_INS_10BasicBlockEEES6_EC2ERKS4_RKS6_SB_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch9brc_matchINS0_14CmpClass_matchINS0_14specificval_tyENS0_11apint_matchENS_8ICmpInstENS_7CmpInst9PredicateELb1EEENS0_7bind_tyINS_10BasicBlockEEESB_E5matchIKNS_11InstructionEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch9brc_matchINS0_7bind_tyINS_5ValueEEENS2_INS_10BasicBlockEEES6_E5matchIKNS_11InstructionEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch4m_BrINS0_7bind_tyINS_5ValueEEEEENS0_9brc_matchIT_NS2_INS_10BasicBlockEEES8_EERKS6_RPS7_SD_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch4m_BrINS0_14CmpClass_matchINS0_14specificval_tyENS0_11apint_matchENS_8ICmpInstENS_7CmpInst9PredicateELb1EEENS0_7bind_tyINS_10BasicBlockEEESB_EENS0_9brc_matchIT_T0_T1_EERKSD_RKSE_RKSF_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch12MaxMin_matchINS_8ICmpInstENS0_14specificval_tyENS0_11apint_matchENS0_12smin_pred_tyELb0EEC2ERKS3_RKS4_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch12MaxMin_matchINS_8ICmpInstENS0_14specificval_tyENS0_11apint_matchENS0_12smax_pred_tyELb0EEC2ERKS3_RKS4_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch12MaxMin_matchINS_8ICmpInstENS0_14specificval_tyENS0_11apint_matchENS0_12umax_pred_tyELb0EEC2ERKS3_RKS4_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch12MaxMin_matchINS_8FCmpInstENS0_14specificval_tyENS0_13apfloat_matchENS0_13ufmax_pred_tyELb0EEC2ERKS3_RKS4_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch12MaxMin_matchINS_8FCmpInstENS0_14specificval_tyENS0_13apfloat_matchENS0_13ufmin_pred_tyELb0EEC2ERKS3_RKS4_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch12MaxMin_matchINS_8FCmpInstENS0_14specificval_tyENS0_13apfloat_matchENS0_13ofmin_pred_tyELb0EEC2ERKS3_RKS4_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch12MaxMin_matchINS_8ICmpInstENS0_7bind_tyINS_5ValueEEES5_NS0_12smax_pred_tyELb0EEC2ERKS5_S9_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch12MaxMin_matchINS_8ICmpInstENS0_7bind_tyINS_5ValueEEES5_NS0_12smin_pred_tyELb0EEC2ERKS5_S9_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch12MaxMin_matchINS_8ICmpInstENS0_7bind_tyINS_5ValueEEES5_NS0_12umax_pred_tyELb0EEC2ERKS5_S9_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch12MaxMin_matchINS_8ICmpInstENS0_7bind_tyINS_5ValueEEES5_NS0_12umin_pred_tyELb0EEC2ERKS5_S9_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch12MaxMin_matchINS_8ICmpInstENS0_14specificval_tyENS0_11apint_matchENS0_12umin_pred_tyELb0EEC2ERKS3_RKS4_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch12MaxMin_matchINS_8FCmpInstENS0_14specificval_tyENS0_13apfloat_matchENS0_13ofmax_pred_tyELb0EEC2ERKS3_RKS4_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch12MaxMin_matchINS_8FCmpInstENS0_14specificval_tyENS0_13apfloat_matchENS0_13ofmin_pred_tyELb0EE5matchINS_5ValueEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch12MaxMin_matchINS_8ICmpInstENS0_7bind_tyINS_5ValueEEES5_NS0_12smax_pred_tyELb0EE5matchIKS4_EEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch12MaxMin_matchINS_8FCmpInstENS0_14specificval_tyENS0_13apfloat_matchENS0_13ufmin_pred_tyELb0EE5matchINS_5ValueEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch12MaxMin_matchINS_8FCmpInstENS0_14specificval_tyENS0_13apfloat_matchENS0_13ofmax_pred_tyELb0EE5matchINS_5ValueEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch12MaxMin_matchINS_8ICmpInstENS0_14specificval_tyENS0_11apint_matchENS0_12umin_pred_tyELb0EE5matchINS_5ValueEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch12MaxMin_matchINS_8FCmpInstENS0_14specificval_tyENS0_13apfloat_matchENS0_13ufmax_pred_tyELb0EE5matchINS_5ValueEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch12MaxMin_matchINS_8ICmpInstENS0_14specificval_tyENS0_11apint_matchENS0_12smax_pred_tyELb0EE5matchINS_5ValueEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch12MaxMin_matchINS_8ICmpInstENS0_14specificval_tyENS0_11apint_matchENS0_12umax_pred_tyELb0EE5matchINS_5ValueEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch12MaxMin_matchINS_8ICmpInstENS0_14specificval_tyENS0_11apint_matchENS0_12smin_pred_tyELb0EE5matchINS_5ValueEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch12MaxMin_matchINS_8ICmpInstENS0_7bind_tyINS_5ValueEEES5_NS0_12smin_pred_tyELb0EE5matchIKS4_EEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch12MaxMin_matchINS_8ICmpInstENS0_7bind_tyINS_5ValueEEES5_NS0_12umax_pred_tyELb0EE5matchIKS4_EEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch12MaxMin_matchINS_8ICmpInstENS0_7bind_tyINS_5ValueEEES5_NS0_12umin_pred_tyELb0EE5matchIKS4_EEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch12smax_pred_ty5matchENS_7CmpInst9PredicateE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch12smin_pred_ty5matchENS_7CmpInst9PredicateE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch12umax_pred_ty5matchENS_7CmpInst9PredicateE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch12umin_pred_ty5matchENS_7CmpInst9PredicateE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch13ofmax_pred_ty5matchENS_7CmpInst9PredicateE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch13ofmin_pred_ty5matchENS_7CmpInst9PredicateE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch13ufmax_pred_ty5matchENS_7CmpInst9PredicateE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch13ufmin_pred_ty5matchENS_7CmpInst9PredicateE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch6m_SMaxINS0_14specificval_tyENS0_11apint_matchEEENS0_12MaxMin_matchINS_8ICmpInstET_T0_NS0_12smax_pred_tyELb0EEERKS6_RKS7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch6m_SMaxINS0_7bind_tyINS_5ValueEEES4_EENS0_12MaxMin_matchINS_8ICmpInstET_T0_NS0_12smax_pred_tyELb0EEERKS7_RKS8_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch6m_SMinINS0_7bind_tyINS_5ValueEEES4_EENS0_12MaxMin_matchINS_8ICmpInstET_T0_NS0_12smin_pred_tyELb0EEERKS7_RKS8_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch6m_SMinINS0_14specificval_tyENS0_11apint_matchEEENS0_12MaxMin_matchINS_8ICmpInstET_T0_NS0_12smin_pred_tyELb0EEERKS6_RKS7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch6m_UMaxINS0_7bind_tyINS_5ValueEEES4_EENS0_12MaxMin_matchINS_8ICmpInstET_T0_NS0_12umax_pred_tyELb0EEERKS7_RKS8_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch6m_UMaxINS0_14specificval_tyENS0_11apint_matchEEENS0_12MaxMin_matchINS_8ICmpInstET_T0_NS0_12umax_pred_tyELb0EEERKS6_RKS7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch6m_UMinINS0_7bind_tyINS_5ValueEEES4_EENS0_12MaxMin_matchINS_8ICmpInstET_T0_NS0_12umin_pred_tyELb0EEERKS7_RKS8_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch6m_UMinINS0_14specificval_tyENS0_11apint_matchEEENS0_12MaxMin_matchINS_8ICmpInstET_T0_NS0_12umin_pred_tyELb0EEERKS6_RKS7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch10m_MaxOrMinINS0_7bind_tyINS_5ValueEEES4_EENS0_16match_combine_orINS5_INS0_12MaxMin_matchINS_8ICmpInstET_T0_NS0_12smax_pred_tyELb0EEENS6_IS7_S8_S9_NS0_12smin_pred_tyELb0EEEEENS5_INS6_IS7_S8_S9_NS0_12umax_pred_tyELb0EEENS6_IS7_S8_S9_NS0_12umin_pred_tyELb0EEEEEEERKS8_RKS9_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch9m_OrdFMaxINS0_14specificval_tyENS0_13apfloat_matchEEENS0_12MaxMin_matchINS_8FCmpInstET_T0_NS0_13ofmax_pred_tyELb0EEERKS6_RKS7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch9m_OrdFMinINS0_14specificval_tyENS0_13apfloat_matchEEENS0_12MaxMin_matchINS_8FCmpInstET_T0_NS0_13ofmin_pred_tyELb0EEERKS6_RKS7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch11m_UnordFMaxINS0_14specificval_tyENS0_13apfloat_matchEEENS0_12MaxMin_matchINS_8FCmpInstET_T0_NS0_13ufmax_pred_tyELb0EEERKS6_RKS7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch11m_UnordFMinINS0_14specificval_tyENS0_13apfloat_matchEEENS0_12MaxMin_matchINS_8FCmpInstET_T0_NS0_13ufmin_pred_tyELb0EEERKS6_RKS7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14Argument_matchINS0_11class_matchINS_5ValueEEEEC2EjRKS4_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14Argument_matchINS0_20bind_const_intval_tyEEC2EjRKS2_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14Argument_matchINS0_7bind_tyINS_5ValueEEEEC2EjRKS4_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14Argument_matchINS0_20bind_const_intval_tyEE5matchINS_5ValueEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14Argument_matchINS0_11class_matchINS_5ValueEEEE5matchIKNS_11InstructionEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14Argument_matchINS0_7bind_tyINS_5ValueEEEE5matchIS3_EEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch10m_ArgumentILj0ENS0_7bind_tyINS_5ValueEEEEENS0_14Argument_matchIT0_EERKS6_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch10m_ArgumentILj1ENS0_20bind_const_intval_tyEEENS0_14Argument_matchIT0_EERKS4_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch10m_ArgumentILj1ENS0_11class_matchINS_5ValueEEEEENS0_14Argument_matchIT0_EERKS6_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch10m_ArgumentILj0ENS0_11class_matchINS_5ValueEEEEENS0_14Argument_matchIT0_EERKS6_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch17IntrinsicID_matchC2Ej</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch17IntrinsicID_match5matchIKNS_11InstructionEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch17IntrinsicID_match5matchIKNS_5ValueEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch17IntrinsicID_match5matchINS_5ValueEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch11m_IntrinsicILj145EEENS0_17IntrinsicID_matchEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch11m_IntrinsicILj424EEENS0_17IntrinsicID_matchEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch11m_IntrinsicILj175EEENS0_17IntrinsicID_matchEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch11m_IntrinsicILj325EEENS0_17IntrinsicID_matchEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch11m_IntrinsicILj175ENS0_7bind_tyINS_5ValueEEEEENS0_14m_Intrinsic_TyIT0_vvvvvvvvvvE2TyERKS6_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch11m_IntrinsicILj325ENS0_11class_matchINS_5ValueEEEEENS0_14m_Intrinsic_TyIT0_vvvvvvvvvvE2TyERKS6_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch11m_IntrinsicILj145ENS0_7bind_tyINS_5ValueEEEEENS0_14m_Intrinsic_TyIT0_vvvvvvvvvvE2TyERKS6_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch11m_IntrinsicILj325ENS0_11class_matchINS_5ValueEEES4_EENS0_14m_Intrinsic_TyIT0_T1_vvvvvvvvvE2TyERKS6_RKS7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch11m_IntrinsicILj175ENS0_7bind_tyINS_5ValueEEENS0_20bind_const_intval_tyEEENS0_14m_Intrinsic_TyIT0_T1_vvvvvvvvvE2TyERKS7_RKS8_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch6m_FAbsINS0_7bind_tyINS_5ValueEEEEENS0_14m_Intrinsic_TyIT_vvvvvvvvvvE2TyERKS6_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch9m_c_BinOpINS0_7bind_tyINS_5ValueEEENS0_14BinaryOp_matchINS0_14deferredval_tyIS3_EES4_Lj13ELb1EEEEENS0_17AnyBinaryOp_matchIT_T0_Lb1EEERKSA_RKSB_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch9m_c_BinOpINS0_7bind_tyINS_5ValueEEENS0_14BinaryOp_matchINS0_14deferredval_tyIS3_EES4_Lj15ELb0EEEEENS0_17AnyBinaryOp_matchIT_T0_Lb1EEERKSA_RKSB_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch9m_c_BinOpINS0_7bind_tyINS_5ValueEEENS0_14BinaryOp_matchIS4_NS0_14deferredval_tyIS3_EELj15ELb0EEEEENS0_17AnyBinaryOp_matchIT_T0_Lb1EEERKSA_RKSB_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch8m_c_ICmpINS0_14BinaryOp_matchINS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEENS0_15BinOpPred_matchINS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS9_EEEENS0_20bind_const_intval_tyENS0_17is_right_shift_opEEELj30ELb1EEENS0_7bind_tyINS_5ValueEEEEENS0_14CmpClass_matchIT_T0_NS_8ICmpInstENS_7CmpInst9PredicateELb1EEERSP_RKSL_RKSM_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch8m_c_ICmpINS0_15BinOpPred_matchINS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS4_EEEENS0_20bind_const_intval_tyENS0_17is_right_shift_opEEENS0_7bind_tyINS_5ValueEEEEENS0_14CmpClass_matchIT_T0_NS_8ICmpInstENS_7CmpInst9PredicateELb1EEERSJ_RKSF_RKSG_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch8m_c_ICmpINS0_14specificval_tyENS0_11apint_matchEEENS0_14CmpClass_matchIT_T0_NS_8ICmpInstENS_7CmpInst9PredicateELb1EEERS9_RKS5_RKS6_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch8m_c_ICmpINS0_14BinaryOp_matchINS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEENS2_INS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS8_EEEENS0_20bind_const_intval_tyELj25ELb0EEELj30ELb1EEENS0_7bind_tyINS_5ValueEEEEENS0_14CmpClass_matchIT_T0_NS_8ICmpInstENS_7CmpInst9PredicateELb1EEERSN_RKSJ_RKSK_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch8m_c_ICmpINS0_16match_combine_orINS0_14specificval_tyENS0_15CastClass_matchIS3_Lj47EEEEENS0_7bind_tyINS_5ValueEEEEENS0_14CmpClass_matchIT_T0_NS_8ICmpInstENS_7CmpInst9PredicateELb1EEERSF_RKSB_RKSC_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch8m_c_ICmpINS0_14BinaryOp_matchINS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS4_EEEENS0_20bind_const_intval_tyELj25ELb0EEENS0_7bind_tyINS_5ValueEEEEENS0_14CmpClass_matchIT_T0_NS_8ICmpInstENS_7CmpInst9PredicateELb1EEERSI_RKSE_RKSF_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch8m_c_ICmpINS0_14specificval_tyENS0_7bind_tyINS_5ValueEEEEENS0_14CmpClass_matchIT_T0_NS_8ICmpInstENS_7CmpInst9PredicateELb1EEERSB_RKS7_RKS8_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch8m_c_ICmpINS0_14BinaryOp_matchINS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEENS2_INS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS8_EEEENS0_7bind_tyINS_5ValueEEELj30ELb1EEELj30ELb1EEESE_EENS0_14CmpClass_matchIT_T0_NS_8ICmpInstENS_7CmpInst9PredicateELb1EEERSM_RKSI_RKSJ_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch8m_c_ICmpINS0_14BinaryOp_matchINS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS4_EEEENS0_7bind_tyINS_5ValueEEELj30ELb1EEESA_EENS0_14CmpClass_matchIT_T0_NS_8ICmpInstENS_7CmpInst9PredicateELb1EEERSH_RKSD_RKSE_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch8m_c_ICmpINS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS3_EEEENS0_7bind_tyINS_5ValueEEEEENS0_14CmpClass_matchIT_T0_NS_8ICmpInstENS_7CmpInst9PredicateELb1EEERSF_RKSB_RKSC_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch8m_c_ICmpINS0_14BinaryOp_matchINS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS4_EEEENS0_7bind_tyINS_5ValueEEELj29ELb1EEESA_EENS0_14CmpClass_matchIT_T0_NS_8ICmpInstENS_7CmpInst9PredicateELb1EEERSH_RKSD_RKSE_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch8m_c_ICmpINS0_14BinaryOp_matchINS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEENS2_INS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS8_EEEENS0_7bind_tyINS_5ValueEEELj28ELb1EEELj30ELb1EEESE_EENS0_14CmpClass_matchIT_T0_NS_8ICmpInstENS_7CmpInst9PredicateELb1EEERSM_RKSI_RKSJ_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch8m_c_ICmpINS0_14BinaryOp_matchINS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS4_EEEENS0_7bind_tyINS_5ValueEEELj28ELb1EEESA_EENS0_14CmpClass_matchIT_T0_NS_8ICmpInstENS_7CmpInst9PredicateELb1EEERSH_RKSD_RKSE_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch8m_c_ICmpINS0_14BinaryOp_matchINS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEENS2_INS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS8_EEEENS0_7bind_tyINS_5ValueEEELj29ELb1EEELj30ELb1EEESE_EENS0_14CmpClass_matchIT_T0_NS_8ICmpInstENS_7CmpInst9PredicateELb1EEERSM_RKSI_RKSJ_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch7m_c_AddINS0_14deferredval_tyINS_5ValueEEENS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEEEENS0_14BinaryOp_matchIT_T0_Lj13ELb1EEERKSA_RKSB_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch7m_c_AddINS0_14deferredval_tyINS_5ValueEEENS0_7bind_tyIS3_EEEENS0_14BinaryOp_matchIT_T0_Lj13ELb1EEERKS8_RKS9_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch7m_c_AndINS0_14specificval_tyENS0_11class_matchINS_5ValueEEEEENS0_14BinaryOp_matchIT_T0_Lj28ELb1EEERKS7_RKS8_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch7m_c_AndINS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS3_EEEENS0_7bind_tyINS_5ValueEEEEENS0_14BinaryOp_matchIT_T0_Lj28ELb1EEERKSB_RKSC_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch7m_c_AndINS0_7bind_tyINS_5ValueEEENS0_14BinaryOp_matchINS0_14cstval_pred_tyINS0_11is_zero_intENS_11ConstantIntEEENS0_14deferredval_tyIS3_EELj15ELb0EEEEENS5_IT_T0_Lj28ELb1EEERKSD_RKSE_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch7m_c_AndINS0_14BinaryOp_matchINS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEENS0_14specificval_tyELj30ELb1EEENS0_11class_matchINS_5ValueEEEEENS2_IT_T0_Lj28ELb1EEERKSC_RKSD_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch7m_c_AndINS0_14BinaryOp_matchINS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEENS0_7bind_tyINS_5ValueEEELj30ELb1EEENS0_11class_matchIS8_EEEENS2_IT_T0_Lj28ELb1EEERKSD_RKSE_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch7m_c_AndINS0_14specificval_tyENS0_7bind_tyINS_5ValueEEEEENS0_14BinaryOp_matchIT_T0_Lj28ELb1EEERKS7_RKS8_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch7m_c_AndINS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS3_EEEENS0_11api_pred_tyINS0_9is_power2EEEEENS0_14BinaryOp_matchIT_T0_Lj28ELb1EEERKSB_RKSC_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch6m_c_OrINS0_14specificval_tyES2_EENS0_14BinaryOp_matchIT_T0_Lj29ELb1EEERKS4_RKS5_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch6m_c_OrINS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS3_EEEENS0_7bind_tyINS_5ValueEEEEENS0_14BinaryOp_matchIT_T0_Lj29ELb1EEERKSB_RKSC_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch7m_c_XorINS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEENS0_14BinaryOp_matchINS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS8_EEEENS0_7bind_tyINS_5ValueEEELj28ELb1EEEEENS6_IT_T0_Lj30ELb1EEERKSG_RKSH_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch7m_c_XorINS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEENS0_7bind_tyINS_5ValueEEEEENS0_14BinaryOp_matchIT_T0_Lj30ELb1EEERKSA_RKSB_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch7m_c_XorINS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEENS0_14BinaryOp_matchINS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS8_EEEENS0_7bind_tyINS_5ValueEEELj30ELb1EEEEENS6_IT_T0_Lj30ELb1EEERKSG_RKSH_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch7m_c_XorINS0_7bind_tyINS_5ValueEEENS0_14BinaryOp_matchINS0_14deferredval_tyIS3_EENS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEELj13ELb1EEEEENS5_IT_T0_Lj30ELb1EEERKSD_RKSE_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch7m_c_XorINS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEENS0_15BinOpPred_matchINS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS8_EEEENS0_20bind_const_intval_tyENS0_17is_right_shift_opEEEEENS0_14BinaryOp_matchIT_T0_Lj30ELb1EEERKSG_RKSH_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch7m_c_XorINS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEENS0_14BinaryOp_matchINS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS8_EEEENS0_20bind_const_intval_tyELj25ELb0EEEEENS6_IT_T0_Lj30ELb1EEERKSE_RKSF_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch7m_c_XorINS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEENS0_14specificval_tyEEENS0_14BinaryOp_matchIT_T0_Lj30ELb1EEERKS8_RKS9_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch7m_c_XorINS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEENS0_14BinaryOp_matchINS0_14specificval_tyES7_Lj29ELb1EEEEENS6_IT_T0_Lj30ELb1EEERKS9_RKSA_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch7m_c_XorINS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS3_EEEENS0_7bind_tyINS_5ValueEEEEENS0_14BinaryOp_matchIT_T0_Lj30ELb1EEERKSB_RKSC_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch7m_c_XorINS0_14BinaryOp_matchINS0_14specificval_tyENS0_7bind_tyINS_5ValueEEELj28ELb1EEENS0_14deferredval_tyIS5_EEEENS2_IT_T0_Lj30ELb1EEERKSA_RKSB_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch7m_c_XorINS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEENS0_14BinaryOp_matchINS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS8_EEEENS0_7bind_tyINS_5ValueEEELj29ELb1EEEEENS6_IT_T0_Lj30ELb1EEERKSG_RKSH_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5m_NegINS0_14deferredval_tyINS_5ValueEEEEENS0_14BinaryOp_matchINS0_14cstval_pred_tyINS0_11is_zero_intENS_11ConstantIntEEET_Lj15ELb0EEERKSA_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5m_NegINS0_14specificval_tyEEENS0_14BinaryOp_matchINS0_14cstval_pred_tyINS0_11is_zero_intENS_11ConstantIntEEET_Lj15ELb0EEERKS8_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5m_NotINS0_7bind_tyINS_5ValueEEEEENS0_14BinaryOp_matchINS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEET_Lj30ELb1EEERKSA_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5m_NotINS0_14BinaryOp_matchINS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS4_EEEENS0_7bind_tyINS_5ValueEEELj30ELb1EEEEENS2_INS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEET_Lj30ELb1EEERKSG_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5m_NotINS0_14specificval_tyEEENS0_14BinaryOp_matchINS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEET_Lj30ELb1EEERKS8_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5m_NotINS0_14BinaryOp_matchINS0_14specificval_tyES3_Lj29ELb1EEEEENS2_INS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEET_Lj30ELb1EEERKS9_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5m_NotINS0_14BinaryOp_matchINS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS4_EEEENS0_7bind_tyINS_5ValueEEELj28ELb1EEEEENS2_INS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEET_Lj30ELb1EEERKSG_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5m_NotINS0_14BinaryOp_matchINS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS4_EEEENS0_7bind_tyINS_5ValueEEELj29ELb1EEEEENS2_INS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEET_Lj30ELb1EEERKSG_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5m_NotINS0_15BinOpPred_matchINS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS4_EEEENS0_20bind_const_intval_tyENS0_17is_right_shift_opEEEEENS0_14BinaryOp_matchINS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEET_Lj30ELb1EEERKSG_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch5m_NotINS0_14BinaryOp_matchINS0_16match_combine_orINS0_14specificval_tyENS0_22PtrToIntSameSize_matchIS4_EEEENS0_20bind_const_intval_tyELj25ELb0EEEEENS2_INS0_14cstval_pred_tyINS0_11is_all_onesENS_11ConstantIntEEET_Lj30ELb1EEERKSE_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch18ExtractValue_matchILin1ENS0_7bind_tyIKNS_16WithOverflowInstEEEEC2ERKS5_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch18ExtractValue_matchILin1ENS0_14specificval_tyEEC2ERKS2_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch18ExtractValue_matchILin1ENS0_7bind_tyIKNS_16WithOverflowInstEEEE5matchIKNS_11InstructionEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch18ExtractValue_matchILin1ENS0_14specificval_tyEE5matchIKNS_5ValueEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14m_ExtractValueINS0_7bind_tyIKNS_16WithOverflowInstEEEEENS0_18ExtractValue_matchILin1ET_EERKS7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch14m_ExtractValueINS0_14specificval_tyEEENS0_18ExtractValue_matchILin1ET_EERKS4_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch15VScaleVal_match5matchIKNS_5ValueEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch8m_VScaleEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch15LogicalOp_matchINS0_11class_matchINS_5ValueEEES4_Lj28ELb0EEC2ERKS4_S7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch15LogicalOp_matchINS0_11class_matchINS_5ValueEEES4_Lj28ELb0EE5matchIKNS_4UserEEEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch15LogicalOp_matchINS0_7bind_tyIKNS_5ValueEEES5_Lj28ELb0EE5matchIS4_EEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch15LogicalOp_matchINS0_7bind_tyIKNS_5ValueEEES5_Lj29ELb0EE5matchIS4_EEbPT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch15LogicalOp_matchINS0_7bind_tyIKNS_5ValueEEES5_Lj28ELb0EE5matchIKNS_11InstructionEEEbPT_</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch15LogicalOp_matchINS0_7bind_tyIKNS_5ValueEEES5_Lj29ELb0EE5matchIKNS_11InstructionEEEbPT_</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12PatternMatch12m_LogicalAndINS0_11class_matchINS_5ValueEEES4_EENS0_15LogicalOp_matchIT_T0_Lj28ELb0EEERKS6_RKS7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Coverage Diff</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Coverage Diff</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span> BUT NOT </span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </th>
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
      <span> BUT NOT </span>
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="codeline">//===- PatternMatch.h - Match on the LLVM IR --------------------*- C++ -*-===//</td>
    <td class="lineNumber">1</td>
    <td class="codeline">//===- PatternMatch.h - Match on the LLVM IR --------------------*- C++ -*-===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="codeline">//</td>
    <td class="lineNumber">2</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="codeline">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">3</td>
    <td class="codeline">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="codeline">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">4</td>
    <td class="codeline">// See https://llvm.org/LICENSE.txt for license information.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="codeline">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">5</td>
    <td class="codeline">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="codeline">//</td>
    <td class="lineNumber">6</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">7</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="codeline">//</td>
    <td class="lineNumber">8</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="codeline">// This file provides a simple and efficient mechanism for performing general</td>
    <td class="lineNumber">9</td>
    <td class="codeline">// This file provides a simple and efficient mechanism for performing general</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="codeline">// tree-based pattern matches on the LLVM IR. The power of these routines is</td>
    <td class="lineNumber">10</td>
    <td class="codeline">// tree-based pattern matches on the LLVM IR. The power of these routines is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="codeline">// that it allows you to write concise patterns that are expressive and easy to</td>
    <td class="lineNumber">11</td>
    <td class="codeline">// that it allows you to write concise patterns that are expressive and easy to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="codeline">// understand. The other major advantage of this is that it allows you to</td>
    <td class="lineNumber">12</td>
    <td class="codeline">// understand. The other major advantage of this is that it allows you to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="codeline">// trivially capture/bind elements in the pattern to variables. For example,</td>
    <td class="lineNumber">13</td>
    <td class="codeline">// trivially capture/bind elements in the pattern to variables. For example,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="codeline">// you can do something like this:</td>
    <td class="lineNumber">14</td>
    <td class="codeline">// you can do something like this:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="codeline">//</td>
    <td class="lineNumber">15</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="codeline">//  Value *Exp = ...</td>
    <td class="lineNumber">16</td>
    <td class="codeline">//  Value *Exp = ...</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="codeline">//  Value *X, *Y;  ConstantInt *C1, *C2;      // (X & C1) | (Y & C2)</td>
    <td class="lineNumber">17</td>
    <td class="codeline">//  Value *X, *Y;  ConstantInt *C1, *C2;      // (X & C1) | (Y & C2)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="codeline">//  if (match(Exp, m_Or(m_And(m_Value(X), m_ConstantInt(C1)),</td>
    <td class="lineNumber">18</td>
    <td class="codeline">//  if (match(Exp, m_Or(m_And(m_Value(X), m_ConstantInt(C1)),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="codeline">//                      m_And(m_Value(Y), m_ConstantInt(C2))))) {</td>
    <td class="lineNumber">19</td>
    <td class="codeline">//                      m_And(m_Value(Y), m_ConstantInt(C2))))) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="codeline">//    ... Pattern is matched and variables are bound ...</td>
    <td class="lineNumber">20</td>
    <td class="codeline">//    ... Pattern is matched and variables are bound ...</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="codeline">//  }</td>
    <td class="lineNumber">21</td>
    <td class="codeline">//  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="codeline">//</td>
    <td class="lineNumber">22</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="codeline">// This is primarily useful to things like the instruction combiner, but can</td>
    <td class="lineNumber">23</td>
    <td class="codeline">// This is primarily useful to things like the instruction combiner, but can</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="codeline">// also be useful for static analysis tools or code generators.</td>
    <td class="lineNumber">24</td>
    <td class="codeline">// also be useful for static analysis tools or code generators.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="codeline">//</td>
    <td class="lineNumber">25</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">26</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="codeline"></td>
    <td class="lineNumber">27</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="codeline">#ifndef LLVM_IR_PATTERNMATCH_H</td>
    <td class="lineNumber">28</td>
    <td class="codeline">#ifndef LLVM_IR_PATTERNMATCH_H</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="codeline">#define LLVM_IR_PATTERNMATCH_H</td>
    <td class="lineNumber">29</td>
    <td class="codeline">#define LLVM_IR_PATTERNMATCH_H</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="codeline"></td>
    <td class="lineNumber">30</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="codeline">#include "llvm/ADT/APFloat.h"</td>
    <td class="lineNumber">31</td>
    <td class="codeline">#include "llvm/ADT/APFloat.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="codeline">#include "llvm/ADT/APInt.h"</td>
    <td class="lineNumber">32</td>
    <td class="codeline">#include "llvm/ADT/APInt.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="codeline">#include "llvm/IR/Constant.h"</td>
    <td class="lineNumber">33</td>
    <td class="codeline">#include "llvm/IR/Constant.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="codeline">#include "llvm/IR/Constants.h"</td>
    <td class="lineNumber">34</td>
    <td class="codeline">#include "llvm/IR/Constants.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="codeline">#include "llvm/IR/DataLayout.h"</td>
    <td class="lineNumber">35</td>
    <td class="codeline">#include "llvm/IR/DataLayout.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="codeline">#include "llvm/IR/InstrTypes.h"</td>
    <td class="lineNumber">36</td>
    <td class="codeline">#include "llvm/IR/InstrTypes.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="codeline">#include "llvm/IR/Instruction.h"</td>
    <td class="lineNumber">37</td>
    <td class="codeline">#include "llvm/IR/Instruction.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="codeline">#include "llvm/IR/Instructions.h"</td>
    <td class="lineNumber">38</td>
    <td class="codeline">#include "llvm/IR/Instructions.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="codeline">#include "llvm/IR/IntrinsicInst.h"</td>
    <td class="lineNumber">39</td>
    <td class="codeline">#include "llvm/IR/IntrinsicInst.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="codeline">#include "llvm/IR/Intrinsics.h"</td>
    <td class="lineNumber">40</td>
    <td class="codeline">#include "llvm/IR/Intrinsics.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="codeline">#include "llvm/IR/Operator.h"</td>
    <td class="lineNumber">41</td>
    <td class="codeline">#include "llvm/IR/Operator.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="codeline">#include "llvm/IR/Value.h"</td>
    <td class="lineNumber">42</td>
    <td class="codeline">#include "llvm/IR/Value.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="codeline">#include "llvm/Support/Casting.h"</td>
    <td class="lineNumber">43</td>
    <td class="codeline">#include "llvm/Support/Casting.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="codeline">#include <cstdint></td>
    <td class="lineNumber">44</td>
    <td class="codeline">#include <cstdint></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="codeline"></td>
    <td class="lineNumber">45</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="codeline">namespace llvm {</td>
    <td class="lineNumber">46</td>
    <td class="codeline">namespace llvm {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="codeline">namespace PatternMatch {</td>
    <td class="lineNumber">47</td>
    <td class="codeline">namespace PatternMatch {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="codeline"></td>
    <td class="lineNumber">48</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="codeline">template <typename Val, typename Pattern> bool match(Val *V, const Pattern &P) {</td>
    <td class="lineNumber">49</td>
    <td class="codeline">template <typename Val, typename Pattern> bool match(Val *V, const Pattern &P) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="codeline">  return const_cast<Pattern &>(P).match(V);</td>
    <td class="lineNumber">50</td>
    <td class="codeline">  return const_cast<Pattern &>(P).match(V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="codeline">}</td>
    <td class="lineNumber">51</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="codeline"></td>
    <td class="lineNumber">52</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="codeline">template <typename Pattern> bool match(ArrayRef<int> Mask, const Pattern &P) {</td>
    <td class="lineNumber">53</td>
    <td class="codeline">template <typename Pattern> bool match(ArrayRef<int> Mask, const Pattern &P) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="codeline">  return const_cast<Pattern &>(P).match(Mask);</td>
    <td class="lineNumber">54</td>
    <td class="codeline">  return const_cast<Pattern &>(P).match(Mask);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="codeline">}</td>
    <td class="lineNumber">55</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="codeline"></td>
    <td class="lineNumber">56</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="codeline">template <typename SubPattern_t> struct OneUse_match {</td>
    <td class="lineNumber">57</td>
    <td class="codeline">template <typename SubPattern_t> struct OneUse_match {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="codeline">  SubPattern_t SubPattern;</td>
    <td class="lineNumber">58</td>
    <td class="codeline">  SubPattern_t SubPattern;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="codeline"></td>
    <td class="lineNumber">59</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="codeline">  OneUse_match(const SubPattern_t &SP) : SubPattern(SP) {}</td>
    <td class="lineNumber">60</td>
    <td class="codeline">  OneUse_match(const SubPattern_t &SP) : SubPattern(SP) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="codeline"></td>
    <td class="lineNumber">61</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="codeline">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td class="lineNumber">62</td>
    <td class="codeline">  template <typename OpTy> bool match(OpTy *V) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="codeline">    return V->hasOneUse() && SubPattern.match(V);</td>
    <td class="lineNumber">63</td>
    <td class="codeline">    return V->hasOneUse() && SubPattern.match(V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">64</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="codeline">};</td>
    <td class="lineNumber">65</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="codeline"></td>
    <td class="lineNumber">66</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="codeline">template <typename T> inline OneUse_match<T> m_OneUse(const T &SubPattern) {</td>
    <td class="lineNumber">67</td>
    <td class="codeline">template <typename T> inline OneUse_match<T> m_OneUse(const T &SubPattern) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="codeline">  return SubPattern;</td>
    <td class="lineNumber">68</td>
    <td class="codeline">  return SubPattern;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="codeline">}</td>
    <td class="lineNumber">69</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="codeline"></td>
    <td class="lineNumber">70</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="codeline">template <typename Class> struct class_match {</td>
    <td class="lineNumber">71</td>
    <td class="codeline">template <typename Class> struct class_match {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="codeline">  template <typename ITy> bool match(ITy *V) { return isa<Class>(V); }</td>
    <td class="lineNumber">72</td>
    <td class="codeline">  template <typename ITy> bool match(ITy *V) { return isa<Class>(V); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="codeline">};</td>
    <td class="lineNumber">73</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="codeline"></td>
    <td class="lineNumber">74</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="codeline">/// Match an arbitrary value and ignore it.</td>
    <td class="lineNumber">75</td>
    <td class="codeline">/// Match an arbitrary value and ignore it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="codeline">inline class_match<Value> m_Value() { return class_match<Value>(); }</td>
    <td class="lineNumber">76</td>
    <td class="codeline">inline class_match<Value> m_Value() { return class_match<Value>(); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="codeline"></td>
    <td class="lineNumber">77</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="codeline">/// Match an arbitrary unary operation and ignore it.</td>
    <td class="lineNumber">78</td>
    <td class="codeline">/// Match an arbitrary unary operation and ignore it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="codeline">inline class_match<UnaryOperator> m_UnOp() {</td>
    <td class="lineNumber">79</td>
    <td class="codeline">inline class_match<UnaryOperator> m_UnOp() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="codeline">  return class_match<UnaryOperator>();</td>
    <td class="lineNumber">80</td>
    <td class="codeline">  return class_match<UnaryOperator>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="codeline">}</td>
    <td class="lineNumber">81</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="codeline"></td>
    <td class="lineNumber">82</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="codeline">/// Match an arbitrary binary operation and ignore it.</td>
    <td class="lineNumber">83</td>
    <td class="codeline">/// Match an arbitrary binary operation and ignore it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="codeline">inline class_match<BinaryOperator> m_BinOp() {</td>
    <td class="lineNumber">84</td>
    <td class="codeline">inline class_match<BinaryOperator> m_BinOp() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="codeline">  return class_match<BinaryOperator>();</td>
    <td class="lineNumber">85</td>
    <td class="codeline">  return class_match<BinaryOperator>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="codeline">}</td>
    <td class="lineNumber">86</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="codeline"></td>
    <td class="lineNumber">87</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="codeline">/// Matches any compare instruction and ignore it.</td>
    <td class="lineNumber">88</td>
    <td class="codeline">/// Matches any compare instruction and ignore it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="codeline">inline class_match<CmpInst> m_Cmp() { return class_match<CmpInst>(); }</td>
    <td class="lineNumber">89</td>
    <td class="codeline">inline class_match<CmpInst> m_Cmp() { return class_match<CmpInst>(); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="codeline"></td>
    <td class="lineNumber">90</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="codeline">struct undef_match {</td>
    <td class="lineNumber">91</td>
    <td class="codeline">struct undef_match {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="codeline">  static bool check(const Value *V) {</td>
    <td class="lineNumber">92</td>
    <td class="codeline">  static bool check(const Value *V) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="codeline">    if (isa<UndefValue>(V))</td>
    <td class="lineNumber">93</td>
    <td class="codeline">    if (isa<UndefValue>(V))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="codeline">      return true;</td>
    <td class="lineNumber">94</td>
    <td class="codeline">      return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="codeline"></td>
    <td class="lineNumber">95</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="codeline">    const auto *CA = dyn_cast<ConstantAggregate>(V);</td>
    <td class="lineNumber">96</td>
    <td class="codeline">    const auto *CA = dyn_cast<ConstantAggregate>(V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="codeline">    if (!CA)</td>
    <td class="lineNumber">97</td>
    <td class="codeline">    if (!CA)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">98</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="codeline"></td>
    <td class="lineNumber">99</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="codeline">    SmallPtrSet<const ConstantAggregate *, 8> Seen;</td>
    <td class="lineNumber">100</td>
    <td class="codeline">    SmallPtrSet<const ConstantAggregate *, 8> Seen;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="codeline">    SmallVector<const ConstantAggregate *, 8> Worklist;</td>
    <td class="lineNumber">101</td>
    <td class="codeline">    SmallVector<const ConstantAggregate *, 8> Worklist;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="codeline"></td>
    <td class="lineNumber">102</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="codeline">    // Either UndefValue, PoisonValue, or an aggregate that only contains</td>
    <td class="lineNumber">103</td>
    <td class="codeline">    // Either UndefValue, PoisonValue, or an aggregate that only contains</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="codeline">    // these is accepted by matcher.</td>
    <td class="lineNumber">104</td>
    <td class="codeline">    // these is accepted by matcher.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="codeline">    // CheckValue returns false if CA cannot satisfy this constraint.</td>
    <td class="lineNumber">105</td>
    <td class="codeline">    // CheckValue returns false if CA cannot satisfy this constraint.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="codeline">    auto CheckValue = [&](const ConstantAggregate *CA) {</td>
    <td class="lineNumber">106</td>
    <td class="codeline">    auto CheckValue = [&](const ConstantAggregate *CA) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="codeline">      for (const Value *Op : CA->operand_values()) {</td>
    <td class="lineNumber">107</td>
    <td class="codeline">      for (const Value *Op : CA->operand_values()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="codeline">        if (isa<UndefValue>(Op))</td>
    <td class="lineNumber">108</td>
    <td class="codeline">        if (isa<UndefValue>(Op))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="codeline">          continue;</td>
    <td class="lineNumber">109</td>
    <td class="codeline">          continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="codeline"></td>
    <td class="lineNumber">110</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="codeline">        const auto *CA = dyn_cast<ConstantAggregate>(Op);</td>
    <td class="lineNumber">111</td>
    <td class="codeline">        const auto *CA = dyn_cast<ConstantAggregate>(Op);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="codeline">        if (!CA)</td>
    <td class="lineNumber">112</td>
    <td class="codeline">        if (!CA)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="codeline">          return false;</td>
    <td class="lineNumber">113</td>
    <td class="codeline">          return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="codeline">        if (Seen.insert(CA).second)</td>
    <td class="lineNumber">114</td>
    <td class="codeline">        if (Seen.insert(CA).second)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="codeline">          Worklist.emplace_back(CA);</td>
    <td class="lineNumber">115</td>
    <td class="codeline">          Worklist.emplace_back(CA);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">116</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="codeline"></td>
    <td class="lineNumber">117</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="codeline">      return true;</td>
    <td class="lineNumber">118</td>
    <td class="codeline">      return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="codeline">    };</td>
    <td class="lineNumber">119</td>
    <td class="codeline">    };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="codeline"></td>
    <td class="lineNumber">120</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="codeline">    if (!CheckValue(CA))</td>
    <td class="lineNumber">121</td>
    <td class="codeline">    if (!CheckValue(CA))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">122</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="codeline"></td>
    <td class="lineNumber">123</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="codeline">    while (!Worklist.empty()) {</td>
    <td class="lineNumber">124</td>
    <td class="codeline">    while (!Worklist.empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="codeline">      if (!CheckValue(Worklist.pop_back_val()))</td>
    <td class="lineNumber">125</td>
    <td class="codeline">      if (!CheckValue(Worklist.pop_back_val()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="codeline">        return false;</td>
    <td class="lineNumber">126</td>
    <td class="codeline">        return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">127</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">128</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">129</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="codeline">  template <typename ITy> bool match(ITy *V) { return check(V); }</td>
    <td class="lineNumber">130</td>
    <td class="codeline">  template <typename ITy> bool match(ITy *V) { return check(V); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="codeline">};</td>
    <td class="lineNumber">131</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="codeline"></td>
    <td class="lineNumber">132</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="codeline">/// Match an arbitrary undef constant. This matches poison as well.</td>
    <td class="lineNumber">133</td>
    <td class="codeline">/// Match an arbitrary undef constant. This matches poison as well.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="codeline">/// If this is an aggregate and contains a non-aggregate element that is</td>
    <td class="lineNumber">134</td>
    <td class="codeline">/// If this is an aggregate and contains a non-aggregate element that is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="codeline">/// neither undef nor poison, the aggregate is not matched.</td>
    <td class="lineNumber">135</td>
    <td class="codeline">/// neither undef nor poison, the aggregate is not matched.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="codeline">inline auto m_Undef() { return undef_match(); }</td>
    <td class="lineNumber">136</td>
    <td class="codeline">inline auto m_Undef() { return undef_match(); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="codeline"></td>
    <td class="lineNumber">137</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="codeline">/// Match an arbitrary poison constant.</td>
    <td class="lineNumber">138</td>
    <td class="codeline">/// Match an arbitrary poison constant.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="codeline">inline class_match<PoisonValue> m_Poison() {</td>
    <td class="lineNumber">139</td>
    <td class="codeline">inline class_match<PoisonValue> m_Poison() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="codeline">  return class_match<PoisonValue>();</td>
    <td class="lineNumber">140</td>
    <td class="codeline">  return class_match<PoisonValue>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="codeline">}</td>
    <td class="lineNumber">141</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="codeline"></td>
    <td class="lineNumber">142</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="codeline">/// Match an arbitrary Constant and ignore it.</td>
    <td class="lineNumber">143</td>
    <td class="codeline">/// Match an arbitrary Constant and ignore it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="codeline">inline class_match<Constant> m_Constant() { return class_match<Constant>(); }</td>
    <td class="lineNumber">144</td>
    <td class="codeline">inline class_match<Constant> m_Constant() { return class_match<Constant>(); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="codeline"></td>
    <td class="lineNumber">145</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="codeline">/// Match an arbitrary ConstantInt and ignore it.</td>
    <td class="lineNumber">146</td>
    <td class="codeline">/// Match an arbitrary ConstantInt and ignore it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="codeline">inline class_match<ConstantInt> m_ConstantInt() {</td>
    <td class="lineNumber">147</td>
    <td class="codeline">inline class_match<ConstantInt> m_ConstantInt() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="codeline">  return class_match<ConstantInt>();</td>
    <td class="lineNumber">148</td>
    <td class="codeline">  return class_match<ConstantInt>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="codeline">}</td>
    <td class="lineNumber">149</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="codeline"></td>
    <td class="lineNumber">150</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="codeline">/// Match an arbitrary ConstantFP and ignore it.</td>
    <td class="lineNumber">151</td>
    <td class="codeline">/// Match an arbitrary ConstantFP and ignore it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="codeline">inline class_match<ConstantFP> m_ConstantFP() {</td>
    <td class="lineNumber">152</td>
    <td class="codeline">inline class_match<ConstantFP> m_ConstantFP() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="codeline">  return class_match<ConstantFP>();</td>
    <td class="lineNumber">153</td>
    <td class="codeline">  return class_match<ConstantFP>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="codeline">}</td>
    <td class="lineNumber">154</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="codeline"></td>
    <td class="lineNumber">155</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="codeline">struct constantexpr_match {</td>
    <td class="lineNumber">156</td>
    <td class="codeline">struct constantexpr_match {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="codeline">  template <typename ITy> bool match(ITy *V) {</td>
    <td class="lineNumber">157</td>
    <td class="codeline">  template <typename ITy> bool match(ITy *V) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="codeline">    auto *C = dyn_cast<Constant>(V);</td>
    <td class="lineNumber">158</td>
    <td class="codeline">    auto *C = dyn_cast<Constant>(V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="codeline">    return C && (isa<ConstantExpr>(C) || C->containsConstantExpression());</td>
    <td class="lineNumber">159</td>
    <td class="codeline">    return C && (isa<ConstantExpr>(C) || C->containsConstantExpression());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">160</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="codeline">};</td>
    <td class="lineNumber">161</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="codeline"></td>
    <td class="lineNumber">162</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="codeline">/// Match a constant expression or a constant that contains a constant</td>
    <td class="lineNumber">163</td>
    <td class="codeline">/// Match a constant expression or a constant that contains a constant</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="codeline">/// expression.</td>
    <td class="lineNumber">164</td>
    <td class="codeline">/// expression.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="codeline">inline constantexpr_match m_ConstantExpr() { return constantexpr_match(); }</td>
    <td class="lineNumber">165</td>
    <td class="codeline">inline constantexpr_match m_ConstantExpr() { return constantexpr_match(); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="codeline"></td>
    <td class="lineNumber">166</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="codeline">/// Match an arbitrary basic block value and ignore it.</td>
    <td class="lineNumber">167</td>
    <td class="codeline">/// Match an arbitrary basic block value and ignore it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="codeline">inline class_match<BasicBlock> m_BasicBlock() {</td>
    <td class="lineNumber">168</td>
    <td class="codeline">inline class_match<BasicBlock> m_BasicBlock() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="codeline">  return class_match<BasicBlock>();</td>
    <td class="lineNumber">169</td>
    <td class="codeline">  return class_match<BasicBlock>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="codeline">}</td>
    <td class="lineNumber">170</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="codeline"></td>
    <td class="lineNumber">171</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="codeline">/// Inverting matcher</td>
    <td class="lineNumber">172</td>
    <td class="codeline">/// Inverting matcher</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="codeline">template <typename Ty> struct match_unless {</td>
    <td class="lineNumber">173</td>
    <td class="codeline">template <typename Ty> struct match_unless {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="codeline">  Ty M;</td>
    <td class="lineNumber">174</td>
    <td class="codeline">  Ty M;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="codeline"></td>
    <td class="lineNumber">175</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="codeline">  match_unless(const Ty &Matcher) : M(Matcher) {}</td>
    <td class="lineNumber">176</td>
    <td class="codeline">  match_unless(const Ty &Matcher) : M(Matcher) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="codeline"></td>
    <td class="lineNumber">177</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="codeline">  template <typename ITy> bool match(ITy *V) { return !M.match(V); }</td>
    <td class="lineNumber">178</td>
    <td class="codeline">  template <typename ITy> bool match(ITy *V) { return !M.match(V); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="codeline">};</td>
    <td class="lineNumber">179</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="codeline"></td>
    <td class="lineNumber">180</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="codeline">/// Match if the inner matcher does *NOT* match.</td>
    <td class="lineNumber">181</td>
    <td class="codeline">/// Match if the inner matcher does *NOT* match.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="codeline">template <typename Ty> inline match_unless<Ty> m_Unless(const Ty &M) {</td>
    <td class="lineNumber">182</td>
    <td class="codeline">template <typename Ty> inline match_unless<Ty> m_Unless(const Ty &M) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="codeline">  return match_unless<Ty>(M);</td>
    <td class="lineNumber">183</td>
    <td class="codeline">  return match_unless<Ty>(M);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="codeline">}</td>
    <td class="lineNumber">184</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="codeline"></td>
    <td class="lineNumber">185</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="codeline">/// Matching combinators</td>
    <td class="lineNumber">186</td>
    <td class="codeline">/// Matching combinators</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="codeline">template <typename LTy, typename RTy> struct match_combine_or {</td>
    <td class="lineNumber">187</td>
    <td class="codeline">template <typename LTy, typename RTy> struct match_combine_or {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="codeline">  LTy L;</td>
    <td class="lineNumber">188</td>
    <td class="codeline">  LTy L;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="codeline">  RTy R;</td>
    <td class="lineNumber">189</td>
    <td class="codeline">  RTy R;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="codeline"></td>
    <td class="lineNumber">190</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="codeline">  match_combine_or(const LTy &Left, const RTy &Right) : L(Left), R(Right) {}</td>
    <td class="lineNumber">191</td>
    <td class="codeline">  match_combine_or(const LTy &Left, const RTy &Right) : L(Left), R(Right) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="codeline"></td>
    <td class="lineNumber">192</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="codeline">  template <typename ITy> bool match(ITy *V) {</td>
    <td class="lineNumber">193</td>
    <td class="codeline">  template <typename ITy> bool match(ITy *V) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="codeline">    if (L.match(V))</td>
    <td class="lineNumber">194</td>
    <td class="codeline">    if (L.match(V))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="codeline">      return true;</td>
    <td class="lineNumber">195</td>
    <td class="codeline">      return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="codeline">    if (R.match(V))</td>
    <td class="lineNumber">196</td>
    <td class="codeline">    if (R.match(V))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="codeline">      return true;</td>
    <td class="lineNumber">197</td>
    <td class="codeline">      return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">198</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">199</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="codeline">};</td>
    <td class="lineNumber">200</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="codeline"></td>
    <td class="lineNumber">201</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="codeline">template <typename LTy, typename RTy> struct match_combine_and {</td>
    <td class="lineNumber">202</td>
    <td class="codeline">template <typename LTy, typename RTy> struct match_combine_and {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="codeline">  LTy L;</td>
    <td class="lineNumber">203</td>
    <td class="codeline">  LTy L;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="codeline">  RTy R;</td>
    <td class="lineNumber">204</td>
    <td class="codeline">  RTy R;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="codeline"></td>
    <td class="lineNumber">205</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="codeline">  match_combine_and(const LTy &Left, const RTy &Right) : L(Left), R(Right) {}</td>
    <td class="lineNumber">206</td>
    <td class="codeline">  match_combine_and(const LTy &Left, const RTy &Right) : L(Left), R(Right) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="codeline"></td>
    <td class="lineNumber">207</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="codeline">  template <typename ITy> bool match(ITy *V) {</td>
    <td class="lineNumber">208</td>
    <td class="codeline">  template <typename ITy> bool match(ITy *V) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="codeline">    if (L.match(V))</td>
    <td class="lineNumber">209</td>
    <td class="codeline">    if (L.match(V))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="codeline">      if (R.match(V))</td>
    <td class="lineNumber">210</td>
    <td class="codeline">      if (R.match(V))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="codeline">        return true;</td>
    <td class="lineNumber">211</td>
    <td class="codeline">        return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">212</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">213</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="codeline">};</td>
    <td class="lineNumber">214</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="codeline"></td>
    <td class="lineNumber">215</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="codeline">/// Combine two pattern matchers matching L || R</td>
    <td class="lineNumber">216</td>
    <td class="codeline">/// Combine two pattern matchers matching L || R</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="codeline">template <typename LTy, typename RTy></td>
    <td class="lineNumber">217</td>
    <td class="codeline">template <typename LTy, typename RTy></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="codeline">inline match_combine_or<LTy, RTy> m_CombineOr(const LTy &L, const RTy &R) {</td>
    <td class="lineNumber">218</td>
    <td class="codeline">inline match_combine_or<LTy, RTy> m_CombineOr(const LTy &L, const RTy &R) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="codeline">  return match_combine_or<LTy, RTy>(L, R);</td>
    <td class="lineNumber">219</td>
    <td class="codeline">  return match_combine_or<LTy, RTy>(L, R);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="codeline">}</td>
    <td class="lineNumber">220</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="codeline"></td>
    <td class="lineNumber">221</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="codeline">/// Combine two pattern matchers matching L && R</td>
    <td class="lineNumber">222</td>
    <td class="codeline">/// Combine two pattern matchers matching L && R</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="codeline">template <typename LTy, typename RTy></td>
    <td class="lineNumber">223</td>
    <td class="codeline">template <typename LTy, typename RTy></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="codeline">inline match_combine_and<LTy, RTy> m_CombineAnd(const LTy &L, const RTy &R) {</td>
    <td class="lineNumber">224</td>
    <td class="codeline">inline match_combine_and<LTy, RTy> m_CombineAnd(const LTy &L, const RTy &R) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="codeline">  return match_combine_and<LTy, RTy>(L, R);</td>
    <td class="lineNumber">225</td>
    <td class="codeline">  return match_combine_and<LTy, RTy>(L, R);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="codeline">}</td>
    <td class="lineNumber">226</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="codeline"></td>
    <td class="lineNumber">227</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="codeline">struct apint_match {</td>
    <td class="lineNumber">228</td>
    <td class="codeline">struct apint_match {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="codeline">  const APInt *&Res;</td>
    <td class="lineNumber">229</td>
    <td class="codeline">  const APInt *&Res;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="codeline">  bool AllowUndef;</td>
    <td class="lineNumber">230</td>
    <td class="codeline">  bool AllowUndef;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="codeline"></td>
    <td class="lineNumber">231</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="codeline">  apint_match(const APInt *&Res, bool AllowUndef)</td>
    <td class="lineNumber">232</td>
    <td class="codeline">  apint_match(const APInt *&Res, bool AllowUndef)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="codeline">      : Res(Res), AllowUndef(AllowUndef) {}</td>
    <td class="lineNumber">233</td>
    <td class="codeline">      : Res(Res), AllowUndef(AllowUndef) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="codeline"></td>
    <td class="lineNumber">234</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="codeline">  template <typename ITy> bool match(ITy *V) {</td>
    <td class="lineNumber">235</td>
    <td class="codeline">  template <typename ITy> bool match(ITy *V) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="codeline">    if (auto *CI = dyn_cast<ConstantInt>(V)) {</td>
    <td class="lineNumber">236</td>
    <td class="codeline">    if (auto *CI = dyn_cast<ConstantInt>(V)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="codeline">      Res = &CI->getValue();</td>
    <td class="lineNumber">237</td>
    <td class="codeline">      Res = &CI->getValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="codeline">      return true;</td>
    <td class="lineNumber">238</td>
    <td class="codeline">      return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">239</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="codeline">    if (V->getType()->isVectorTy())</td>
    <td class="lineNumber">240</td>
    <td class="codeline">    if (V->getType()->isVectorTy())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="codeline">      if (const auto *C = dyn_cast<Constant>(V))</td>
    <td class="lineNumber">241</td>
    <td class="codeline">      if (const auto *C = dyn_cast<Constant>(V))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="codeline">        if (auto *CI =</td>
    <td class="lineNumber">242</td>
    <td class="codeline">        if (auto *CI =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="codeline">                dyn_cast_or_null<ConstantInt>(C->getSplatValue(AllowUndef))) {</td>
    <td class="lineNumber">243</td>
    <td class="codeline">                dyn_cast_or_null<ConstantInt>(C->getSplatValue(AllowUndef))) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="codeline">          Res = &CI->getValue();</td>
    <td class="lineNumber">244</td>
    <td class="codeline">          Res = &CI->getValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="codeline">          return true;</td>
    <td class="lineNumber">245</td>
    <td class="codeline">          return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">246</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">247</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">248</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="codeline">};</td>
    <td class="lineNumber">249</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="codeline">// Either constexpr if or renaming ConstantFP::getValueAPF to</td>
    <td class="lineNumber">250</td>
    <td class="codeline">// Either constexpr if or renaming ConstantFP::getValueAPF to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="codeline">// ConstantFP::getValue is needed to do it via single template</td>
    <td class="lineNumber">251</td>
    <td class="codeline">// ConstantFP::getValue is needed to do it via single template</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="codeline">// function for both apint/apfloat.</td>
    <td class="lineNumber">252</td>
    <td class="codeline">// function for both apint/apfloat.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="codeline">struct apfloat_match {</td>
    <td class="lineNumber">253</td>
    <td class="codeline">struct apfloat_match {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="codeline">  const APFloat *&Res;</td>
    <td class="lineNumber">254</td>
    <td class="codeline">  const APFloat *&Res;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="codeline">  bool AllowUndef;</td>
    <td class="lineNumber">255</td>
    <td class="codeline">  bool AllowUndef;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="codeline"></td>
    <td class="lineNumber">256</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="codeline">  apfloat_match(const APFloat *&Res, bool AllowUndef)</td>
    <td class="lineNumber">257</td>
    <td class="codeline">  apfloat_match(const APFloat *&Res, bool AllowUndef)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="codeline">      : Res(Res), AllowUndef(AllowUndef) {}</td>
    <td class="lineNumber">258</td>
    <td class="codeline">      : Res(Res), AllowUndef(AllowUndef) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="codeline"></td>
    <td class="lineNumber">259</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="codeline">  template <typename ITy> bool match(ITy *V) {</td>
    <td class="lineNumber">260</td>
    <td class="codeline">  template <typename ITy> bool match(ITy *V) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="codeline">    if (auto *CI = dyn_cast<ConstantFP>(V)) {</td>
    <td class="lineNumber">261</td>
    <td class="codeline">    if (auto *CI = dyn_cast<ConstantFP>(V)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="codeline">      Res = &CI->getValueAPF();</td>
    <td class="lineNumber">262</td>
    <td class="codeline">      Res = &CI->getValueAPF();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="codeline">      return true;</td>
    <td class="lineNumber">263</td>
    <td class="codeline">      return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">264</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="codeline">    if (V->getType()->isVectorTy())</td>
    <td class="lineNumber">265</td>
    <td class="codeline">    if (V->getType()->isVectorTy())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="codeline">      if (const auto *C = dyn_cast<Constant>(V))</td>
    <td class="lineNumber">266</td>
    <td class="codeline">      if (const auto *C = dyn_cast<Constant>(V))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="codeline">        if (auto *CI =</td>
    <td class="lineNumber">267</td>
    <td class="codeline">        if (auto *CI =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="codeline">                dyn_cast_or_null<ConstantFP>(C->getSplatValue(AllowUndef))) {</td>
    <td class="lineNumber">268</td>
    <td class="codeline">                dyn_cast_or_null<ConstantFP>(C->getSplatValue(AllowUndef))) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="codeline">          Res = &CI->getValueAPF();</td>
    <td class="lineNumber">269</td>
    <td class="codeline">          Res = &CI->getValueAPF();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="codeline">          return true;</td>
    <td class="lineNumber">270</td>
    <td class="codeline">          return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">271</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">272</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">273</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="codeline">};</td>
    <td class="lineNumber">274</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="codeline"></td>
    <td class="lineNumber">275</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="codeline">/// Match a ConstantInt or splatted ConstantVector, binding the</td>
    <td class="lineNumber">276</td>
    <td class="codeline">/// Match a ConstantInt or splatted ConstantVector, binding the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="codeline">/// specified pointer to the contained APInt.</td>
    <td class="lineNumber">277</td>
    <td class="codeline">/// specified pointer to the contained APInt.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="codeline">inline apint_match m_APInt(const APInt *&Res) {</td>
    <td class="lineNumber">278</td>
    <td class="codeline">inline apint_match m_APInt(const APInt *&Res) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="codeline">  // Forbid undefs by default to maintain previous behavior.</td>
    <td class="lineNumber">279</td>
    <td class="codeline">  // Forbid undefs by default to maintain previous behavior.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="codeline">  return apint_match(Res, /* AllowUndef */ false);</td>
    <td class="lineNumber">280</td>
    <td class="codeline">  return apint_match(Res, /* AllowUndef */ false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="codeline">}</td>
    <td class="lineNumber">281</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="codeline"></td>
    <td class="lineNumber">282</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="codeline">/// Match APInt while allowing undefs in splat vector constants.</td>
    <td class="lineNumber">283</td>
    <td class="codeline">/// Match APInt while allowing undefs in splat vector constants.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="codeline">inline apint_match m_APIntAllowUndef(const APInt *&Res) {</td>
    <td class="lineNumber">284</td>
    <td class="codeline">inline apint_match m_APIntAllowUndef(const APInt *&Res) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="codeline">  return apint_match(Res, /* AllowUndef */ true);</td>
    <td class="lineNumber">285</td>
    <td class="codeline">  return apint_match(Res, /* AllowUndef */ true);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="codeline">}</td>
    <td class="lineNumber">286</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="codeline"></td>
    <td class="lineNumber">287</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="codeline">/// Match APInt while forbidding undefs in splat vector constants.</td>
    <td class="lineNumber">288</td>
    <td class="codeline">/// Match APInt while forbidding undefs in splat vector constants.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="codeline">inline apint_match m_APIntForbidUndef(const APInt *&Res) {</td>
    <td class="lineNumber">289</td>
    <td class="codeline">inline apint_match m_APIntForbidUndef(const APInt *&Res) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="codeline">  return apint_match(Res, /* AllowUndef */ false);</td>
    <td class="lineNumber">290</td>
    <td class="codeline">  return apint_match(Res, /* AllowUndef */ false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="codeline">}</td>
    <td class="lineNumber">291</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="codeline"></td>
    <td class="lineNumber">292</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="codeline">/// Match a ConstantFP or splatted ConstantVector, binding the</td>
    <td class="lineNumber">293</td>
    <td class="codeline">/// Match a ConstantFP or splatted ConstantVector, binding the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="codeline">/// specified pointer to the contained APFloat.</td>
    <td class="lineNumber">294</td>
    <td class="codeline">/// specified pointer to the contained APFloat.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="codeline">inline apfloat_match m_APFloat(const APFloat *&Res) {</td>
    <td class="lineNumber">295</td>
    <td class="codeline">inline apfloat_match m_APFloat(const APFloat *&Res) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="codeline">  // Forbid undefs by default to maintain previous behavior.</td>
    <td class="lineNumber">296</td>
    <td class="codeline">  // Forbid undefs by default to maintain previous behavior.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="codeline">  return apfloat_match(Res, /* AllowUndef */ false);</td>
    <td class="lineNumber">297</td>
    <td class="codeline">  return apfloat_match(Res, /* AllowUndef */ false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="codeline">}</td>
    <td class="lineNumber">298</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="codeline"></td>
    <td class="lineNumber">299</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="codeline">/// Match APFloat while allowing undefs in splat vector constants.</td>
    <td class="lineNumber">300</td>
    <td class="codeline">/// Match APFloat while allowing undefs in splat vector constants.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="codeline">inline apfloat_match m_APFloatAllowUndef(const APFloat *&Res) {</td>
    <td class="lineNumber">301</td>
    <td class="codeline">inline apfloat_match m_APFloatAllowUndef(const APFloat *&Res) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="codeline">  return apfloat_match(Res, /* AllowUndef */ true);</td>
    <td class="lineNumber">302</td>
    <td class="codeline">  return apfloat_match(Res, /* AllowUndef */ true);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="codeline">}</td>
    <td class="lineNumber">303</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="codeline"></td>
    <td class="lineNumber">304</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="codeline">/// Match APFloat while forbidding undefs in splat vector constants.</td>
    <td class="lineNumber">305</td>
    <td class="codeline">/// Match APFloat while forbidding undefs in splat vector constants.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="codeline">inline apfloat_match m_APFloatForbidUndef(const APFloat *&Res) {</td>
    <td class="lineNumber">306</td>
    <td class="codeline">inline apfloat_match m_APFloatForbidUndef(const APFloat *&Res) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="codeline">  return apfloat_match(Res, /* AllowUndef */ false);</td>
    <td class="lineNumber">307</td>
    <td class="codeline">  return apfloat_match(Res, /* AllowUndef */ false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="codeline">}</td>
    <td class="lineNumber">308</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="codeline"></td>
    <td class="lineNumber">309</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="codeline">template <int64_t Val> struct constantint_match {</td>
    <td class="lineNumber">310</td>
    <td class="codeline">template <int64_t Val> struct constantint_match {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="codeline">  template <typename ITy> bool match(ITy *V) {</td>
    <td class="lineNumber">311</td>
    <td class="codeline">  template <typename ITy> bool match(ITy *V) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="codeline">    if (const auto *CI = dyn_cast<ConstantInt>(V)) {</td>
    <td class="lineNumber">312</td>
    <td class="codeline">    if (const auto *CI = dyn_cast<ConstantInt>(V)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="codeline">      const APInt &CIV = CI->getValue();</td>
    <td class="lineNumber">313</td>
    <td class="codeline">      const APInt &CIV = CI->getValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="codeline">      if (Val >= 0)</td>
    <td class="lineNumber">314</td>
    <td class="codeline">      if (Val >= 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="codeline">        return CIV == static_cast<uint64_t>(Val);</td>
    <td class="lineNumber">315</td>
    <td class="codeline">        return CIV == static_cast<uint64_t>(Val);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="codeline">      // If Val is negative, and CI is shorter than it, truncate to the right</td>
    <td class="lineNumber">316</td>
    <td class="codeline">      // If Val is negative, and CI is shorter than it, truncate to the right</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="codeline">      // number of bits.  If it is larger, then we have to sign extend.  Just</td>
    <td class="lineNumber">317</td>
    <td class="codeline">      // number of bits.  If it is larger, then we have to sign extend.  Just</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="codeline">      // compare their negated values.</td>
    <td class="lineNumber">318</td>
    <td class="codeline">      // compare their negated values.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="codeline">      return -CIV == -Val;</td>
    <td class="lineNumber">319</td>
    <td class="codeline">      return -CIV == -Val;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">320</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">321</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">322</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="codeline">};</td>
    <td class="lineNumber">323</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="codeline"></td>
    <td class="lineNumber">324</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="codeline">/// Match a ConstantInt with a specific value.</td>
    <td class="lineNumber">325</td>
    <td class="codeline">/// Match a ConstantInt with a specific value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="codeline">template <int64_t Val> inline constantint_match<Val> m_ConstantInt() {</td>
    <td class="lineNumber">326</td>
    <td class="codeline">template <int64_t Val> inline constantint_match<Val> m_ConstantInt() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="codeline">  return constantint_match<Val>();</td>
    <td class="lineNumber">327</td>
    <td class="codeline">  return constantint_match<Val>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="codeline">}</td>
    <td class="lineNumber">328</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="codeline"></td>
    <td class="lineNumber">329</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="codeline">/// This helper class is used to match constant scalars, vector splats,</td>
    <td class="lineNumber">330</td>
    <td class="codeline">/// This helper class is used to match constant scalars, vector splats,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="codeline">/// and fixed width vectors that satisfy a specified predicate.</td>
    <td class="lineNumber">331</td>
    <td class="codeline">/// and fixed width vectors that satisfy a specified predicate.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="codeline">/// For fixed width vector constants, undefined elements are ignored.</td>
    <td class="lineNumber">332</td>
    <td class="codeline">/// For fixed width vector constants, undefined elements are ignored.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="codeline">template <typename Predicate, typename ConstantVal></td>
    <td class="lineNumber">333</td>
    <td class="codeline">template <typename Predicate, typename ConstantVal></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="codeline">struct cstval_pred_ty : public Predicate {</td>
    <td class="lineNumber">334</td>
    <td class="codeline">struct cstval_pred_ty : public Predicate {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="codeline">  template <typename ITy> bool match(ITy *V) {</td>
    <td class="lineNumber">335</td>
    <td class="codeline">  template <typename ITy> bool match(ITy *V) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="codeline">    if (const auto *CV = dyn_cast<ConstantVal>(V))</td>
    <td class="lineNumber">336</td>
    <td class="codeline">    if (const auto *CV = dyn_cast<ConstantVal>(V))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="codeline">      return this->isValue(CV->getValue());</td>
    <td class="lineNumber">337</td>
    <td class="codeline">      return this->isValue(CV->getValue());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="codeline">    if (const auto *VTy = dyn_cast<VectorType>(V->getType())) {</td>
    <td class="lineNumber">338</td>
    <td class="codeline">    if (const auto *VTy = dyn_cast<VectorType>(V->getType())) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="codeline">      if (const auto *C = dyn_cast<Constant>(V)) {</td>
    <td class="lineNumber">339</td>
    <td class="codeline">      if (const auto *C = dyn_cast<Constant>(V)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="codeline">        if (const auto *CV = dyn_cast_or_null<ConstantVal>(C->getSplatValue()))</td>
    <td class="lineNumber">340</td>
    <td class="codeline">        if (const auto *CV = dyn_cast_or_null<ConstantVal>(C->getSplatValue()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="codeline">          return this->isValue(CV->getValue());</td>
    <td class="lineNumber">341</td>
    <td class="codeline">          return this->isValue(CV->getValue());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="codeline"></td>
    <td class="lineNumber">342</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="codeline">        // Number of elements of a scalable vector unknown at compile time</td>
    <td class="lineNumber">343</td>
    <td class="codeline">        // Number of elements of a scalable vector unknown at compile time</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="codeline">        auto *FVTy = dyn_cast<FixedVectorType>(VTy);</td>
    <td class="lineNumber">344</td>
    <td class="codeline">        auto *FVTy = dyn_cast<FixedVectorType>(VTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="codeline">        if (!FVTy)</td>
    <td class="lineNumber">345</td>
    <td class="codeline">        if (!FVTy)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="codeline">          return false;</td>
    <td class="lineNumber">346</td>
    <td class="codeline">          return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="codeline"></td>
    <td class="lineNumber">347</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="codeline">        // Non-splat vector constant: check each element for a match.</td>
    <td class="lineNumber">348</td>
    <td class="codeline">        // Non-splat vector constant: check each element for a match.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="codeline">        unsigned NumElts = FVTy->getNumElements();</td>
    <td class="lineNumber">349</td>
    <td class="codeline">        unsigned NumElts = FVTy->getNumElements();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="codeline">        assert(NumElts != 0 && "Constant vector with no elements?");</td>
    <td class="lineNumber">350</td>
    <td class="codeline">        assert(NumElts != 0 && "Constant vector with no elements?");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="codeline">        bool HasNonUndefElements = false;</td>
    <td class="lineNumber">351</td>
    <td class="codeline">        bool HasNonUndefElements = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="codeline">        for (unsigned i = 0; i != NumElts; ++i) {</td>
    <td class="lineNumber">352</td>
    <td class="codeline">        for (unsigned i = 0; i != NumElts; ++i) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="codeline">          Constant *Elt = C->getAggregateElement(i);</td>
    <td class="lineNumber">353</td>
    <td class="codeline">          Constant *Elt = C->getAggregateElement(i);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="codeline">          if (!Elt)</td>
    <td class="lineNumber">354</td>
    <td class="codeline">          if (!Elt)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="codeline">            return false;</td>
    <td class="lineNumber">355</td>
    <td class="codeline">            return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="codeline">          if (isa<UndefValue>(Elt))</td>
    <td class="lineNumber">356</td>
    <td class="codeline">          if (isa<UndefValue>(Elt))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="codeline">            continue;</td>
    <td class="lineNumber">357</td>
    <td class="codeline">            continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="codeline">          auto *CV = dyn_cast<ConstantVal>(Elt);</td>
    <td class="lineNumber">358</td>
    <td class="codeline">          auto *CV = dyn_cast<ConstantVal>(Elt);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="codeline">          if (!CV || !this->isValue(CV->getValue()))</td>
    <td class="lineNumber">359</td>
    <td class="codeline">          if (!CV || !this->isValue(CV->getValue()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="codeline">            return false;</td>
    <td class="lineNumber">360</td>
    <td class="codeline">            return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="codeline">          HasNonUndefElements = true;</td>
    <td class="lineNumber">361</td>
    <td class="codeline">          HasNonUndefElements = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">362</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="codeline">        return HasNonUndefElements;</td>
    <td class="lineNumber">363</td>
    <td class="codeline">        return HasNonUndefElements;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">364</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">365</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">366</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">367</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="codeline">};</td>
    <td class="lineNumber">368</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="codeline"></td>
    <td class="lineNumber">369</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="codeline">/// specialization of cstval_pred_ty for ConstantInt</td>
    <td class="lineNumber">370</td>
    <td class="codeline">/// specialization of cstval_pred_ty for ConstantInt</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="codeline">template <typename Predicate></td>
    <td class="lineNumber">371</td>
    <td class="codeline">template <typename Predicate></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="codeline">using cst_pred_ty = cstval_pred_ty<Predicate, ConstantInt>;</td>
    <td class="lineNumber">372</td>
    <td class="codeline">using cst_pred_ty = cstval_pred_ty<Predicate, ConstantInt>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="codeline"></td>
    <td class="lineNumber">373</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="codeline">/// specialization of cstval_pred_ty for ConstantFP</td>
    <td class="lineNumber">374</td>
    <td class="codeline">/// specialization of cstval_pred_ty for ConstantFP</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="codeline">template <typename Predicate></td>
    <td class="lineNumber">375</td>
    <td class="codeline">template <typename Predicate></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="codeline">using cstfp_pred_ty = cstval_pred_ty<Predicate, ConstantFP>;</td>
    <td class="lineNumber">376</td>
    <td class="codeline">using cstfp_pred_ty = cstval_pred_ty<Predicate, ConstantFP>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="codeline"></td>
    <td class="lineNumber">377</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="codeline">/// This helper class is used to match scalar and vector constants that</td>
    <td class="lineNumber">378</td>
    <td class="codeline">/// This helper class is used to match scalar and vector constants that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="codeline">/// satisfy a specified predicate, and bind them to an APInt.</td>
    <td class="lineNumber">379</td>
    <td class="codeline">/// satisfy a specified predicate, and bind them to an APInt.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="codeline">template <typename Predicate> struct api_pred_ty : public Predicate {</td>
    <td class="lineNumber">380</td>
    <td class="codeline">template <typename Predicate> struct api_pred_ty : public Predicate {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="codeline">  const APInt *&Res;</td>
    <td class="lineNumber">381</td>
    <td class="codeline">  const APInt *&Res;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="codeline"></td>
    <td class="lineNumber">382</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="codeline">  api_pred_ty(const APInt *&R) : Res(R) {}</td>
    <td class="lineNumber">383</td>
    <td class="codeline">  api_pred_ty(const APInt *&R) : Res(R) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="codeline"></td>
    <td class="lineNumber">384</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="codeline">  template <typename ITy> bool match(ITy *V) {</td>
    <td class="lineNumber">385</td>
    <td class="codeline">  template <typename ITy> bool match(ITy *V) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="codeline">    if (const auto *CI = dyn_cast<ConstantInt>(V))</td>
    <td class="lineNumber">386</td>
    <td class="codeline">    if (const auto *CI = dyn_cast<ConstantInt>(V))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="codeline">      if (this->isValue(CI->getValue())) {</td>
    <td class="lineNumber">387</td>
    <td class="codeline">      if (this->isValue(CI->getValue())) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="codeline">        Res = &CI->getValue();</td>
    <td class="lineNumber">388</td>
    <td class="codeline">        Res = &CI->getValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="codeline">        return true;</td>
    <td class="lineNumber">389</td>
    <td class="codeline">        return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">390</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="codeline">    if (V->getType()->isVectorTy())</td>
    <td class="lineNumber">391</td>
    <td class="codeline">    if (V->getType()->isVectorTy())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="codeline">      if (const auto *C = dyn_cast<Constant>(V))</td>
    <td class="lineNumber">392</td>
    <td class="codeline">      if (const auto *C = dyn_cast<Constant>(V))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="codeline">        if (auto *CI = dyn_cast_or_null<ConstantInt>(C->getSplatValue()))</td>
    <td class="lineNumber">393</td>
    <td class="codeline">        if (auto *CI = dyn_cast_or_null<ConstantInt>(C->getSplatValue()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="codeline">          if (this->isValue(CI->getValue())) {</td>
    <td class="lineNumber">394</td>
    <td class="codeline">          if (this->isValue(CI->getValue())) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="codeline">            Res = &CI->getValue();</td>
    <td class="lineNumber">395</td>
    <td class="codeline">            Res = &CI->getValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="codeline">            return true;</td>
    <td class="lineNumber">396</td>
    <td class="codeline">            return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="codeline">          }</td>
    <td class="lineNumber">397</td>
    <td class="codeline">          }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="codeline"></td>
    <td class="lineNumber">398</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">399</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">400</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="codeline">};</td>
    <td class="lineNumber">401</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="codeline"></td>
    <td class="lineNumber">402</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="codeline">/// This helper class is used to match scalar and vector constants that</td>
    <td class="lineNumber">403</td>
    <td class="codeline">/// This helper class is used to match scalar and vector constants that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="codeline">/// satisfy a specified predicate, and bind them to an APFloat.</td>
    <td class="lineNumber">404</td>
    <td class="codeline">/// satisfy a specified predicate, and bind them to an APFloat.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="codeline">/// Undefs are allowed in splat vector constants.</td>
    <td class="lineNumber">405</td>
    <td class="codeline">/// Undefs are allowed in splat vector constants.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="codeline">template <typename Predicate> struct apf_pred_ty : public Predicate {</td>
    <td class="lineNumber">406</td>
    <td class="codeline">template <typename Predicate> struct apf_pred_ty : public Predicate {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="codeline">  const APFloat *&Res;</td>
    <td class="lineNumber">407</td>
    <td class="codeline">  const APFloat *&Res;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="codeline"></td>
    <td class="lineNumber">408</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="codeline">  apf_pred_ty(const APFloat *&R) : Res(R) {}</td>
    <td class="lineNumber">409</td>
    <td class="codeline">  apf_pred_ty(const APFloat *&R) : Res(R) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="codeline"></td>
    <td class="lineNumber">410</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="codeline">  template <typename ITy> bool match(ITy *V) {</td>
    <td class="lineNumber">411</td>
    <td class="codeline">  template <typename ITy> bool match(ITy *V) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="codeline">    if (const auto *CI = dyn_cast<ConstantFP>(V))</td>
    <td class="lineNumber">412</td>
    <td class="codeline">    if (const auto *CI = dyn_cast<ConstantFP>(V))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="codeline">      if (this->isValue(CI->getValue())) {</td>
    <td class="lineNumber">413</td>
    <td class="codeline">      if (this->isValue(CI->getValue())) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="codeline">        Res = &CI->getValue();</td>
    <td class="lineNumber">414</td>
    <td class="codeline">        Res = &CI->getValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="codeline">        return true;</td>
    <td class="lineNumber">415</td>
    <td class="codeline">        return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">416</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="codeline">    if (V->getType()->isVectorTy())</td>
    <td class="lineNumber">417</td>
    <td class="codeline">    if (V->getType()->isVectorTy())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="codeline">      if (const auto *C = dyn_cast<Constant>(V))</td>
    <td class="lineNumber">418</td>
    <td class="codeline">      if (const auto *C = dyn_cast<Constant>(V))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="codeline">        if (auto *CI = dyn_cast_or_null<ConstantFP>(</td>
    <td class="lineNumber">419</td>
    <td class="codeline">        if (auto *CI = dyn_cast_or_null<ConstantFP>(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="codeline">                C->getSplatValue(/* AllowUndef */ true)))</td>
    <td class="lineNumber">420</td>
    <td class="codeline">                C->getSplatValue(/* AllowUndef */ true)))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="codeline">          if (this->isValue(CI->getValue())) {</td>
    <td class="lineNumber">421</td>
    <td class="codeline">          if (this->isValue(CI->getValue())) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="codeline">            Res = &CI->getValue();</td>
    <td class="lineNumber">422</td>
    <td class="codeline">            Res = &CI->getValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="codeline">            return true;</td>
    <td class="lineNumber">423</td>
    <td class="codeline">            return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="codeline">          }</td>
    <td class="lineNumber">424</td>
    <td class="codeline">          }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="codeline"></td>
    <td class="lineNumber">425</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">426</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">427</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="codeline">};</td>
    <td class="lineNumber">428</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="codeline"></td>
    <td class="lineNumber">429</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="codeline">///////////////////////////////////////////////////////////////////////////////</td>
    <td class="lineNumber">430</td>
    <td class="codeline">///////////////////////////////////////////////////////////////////////////////</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="codeline">//</td>
    <td class="lineNumber">431</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="codeline">// Encapsulate constant value queries for use in templated predicate matchers.</td>
    <td class="lineNumber">432</td>
    <td class="codeline">// Encapsulate constant value queries for use in templated predicate matchers.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="codeline">// This allows checking if constants match using compound predicates and works</td>
    <td class="lineNumber">433</td>
    <td class="codeline">// This allows checking if constants match using compound predicates and works</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="codeline">// with vector constants, possibly with relaxed constraints. For example, ignore</td>
    <td class="lineNumber">434</td>
    <td class="codeline">// with vector constants, possibly with relaxed constraints. For example, ignore</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="codeline">// undef values.</td>
    <td class="lineNumber">435</td>
    <td class="codeline">// undef values.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="codeline">//</td>
    <td class="lineNumber">436</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="codeline">///////////////////////////////////////////////////////////////////////////////</td>
    <td class="lineNumber">437</td>
    <td class="codeline">///////////////////////////////////////////////////////////////////////////////</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="codeline"></td>
    <td class="lineNumber">438</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="codeline">struct is_any_apint {</td>
    <td class="lineNumber">439</td>
    <td class="codeline">struct is_any_apint {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="codeline">  bool isValue(const APInt &C) { return true; }</td>
    <td class="lineNumber">440</td>
    <td class="codeline">  bool isValue(const APInt &C) { return true; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="codeline">};</td>
    <td class="lineNumber">441</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="codeline">/// Match an integer or vector with any integral constant.</td>
    <td class="lineNumber">442</td>
    <td class="codeline">/// Match an integer or vector with any integral constant.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="codeline">/// For vectors, this includes constants with undefined elements.</td>
    <td class="lineNumber">443</td>
    <td class="codeline">/// For vectors, this includes constants with undefined elements.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="codeline">inline cst_pred_ty<is_any_apint> m_AnyIntegralConstant() {</td>
    <td class="lineNumber">444</td>
    <td class="codeline">inline cst_pred_ty<is_any_apint> m_AnyIntegralConstant() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="codeline">  return cst_pred_ty<is_any_apint>();</td>
    <td class="lineNumber">445</td>
    <td class="codeline">  return cst_pred_ty<is_any_apint>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="codeline">}</td>
    <td class="lineNumber">446</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="codeline"></td>
    <td class="lineNumber">447</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="codeline">struct is_shifted_mask {</td>
    <td class="lineNumber">448</td>
    <td class="codeline">struct is_shifted_mask {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="codeline">  bool isValue(const APInt &C) { return C.isShiftedMask(); }</td>
    <td class="lineNumber">449</td>
    <td class="codeline">  bool isValue(const APInt &C) { return C.isShiftedMask(); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="codeline">};</td>
    <td class="lineNumber">450</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="codeline"></td>
    <td class="lineNumber">451</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="codeline">inline cst_pred_ty<is_shifted_mask> m_ShiftedMask() {</td>
    <td class="lineNumber">452</td>
    <td class="codeline">inline cst_pred_ty<is_shifted_mask> m_ShiftedMask() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="codeline">  return cst_pred_ty<is_shifted_mask>();</td>
    <td class="lineNumber">453</td>
    <td class="codeline">  return cst_pred_ty<is_shifted_mask>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="codeline">}</td>
    <td class="lineNumber">454</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="codeline"></td>
    <td class="lineNumber">455</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="codeline">struct is_all_ones {</td>
    <td class="lineNumber">456</td>
    <td class="codeline">struct is_all_ones {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="codeline">  bool isValue(const APInt &C) { return C.isAllOnes(); }</td>
    <td class="lineNumber">457</td>
    <td class="codeline">  bool isValue(const APInt &C) { return C.isAllOnes(); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="codeline">};</td>
    <td class="lineNumber">458</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="codeline">/// Match an integer or vector with all bits set.</td>
    <td class="lineNumber">459</td>
    <td class="codeline">/// Match an integer or vector with all bits set.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="codeline">/// For vectors, this includes constants with undefined elements.</td>
    <td class="lineNumber">460</td>
    <td class="codeline">/// For vectors, this includes constants with undefined elements.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="codeline">inline cst_pred_ty<is_all_ones> m_AllOnes() {</td>
    <td class="lineNumber">461</td>
    <td class="codeline">inline cst_pred_ty<is_all_ones> m_AllOnes() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="codeline">  return cst_pred_ty<is_all_ones>();</td>
    <td class="lineNumber">462</td>
    <td class="codeline">  return cst_pred_ty<is_all_ones>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="codeline">}</td>
    <td class="lineNumber">463</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="codeline"></td>
    <td class="lineNumber">464</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="codeline">struct is_maxsignedvalue {</td>
    <td class="lineNumber">465</td>
    <td class="codeline">struct is_maxsignedvalue {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="codeline">  bool isValue(const APInt &C) { return C.isMaxSignedValue(); }</td>
    <td class="lineNumber">466</td>
    <td class="codeline">  bool isValue(const APInt &C) { return C.isMaxSignedValue(); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="codeline">};</td>
    <td class="lineNumber">467</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="codeline">/// Match an integer or vector with values having all bits except for the high</td>
    <td class="lineNumber">468</td>
    <td class="codeline">/// Match an integer or vector with values having all bits except for the high</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="codeline">/// bit set (0x7f...).</td>
    <td class="lineNumber">469</td>
    <td class="codeline">/// bit set (0x7f...).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="codeline">/// For vectors, this includes constants with undefined elements.</td>
    <td class="lineNumber">470</td>
    <td class="codeline">/// For vectors, this includes constants with undefined elements.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="codeline">inline cst_pred_ty<is_maxsignedvalue> m_MaxSignedValue() {</td>
    <td class="lineNumber">471</td>
    <td class="codeline">inline cst_pred_ty<is_maxsignedvalue> m_MaxSignedValue() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="codeline">  return cst_pred_ty<is_maxsignedvalue>();</td>
    <td class="lineNumber">472</td>
    <td class="codeline">  return cst_pred_ty<is_maxsignedvalue>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="codeline">}</td>
    <td class="lineNumber">473</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="codeline">inline api_pred_ty<is_maxsignedvalue> m_MaxSignedValue(const APInt *&V) {</td>
    <td class="lineNumber">474</td>
    <td class="codeline">inline api_pred_ty<is_maxsignedvalue> m_MaxSignedValue(const APInt *&V) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="codeline">  return V;</td>
    <td class="lineNumber">475</td>
    <td class="codeline">  return V;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="codeline">}</td>
    <td class="lineNumber">476</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="codeline"></td>
    <td class="lineNumber">477</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="codeline">struct is_negative {</td>
    <td class="lineNumber">478</td>
    <td class="codeline">struct is_negative {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="codeline">  bool isValue(const APInt &C) { return C.isNegative(); }</td>
    <td class="lineNumber">479</td>
    <td class="codeline">  bool isValue(const APInt &C) { return C.isNegative(); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="codeline">};</td>
    <td class="lineNumber">480</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="codeline">/// Match an integer or vector of negative values.</td>
    <td class="lineNumber">481</td>
    <td class="codeline">/// Match an integer or vector of negative values.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="codeline">/// For vectors, this includes constants with undefined elements.</td>
    <td class="lineNumber">482</td>
    <td class="codeline">/// For vectors, this includes constants with undefined elements.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="codeline">inline cst_pred_ty<is_negative> m_Negative() {</td>
    <td class="lineNumber">483</td>
    <td class="codeline">inline cst_pred_ty<is_negative> m_Negative() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="codeline">  return cst_pred_ty<is_negative>();</td>
    <td class="lineNumber">484</td>
    <td class="codeline">  return cst_pred_ty<is_negative>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="codeline">}</td>
    <td class="lineNumber">485</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="codeline">inline api_pred_ty<is_negative> m_Negative(const APInt *&V) { return V; }</td>
    <td class="lineNumber">486</td>
    <td class="codeline">inline api_pred_ty<is_negative> m_Negative(const APInt *&V) { return V; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="codeline"></td>
    <td class="lineNumber">487</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="codeline">struct is_nonnegative {</td>
    <td class="lineNumber">488</td>
    <td class="codeline">struct is_nonnegative {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="codeline">  bool isValue(const APInt &C) { return C.isNonNegative(); }</td>
    <td class="lineNumber">489</td>
    <td class="codeline">  bool isValue(const APInt &C) { return C.isNonNegative(); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="codeline">};</td>
    <td class="lineNumber">490</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="codeline">/// Match an integer or vector of non-negative values.</td>
    <td class="lineNumber">491</td>
    <td class="codeline">/// Match an integer or vector of non-negative values.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="codeline">/// For vectors, this includes constants with undefined elements.</td>
    <td class="lineNumber">492</td>
    <td class="codeline">/// For vectors, this includes constants with undefined elements.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="codeline">inline cst_pred_ty<is_nonnegative> m_NonNegative() {</td>
    <td class="lineNumber">493</td>
    <td class="codeline">inline cst_pred_ty<is_nonnegative> m_NonNegative() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="codeline">  return cst_pred_ty<is_nonnegative>();</td>
    <td class="lineNumber">494</td>
    <td class="codeline">  return cst_pred_ty<is_nonnegative>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="codeline">}</td>
    <td class="lineNumber">495</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="codeline">inline api_pred_ty<is_nonnegative> m_NonNegative(const APInt *&V) { return V; }</td>
    <td class="lineNumber">496</td>
    <td class="codeline">inline api_pred_ty<is_nonnegative> m_NonNegative(const APInt *&V) { return V; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="codeline"></td>
    <td class="lineNumber">497</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="codeline">struct is_strictlypositive {</td>
    <td class="lineNumber">498</td>
    <td class="codeline">struct is_strictlypositive {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="codeline">  bool isValue(const APInt &C) { return C.isStrictlyPositive(); }</td>
    <td class="lineNumber">499</td>
    <td class="codeline">  bool isValue(const APInt &C) { return C.isStrictlyPositive(); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="codeline">};</td>
    <td class="lineNumber">500</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="codeline">/// Match an integer or vector of strictly positive values.</td>
    <td class="lineNumber">501</td>
    <td class="codeline">/// Match an integer or vector of strictly positive values.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="codeline">/// For vectors, this includes constants with undefined elements.</td>
    <td class="lineNumber">502</td>
    <td class="codeline">/// For vectors, this includes constants with undefined elements.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="codeline">inline cst_pred_ty<is_strictlypositive> m_StrictlyPositive() {</td>
    <td class="lineNumber">503</td>
    <td class="codeline">inline cst_pred_ty<is_strictlypositive> m_StrictlyPositive() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class="codeline">  return cst_pred_ty<is_strictlypositive>();</td>
    <td class="lineNumber">504</td>
    <td class="codeline">  return cst_pred_ty<is_strictlypositive>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="codeline">}</td>
    <td class="lineNumber">505</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="codeline">inline api_pred_ty<is_strictlypositive> m_StrictlyPositive(const APInt *&V) {</td>
    <td class="lineNumber">506</td>
    <td class="codeline">inline api_pred_ty<is_strictlypositive> m_StrictlyPositive(const APInt *&V) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="codeline">  return V;</td>
    <td class="lineNumber">507</td>
    <td class="codeline">  return V;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="codeline">}</td>
    <td class="lineNumber">508</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="codeline"></td>
    <td class="lineNumber">509</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="codeline">struct is_nonpositive {</td>
    <td class="lineNumber">510</td>
    <td class="codeline">struct is_nonpositive {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="codeline">  bool isValue(const APInt &C) { return C.isNonPositive(); }</td>
    <td class="lineNumber">511</td>
    <td class="codeline">  bool isValue(const APInt &C) { return C.isNonPositive(); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="codeline">};</td>
    <td class="lineNumber">512</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class="codeline">/// Match an integer or vector of non-positive values.</td>
    <td class="lineNumber">513</td>
    <td class="codeline">/// Match an integer or vector of non-positive values.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="codeline">/// For vectors, this includes constants with undefined elements.</td>
    <td class="lineNumber">514</td>
    <td class="codeline">/// For vectors, this includes constants with undefined elements.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="codeline">inline cst_pred_ty<is_nonpositive> m_NonPositive() {</td>
    <td class="lineNumber">515</td>
    <td class="codeline">inline cst_pred_ty<is_nonpositive> m_NonPositive() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="codeline">  return cst_pred_ty<is_nonpositive>();</td>
    <td class="lineNumber">516</td>
    <td class="codeline">  return cst_pred_ty<is_nonpositive>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class="codeline">}</td>
    <td class="lineNumber">517</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="codeline">inline api_pred_ty<is_nonpositive> m_NonPositive(const APInt *&V) { return V; }</td>
    <td class="lineNumber">518</td>
    <td class="codeline">inline api_pred_ty<is_nonpositive> m_NonPositive(const APInt *&V) { return V; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="codeline"></td>
    <td class="lineNumber">519</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class="codeline">struct is_one {</td>
    <td class="lineNumber">520</td>
    <td class="codeline">struct is_one {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="codeline">  bool isValue(const APInt &C) { return C.isOne(); }</td>
    <td class="lineNumber">521</td>
    <td class="codeline">  bool isValue(const APInt &C) { return C.isOne(); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="codeline">};</td>
    <td class="lineNumber">522</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="codeline">/// Match an integer 1 or a vector with all elements equal to 1.</td>
    <td class="lineNumber">523</td>
    <td class="codeline">/// Match an integer 1 or a vector with all elements equal to 1.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="codeline">/// For vectors, this includes constants with undefined elements.</td>
    <td class="lineNumber">524</td>
    <td class="codeline">/// For vectors, this includes constants with undefined elements.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="codeline">inline cst_pred_ty<is_one> m_One() { return cst_pred_ty<is_one>(); }</td>
    <td class="lineNumber">525</td>
    <td class="codeline">inline cst_pred_ty<is_one> m_One() { return cst_pred_ty<is_one>(); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class="codeline"></td>
    <td class="lineNumber">526</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="codeline">struct is_zero_int {</td>
    <td class="lineNumber">527</td>
    <td class="codeline">struct is_zero_int {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="codeline">  bool isValue(const APInt &C) { return C.isZero(); }</td>
    <td class="lineNumber">528</td>
    <td class="codeline">  bool isValue(const APInt &C) { return C.isZero(); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="codeline">};</td>
    <td class="lineNumber">529</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="codeline">/// Match an integer 0 or a vector with all elements equal to 0.</td>
    <td class="lineNumber">530</td>
    <td class="codeline">/// Match an integer 0 or a vector with all elements equal to 0.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="codeline">/// For vectors, this includes constants with undefined elements.</td>
    <td class="lineNumber">531</td>
    <td class="codeline">/// For vectors, this includes constants with undefined elements.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="codeline">inline cst_pred_ty<is_zero_int> m_ZeroInt() {</td>
    <td class="lineNumber">532</td>
    <td class="codeline">inline cst_pred_ty<is_zero_int> m_ZeroInt() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class="codeline">  return cst_pred_ty<is_zero_int>();</td>
    <td class="lineNumber">533</td>
    <td class="codeline">  return cst_pred_ty<is_zero_int>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="codeline">}</td>
    <td class="lineNumber">534</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="codeline"></td>
    <td class="lineNumber">535</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="codeline">struct is_zero {</td>
    <td class="lineNumber">536</td>
    <td class="codeline">struct is_zero {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="codeline">  template <typename ITy> bool match(ITy *V) {</td>
    <td class="lineNumber">537</td>
    <td class="codeline">  template <typename ITy> bool match(ITy *V) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="codeline">    auto *C = dyn_cast<Constant>(V);</td>
    <td class="lineNumber">538</td>
    <td class="codeline">    auto *C = dyn_cast<Constant>(V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="codeline">    // FIXME: this should be able to do something for scalable vectors</td>
    <td class="lineNumber">539</td>
    <td class="codeline">    // FIXME: this should be able to do something for scalable vectors</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class="codeline">    return C && (C->isNullValue() || cst_pred_ty<is_zero_int>().match(C));</td>
    <td class="lineNumber">540</td>
    <td class="codeline">    return C && (C->isNullValue() || cst_pred_ty<is_zero_int>().match(C));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">541</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="codeline">};</td>
    <td class="lineNumber">542</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="codeline">/// Match any null constant or a vector with all elements equal to 0.</td>
    <td class="lineNumber">543</td>
    <td class="codeline">/// Match any null constant or a vector with all elements equal to 0.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="codeline">/// For vectors, this includes constants with undefined elements.</td>
    <td class="lineNumber">544</td>
    <td class="codeline">/// For vectors, this includes constants with undefined elements.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="codeline">inline is_zero m_Zero() { return is_zero(); }</td>
    <td class="lineNumber">545</td>
    <td class="codeline">inline is_zero m_Zero() { return is_zero(); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="codeline"></td>
    <td class="lineNumber">546</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="codeline">struct is_power2 {</td>
    <td class="lineNumber">547</td>
    <td class="codeline">struct is_power2 {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="codeline">  bool isValue(const APInt &C) { return C.isPowerOf2(); }</td>
    <td class="lineNumber">548</td>
    <td class="codeline">  bool isValue(const APInt &C) { return C.isPowerOf2(); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="codeline">};</td>
    <td class="lineNumber">549</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="codeline">/// Match an integer or vector power-of-2.</td>
    <td class="lineNumber">550</td>
    <td class="codeline">/// Match an integer or vector power-of-2.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="codeline">/// For vectors, this includes constants with undefined elements.</td>
    <td class="lineNumber">551</td>
    <td class="codeline">/// For vectors, this includes constants with undefined elements.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="codeline">inline cst_pred_ty<is_power2> m_Power2() { return cst_pred_ty<is_power2>(); }</td>
    <td class="lineNumber">552</td>
    <td class="codeline">inline cst_pred_ty<is_power2> m_Power2() { return cst_pred_ty<is_power2>(); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="codeline">inline api_pred_ty<is_power2> m_Power2(const APInt *&V) { return V; }</td>
    <td class="lineNumber">553</td>
    <td class="codeline">inline api_pred_ty<is_power2> m_Power2(const APInt *&V) { return V; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="codeline"></td>
    <td class="lineNumber">554</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="codeline">struct is_negated_power2 {</td>
    <td class="lineNumber">555</td>
    <td class="codeline">struct is_negated_power2 {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="codeline">  bool isValue(const APInt &C) { return C.isNegatedPowerOf2(); }</td>
    <td class="lineNumber">556</td>
    <td class="codeline">  bool isValue(const APInt &C) { return C.isNegatedPowerOf2(); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="codeline">};</td>
    <td class="lineNumber">557</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="codeline">/// Match a integer or vector negated power-of-2.</td>
    <td class="lineNumber">558</td>
    <td class="codeline">/// Match a integer or vector negated power-of-2.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="codeline">/// For vectors, this includes constants with undefined elements.</td>
    <td class="lineNumber">559</td>
    <td class="codeline">/// For vectors, this includes constants with undefined elements.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="codeline">inline cst_pred_ty<is_negated_power2> m_NegatedPower2() {</td>
    <td class="lineNumber">560</td>
    <td class="codeline">inline cst_pred_ty<is_negated_power2> m_NegatedPower2() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="codeline">  return cst_pred_ty<is_negated_power2>();</td>
    <td class="lineNumber">561</td>
    <td class="codeline">  return cst_pred_ty<is_negated_power2>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="codeline">}</td>
    <td class="lineNumber">562</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="codeline">inline api_pred_ty<is_negated_power2> m_NegatedPower2(const APInt *&V) {</td>
    <td class="lineNumber">563</td>
    <td class="codeline">inline api_pred_ty<is_negated_power2> m_NegatedPower2(const APInt *&V) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="codeline">  return V;</td>
    <td class="lineNumber">564</td>
    <td class="codeline">  return V;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class="codeline">}</td>
    <td class="lineNumber">565</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="codeline"></td>
    <td class="lineNumber">566</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="codeline">struct is_power2_or_zero {</td>
    <td class="lineNumber">567</td>
    <td class="codeline">struct is_power2_or_zero {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="codeline">  bool isValue(const APInt &C) { return !C || C.isPowerOf2(); }</td>
    <td class="lineNumber">568</td>
    <td class="codeline">  bool isValue(const APInt &C) { return !C || C.isPowerOf2(); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="codeline">};</td>
    <td class="lineNumber">569</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="codeline">/// Match an integer or vector of 0 or power-of-2 values.</td>
    <td class="lineNumber">570</td>
    <td class="codeline">/// Match an integer or vector of 0 or power-of-2 values.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="codeline">/// For vectors, this includes constants with undefined elements.</td>
    <td class="lineNumber">571</td>
    <td class="codeline">/// For vectors, this includes constants with undefined elements.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="codeline">inline cst_pred_ty<is_power2_or_zero> m_Power2OrZero() {</td>
    <td class="lineNumber">572</td>
    <td class="codeline">inline cst_pred_ty<is_power2_or_zero> m_Power2OrZero() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="codeline">  return cst_pred_ty<is_power2_or_zero>();</td>
    <td class="lineNumber">573</td>
    <td class="codeline">  return cst_pred_ty<is_power2_or_zero>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="codeline">}</td>
    <td class="lineNumber">574</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="codeline">inline api_pred_ty<is_power2_or_zero> m_Power2OrZero(const APInt *&V) {</td>
    <td class="lineNumber">575</td>
    <td class="codeline">inline api_pred_ty<is_power2_or_zero> m_Power2OrZero(const APInt *&V) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="codeline">  return V;</td>
    <td class="lineNumber">576</td>
    <td class="codeline">  return V;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="codeline">}</td>
    <td class="lineNumber">577</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="codeline"></td>
    <td class="lineNumber">578</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class="codeline">struct is_sign_mask {</td>
    <td class="lineNumber">579</td>
    <td class="codeline">struct is_sign_mask {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="codeline">  bool isValue(const APInt &C) { return C.isSignMask(); }</td>
    <td class="lineNumber">580</td>
    <td class="codeline">  bool isValue(const APInt &C) { return C.isSignMask(); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="codeline">};</td>
    <td class="lineNumber">581</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class="codeline">/// Match an integer or vector with only the sign bit(s) set.</td>
    <td class="lineNumber">582</td>
    <td class="codeline">/// Match an integer or vector with only the sign bit(s) set.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="codeline">/// For vectors, this includes constants with undefined elements.</td>
    <td class="lineNumber">583</td>
    <td class="codeline">/// For vectors, this includes constants with undefined elements.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="codeline">inline cst_pred_ty<is_sign_mask> m_SignMask() {</td>
    <td class="lineNumber">584</td>
    <td class="codeline">inline cst_pred_ty<is_sign_mask> m_SignMask() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="codeline">  return cst_pred_ty<is_sign_mask>();</td>
    <td class="lineNumber">585</td>
    <td class="codeline">  return cst_pred_ty<is_sign_mask>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="codeline">}</td>
    <td class="lineNumber">586</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class="codeline"></td>
    <td class="lineNumber">587</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="codeline">struct is_lowbit_mask {</td>
    <td class="lineNumber">588</td>
    <td class="codeline">struct is_lowbit_mask {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="codeline">  bool isValue(const APInt &C) { return C.isMask(); }</td>
    <td class="lineNumber">589</td>
    <td class="codeline">  bool isValue(const APInt &C) { return C.isMask(); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class="codeline">};</td>
    <td class="lineNumber">590</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="codeline">/// Match an integer or vector with only the low bit(s) set.</td>
    <td class="lineNumber">591</td>
    <td class="codeline">/// Match an integer or vector with only the low bit(s) set.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="codeline">/// For vectors, this includes constants with undefined elements.</td>
    <td class="lineNumber">592</td>
    <td class="codeline">/// For vectors, this includes constants with undefined elements.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="codeline">inline cst_pred_ty<is_lowbit_mask> m_LowBitMask() {</td>
    <td class="lineNumber">593</td>
    <td class="codeline">inline cst_pred_ty<is_lowbit_mask> m_LowBitMask() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="codeline">  return cst_pred_ty<is_lowbit_mask>();</td>
    <td class="lineNumber">594</td>
    <td class="codeline">  return cst_pred_ty<is_lowbit_mask>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="codeline">}</td>
    <td class="lineNumber">595</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="codeline">inline api_pred_ty<is_lowbit_mask> m_LowBitMask(const APInt *&V) { return V; }</td>
    <td class="lineNumber">596</td>
    <td class="codeline">inline api_pred_ty<is_lowbit_mask> m_LowBitMask(const APInt *&V) { return V; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class="codeline"></td>
    <td class="lineNumber">597</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="codeline">struct icmp_pred_with_threshold {</td>
    <td class="lineNumber">598</td>
    <td class="codeline">struct icmp_pred_with_threshold {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="codeline">  ICmpInst::Predicate Pred;</td>
    <td class="lineNumber">599</td>
    <td class="codeline">  ICmpInst::Predicate Pred;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="codeline">  const APInt *Thr;</td>
    <td class="lineNumber">600</td>
    <td class="codeline">  const APInt *Thr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="codeline">  bool isValue(const APInt &C) { return ICmpInst::compare(C, *Thr, Pred); }</td>
    <td class="lineNumber">601</td>
    <td class="codeline">  bool isValue(const APInt &C) { return ICmpInst::compare(C, *Thr, Pred); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="codeline">};</td>
    <td class="lineNumber">602</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="codeline">/// Match an integer or vector with every element comparing 'pred' (eg/ne/...)</td>
    <td class="lineNumber">603</td>
    <td class="codeline">/// Match an integer or vector with every element comparing 'pred' (eg/ne/...)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="codeline">/// to Threshold. For vectors, this includes constants with undefined elements.</td>
    <td class="lineNumber">604</td>
    <td class="codeline">/// to Threshold. For vectors, this includes constants with undefined elements.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="codeline">inline cst_pred_ty<icmp_pred_with_threshold></td>
    <td class="lineNumber">605</td>
    <td class="codeline">inline cst_pred_ty<icmp_pred_with_threshold></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="codeline">m_SpecificInt_ICMP(ICmpInst::Predicate Predicate, const APInt &Threshold) {</td>
    <td class="lineNumber">606</td>
    <td class="codeline">m_SpecificInt_ICMP(ICmpInst::Predicate Predicate, const APInt &Threshold) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="codeline">  cst_pred_ty<icmp_pred_with_threshold> P;</td>
    <td class="lineNumber">607</td>
    <td class="codeline">  cst_pred_ty<icmp_pred_with_threshold> P;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="codeline">  P.Pred = Predicate;</td>
    <td class="lineNumber">608</td>
    <td class="codeline">  P.Pred = Predicate;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="codeline">  P.Thr = &Threshold;</td>
    <td class="lineNumber">609</td>
    <td class="codeline">  P.Thr = &Threshold;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="codeline">  return P;</td>
    <td class="lineNumber">610</td>
    <td class="codeline">  return P;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="codeline">}</td>
    <td class="lineNumber">611</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="codeline"></td>
    <td class="lineNumber">612</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class="codeline">struct is_nan {</td>
    <td class="lineNumber">613</td>
    <td class="codeline">struct is_nan {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class="codeline">  bool isValue(const APFloat &C) { return C.isNaN(); }</td>
    <td class="lineNumber">614</td>
    <td class="codeline">  bool isValue(const APFloat &C) { return C.isNaN(); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="codeline">};</td>
    <td class="lineNumber">615</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="codeline">/// Match an arbitrary NaN constant. This includes quiet and signalling nans.</td>
    <td class="lineNumber">616</td>
    <td class="codeline">/// Match an arbitrary NaN constant. This includes quiet and signalling nans.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="codeline">/// For vectors, this includes constants with undefined elements.</td>
    <td class="lineNumber">617</td>
    <td class="codeline">/// For vectors, this includes constants with undefined elements.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class="codeline">inline cstfp_pred_ty<is_nan> m_NaN() { return cstfp_pred_ty<is_nan>(); }</td>
    <td class="lineNumber">618</td>
    <td class="codeline">inline cstfp_pred_ty<is_nan> m_NaN() { return cstfp_pred_ty<is_nan>(); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="codeline"></td>
    <td class="lineNumber">619</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="codeline">struct is_nonnan {</td>
    <td class="lineNumber">620</td>
    <td class="codeline">struct is_nonnan {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class="codeline">  bool isValue(const APFloat &C) { return !C.isNaN(); }</td>
    <td class="lineNumber">621</td>
    <td class="codeline">  bool isValue(const APFloat &C) { return !C.isNaN(); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="codeline">};</td>
    <td class="lineNumber">622</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="codeline">/// Match a non-NaN FP constant.</td>
    <td class="lineNumber">623</td>
    <td class="codeline">/// Match a non-NaN FP constant.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="codeline">/// For vectors, this includes constants with undefined elements.</td>
    <td class="lineNumber">624</td>
    <td class="codeline">/// For vectors, this includes constants with undefined elements.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="codeline">inline cstfp_pred_ty<is_nonnan> m_NonNaN() {</td>
    <td class="lineNumber">625</td>
    <td class="codeline">inline cstfp_pred_ty<is_nonnan> m_NonNaN() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="codeline">  return cstfp_pred_ty<is_nonnan>();</td>
    <td class="lineNumber">626</td>
    <td class="codeline">  return cstfp_pred_ty<is_nonnan>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="codeline">}</td>
    <td class="lineNumber">627</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class="codeline"></td>
    <td class="lineNumber">628</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="codeline">struct is_inf {</td>
    <td class="lineNumber">629</td>
    <td class="codeline">struct is_inf {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class="codeline">  bool isValue(const APFloat &C) { return C.isInfinity(); }</td>
    <td class="lineNumber">630</td>
    <td class="codeline">  bool isValue(const APFloat &C) { return C.isInfinity(); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="codeline">};</td>
    <td class="lineNumber">631</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="codeline">/// Match a positive or negative infinity FP constant.</td>
    <td class="lineNumber">632</td>
    <td class="codeline">/// Match a positive or negative infinity FP constant.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="codeline">/// For vectors, this includes constants with undefined elements.</td>
    <td class="lineNumber">633</td>
    <td class="codeline">/// For vectors, this includes constants with undefined elements.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="codeline">inline cstfp_pred_ty<is_inf> m_Inf() { return cstfp_pred_ty<is_inf>(); }</td>
    <td class="lineNumber">634</td>
    <td class="codeline">inline cstfp_pred_ty<is_inf> m_Inf() { return cstfp_pred_ty<is_inf>(); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="codeline"></td>
    <td class="lineNumber">635</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="codeline">struct is_noninf {</td>
    <td class="lineNumber">636</td>
    <td class="codeline">struct is_noninf {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="codeline">  bool isValue(const APFloat &C) { return !C.isInfinity(); }</td>
    <td class="lineNumber">637</td>
    <td class="codeline">  bool isValue(const APFloat &C) { return !C.isInfinity(); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="codeline">};</td>
    <td class="lineNumber">638</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="codeline">/// Match a non-infinity FP constant, i.e. finite or NaN.</td>
    <td class="lineNumber">639</td>
    <td class="codeline">/// Match a non-infinity FP constant, i.e. finite or NaN.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="codeline">/// For vectors, this includes constants with undefined elements.</td>
    <td class="lineNumber">640</td>
    <td class="codeline">/// For vectors, this includes constants with undefined elements.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="codeline">inline cstfp_pred_ty<is_noninf> m_NonInf() {</td>
    <td class="lineNumber">641</td>
    <td class="codeline">inline cstfp_pred_ty<is_noninf> m_NonInf() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="codeline">  return cstfp_pred_ty<is_noninf>();</td>
    <td class="lineNumber">642</td>
    <td class="codeline">  return cstfp_pred_ty<is_noninf>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="codeline">}</td>
    <td class="lineNumber">643</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class="codeline"></td>
    <td class="lineNumber">644</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="codeline">struct is_finite {</td>
    <td class="lineNumber">645</td>
    <td class="codeline">struct is_finite {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="codeline">  bool isValue(const APFloat &C) { return C.isFinite(); }</td>
    <td class="lineNumber">646</td>
    <td class="codeline">  bool isValue(const APFloat &C) { return C.isFinite(); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="codeline">};</td>
    <td class="lineNumber">647</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="codeline">/// Match a finite FP constant, i.e. not infinity or NaN.</td>
    <td class="lineNumber">648</td>
    <td class="codeline">/// Match a finite FP constant, i.e. not infinity or NaN.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="codeline">/// For vectors, this includes constants with undefined elements.</td>
    <td class="lineNumber">649</td>
    <td class="codeline">/// For vectors, this includes constants with undefined elements.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="codeline">inline cstfp_pred_ty<is_finite> m_Finite() {</td>
    <td class="lineNumber">650</td>
    <td class="codeline">inline cstfp_pred_ty<is_finite> m_Finite() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="codeline">  return cstfp_pred_ty<is_finite>();</td>
    <td class="lineNumber">651</td>
    <td class="codeline">  return cstfp_pred_ty<is_finite>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="codeline">}</td>
    <td class="lineNumber">652</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="codeline">inline apf_pred_ty<is_finite> m_Finite(const APFloat *&V) { return V; }</td>
    <td class="lineNumber">653</td>
    <td class="codeline">inline apf_pred_ty<is_finite> m_Finite(const APFloat *&V) { return V; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="codeline"></td>
    <td class="lineNumber">654</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="codeline">struct is_finitenonzero {</td>
    <td class="lineNumber">655</td>
    <td class="codeline">struct is_finitenonzero {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="codeline">  bool isValue(const APFloat &C) { return C.isFiniteNonZero(); }</td>
    <td class="lineNumber">656</td>
    <td class="codeline">  bool isValue(const APFloat &C) { return C.isFiniteNonZero(); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class="codeline">};</td>
    <td class="lineNumber">657</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="codeline">/// Match a finite non-zero FP constant.</td>
    <td class="lineNumber">658</td>
    <td class="codeline">/// Match a finite non-zero FP constant.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="codeline">/// For vectors, this includes constants with undefined elements.</td>
    <td class="lineNumber">659</td>
    <td class="codeline">/// For vectors, this includes constants with undefined elements.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="codeline">inline cstfp_pred_ty<is_finitenonzero> m_FiniteNonZero() {</td>
    <td class="lineNumber">660</td>
    <td class="codeline">inline cstfp_pred_ty<is_finitenonzero> m_FiniteNonZero() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="codeline">  return cstfp_pred_ty<is_finitenonzero>();</td>
    <td class="lineNumber">661</td>
    <td class="codeline">  return cstfp_pred_ty<is_finitenonzero>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="codeline">}</td>
    <td class="lineNumber">662</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="codeline">inline apf_pred_ty<is_finitenonzero> m_FiniteNonZero(const APFloat *&V) {</td>
    <td class="lineNumber">663</td>
    <td class="codeline">inline apf_pred_ty<is_finitenonzero> m_FiniteNonZero(const APFloat *&V) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="codeline">  return V;</td>
    <td class="lineNumber">664</td>
    <td class="codeline">  return V;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="codeline">}</td>
    <td class="lineNumber">665</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="codeline"></td>
    <td class="lineNumber">666</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="codeline">struct is_any_zero_fp {</td>
    <td class="lineNumber">667</td>
    <td class="codeline">struct is_any_zero_fp {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="codeline">  bool isValue(const APFloat &C) { return C.isZero(); }</td>
    <td class="lineNumber">668</td>
    <td class="codeline">  bool isValue(const APFloat &C) { return C.isZero(); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="codeline">};</td>
    <td class="lineNumber">669</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="codeline">/// Match a floating-point negative zero or positive zero.</td>
    <td class="lineNumber">670</td>
    <td class="codeline">/// Match a floating-point negative zero or positive zero.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="codeline">/// For vectors, this includes constants with undefined elements.</td>
    <td class="lineNumber">671</td>
    <td class="codeline">/// For vectors, this includes constants with undefined elements.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class="codeline">inline cstfp_pred_ty<is_any_zero_fp> m_AnyZeroFP() {</td>
    <td class="lineNumber">672</td>
    <td class="codeline">inline cstfp_pred_ty<is_any_zero_fp> m_AnyZeroFP() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="codeline">  return cstfp_pred_ty<is_any_zero_fp>();</td>
    <td class="lineNumber">673</td>
    <td class="codeline">  return cstfp_pred_ty<is_any_zero_fp>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="codeline">}</td>
    <td class="lineNumber">674</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class="codeline"></td>
    <td class="lineNumber">675</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class="codeline">struct is_pos_zero_fp {</td>
    <td class="lineNumber">676</td>
    <td class="codeline">struct is_pos_zero_fp {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="codeline">  bool isValue(const APFloat &C) { return C.isPosZero(); }</td>
    <td class="lineNumber">677</td>
    <td class="codeline">  bool isValue(const APFloat &C) { return C.isPosZero(); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="codeline">};</td>
    <td class="lineNumber">678</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="codeline">/// Match a floating-point positive zero.</td>
    <td class="lineNumber">679</td>
    <td class="codeline">/// Match a floating-point positive zero.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="codeline">/// For vectors, this includes constants with undefined elements.</td>
    <td class="lineNumber">680</td>
    <td class="codeline">/// For vectors, this includes constants with undefined elements.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="codeline">inline cstfp_pred_ty<is_pos_zero_fp> m_PosZeroFP() {</td>
    <td class="lineNumber">681</td>
    <td class="codeline">inline cstfp_pred_ty<is_pos_zero_fp> m_PosZeroFP() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="codeline">  return cstfp_pred_ty<is_pos_zero_fp>();</td>
    <td class="lineNumber">682</td>
    <td class="codeline">  return cstfp_pred_ty<is_pos_zero_fp>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class="codeline">}</td>
    <td class="lineNumber">683</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="codeline"></td>
    <td class="lineNumber">684</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class="codeline">struct is_neg_zero_fp {</td>
    <td class="lineNumber">685</td>
    <td class="codeline">struct is_neg_zero_fp {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="codeline">  bool isValue(const APFloat &C) { return C.isNegZero(); }</td>
    <td class="lineNumber">686</td>
    <td class="codeline">  bool isValue(const APFloat &C) { return C.isNegZero(); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="codeline">};</td>
    <td class="lineNumber">687</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class="codeline">/// Match a floating-point negative zero.</td>
    <td class="lineNumber">688</td>
    <td class="codeline">/// Match a floating-point negative zero.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class="codeline">/// For vectors, this includes constants with undefined elements.</td>
    <td class="lineNumber">689</td>
    <td class="codeline">/// For vectors, this includes constants with undefined elements.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class="codeline">inline cstfp_pred_ty<is_neg_zero_fp> m_NegZeroFP() {</td>
    <td class="lineNumber">690</td>
    <td class="codeline">inline cstfp_pred_ty<is_neg_zero_fp> m_NegZeroFP() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class="codeline">  return cstfp_pred_ty<is_neg_zero_fp>();</td>
    <td class="lineNumber">691</td>
    <td class="codeline">  return cstfp_pred_ty<is_neg_zero_fp>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="codeline">}</td>
    <td class="lineNumber">692</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class="codeline"></td>
    <td class="lineNumber">693</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class="codeline">struct is_non_zero_fp {</td>
    <td class="lineNumber">694</td>
    <td class="codeline">struct is_non_zero_fp {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="codeline">  bool isValue(const APFloat &C) { return C.isNonZero(); }</td>
    <td class="lineNumber">695</td>
    <td class="codeline">  bool isValue(const APFloat &C) { return C.isNonZero(); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="codeline">};</td>
    <td class="lineNumber">696</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class="codeline">/// Match a floating-point non-zero.</td>
    <td class="lineNumber">697</td>
    <td class="codeline">/// Match a floating-point non-zero.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class="codeline">/// For vectors, this includes constants with undefined elements.</td>
    <td class="lineNumber">698</td>
    <td class="codeline">/// For vectors, this includes constants with undefined elements.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class="codeline">inline cstfp_pred_ty<is_non_zero_fp> m_NonZeroFP() {</td>
    <td class="lineNumber">699</td>
    <td class="codeline">inline cstfp_pred_ty<is_non_zero_fp> m_NonZeroFP() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="codeline">  return cstfp_pred_ty<is_non_zero_fp>();</td>
    <td class="lineNumber">700</td>
    <td class="codeline">  return cstfp_pred_ty<is_non_zero_fp>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="codeline">}</td>
    <td class="lineNumber">701</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class="codeline"></td>
    <td class="lineNumber">702</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="codeline">///////////////////////////////////////////////////////////////////////////////</td>
    <td class="lineNumber">703</td>
    <td class="codeline">///////////////////////////////////////////////////////////////////////////////</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class="codeline"></td>
    <td class="lineNumber">704</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="codeline">template <typename Class> struct bind_ty {</td>
    <td class="lineNumber">705</td>
    <td class="codeline">template <typename Class> struct bind_ty {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class="codeline">  Class *&VR;</td>
    <td class="lineNumber">706</td>
    <td class="codeline">  Class *&VR;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class="codeline"></td>
    <td class="lineNumber">707</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class="codeline">  bind_ty(Class *&V) : VR(V) {}</td>
    <td class="lineNumber">708</td>
    <td class="codeline">  bind_ty(Class *&V) : VR(V) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class="codeline"></td>
    <td class="lineNumber">709</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="codeline">  template <typename ITy> bool match(ITy *V) {</td>
    <td class="lineNumber">710</td>
    <td class="codeline">  template <typename ITy> bool match(ITy *V) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class="codeline">    if (auto *CV = dyn_cast<Class>(V)) {</td>
    <td class="lineNumber">711</td>
    <td class="codeline">    if (auto *CV = dyn_cast<Class>(V)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class="codeline">      VR = CV;</td>
    <td class="lineNumber">712</td>
    <td class="codeline">      VR = CV;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="codeline">      return true;</td>
    <td class="lineNumber">713</td>
    <td class="codeline">      return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">714</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">715</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">716</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class="codeline">};</td>
    <td class="lineNumber">717</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class="codeline"></td>
    <td class="lineNumber">718</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class="codeline">/// Match a value, capturing it if we match.</td>
    <td class="lineNumber">719</td>
    <td class="codeline">/// Match a value, capturing it if we match.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class="codeline">inline bind_ty<Value> m_Value(Value *&V) { return V; }</td>
    <td class="lineNumber">720</td>
    <td class="codeline">inline bind_ty<Value> m_Value(Value *&V) { return V; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="codeline">inline bind_ty<const Value> m_Value(const Value *&V) { return V; }</td>
    <td class="lineNumber">721</td>
    <td class="codeline">inline bind_ty<const Value> m_Value(const Value *&V) { return V; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class="codeline"></td>
    <td class="lineNumber">722</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="codeline">/// Match an instruction, capturing it if we match.</td>
    <td class="lineNumber">723</td>
    <td class="codeline">/// Match an instruction, capturing it if we match.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class="codeline">inline bind_ty<Instruction> m_Instruction(Instruction *&I) { return I; }</td>
    <td class="lineNumber">724</td>
    <td class="codeline">inline bind_ty<Instruction> m_Instruction(Instruction *&I) { return I; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="codeline">/// Match a unary operator, capturing it if we match.</td>
    <td class="lineNumber">725</td>
    <td class="codeline">/// Match a unary operator, capturing it if we match.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class="codeline">inline bind_ty<UnaryOperator> m_UnOp(UnaryOperator *&I) { return I; }</td>
    <td class="lineNumber">726</td>
    <td class="codeline">inline bind_ty<UnaryOperator> m_UnOp(UnaryOperator *&I) { return I; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class="codeline">/// Match a binary operator, capturing it if we match.</td>
    <td class="lineNumber">727</td>
    <td class="codeline">/// Match a binary operator, capturing it if we match.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class="codeline">inline bind_ty<BinaryOperator> m_BinOp(BinaryOperator *&I) { return I; }</td>
    <td class="lineNumber">728</td>
    <td class="codeline">inline bind_ty<BinaryOperator> m_BinOp(BinaryOperator *&I) { return I; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="codeline">/// Match a with overflow intrinsic, capturing it if we match.</td>
    <td class="lineNumber">729</td>
    <td class="codeline">/// Match a with overflow intrinsic, capturing it if we match.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class="codeline">inline bind_ty<WithOverflowInst> m_WithOverflowInst(WithOverflowInst *&I) {</td>
    <td class="lineNumber">730</td>
    <td class="codeline">inline bind_ty<WithOverflowInst> m_WithOverflowInst(WithOverflowInst *&I) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class="codeline">  return I;</td>
    <td class="lineNumber">731</td>
    <td class="codeline">  return I;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class="codeline">}</td>
    <td class="lineNumber">732</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="codeline">inline bind_ty<const WithOverflowInst></td>
    <td class="lineNumber">733</td>
    <td class="codeline">inline bind_ty<const WithOverflowInst></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="codeline">m_WithOverflowInst(const WithOverflowInst *&I) {</td>
    <td class="lineNumber">734</td>
    <td class="codeline">m_WithOverflowInst(const WithOverflowInst *&I) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class="codeline">  return I;</td>
    <td class="lineNumber">735</td>
    <td class="codeline">  return I;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class="codeline">}</td>
    <td class="lineNumber">736</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class="codeline"></td>
    <td class="lineNumber">737</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class="codeline">/// Match a Constant, capturing the value if we match.</td>
    <td class="lineNumber">738</td>
    <td class="codeline">/// Match a Constant, capturing the value if we match.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class="codeline">inline bind_ty<Constant> m_Constant(Constant *&C) { return C; }</td>
    <td class="lineNumber">739</td>
    <td class="codeline">inline bind_ty<Constant> m_Constant(Constant *&C) { return C; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="codeline"></td>
    <td class="lineNumber">740</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class="codeline">/// Match a ConstantInt, capturing the value if we match.</td>
    <td class="lineNumber">741</td>
    <td class="codeline">/// Match a ConstantInt, capturing the value if we match.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class="codeline">inline bind_ty<ConstantInt> m_ConstantInt(ConstantInt *&CI) { return CI; }</td>
    <td class="lineNumber">742</td>
    <td class="codeline">inline bind_ty<ConstantInt> m_ConstantInt(ConstantInt *&CI) { return CI; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class="codeline"></td>
    <td class="lineNumber">743</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="codeline">/// Match a ConstantFP, capturing the value if we match.</td>
    <td class="lineNumber">744</td>
    <td class="codeline">/// Match a ConstantFP, capturing the value if we match.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="codeline">inline bind_ty<ConstantFP> m_ConstantFP(ConstantFP *&C) { return C; }</td>
    <td class="lineNumber">745</td>
    <td class="codeline">inline bind_ty<ConstantFP> m_ConstantFP(ConstantFP *&C) { return C; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class="codeline"></td>
    <td class="lineNumber">746</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class="codeline">/// Match a ConstantExpr, capturing the value if we match.</td>
    <td class="lineNumber">747</td>
    <td class="codeline">/// Match a ConstantExpr, capturing the value if we match.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="codeline">inline bind_ty<ConstantExpr> m_ConstantExpr(ConstantExpr *&C) { return C; }</td>
    <td class="lineNumber">748</td>
    <td class="codeline">inline bind_ty<ConstantExpr> m_ConstantExpr(ConstantExpr *&C) { return C; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="codeline"></td>
    <td class="lineNumber">749</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="codeline">/// Match a basic block value, capturing it if we match.</td>
    <td class="lineNumber">750</td>
    <td class="codeline">/// Match a basic block value, capturing it if we match.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class="codeline">inline bind_ty<BasicBlock> m_BasicBlock(BasicBlock *&V) { return V; }</td>
    <td class="lineNumber">751</td>
    <td class="codeline">inline bind_ty<BasicBlock> m_BasicBlock(BasicBlock *&V) { return V; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class="codeline">inline bind_ty<const BasicBlock> m_BasicBlock(const BasicBlock *&V) {</td>
    <td class="lineNumber">752</td>
    <td class="codeline">inline bind_ty<const BasicBlock> m_BasicBlock(const BasicBlock *&V) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class="codeline">  return V;</td>
    <td class="lineNumber">753</td>
    <td class="codeline">  return V;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class="codeline">}</td>
    <td class="lineNumber">754</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class="codeline"></td>
    <td class="lineNumber">755</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="codeline">/// Match an arbitrary immediate Constant and ignore it.</td>
    <td class="lineNumber">756</td>
    <td class="codeline">/// Match an arbitrary immediate Constant and ignore it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="codeline">inline match_combine_and<class_match<Constant>,</td>
    <td class="lineNumber">757</td>
    <td class="codeline">inline match_combine_and<class_match<Constant>,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="codeline">                         match_unless<constantexpr_match>></td>
    <td class="lineNumber">758</td>
    <td class="codeline">                         match_unless<constantexpr_match>></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="codeline">m_ImmConstant() {</td>
    <td class="lineNumber">759</td>
    <td class="codeline">m_ImmConstant() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class="codeline">  return m_CombineAnd(m_Constant(), m_Unless(m_ConstantExpr()));</td>
    <td class="lineNumber">760</td>
    <td class="codeline">  return m_CombineAnd(m_Constant(), m_Unless(m_ConstantExpr()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class="codeline">}</td>
    <td class="lineNumber">761</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class="codeline"></td>
    <td class="lineNumber">762</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="codeline">/// Match an immediate Constant, capturing the value if we match.</td>
    <td class="lineNumber">763</td>
    <td class="codeline">/// Match an immediate Constant, capturing the value if we match.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class="codeline">inline match_combine_and<bind_ty<Constant>,</td>
    <td class="lineNumber">764</td>
    <td class="codeline">inline match_combine_and<bind_ty<Constant>,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class="codeline">                         match_unless<constantexpr_match>></td>
    <td class="lineNumber">765</td>
    <td class="codeline">                         match_unless<constantexpr_match>></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class="codeline">m_ImmConstant(Constant *&C) {</td>
    <td class="lineNumber">766</td>
    <td class="codeline">m_ImmConstant(Constant *&C) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="codeline">  return m_CombineAnd(m_Constant(C), m_Unless(m_ConstantExpr()));</td>
    <td class="lineNumber">767</td>
    <td class="codeline">  return m_CombineAnd(m_Constant(C), m_Unless(m_ConstantExpr()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class="codeline">}</td>
    <td class="lineNumber">768</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="codeline"></td>
    <td class="lineNumber">769</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="codeline">/// Match a specified Value*.</td>
    <td class="lineNumber">770</td>
    <td class="codeline">/// Match a specified Value*.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class="codeline">struct specificval_ty {</td>
    <td class="lineNumber">771</td>
    <td class="codeline">struct specificval_ty {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="codeline">  const Value *Val;</td>
    <td class="lineNumber">772</td>
    <td class="codeline">  const Value *Val;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class="codeline"></td>
    <td class="lineNumber">773</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="codeline">  specificval_ty(const Value *V) : Val(V) {}</td>
    <td class="lineNumber">774</td>
    <td class="codeline">  specificval_ty(const Value *V) : Val(V) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class="codeline"></td>
    <td class="lineNumber">775</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class="codeline">  template <typename ITy> bool match(ITy *V) { return V == Val; }</td>
    <td class="lineNumber">776</td>
    <td class="codeline">  template <typename ITy> bool match(ITy *V) { return V == Val; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="codeline">};</td>
    <td class="lineNumber">777</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class="codeline"></td>
    <td class="lineNumber">778</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="codeline">/// Match if we have a specific specified value.</td>
    <td class="lineNumber">779</td>
    <td class="codeline">/// Match if we have a specific specified value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class="codeline">inline specificval_ty m_Specific(const Value *V) { return V; }</td>
    <td class="lineNumber">780</td>
    <td class="codeline">inline specificval_ty m_Specific(const Value *V) { return V; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class="codeline"></td>
    <td class="lineNumber">781</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="codeline">/// Stores a reference to the Value *, not the Value * itself,</td>
    <td class="lineNumber">782</td>
    <td class="codeline">/// Stores a reference to the Value *, not the Value * itself,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="codeline">/// thus can be used in commutative matchers.</td>
    <td class="lineNumber">783</td>
    <td class="codeline">/// thus can be used in commutative matchers.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class="codeline">template <typename Class> struct deferredval_ty {</td>
    <td class="lineNumber">784</td>
    <td class="codeline">template <typename Class> struct deferredval_ty {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class="codeline">  Class *const &Val;</td>
    <td class="lineNumber">785</td>
    <td class="codeline">  Class *const &Val;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class="codeline"></td>
    <td class="lineNumber">786</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class="codeline">  deferredval_ty(Class *const &V) : Val(V) {}</td>
    <td class="lineNumber">787</td>
    <td class="codeline">  deferredval_ty(Class *const &V) : Val(V) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="codeline"></td>
    <td class="lineNumber">788</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class="codeline">  template <typename ITy> bool match(ITy *const V) { return V == Val; }</td>
    <td class="lineNumber">789</td>
    <td class="codeline">  template <typename ITy> bool match(ITy *const V) { return V == Val; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class="codeline">};</td>
    <td class="lineNumber">790</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class="codeline"></td>
    <td class="lineNumber">791</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class="codeline">/// Like m_Specific(), but works if the specific value to match is determined</td>
    <td class="lineNumber">792</td>
    <td class="codeline">/// Like m_Specific(), but works if the specific value to match is determined</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="codeline">/// as part of the same match() expression. For example:</td>
    <td class="lineNumber">793</td>
    <td class="codeline">/// as part of the same match() expression. For example:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class="codeline">/// m_Add(m_Value(X), m_Specific(X)) is incorrect, because m_Specific() will</td>
    <td class="lineNumber">794</td>
    <td class="codeline">/// m_Add(m_Value(X), m_Specific(X)) is incorrect, because m_Specific() will</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="codeline">/// bind X before the pattern match starts.</td>
    <td class="lineNumber">795</td>
    <td class="codeline">/// bind X before the pattern match starts.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class="codeline">/// m_Add(m_Value(X), m_Deferred(X)) is correct, and will check against</td>
    <td class="lineNumber">796</td>
    <td class="codeline">/// m_Add(m_Value(X), m_Deferred(X)) is correct, and will check against</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class="codeline">/// whichever value m_Value(X) populated.</td>
    <td class="lineNumber">797</td>
    <td class="codeline">/// whichever value m_Value(X) populated.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class="codeline">inline deferredval_ty<Value> m_Deferred(Value *const &V) { return V; }</td>
    <td class="lineNumber">798</td>
    <td class="codeline">inline deferredval_ty<Value> m_Deferred(Value *const &V) { return V; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class="codeline">inline deferredval_ty<const Value> m_Deferred(const Value *const &V) {</td>
    <td class="lineNumber">799</td>
    <td class="codeline">inline deferredval_ty<const Value> m_Deferred(const Value *const &V) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class="codeline">  return V;</td>
    <td class="lineNumber">800</td>
    <td class="codeline">  return V;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class="codeline">}</td>
    <td class="lineNumber">801</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class="codeline"></td>
    <td class="lineNumber">802</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class="codeline">/// Match a specified floating point value or vector of all elements of</td>
    <td class="lineNumber">803</td>
    <td class="codeline">/// Match a specified floating point value or vector of all elements of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class="codeline">/// that value.</td>
    <td class="lineNumber">804</td>
    <td class="codeline">/// that value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class="codeline">struct specific_fpval {</td>
    <td class="lineNumber">805</td>
    <td class="codeline">struct specific_fpval {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class="codeline">  double Val;</td>
    <td class="lineNumber">806</td>
    <td class="codeline">  double Val;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class="codeline"></td>
    <td class="lineNumber">807</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class="codeline">  specific_fpval(double V) : Val(V) {}</td>
    <td class="lineNumber">808</td>
    <td class="codeline">  specific_fpval(double V) : Val(V) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class="codeline"></td>
    <td class="lineNumber">809</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class="codeline">  template <typename ITy> bool match(ITy *V) {</td>
    <td class="lineNumber">810</td>
    <td class="codeline">  template <typename ITy> bool match(ITy *V) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class="codeline">    if (const auto *CFP = dyn_cast<ConstantFP>(V))</td>
    <td class="lineNumber">811</td>
    <td class="codeline">    if (const auto *CFP = dyn_cast<ConstantFP>(V))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class="codeline">      return CFP->isExactlyValue(Val);</td>
    <td class="lineNumber">812</td>
    <td class="codeline">      return CFP->isExactlyValue(Val);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class="codeline">    if (V->getType()->isVectorTy())</td>
    <td class="lineNumber">813</td>
    <td class="codeline">    if (V->getType()->isVectorTy())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class="codeline">      if (const auto *C = dyn_cast<Constant>(V))</td>
    <td class="lineNumber">814</td>
    <td class="codeline">      if (const auto *C = dyn_cast<Constant>(V))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class="codeline">        if (auto *CFP = dyn_cast_or_null<ConstantFP>(C->getSplatValue()))</td>
    <td class="lineNumber">815</td>
    <td class="codeline">        if (auto *CFP = dyn_cast_or_null<ConstantFP>(C->getSplatValue()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class="codeline">          return CFP->isExactlyValue(Val);</td>
    <td class="lineNumber">816</td>
    <td class="codeline">          return CFP->isExactlyValue(Val);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">817</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">818</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class="codeline">};</td>
    <td class="lineNumber">819</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class="codeline"></td>
    <td class="lineNumber">820</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class="codeline">/// Match a specific floating point value or vector with all elements</td>
    <td class="lineNumber">821</td>
    <td class="codeline">/// Match a specific floating point value or vector with all elements</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class="codeline">/// equal to the value.</td>
    <td class="lineNumber">822</td>
    <td class="codeline">/// equal to the value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class="codeline">inline specific_fpval m_SpecificFP(double V) { return specific_fpval(V); }</td>
    <td class="lineNumber">823</td>
    <td class="codeline">inline specific_fpval m_SpecificFP(double V) { return specific_fpval(V); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class="codeline"></td>
    <td class="lineNumber">824</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class="codeline">/// Match a float 1.0 or vector with all elements equal to 1.0.</td>
    <td class="lineNumber">825</td>
    <td class="codeline">/// Match a float 1.0 or vector with all elements equal to 1.0.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class="codeline">inline specific_fpval m_FPOne() { return m_SpecificFP(1.0); }</td>
    <td class="lineNumber">826</td>
    <td class="codeline">inline specific_fpval m_FPOne() { return m_SpecificFP(1.0); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class="codeline"></td>
    <td class="lineNumber">827</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class="codeline">struct bind_const_intval_ty {</td>
    <td class="lineNumber">828</td>
    <td class="codeline">struct bind_const_intval_ty {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class="codeline">  uint64_t &VR;</td>
    <td class="lineNumber">829</td>
    <td class="codeline">  uint64_t &VR;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class="codeline"></td>
    <td class="lineNumber">830</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class="codeline">  bind_const_intval_ty(uint64_t &V) : VR(V) {}</td>
    <td class="lineNumber">831</td>
    <td class="codeline">  bind_const_intval_ty(uint64_t &V) : VR(V) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class="codeline"></td>
    <td class="lineNumber">832</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class="codeline">  template <typename ITy> bool match(ITy *V) {</td>
    <td class="lineNumber">833</td>
    <td class="codeline">  template <typename ITy> bool match(ITy *V) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class="codeline">    if (const auto *CV = dyn_cast<ConstantInt>(V))</td>
    <td class="lineNumber">834</td>
    <td class="codeline">    if (const auto *CV = dyn_cast<ConstantInt>(V))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class="codeline">      if (CV->getValue().ule(UINT64_MAX)) {</td>
    <td class="lineNumber">835</td>
    <td class="codeline">      if (CV->getValue().ule(UINT64_MAX)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class="codeline">        VR = CV->getZExtValue();</td>
    <td class="lineNumber">836</td>
    <td class="codeline">        VR = CV->getZExtValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class="codeline">        return true;</td>
    <td class="lineNumber">837</td>
    <td class="codeline">        return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">838</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">839</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">840</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class="codeline">};</td>
    <td class="lineNumber">841</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class="codeline"></td>
    <td class="lineNumber">842</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class="codeline">/// Match a specified integer value or vector of all elements of that</td>
    <td class="lineNumber">843</td>
    <td class="codeline">/// Match a specified integer value or vector of all elements of that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class="codeline">/// value.</td>
    <td class="lineNumber">844</td>
    <td class="codeline">/// value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class="codeline">template <bool AllowUndefs> struct specific_intval {</td>
    <td class="lineNumber">845</td>
    <td class="codeline">template <bool AllowUndefs> struct specific_intval {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class="codeline">  APInt Val;</td>
    <td class="lineNumber">846</td>
    <td class="codeline">  APInt Val;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class="codeline"></td>
    <td class="lineNumber">847</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class="codeline">  specific_intval(APInt V) : Val(std::move(V)) {}</td>
    <td class="lineNumber">848</td>
    <td class="codeline">  specific_intval(APInt V) : Val(std::move(V)) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class="codeline"></td>
    <td class="lineNumber">849</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class="codeline">  template <typename ITy> bool match(ITy *V) {</td>
    <td class="lineNumber">850</td>
    <td class="codeline">  template <typename ITy> bool match(ITy *V) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class="codeline">    const auto *CI = dyn_cast<ConstantInt>(V);</td>
    <td class="lineNumber">851</td>
    <td class="codeline">    const auto *CI = dyn_cast<ConstantInt>(V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class="codeline">    if (!CI && V->getType()->isVectorTy())</td>
    <td class="lineNumber">852</td>
    <td class="codeline">    if (!CI && V->getType()->isVectorTy())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class="codeline">      if (const auto *C = dyn_cast<Constant>(V))</td>
    <td class="lineNumber">853</td>
    <td class="codeline">      if (const auto *C = dyn_cast<Constant>(V))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class="codeline">        CI = dyn_cast_or_null<ConstantInt>(C->getSplatValue(AllowUndefs));</td>
    <td class="lineNumber">854</td>
    <td class="codeline">        CI = dyn_cast_or_null<ConstantInt>(C->getSplatValue(AllowUndefs));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class="codeline"></td>
    <td class="lineNumber">855</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class="codeline">    return CI && APInt::isSameValue(CI->getValue(), Val);</td>
    <td class="lineNumber">856</td>
    <td class="codeline">    return CI && APInt::isSameValue(CI->getValue(), Val);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">857</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class="codeline">};</td>
    <td class="lineNumber">858</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class="codeline"></td>
    <td class="lineNumber">859</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class="codeline">/// Match a specific integer value or vector with all elements equal to</td>
    <td class="lineNumber">860</td>
    <td class="codeline">/// Match a specific integer value or vector with all elements equal to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class="codeline">/// the value.</td>
    <td class="lineNumber">861</td>
    <td class="codeline">/// the value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class="codeline">inline specific_intval<false> m_SpecificInt(APInt V) {</td>
    <td class="lineNumber">862</td>
    <td class="codeline">inline specific_intval<false> m_SpecificInt(APInt V) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class="codeline">  return specific_intval<false>(std::move(V));</td>
    <td class="lineNumber">863</td>
    <td class="codeline">  return specific_intval<false>(std::move(V));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class="codeline">}</td>
    <td class="lineNumber">864</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class="codeline"></td>
    <td class="lineNumber">865</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class="codeline">inline specific_intval<false> m_SpecificInt(uint64_t V) {</td>
    <td class="lineNumber">866</td>
    <td class="codeline">inline specific_intval<false> m_SpecificInt(uint64_t V) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class="codeline">  return m_SpecificInt(APInt(64, V));</td>
    <td class="lineNumber">867</td>
    <td class="codeline">  return m_SpecificInt(APInt(64, V));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class="codeline">}</td>
    <td class="lineNumber">868</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class="codeline"></td>
    <td class="lineNumber">869</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="codeline">inline specific_intval<true> m_SpecificIntAllowUndef(APInt V) {</td>
    <td class="lineNumber">870</td>
    <td class="codeline">inline specific_intval<true> m_SpecificIntAllowUndef(APInt V) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class="codeline">  return specific_intval<true>(std::move(V));</td>
    <td class="lineNumber">871</td>
    <td class="codeline">  return specific_intval<true>(std::move(V));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">872</td>
    <td class="codeline">}</td>
    <td class="lineNumber">872</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">873</td>
    <td class="codeline"></td>
    <td class="lineNumber">873</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">874</td>
    <td class="codeline">inline specific_intval<true> m_SpecificIntAllowUndef(uint64_t V) {</td>
    <td class="lineNumber">874</td>
    <td class="codeline">inline specific_intval<true> m_SpecificIntAllowUndef(uint64_t V) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">875</td>
    <td class="codeline">  return m_SpecificIntAllowUndef(APInt(64, V));</td>
    <td class="lineNumber">875</td>
    <td class="codeline">  return m_SpecificIntAllowUndef(APInt(64, V));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">876</td>
    <td class="codeline">}</td>
    <td class="lineNumber">876</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">877</td>
    <td class="codeline"></td>
    <td class="lineNumber">877</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">878</td>
    <td class="codeline">/// Match a ConstantInt and bind to its value.  This does not match</td>
    <td class="lineNumber">878</td>
    <td class="codeline">/// Match a ConstantInt and bind to its value.  This does not match</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">879</td>
    <td class="codeline">/// ConstantInts wider than 64-bits.</td>
    <td class="lineNumber">879</td>
    <td class="codeline">/// ConstantInts wider than 64-bits.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">880</td>
    <td class="codeline">inline bind_const_intval_ty m_ConstantInt(uint64_t &V) { return V; }</td>
    <td class="lineNumber">880</td>
    <td class="codeline">inline bind_const_intval_ty m_ConstantInt(uint64_t &V) { return V; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">881</td>
    <td class="codeline"></td>
    <td class="lineNumber">881</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">882</td>
    <td class="codeline">/// Match a specified basic block value.</td>
    <td class="lineNumber">882</td>
    <td class="codeline">/// Match a specified basic block value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">883</td>
    <td class="codeline">struct specific_bbval {</td>
    <td class="lineNumber">883</td>
    <td class="codeline">struct specific_bbval {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">884</td>
    <td class="codeline">  BasicBlock *Val;</td>
    <td class="lineNumber">884</td>
    <td class="codeline">  BasicBlock *Val;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">885</td>
    <td class="codeline"></td>
    <td class="lineNumber">885</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">886</td>
    <td class="codeline">  specific_bbval(BasicBlock *Val) : Val(Val) {}</td>
    <td class="lineNumber">886</td>
    <td class="codeline">  specific_bbval(BasicBlock *Val) : Val(Val) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">887</td>
    <td class="codeline"></td>
    <td class="lineNumber">887</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">888</td>
    <td class="codeline">  template <typename ITy> bool match(ITy *V) {</td>
    <td class="lineNumber">888</td>
    <td class="codeline">  template <typename ITy> bool match(ITy *V) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">889</td>
    <td class="codeline">    const auto *BB = dyn_cast<BasicBlock>(V);</td>
    <td class="lineNumber">889</td>
    <td class="codeline">    const auto *BB = dyn_cast<BasicBlock>(V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">890</td>
    <td class="codeline">    return BB && BB == Val;</td>
    <td class="lineNumber">890</td>
    <td class="codeline">    return BB && BB == Val;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">891</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">891</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">892</td>
    <td class="codeline">};</td>
    <td class="lineNumber">892</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">893</td>
    <td class="codeline"></td>
    <td class="lineNumber">893</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">894</td>
    <td class="codeline">/// Match a specific basic block value.</td>
    <td class="lineNumber">894</td>
    <td class="codeline">/// Match a specific basic block value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">895</td>
    <td class="codeline">inline specific_bbval m_SpecificBB(BasicBlock *BB) {</td>
    <td class="lineNumber">895</td>
    <td class="codeline">inline specific_bbval m_SpecificBB(BasicBlock *BB) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">896</td>
    <td class="codeline">  return specific_bbval(BB);</td>
    <td class="lineNumber">896</td>
    <td class="codeline">  return specific_bbval(BB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">897</td>
    <td class="codeline">}</td>
    <td class="lineNumber">897</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">898</td>
    <td class="codeline"></td>
    <td class="lineNumber">898</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">899</td>
    <td class="codeline">/// A commutative-friendly version of m_Specific().</td>
    <td class="lineNumber">899</td>
    <td class="codeline">/// A commutative-friendly version of m_Specific().</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">900</td>
    <td class="codeline">inline deferredval_ty<BasicBlock> m_Deferred(BasicBlock *const &BB) {</td>
    <td class="lineNumber">900</td>
    <td class="codeline">inline deferredval_ty<BasicBlock> m_Deferred(BasicBlock *const &BB) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">901</td>
    <td class="codeline">  return BB;</td>
    <td class="lineNumber">901</td>
    <td class="codeline">  return BB;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">902</td>
    <td class="codeline">}</td>
    <td class="lineNumber">902</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">903</td>
    <td class="codeline">inline deferredval_ty<const BasicBlock></td>
    <td class="lineNumber">903</td>
    <td class="codeline">inline deferredval_ty<const BasicBlock></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">904</td>
    <td class="codeline">m_Deferred(const BasicBlock *const &BB) {</td>
    <td class="lineNumber">904</td>
    <td class="codeline">m_Deferred(const BasicBlock *const &BB) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">905</td>
    <td class="codeline">  return BB;</td>
    <td class="lineNumber">905</td>
    <td class="codeline">  return BB;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">906</td>
    <td class="codeline">}</td>
    <td class="lineNumber">906</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">907</td>
    <td class="codeline"></td>
    <td class="lineNumber">907</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">908</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">908</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">909</td>
    <td class="codeline">// Matcher for any binary operator.</td>
    <td class="lineNumber">909</td>
    <td class="codeline">// Matcher for any binary operator.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">910</td>
    <td class="codeline">//</td>
    <td class="lineNumber">910</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">911</td>
    <td class="codeline">template <typename LHS_t, typename RHS_t, bool Commutable = false></td>
    <td class="lineNumber">911</td>
    <td class="codeline">template <typename LHS_t, typename RHS_t, bool Commutable = false></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">912</td>
    <td class="codeline">struct AnyBinaryOp_match {</td>
    <td class="lineNumber">912</td>
    <td class="codeline">struct AnyBinaryOp_match {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">913</td>
    <td class="codeline">  LHS_t L;</td>
    <td class="lineNumber">913</td>
    <td class="codeline">  LHS_t L;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">914</td>
    <td class="codeline">  RHS_t R;</td>
    <td class="lineNumber">914</td>
    <td class="codeline">  RHS_t R;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">915</td>
    <td class="codeline"></td>
    <td class="lineNumber">915</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">916</td>
    <td class="codeline">  // The evaluation order is always stable, regardless of Commutability.</td>
    <td class="lineNumber">916</td>
    <td class="codeline">  // The evaluation order is always stable, regardless of Commutability.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">917</td>
    <td class="codeline">  // The LHS is always matched first.</td>
    <td class="lineNumber">917</td>
    <td class="codeline">  // The LHS is always matched first.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">918</td>
    <td class="codeline">  AnyBinaryOp_match(const LHS_t &LHS, const RHS_t &RHS) : L(LHS), R(RHS) {}</td>
    <td class="lineNumber">918</td>
    <td class="codeline">  AnyBinaryOp_match(const LHS_t &LHS, const RHS_t &RHS) : L(LHS), R(RHS) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">919</td>
    <td class="codeline"></td>
    <td class="lineNumber">919</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">920</td>
    <td class="codeline">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td class="lineNumber">920</td>
    <td class="codeline">  template <typename OpTy> bool match(OpTy *V) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">921</td>
    <td class="codeline">    if (auto *I = dyn_cast<BinaryOperator>(V))</td>
    <td class="lineNumber">921</td>
    <td class="codeline">    if (auto *I = dyn_cast<BinaryOperator>(V))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">922</td>
    <td class="codeline">      return (L.match(I->getOperand(0)) && R.match(I->getOperand(1))) ||</td>
    <td class="lineNumber">922</td>
    <td class="codeline">      return (L.match(I->getOperand(0)) && R.match(I->getOperand(1))) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">923</td>
    <td class="codeline">             (Commutable && L.match(I->getOperand(1)) &&</td>
    <td class="lineNumber">923</td>
    <td class="codeline">             (Commutable && L.match(I->getOperand(1)) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">924</td>
    <td class="codeline">              R.match(I->getOperand(0)));</td>
    <td class="lineNumber">924</td>
    <td class="codeline">              R.match(I->getOperand(0)));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">925</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">925</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">926</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">926</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">927</td>
    <td class="codeline">};</td>
    <td class="lineNumber">927</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">928</td>
    <td class="codeline"></td>
    <td class="lineNumber">928</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">929</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
    <td class="lineNumber">929</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">930</td>
    <td class="codeline">inline AnyBinaryOp_match<LHS, RHS> m_BinOp(const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">930</td>
    <td class="codeline">inline AnyBinaryOp_match<LHS, RHS> m_BinOp(const LHS &L, const RHS &R) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">931</td>
    <td class="codeline">  return AnyBinaryOp_match<LHS, RHS>(L, R);</td>
    <td class="lineNumber">931</td>
    <td class="codeline">  return AnyBinaryOp_match<LHS, RHS>(L, R);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">932</td>
    <td class="codeline">}</td>
    <td class="lineNumber">932</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">933</td>
    <td class="codeline"></td>
    <td class="lineNumber">933</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">934</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">934</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">935</td>
    <td class="codeline">// Matcher for any unary operator.</td>
    <td class="lineNumber">935</td>
    <td class="codeline">// Matcher for any unary operator.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">936</td>
    <td class="codeline">// TODO fuse unary, binary matcher into n-ary matcher</td>
    <td class="lineNumber">936</td>
    <td class="codeline">// TODO fuse unary, binary matcher into n-ary matcher</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">937</td>
    <td class="codeline">//</td>
    <td class="lineNumber">937</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">938</td>
    <td class="codeline">template <typename OP_t> struct AnyUnaryOp_match {</td>
    <td class="lineNumber">938</td>
    <td class="codeline">template <typename OP_t> struct AnyUnaryOp_match {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">939</td>
    <td class="codeline">  OP_t X;</td>
    <td class="lineNumber">939</td>
    <td class="codeline">  OP_t X;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">940</td>
    <td class="codeline"></td>
    <td class="lineNumber">940</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">941</td>
    <td class="codeline">  AnyUnaryOp_match(const OP_t &X) : X(X) {}</td>
    <td class="lineNumber">941</td>
    <td class="codeline">  AnyUnaryOp_match(const OP_t &X) : X(X) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">942</td>
    <td class="codeline"></td>
    <td class="lineNumber">942</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">943</td>
    <td class="codeline">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td class="lineNumber">943</td>
    <td class="codeline">  template <typename OpTy> bool match(OpTy *V) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">944</td>
    <td class="codeline">    if (auto *I = dyn_cast<UnaryOperator>(V))</td>
    <td class="lineNumber">944</td>
    <td class="codeline">    if (auto *I = dyn_cast<UnaryOperator>(V))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">945</td>
    <td class="codeline">      return X.match(I->getOperand(0));</td>
    <td class="lineNumber">945</td>
    <td class="codeline">      return X.match(I->getOperand(0));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">946</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">946</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">947</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">947</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">948</td>
    <td class="codeline">};</td>
    <td class="lineNumber">948</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">949</td>
    <td class="codeline"></td>
    <td class="lineNumber">949</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">950</td>
    <td class="codeline">template <typename OP_t> inline AnyUnaryOp_match<OP_t> m_UnOp(const OP_t &X) {</td>
    <td class="lineNumber">950</td>
    <td class="codeline">template <typename OP_t> inline AnyUnaryOp_match<OP_t> m_UnOp(const OP_t &X) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">951</td>
    <td class="codeline">  return AnyUnaryOp_match<OP_t>(X);</td>
    <td class="lineNumber">951</td>
    <td class="codeline">  return AnyUnaryOp_match<OP_t>(X);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">952</td>
    <td class="codeline">}</td>
    <td class="lineNumber">952</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">953</td>
    <td class="codeline"></td>
    <td class="lineNumber">953</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">954</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">954</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">955</td>
    <td class="codeline">// Matchers for specific binary operators.</td>
    <td class="lineNumber">955</td>
    <td class="codeline">// Matchers for specific binary operators.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">956</td>
    <td class="codeline">//</td>
    <td class="lineNumber">956</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">957</td>
    <td class="codeline"></td>
    <td class="lineNumber">957</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">958</td>
    <td class="codeline">template <typename LHS_t, typename RHS_t, unsigned Opcode,</td>
    <td class="lineNumber">958</td>
    <td class="codeline">template <typename LHS_t, typename RHS_t, unsigned Opcode,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">959</td>
    <td class="codeline">          bool Commutable = false></td>
    <td class="lineNumber">959</td>
    <td class="codeline">          bool Commutable = false></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">960</td>
    <td class="codeline">struct BinaryOp_match {</td>
    <td class="lineNumber">960</td>
    <td class="codeline">struct BinaryOp_match {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">961</td>
    <td class="codeline">  LHS_t L;</td>
    <td class="lineNumber">961</td>
    <td class="codeline">  LHS_t L;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">962</td>
    <td class="codeline">  RHS_t R;</td>
    <td class="lineNumber">962</td>
    <td class="codeline">  RHS_t R;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">963</td>
    <td class="codeline"></td>
    <td class="lineNumber">963</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">964</td>
    <td class="codeline">  // The evaluation order is always stable, regardless of Commutability.</td>
    <td class="lineNumber">964</td>
    <td class="codeline">  // The evaluation order is always stable, regardless of Commutability.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">965</td>
    <td class="codeline">  // The LHS is always matched first.</td>
    <td class="lineNumber">965</td>
    <td class="codeline">  // The LHS is always matched first.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">966</td>
    <td class="codeline">  BinaryOp_match(const LHS_t &LHS, const RHS_t &RHS) : L(LHS), R(RHS) {}</td>
    <td class="lineNumber">966</td>
    <td class="codeline">  BinaryOp_match(const LHS_t &LHS, const RHS_t &RHS) : L(LHS), R(RHS) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">967</td>
    <td class="codeline"></td>
    <td class="lineNumber">967</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">968</td>
    <td class="codeline">  template <typename OpTy> inline bool match(unsigned Opc, OpTy *V) {</td>
    <td class="lineNumber">968</td>
    <td class="codeline">  template <typename OpTy> inline bool match(unsigned Opc, OpTy *V) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">969</td>
    <td class="codeline">    if (V->getValueID() == Value::InstructionVal + Opc) {</td>
    <td class="lineNumber">969</td>
    <td class="codeline">    if (V->getValueID() == Value::InstructionVal + Opc) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">970</td>
    <td class="codeline">      auto *I = cast<BinaryOperator>(V);</td>
    <td class="lineNumber">970</td>
    <td class="codeline">      auto *I = cast<BinaryOperator>(V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">971</td>
    <td class="codeline">      return (L.match(I->getOperand(0)) && R.match(I->getOperand(1))) ||</td>
    <td class="lineNumber">971</td>
    <td class="codeline">      return (L.match(I->getOperand(0)) && R.match(I->getOperand(1))) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">972</td>
    <td class="codeline">             (Commutable && L.match(I->getOperand(1)) &&</td>
    <td class="lineNumber">972</td>
    <td class="codeline">             (Commutable && L.match(I->getOperand(1)) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">973</td>
    <td class="codeline">              R.match(I->getOperand(0)));</td>
    <td class="lineNumber">973</td>
    <td class="codeline">              R.match(I->getOperand(0)));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">974</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">974</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">975</td>
    <td class="codeline">    if (auto *CE = dyn_cast<ConstantExpr>(V))</td>
    <td class="lineNumber">975</td>
    <td class="codeline">    if (auto *CE = dyn_cast<ConstantExpr>(V))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">976</td>
    <td class="codeline">      return CE->getOpcode() == Opc &&</td>
    <td class="lineNumber">976</td>
    <td class="codeline">      return CE->getOpcode() == Opc &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">977</td>
    <td class="codeline">             ((L.match(CE->getOperand(0)) && R.match(CE->getOperand(1))) ||</td>
    <td class="lineNumber">977</td>
    <td class="codeline">             ((L.match(CE->getOperand(0)) && R.match(CE->getOperand(1))) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">978</td>
    <td class="codeline">              (Commutable && L.match(CE->getOperand(1)) &&</td>
    <td class="lineNumber">978</td>
    <td class="codeline">              (Commutable && L.match(CE->getOperand(1)) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">979</td>
    <td class="codeline">               R.match(CE->getOperand(0))));</td>
    <td class="lineNumber">979</td>
    <td class="codeline">               R.match(CE->getOperand(0))));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">980</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">980</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">981</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">981</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">982</td>
    <td class="codeline"></td>
    <td class="lineNumber">982</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">983</td>
    <td class="codeline">  template <typename OpTy> bool match(OpTy *V) { return match(Opcode, V); }</td>
    <td class="lineNumber">983</td>
    <td class="codeline">  template <typename OpTy> bool match(OpTy *V) { return match(Opcode, V); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">984</td>
    <td class="codeline">};</td>
    <td class="lineNumber">984</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">985</td>
    <td class="codeline"></td>
    <td class="lineNumber">985</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">986</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
    <td class="lineNumber">986</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">987</td>
    <td class="codeline">inline BinaryOp_match<LHS, RHS, Instruction::Add> m_Add(const LHS &L,</td>
    <td class="lineNumber">987</td>
    <td class="codeline">inline BinaryOp_match<LHS, RHS, Instruction::Add> m_Add(const LHS &L,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">988</td>
    <td class="codeline">                                                        const RHS &R) {</td>
    <td class="lineNumber">988</td>
    <td class="codeline">                                                        const RHS &R) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">989</td>
    <td class="codeline">  return BinaryOp_match<LHS, RHS, Instruction::Add>(L, R);</td>
    <td class="lineNumber">989</td>
    <td class="codeline">  return BinaryOp_match<LHS, RHS, Instruction::Add>(L, R);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">990</td>
    <td class="codeline">}</td>
    <td class="lineNumber">990</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">991</td>
    <td class="codeline"></td>
    <td class="lineNumber">991</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">992</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
    <td class="lineNumber">992</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">993</td>
    <td class="codeline">inline BinaryOp_match<LHS, RHS, Instruction::FAdd> m_FAdd(const LHS &L,</td>
    <td class="lineNumber">993</td>
    <td class="codeline">inline BinaryOp_match<LHS, RHS, Instruction::FAdd> m_FAdd(const LHS &L,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">994</td>
    <td class="codeline">                                                          const RHS &R) {</td>
    <td class="lineNumber">994</td>
    <td class="codeline">                                                          const RHS &R) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">995</td>
    <td class="codeline">  return BinaryOp_match<LHS, RHS, Instruction::FAdd>(L, R);</td>
    <td class="lineNumber">995</td>
    <td class="codeline">  return BinaryOp_match<LHS, RHS, Instruction::FAdd>(L, R);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">996</td>
    <td class="codeline">}</td>
    <td class="lineNumber">996</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">997</td>
    <td class="codeline"></td>
    <td class="lineNumber">997</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">998</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
    <td class="lineNumber">998</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">999</td>
    <td class="codeline">inline BinaryOp_match<LHS, RHS, Instruction::Sub> m_Sub(const LHS &L,</td>
    <td class="lineNumber">999</td>
    <td class="codeline">inline BinaryOp_match<LHS, RHS, Instruction::Sub> m_Sub(const LHS &L,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1000</td>
    <td class="codeline">                                                        const RHS &R) {</td>
    <td class="lineNumber">1000</td>
    <td class="codeline">                                                        const RHS &R) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1001</td>
    <td class="codeline">  return BinaryOp_match<LHS, RHS, Instruction::Sub>(L, R);</td>
    <td class="lineNumber">1001</td>
    <td class="codeline">  return BinaryOp_match<LHS, RHS, Instruction::Sub>(L, R);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1002</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1002</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1003</td>
    <td class="codeline"></td>
    <td class="lineNumber">1003</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1004</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
    <td class="lineNumber">1004</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1005</td>
    <td class="codeline">inline BinaryOp_match<LHS, RHS, Instruction::FSub> m_FSub(const LHS &L,</td>
    <td class="lineNumber">1005</td>
    <td class="codeline">inline BinaryOp_match<LHS, RHS, Instruction::FSub> m_FSub(const LHS &L,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1006</td>
    <td class="codeline">                                                          const RHS &R) {</td>
    <td class="lineNumber">1006</td>
    <td class="codeline">                                                          const RHS &R) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1007</td>
    <td class="codeline">  return BinaryOp_match<LHS, RHS, Instruction::FSub>(L, R);</td>
    <td class="lineNumber">1007</td>
    <td class="codeline">  return BinaryOp_match<LHS, RHS, Instruction::FSub>(L, R);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1008</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1008</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1009</td>
    <td class="codeline"></td>
    <td class="lineNumber">1009</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1010</td>
    <td class="codeline">template <typename Op_t> struct FNeg_match {</td>
    <td class="lineNumber">1010</td>
    <td class="codeline">template <typename Op_t> struct FNeg_match {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1011</td>
    <td class="codeline">  Op_t X;</td>
    <td class="lineNumber">1011</td>
    <td class="codeline">  Op_t X;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1012</td>
    <td class="codeline"></td>
    <td class="lineNumber">1012</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1013</td>
    <td class="codeline">  FNeg_match(const Op_t &Op) : X(Op) {}</td>
    <td class="lineNumber">1013</td>
    <td class="codeline">  FNeg_match(const Op_t &Op) : X(Op) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1014</td>
    <td class="codeline">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td class="lineNumber">1014</td>
    <td class="codeline">  template <typename OpTy> bool match(OpTy *V) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1015</td>
    <td class="codeline">    auto *FPMO = dyn_cast<FPMathOperator>(V);</td>
    <td class="lineNumber">1015</td>
    <td class="codeline">    auto *FPMO = dyn_cast<FPMathOperator>(V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1016</td>
    <td class="codeline">    if (!FPMO)</td>
    <td class="lineNumber">1016</td>
    <td class="codeline">    if (!FPMO)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1017</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">1017</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1018</td>
    <td class="codeline"></td>
    <td class="lineNumber">1018</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1019</td>
    <td class="codeline">    if (FPMO->getOpcode() == Instruction::FNeg)</td>
    <td class="lineNumber">1019</td>
    <td class="codeline">    if (FPMO->getOpcode() == Instruction::FNeg)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1020</td>
    <td class="codeline">      return X.match(FPMO->getOperand(0));</td>
    <td class="lineNumber">1020</td>
    <td class="codeline">      return X.match(FPMO->getOperand(0));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1021</td>
    <td class="codeline"></td>
    <td class="lineNumber">1021</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1022</td>
    <td class="codeline">    if (FPMO->getOpcode() == Instruction::FSub) {</td>
    <td class="lineNumber">1022</td>
    <td class="codeline">    if (FPMO->getOpcode() == Instruction::FSub) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1023</td>
    <td class="codeline">      if (FPMO->hasNoSignedZeros()) {</td>
    <td class="lineNumber">1023</td>
    <td class="codeline">      if (FPMO->hasNoSignedZeros()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1024</td>
    <td class="codeline">        // With 'nsz', any zero goes.</td>
    <td class="lineNumber">1024</td>
    <td class="codeline">        // With 'nsz', any zero goes.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1025</td>
    <td class="codeline">        if (!cstfp_pred_ty<is_any_zero_fp>().match(FPMO->getOperand(0)))</td>
    <td class="lineNumber">1025</td>
    <td class="codeline">        if (!cstfp_pred_ty<is_any_zero_fp>().match(FPMO->getOperand(0)))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1026</td>
    <td class="codeline">          return false;</td>
    <td class="lineNumber">1026</td>
    <td class="codeline">          return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1027</td>
    <td class="codeline">      } else {</td>
    <td class="lineNumber">1027</td>
    <td class="codeline">      } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1028</td>
    <td class="codeline">        // Without 'nsz', we need fsub -0.0, X exactly.</td>
    <td class="lineNumber">1028</td>
    <td class="codeline">        // Without 'nsz', we need fsub -0.0, X exactly.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1029</td>
    <td class="codeline">        if (!cstfp_pred_ty<is_neg_zero_fp>().match(FPMO->getOperand(0)))</td>
    <td class="lineNumber">1029</td>
    <td class="codeline">        if (!cstfp_pred_ty<is_neg_zero_fp>().match(FPMO->getOperand(0)))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1030</td>
    <td class="codeline">          return false;</td>
    <td class="lineNumber">1030</td>
    <td class="codeline">          return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1031</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1031</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1032</td>
    <td class="codeline"></td>
    <td class="lineNumber">1032</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1033</td>
    <td class="codeline">      return X.match(FPMO->getOperand(1));</td>
    <td class="lineNumber">1033</td>
    <td class="codeline">      return X.match(FPMO->getOperand(1));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1034</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1034</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1035</td>
    <td class="codeline"></td>
    <td class="lineNumber">1035</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1036</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1036</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1037</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1037</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1038</td>
    <td class="codeline">};</td>
    <td class="lineNumber">1038</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1039</td>
    <td class="codeline"></td>
    <td class="lineNumber">1039</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1040</td>
    <td class="codeline">/// Match 'fneg X' as 'fsub -0.0, X'.</td>
    <td class="lineNumber">1040</td>
    <td class="codeline">/// Match 'fneg X' as 'fsub -0.0, X'.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1041</td>
    <td class="codeline">template <typename OpTy> inline FNeg_match<OpTy> m_FNeg(const OpTy &X) {</td>
    <td class="lineNumber">1041</td>
    <td class="codeline">template <typename OpTy> inline FNeg_match<OpTy> m_FNeg(const OpTy &X) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1042</td>
    <td class="codeline">  return FNeg_match<OpTy>(X);</td>
    <td class="lineNumber">1042</td>
    <td class="codeline">  return FNeg_match<OpTy>(X);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1043</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1043</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1044</td>
    <td class="codeline"></td>
    <td class="lineNumber">1044</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1045</td>
    <td class="codeline">/// Match 'fneg X' as 'fsub +-0.0, X'.</td>
    <td class="lineNumber">1045</td>
    <td class="codeline">/// Match 'fneg X' as 'fsub +-0.0, X'.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1046</td>
    <td class="codeline">template <typename RHS></td>
    <td class="lineNumber">1046</td>
    <td class="codeline">template <typename RHS></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1047</td>
    <td class="codeline">inline BinaryOp_match<cstfp_pred_ty<is_any_zero_fp>, RHS, Instruction::FSub></td>
    <td class="lineNumber">1047</td>
    <td class="codeline">inline BinaryOp_match<cstfp_pred_ty<is_any_zero_fp>, RHS, Instruction::FSub></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1048</td>
    <td class="codeline">m_FNegNSZ(const RHS &X) {</td>
    <td class="lineNumber">1048</td>
    <td class="codeline">m_FNegNSZ(const RHS &X) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1049</td>
    <td class="codeline">  return m_FSub(m_AnyZeroFP(), X);</td>
    <td class="lineNumber">1049</td>
    <td class="codeline">  return m_FSub(m_AnyZeroFP(), X);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1050</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1050</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1051</td>
    <td class="codeline"></td>
    <td class="lineNumber">1051</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1052</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
    <td class="lineNumber">1052</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1053</td>
    <td class="codeline">inline BinaryOp_match<LHS, RHS, Instruction::Mul> m_Mul(const LHS &L,</td>
    <td class="lineNumber">1053</td>
    <td class="codeline">inline BinaryOp_match<LHS, RHS, Instruction::Mul> m_Mul(const LHS &L,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1054</td>
    <td class="codeline">                                                        const RHS &R) {</td>
    <td class="lineNumber">1054</td>
    <td class="codeline">                                                        const RHS &R) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1055</td>
    <td class="codeline">  return BinaryOp_match<LHS, RHS, Instruction::Mul>(L, R);</td>
    <td class="lineNumber">1055</td>
    <td class="codeline">  return BinaryOp_match<LHS, RHS, Instruction::Mul>(L, R);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1056</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1056</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1057</td>
    <td class="codeline"></td>
    <td class="lineNumber">1057</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1058</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
    <td class="lineNumber">1058</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1059</td>
    <td class="codeline">inline BinaryOp_match<LHS, RHS, Instruction::FMul> m_FMul(const LHS &L,</td>
    <td class="lineNumber">1059</td>
    <td class="codeline">inline BinaryOp_match<LHS, RHS, Instruction::FMul> m_FMul(const LHS &L,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1060</td>
    <td class="codeline">                                                          const RHS &R) {</td>
    <td class="lineNumber">1060</td>
    <td class="codeline">                                                          const RHS &R) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1061</td>
    <td class="codeline">  return BinaryOp_match<LHS, RHS, Instruction::FMul>(L, R);</td>
    <td class="lineNumber">1061</td>
    <td class="codeline">  return BinaryOp_match<LHS, RHS, Instruction::FMul>(L, R);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1062</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1062</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1063</td>
    <td class="codeline"></td>
    <td class="lineNumber">1063</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1064</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
    <td class="lineNumber">1064</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1065</td>
    <td class="codeline">inline BinaryOp_match<LHS, RHS, Instruction::UDiv> m_UDiv(const LHS &L,</td>
    <td class="lineNumber">1065</td>
    <td class="codeline">inline BinaryOp_match<LHS, RHS, Instruction::UDiv> m_UDiv(const LHS &L,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1066</td>
    <td class="codeline">                                                          const RHS &R) {</td>
    <td class="lineNumber">1066</td>
    <td class="codeline">                                                          const RHS &R) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1067</td>
    <td class="codeline">  return BinaryOp_match<LHS, RHS, Instruction::UDiv>(L, R);</td>
    <td class="lineNumber">1067</td>
    <td class="codeline">  return BinaryOp_match<LHS, RHS, Instruction::UDiv>(L, R);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1068</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1068</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1069</td>
    <td class="codeline"></td>
    <td class="lineNumber">1069</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1070</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
    <td class="lineNumber">1070</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1071</td>
    <td class="codeline">inline BinaryOp_match<LHS, RHS, Instruction::SDiv> m_SDiv(const LHS &L,</td>
    <td class="lineNumber">1071</td>
    <td class="codeline">inline BinaryOp_match<LHS, RHS, Instruction::SDiv> m_SDiv(const LHS &L,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1072</td>
    <td class="codeline">                                                          const RHS &R) {</td>
    <td class="lineNumber">1072</td>
    <td class="codeline">                                                          const RHS &R) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1073</td>
    <td class="codeline">  return BinaryOp_match<LHS, RHS, Instruction::SDiv>(L, R);</td>
    <td class="lineNumber">1073</td>
    <td class="codeline">  return BinaryOp_match<LHS, RHS, Instruction::SDiv>(L, R);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1074</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1074</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1075</td>
    <td class="codeline"></td>
    <td class="lineNumber">1075</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1076</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
    <td class="lineNumber">1076</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1077</td>
    <td class="codeline">inline BinaryOp_match<LHS, RHS, Instruction::FDiv> m_FDiv(const LHS &L,</td>
    <td class="lineNumber">1077</td>
    <td class="codeline">inline BinaryOp_match<LHS, RHS, Instruction::FDiv> m_FDiv(const LHS &L,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1078</td>
    <td class="codeline">                                                          const RHS &R) {</td>
    <td class="lineNumber">1078</td>
    <td class="codeline">                                                          const RHS &R) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1079</td>
    <td class="codeline">  return BinaryOp_match<LHS, RHS, Instruction::FDiv>(L, R);</td>
    <td class="lineNumber">1079</td>
    <td class="codeline">  return BinaryOp_match<LHS, RHS, Instruction::FDiv>(L, R);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1080</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1080</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1081</td>
    <td class="codeline"></td>
    <td class="lineNumber">1081</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1082</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
    <td class="lineNumber">1082</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1083</td>
    <td class="codeline">inline BinaryOp_match<LHS, RHS, Instruction::URem> m_URem(const LHS &L,</td>
    <td class="lineNumber">1083</td>
    <td class="codeline">inline BinaryOp_match<LHS, RHS, Instruction::URem> m_URem(const LHS &L,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1084</td>
    <td class="codeline">                                                          const RHS &R) {</td>
    <td class="lineNumber">1084</td>
    <td class="codeline">                                                          const RHS &R) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1085</td>
    <td class="codeline">  return BinaryOp_match<LHS, RHS, Instruction::URem>(L, R);</td>
    <td class="lineNumber">1085</td>
    <td class="codeline">  return BinaryOp_match<LHS, RHS, Instruction::URem>(L, R);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1086</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1086</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1087</td>
    <td class="codeline"></td>
    <td class="lineNumber">1087</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1088</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
    <td class="lineNumber">1088</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1089</td>
    <td class="codeline">inline BinaryOp_match<LHS, RHS, Instruction::SRem> m_SRem(const LHS &L,</td>
    <td class="lineNumber">1089</td>
    <td class="codeline">inline BinaryOp_match<LHS, RHS, Instruction::SRem> m_SRem(const LHS &L,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1090</td>
    <td class="codeline">                                                          const RHS &R) {</td>
    <td class="lineNumber">1090</td>
    <td class="codeline">                                                          const RHS &R) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1091</td>
    <td class="codeline">  return BinaryOp_match<LHS, RHS, Instruction::SRem>(L, R);</td>
    <td class="lineNumber">1091</td>
    <td class="codeline">  return BinaryOp_match<LHS, RHS, Instruction::SRem>(L, R);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1092</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1092</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1093</td>
    <td class="codeline"></td>
    <td class="lineNumber">1093</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1094</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
    <td class="lineNumber">1094</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1095</td>
    <td class="codeline">inline BinaryOp_match<LHS, RHS, Instruction::FRem> m_FRem(const LHS &L,</td>
    <td class="lineNumber">1095</td>
    <td class="codeline">inline BinaryOp_match<LHS, RHS, Instruction::FRem> m_FRem(const LHS &L,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1096</td>
    <td class="codeline">                                                          const RHS &R) {</td>
    <td class="lineNumber">1096</td>
    <td class="codeline">                                                          const RHS &R) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1097</td>
    <td class="codeline">  return BinaryOp_match<LHS, RHS, Instruction::FRem>(L, R);</td>
    <td class="lineNumber">1097</td>
    <td class="codeline">  return BinaryOp_match<LHS, RHS, Instruction::FRem>(L, R);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1098</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1098</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1099</td>
    <td class="codeline"></td>
    <td class="lineNumber">1099</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1100</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
    <td class="lineNumber">1100</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1101</td>
    <td class="codeline">inline BinaryOp_match<LHS, RHS, Instruction::And> m_And(const LHS &L,</td>
    <td class="lineNumber">1101</td>
    <td class="codeline">inline BinaryOp_match<LHS, RHS, Instruction::And> m_And(const LHS &L,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1102</td>
    <td class="codeline">                                                        const RHS &R) {</td>
    <td class="lineNumber">1102</td>
    <td class="codeline">                                                        const RHS &R) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1103</td>
    <td class="codeline">  return BinaryOp_match<LHS, RHS, Instruction::And>(L, R);</td>
    <td class="lineNumber">1103</td>
    <td class="codeline">  return BinaryOp_match<LHS, RHS, Instruction::And>(L, R);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1104</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1104</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1105</td>
    <td class="codeline"></td>
    <td class="lineNumber">1105</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1106</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
    <td class="lineNumber">1106</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1107</td>
    <td class="codeline">inline BinaryOp_match<LHS, RHS, Instruction::Or> m_Or(const LHS &L,</td>
    <td class="lineNumber">1107</td>
    <td class="codeline">inline BinaryOp_match<LHS, RHS, Instruction::Or> m_Or(const LHS &L,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1108</td>
    <td class="codeline">                                                      const RHS &R) {</td>
    <td class="lineNumber">1108</td>
    <td class="codeline">                                                      const RHS &R) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1109</td>
    <td class="codeline">  return BinaryOp_match<LHS, RHS, Instruction::Or>(L, R);</td>
    <td class="lineNumber">1109</td>
    <td class="codeline">  return BinaryOp_match<LHS, RHS, Instruction::Or>(L, R);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1110</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1110</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1111</td>
    <td class="codeline"></td>
    <td class="lineNumber">1111</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1112</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
    <td class="lineNumber">1112</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1113</td>
    <td class="codeline">inline BinaryOp_match<LHS, RHS, Instruction::Xor> m_Xor(const LHS &L,</td>
    <td class="lineNumber">1113</td>
    <td class="codeline">inline BinaryOp_match<LHS, RHS, Instruction::Xor> m_Xor(const LHS &L,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1114</td>
    <td class="codeline">                                                        const RHS &R) {</td>
    <td class="lineNumber">1114</td>
    <td class="codeline">                                                        const RHS &R) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1115</td>
    <td class="codeline">  return BinaryOp_match<LHS, RHS, Instruction::Xor>(L, R);</td>
    <td class="lineNumber">1115</td>
    <td class="codeline">  return BinaryOp_match<LHS, RHS, Instruction::Xor>(L, R);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1116</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1116</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1117</td>
    <td class="codeline"></td>
    <td class="lineNumber">1117</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1118</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
    <td class="lineNumber">1118</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1119</td>
    <td class="codeline">inline BinaryOp_match<LHS, RHS, Instruction::Shl> m_Shl(const LHS &L,</td>
    <td class="lineNumber">1119</td>
    <td class="codeline">inline BinaryOp_match<LHS, RHS, Instruction::Shl> m_Shl(const LHS &L,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1120</td>
    <td class="codeline">                                                        const RHS &R) {</td>
    <td class="lineNumber">1120</td>
    <td class="codeline">                                                        const RHS &R) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1121</td>
    <td class="codeline">  return BinaryOp_match<LHS, RHS, Instruction::Shl>(L, R);</td>
    <td class="lineNumber">1121</td>
    <td class="codeline">  return BinaryOp_match<LHS, RHS, Instruction::Shl>(L, R);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1122</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1122</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1123</td>
    <td class="codeline"></td>
    <td class="lineNumber">1123</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1124</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
    <td class="lineNumber">1124</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1125</td>
    <td class="codeline">inline BinaryOp_match<LHS, RHS, Instruction::LShr> m_LShr(const LHS &L,</td>
    <td class="lineNumber">1125</td>
    <td class="codeline">inline BinaryOp_match<LHS, RHS, Instruction::LShr> m_LShr(const LHS &L,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1126</td>
    <td class="codeline">                                                          const RHS &R) {</td>
    <td class="lineNumber">1126</td>
    <td class="codeline">                                                          const RHS &R) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1127</td>
    <td class="codeline">  return BinaryOp_match<LHS, RHS, Instruction::LShr>(L, R);</td>
    <td class="lineNumber">1127</td>
    <td class="codeline">  return BinaryOp_match<LHS, RHS, Instruction::LShr>(L, R);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1128</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1128</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1129</td>
    <td class="codeline"></td>
    <td class="lineNumber">1129</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1130</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
    <td class="lineNumber">1130</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1131</td>
    <td class="codeline">inline BinaryOp_match<LHS, RHS, Instruction::AShr> m_AShr(const LHS &L,</td>
    <td class="lineNumber">1131</td>
    <td class="codeline">inline BinaryOp_match<LHS, RHS, Instruction::AShr> m_AShr(const LHS &L,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1132</td>
    <td class="codeline">                                                          const RHS &R) {</td>
    <td class="lineNumber">1132</td>
    <td class="codeline">                                                          const RHS &R) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1133</td>
    <td class="codeline">  return BinaryOp_match<LHS, RHS, Instruction::AShr>(L, R);</td>
    <td class="lineNumber">1133</td>
    <td class="codeline">  return BinaryOp_match<LHS, RHS, Instruction::AShr>(L, R);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1134</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1134</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1135</td>
    <td class="codeline"></td>
    <td class="lineNumber">1135</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1136</td>
    <td class="codeline">template <typename LHS_t, typename RHS_t, unsigned Opcode,</td>
    <td class="lineNumber">1136</td>
    <td class="codeline">template <typename LHS_t, typename RHS_t, unsigned Opcode,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1137</td>
    <td class="codeline">          unsigned WrapFlags = 0></td>
    <td class="lineNumber">1137</td>
    <td class="codeline">          unsigned WrapFlags = 0></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1138</td>
    <td class="codeline">struct OverflowingBinaryOp_match {</td>
    <td class="lineNumber">1138</td>
    <td class="codeline">struct OverflowingBinaryOp_match {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1139</td>
    <td class="codeline">  LHS_t L;</td>
    <td class="lineNumber">1139</td>
    <td class="codeline">  LHS_t L;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1140</td>
    <td class="codeline">  RHS_t R;</td>
    <td class="lineNumber">1140</td>
    <td class="codeline">  RHS_t R;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1141</td>
    <td class="codeline"></td>
    <td class="lineNumber">1141</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1142</td>
    <td class="codeline">  OverflowingBinaryOp_match(const LHS_t &LHS, const RHS_t &RHS)</td>
    <td class="lineNumber">1142</td>
    <td class="codeline">  OverflowingBinaryOp_match(const LHS_t &LHS, const RHS_t &RHS)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1143</td>
    <td class="codeline">      : L(LHS), R(RHS) {}</td>
    <td class="lineNumber">1143</td>
    <td class="codeline">      : L(LHS), R(RHS) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1144</td>
    <td class="codeline"></td>
    <td class="lineNumber">1144</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1145</td>
    <td class="codeline">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td class="lineNumber">1145</td>
    <td class="codeline">  template <typename OpTy> bool match(OpTy *V) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1146</td>
    <td class="codeline">    if (auto *Op = dyn_cast<OverflowingBinaryOperator>(V)) {</td>
    <td class="lineNumber">1146</td>
    <td class="codeline">    if (auto *Op = dyn_cast<OverflowingBinaryOperator>(V)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1147</td>
    <td class="codeline">      if (Op->getOpcode() != Opcode)</td>
    <td class="lineNumber">1147</td>
    <td class="codeline">      if (Op->getOpcode() != Opcode)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1148</td>
    <td class="codeline">        return false;</td>
    <td class="lineNumber">1148</td>
    <td class="codeline">        return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1149</td>
    <td class="codeline">      if ((WrapFlags & OverflowingBinaryOperator::NoUnsignedWrap) &&</td>
    <td class="lineNumber">1149</td>
    <td class="codeline">      if ((WrapFlags & OverflowingBinaryOperator::NoUnsignedWrap) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1150</td>
    <td class="codeline">          !Op->hasNoUnsignedWrap())</td>
    <td class="lineNumber">1150</td>
    <td class="codeline">          !Op->hasNoUnsignedWrap())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1151</td>
    <td class="codeline">        return false;</td>
    <td class="lineNumber">1151</td>
    <td class="codeline">        return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1152</td>
    <td class="codeline">      if ((WrapFlags & OverflowingBinaryOperator::NoSignedWrap) &&</td>
    <td class="lineNumber">1152</td>
    <td class="codeline">      if ((WrapFlags & OverflowingBinaryOperator::NoSignedWrap) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1153</td>
    <td class="codeline">          !Op->hasNoSignedWrap())</td>
    <td class="lineNumber">1153</td>
    <td class="codeline">          !Op->hasNoSignedWrap())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1154</td>
    <td class="codeline">        return false;</td>
    <td class="lineNumber">1154</td>
    <td class="codeline">        return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1155</td>
    <td class="codeline">      return L.match(Op->getOperand(0)) && R.match(Op->getOperand(1));</td>
    <td class="lineNumber">1155</td>
    <td class="codeline">      return L.match(Op->getOperand(0)) && R.match(Op->getOperand(1));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1156</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1156</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1157</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1157</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1158</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1158</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1159</td>
    <td class="codeline">};</td>
    <td class="lineNumber">1159</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1160</td>
    <td class="codeline"></td>
    <td class="lineNumber">1160</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1161</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
    <td class="lineNumber">1161</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1162</td>
    <td class="codeline">inline OverflowingBinaryOp_match<LHS, RHS, Instruction::Add,</td>
    <td class="lineNumber">1162</td>
    <td class="codeline">inline OverflowingBinaryOp_match<LHS, RHS, Instruction::Add,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1163</td>
    <td class="codeline">                                 OverflowingBinaryOperator::NoSignedWrap></td>
    <td class="lineNumber">1163</td>
    <td class="codeline">                                 OverflowingBinaryOperator::NoSignedWrap></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1164</td>
    <td class="codeline">m_NSWAdd(const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">1164</td>
    <td class="codeline">m_NSWAdd(const LHS &L, const RHS &R) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1165</td>
    <td class="codeline">  return OverflowingBinaryOp_match<LHS, RHS, Instruction::Add,</td>
    <td class="lineNumber">1165</td>
    <td class="codeline">  return OverflowingBinaryOp_match<LHS, RHS, Instruction::Add,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1166</td>
    <td class="codeline">                                   OverflowingBinaryOperator::NoSignedWrap>(L,</td>
    <td class="lineNumber">1166</td>
    <td class="codeline">                                   OverflowingBinaryOperator::NoSignedWrap>(L,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1167</td>
    <td class="codeline">                                                                            R);</td>
    <td class="lineNumber">1167</td>
    <td class="codeline">                                                                            R);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1168</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1168</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1169</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
    <td class="lineNumber">1169</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1170</td>
    <td class="codeline">inline OverflowingBinaryOp_match<LHS, RHS, Instruction::Sub,</td>
    <td class="lineNumber">1170</td>
    <td class="codeline">inline OverflowingBinaryOp_match<LHS, RHS, Instruction::Sub,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1171</td>
    <td class="codeline">                                 OverflowingBinaryOperator::NoSignedWrap></td>
    <td class="lineNumber">1171</td>
    <td class="codeline">                                 OverflowingBinaryOperator::NoSignedWrap></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1172</td>
    <td class="codeline">m_NSWSub(const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">1172</td>
    <td class="codeline">m_NSWSub(const LHS &L, const RHS &R) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1173</td>
    <td class="codeline">  return OverflowingBinaryOp_match<LHS, RHS, Instruction::Sub,</td>
    <td class="lineNumber">1173</td>
    <td class="codeline">  return OverflowingBinaryOp_match<LHS, RHS, Instruction::Sub,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1174</td>
    <td class="codeline">                                   OverflowingBinaryOperator::NoSignedWrap>(L,</td>
    <td class="lineNumber">1174</td>
    <td class="codeline">                                   OverflowingBinaryOperator::NoSignedWrap>(L,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1175</td>
    <td class="codeline">                                                                            R);</td>
    <td class="lineNumber">1175</td>
    <td class="codeline">                                                                            R);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1176</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1176</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1177</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
    <td class="lineNumber">1177</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1178</td>
    <td class="codeline">inline OverflowingBinaryOp_match<LHS, RHS, Instruction::Mul,</td>
    <td class="lineNumber">1178</td>
    <td class="codeline">inline OverflowingBinaryOp_match<LHS, RHS, Instruction::Mul,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1179</td>
    <td class="codeline">                                 OverflowingBinaryOperator::NoSignedWrap></td>
    <td class="lineNumber">1179</td>
    <td class="codeline">                                 OverflowingBinaryOperator::NoSignedWrap></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1180</td>
    <td class="codeline">m_NSWMul(const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">1180</td>
    <td class="codeline">m_NSWMul(const LHS &L, const RHS &R) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1181</td>
    <td class="codeline">  return OverflowingBinaryOp_match<LHS, RHS, Instruction::Mul,</td>
    <td class="lineNumber">1181</td>
    <td class="codeline">  return OverflowingBinaryOp_match<LHS, RHS, Instruction::Mul,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1182</td>
    <td class="codeline">                                   OverflowingBinaryOperator::NoSignedWrap>(L,</td>
    <td class="lineNumber">1182</td>
    <td class="codeline">                                   OverflowingBinaryOperator::NoSignedWrap>(L,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1183</td>
    <td class="codeline">                                                                            R);</td>
    <td class="lineNumber">1183</td>
    <td class="codeline">                                                                            R);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1184</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1184</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1185</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
    <td class="lineNumber">1185</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1186</td>
    <td class="codeline">inline OverflowingBinaryOp_match<LHS, RHS, Instruction::Shl,</td>
    <td class="lineNumber">1186</td>
    <td class="codeline">inline OverflowingBinaryOp_match<LHS, RHS, Instruction::Shl,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1187</td>
    <td class="codeline">                                 OverflowingBinaryOperator::NoSignedWrap></td>
    <td class="lineNumber">1187</td>
    <td class="codeline">                                 OverflowingBinaryOperator::NoSignedWrap></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1188</td>
    <td class="codeline">m_NSWShl(const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">1188</td>
    <td class="codeline">m_NSWShl(const LHS &L, const RHS &R) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1189</td>
    <td class="codeline">  return OverflowingBinaryOp_match<LHS, RHS, Instruction::Shl,</td>
    <td class="lineNumber">1189</td>
    <td class="codeline">  return OverflowingBinaryOp_match<LHS, RHS, Instruction::Shl,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1190</td>
    <td class="codeline">                                   OverflowingBinaryOperator::NoSignedWrap>(L,</td>
    <td class="lineNumber">1190</td>
    <td class="codeline">                                   OverflowingBinaryOperator::NoSignedWrap>(L,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1191</td>
    <td class="codeline">                                                                            R);</td>
    <td class="lineNumber">1191</td>
    <td class="codeline">                                                                            R);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1192</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1192</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1193</td>
    <td class="codeline"></td>
    <td class="lineNumber">1193</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1194</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
    <td class="lineNumber">1194</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1195</td>
    <td class="codeline">inline OverflowingBinaryOp_match<LHS, RHS, Instruction::Add,</td>
    <td class="lineNumber">1195</td>
    <td class="codeline">inline OverflowingBinaryOp_match<LHS, RHS, Instruction::Add,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1196</td>
    <td class="codeline">                                 OverflowingBinaryOperator::NoUnsignedWrap></td>
    <td class="lineNumber">1196</td>
    <td class="codeline">                                 OverflowingBinaryOperator::NoUnsignedWrap></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1197</td>
    <td class="codeline">m_NUWAdd(const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">1197</td>
    <td class="codeline">m_NUWAdd(const LHS &L, const RHS &R) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1198</td>
    <td class="codeline">  return OverflowingBinaryOp_match<LHS, RHS, Instruction::Add,</td>
    <td class="lineNumber">1198</td>
    <td class="codeline">  return OverflowingBinaryOp_match<LHS, RHS, Instruction::Add,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1199</td>
    <td class="codeline">                                   OverflowingBinaryOperator::NoUnsignedWrap>(</td>
    <td class="lineNumber">1199</td>
    <td class="codeline">                                   OverflowingBinaryOperator::NoUnsignedWrap>(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1200</td>
    <td class="codeline">      L, R);</td>
    <td class="lineNumber">1200</td>
    <td class="codeline">      L, R);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1201</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1201</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1202</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
    <td class="lineNumber">1202</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1203</td>
    <td class="codeline">inline OverflowingBinaryOp_match<LHS, RHS, Instruction::Sub,</td>
    <td class="lineNumber">1203</td>
    <td class="codeline">inline OverflowingBinaryOp_match<LHS, RHS, Instruction::Sub,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1204</td>
    <td class="codeline">                                 OverflowingBinaryOperator::NoUnsignedWrap></td>
    <td class="lineNumber">1204</td>
    <td class="codeline">                                 OverflowingBinaryOperator::NoUnsignedWrap></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1205</td>
    <td class="codeline">m_NUWSub(const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">1205</td>
    <td class="codeline">m_NUWSub(const LHS &L, const RHS &R) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1206</td>
    <td class="codeline">  return OverflowingBinaryOp_match<LHS, RHS, Instruction::Sub,</td>
    <td class="lineNumber">1206</td>
    <td class="codeline">  return OverflowingBinaryOp_match<LHS, RHS, Instruction::Sub,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1207</td>
    <td class="codeline">                                   OverflowingBinaryOperator::NoUnsignedWrap>(</td>
    <td class="lineNumber">1207</td>
    <td class="codeline">                                   OverflowingBinaryOperator::NoUnsignedWrap>(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1208</td>
    <td class="codeline">      L, R);</td>
    <td class="lineNumber">1208</td>
    <td class="codeline">      L, R);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1209</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1209</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1210</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
    <td class="lineNumber">1210</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1211</td>
    <td class="codeline">inline OverflowingBinaryOp_match<LHS, RHS, Instruction::Mul,</td>
    <td class="lineNumber">1211</td>
    <td class="codeline">inline OverflowingBinaryOp_match<LHS, RHS, Instruction::Mul,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1212</td>
    <td class="codeline">                                 OverflowingBinaryOperator::NoUnsignedWrap></td>
    <td class="lineNumber">1212</td>
    <td class="codeline">                                 OverflowingBinaryOperator::NoUnsignedWrap></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1213</td>
    <td class="codeline">m_NUWMul(const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">1213</td>
    <td class="codeline">m_NUWMul(const LHS &L, const RHS &R) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1214</td>
    <td class="codeline">  return OverflowingBinaryOp_match<LHS, RHS, Instruction::Mul,</td>
    <td class="lineNumber">1214</td>
    <td class="codeline">  return OverflowingBinaryOp_match<LHS, RHS, Instruction::Mul,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1215</td>
    <td class="codeline">                                   OverflowingBinaryOperator::NoUnsignedWrap>(</td>
    <td class="lineNumber">1215</td>
    <td class="codeline">                                   OverflowingBinaryOperator::NoUnsignedWrap>(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1216</td>
    <td class="codeline">      L, R);</td>
    <td class="lineNumber">1216</td>
    <td class="codeline">      L, R);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1217</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1217</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1218</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
    <td class="lineNumber">1218</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1219</td>
    <td class="codeline">inline OverflowingBinaryOp_match<LHS, RHS, Instruction::Shl,</td>
    <td class="lineNumber">1219</td>
    <td class="codeline">inline OverflowingBinaryOp_match<LHS, RHS, Instruction::Shl,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1220</td>
    <td class="codeline">                                 OverflowingBinaryOperator::NoUnsignedWrap></td>
    <td class="lineNumber">1220</td>
    <td class="codeline">                                 OverflowingBinaryOperator::NoUnsignedWrap></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1221</td>
    <td class="codeline">m_NUWShl(const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">1221</td>
    <td class="codeline">m_NUWShl(const LHS &L, const RHS &R) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1222</td>
    <td class="codeline">  return OverflowingBinaryOp_match<LHS, RHS, Instruction::Shl,</td>
    <td class="lineNumber">1222</td>
    <td class="codeline">  return OverflowingBinaryOp_match<LHS, RHS, Instruction::Shl,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1223</td>
    <td class="codeline">                                   OverflowingBinaryOperator::NoUnsignedWrap>(</td>
    <td class="lineNumber">1223</td>
    <td class="codeline">                                   OverflowingBinaryOperator::NoUnsignedWrap>(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1224</td>
    <td class="codeline">      L, R);</td>
    <td class="lineNumber">1224</td>
    <td class="codeline">      L, R);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1225</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1225</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1226</td>
    <td class="codeline"></td>
    <td class="lineNumber">1226</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1227</td>
    <td class="codeline">template <typename LHS_t, typename RHS_t, bool Commutable = false></td>
    <td class="lineNumber">1227</td>
    <td class="codeline">template <typename LHS_t, typename RHS_t, bool Commutable = false></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1228</td>
    <td class="codeline">struct SpecificBinaryOp_match</td>
    <td class="lineNumber">1228</td>
    <td class="codeline">struct SpecificBinaryOp_match</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1229</td>
    <td class="codeline">    : public BinaryOp_match<LHS_t, RHS_t, 0, Commutable> {</td>
    <td class="lineNumber">1229</td>
    <td class="codeline">    : public BinaryOp_match<LHS_t, RHS_t, 0, Commutable> {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1230</td>
    <td class="codeline">  unsigned Opcode;</td>
    <td class="lineNumber">1230</td>
    <td class="codeline">  unsigned Opcode;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1231</td>
    <td class="codeline"></td>
    <td class="lineNumber">1231</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1232</td>
    <td class="codeline">  SpecificBinaryOp_match(unsigned Opcode, const LHS_t &LHS, const RHS_t &RHS)</td>
    <td class="lineNumber">1232</td>
    <td class="codeline">  SpecificBinaryOp_match(unsigned Opcode, const LHS_t &LHS, const RHS_t &RHS)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1233</td>
    <td class="codeline">      : BinaryOp_match<LHS_t, RHS_t, 0, Commutable>(LHS, RHS), Opcode(Opcode) {}</td>
    <td class="lineNumber">1233</td>
    <td class="codeline">      : BinaryOp_match<LHS_t, RHS_t, 0, Commutable>(LHS, RHS), Opcode(Opcode) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1234</td>
    <td class="codeline"></td>
    <td class="lineNumber">1234</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1235</td>
    <td class="codeline">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td class="lineNumber">1235</td>
    <td class="codeline">  template <typename OpTy> bool match(OpTy *V) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1236</td>
    <td class="codeline">    return BinaryOp_match<LHS_t, RHS_t, 0, Commutable>::match(Opcode, V);</td>
    <td class="lineNumber">1236</td>
    <td class="codeline">    return BinaryOp_match<LHS_t, RHS_t, 0, Commutable>::match(Opcode, V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1237</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1237</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1238</td>
    <td class="codeline">};</td>
    <td class="lineNumber">1238</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1239</td>
    <td class="codeline"></td>
    <td class="lineNumber">1239</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1240</td>
    <td class="codeline">/// Matches a specific opcode.</td>
    <td class="lineNumber">1240</td>
    <td class="codeline">/// Matches a specific opcode.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1241</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
    <td class="lineNumber">1241</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1242</td>
    <td class="codeline">inline SpecificBinaryOp_match<LHS, RHS> m_BinOp(unsigned Opcode, const LHS &L,</td>
    <td class="lineNumber">1242</td>
    <td class="codeline">inline SpecificBinaryOp_match<LHS, RHS> m_BinOp(unsigned Opcode, const LHS &L,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1243</td>
    <td class="codeline">                                                const RHS &R) {</td>
    <td class="lineNumber">1243</td>
    <td class="codeline">                                                const RHS &R) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1244</td>
    <td class="codeline">  return SpecificBinaryOp_match<LHS, RHS>(Opcode, L, R);</td>
    <td class="lineNumber">1244</td>
    <td class="codeline">  return SpecificBinaryOp_match<LHS, RHS>(Opcode, L, R);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1245</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1245</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1246</td>
    <td class="codeline"></td>
    <td class="lineNumber">1246</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1247</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">1247</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1248</td>
    <td class="codeline">// Class that matches a group of binary opcodes.</td>
    <td class="lineNumber">1248</td>
    <td class="codeline">// Class that matches a group of binary opcodes.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1249</td>
    <td class="codeline">//</td>
    <td class="lineNumber">1249</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1250</td>
    <td class="codeline">template <typename LHS_t, typename RHS_t, typename Predicate></td>
    <td class="lineNumber">1250</td>
    <td class="codeline">template <typename LHS_t, typename RHS_t, typename Predicate></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1251</td>
    <td class="codeline">struct BinOpPred_match : Predicate {</td>
    <td class="lineNumber">1251</td>
    <td class="codeline">struct BinOpPred_match : Predicate {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1252</td>
    <td class="codeline">  LHS_t L;</td>
    <td class="lineNumber">1252</td>
    <td class="codeline">  LHS_t L;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1253</td>
    <td class="codeline">  RHS_t R;</td>
    <td class="lineNumber">1253</td>
    <td class="codeline">  RHS_t R;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1254</td>
    <td class="codeline"></td>
    <td class="lineNumber">1254</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1255</td>
    <td class="codeline">  BinOpPred_match(const LHS_t &LHS, const RHS_t &RHS) : L(LHS), R(RHS) {}</td>
    <td class="lineNumber">1255</td>
    <td class="codeline">  BinOpPred_match(const LHS_t &LHS, const RHS_t &RHS) : L(LHS), R(RHS) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1256</td>
    <td class="codeline"></td>
    <td class="lineNumber">1256</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1257</td>
    <td class="codeline">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td class="lineNumber">1257</td>
    <td class="codeline">  template <typename OpTy> bool match(OpTy *V) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1258</td>
    <td class="codeline">    if (auto *I = dyn_cast<Instruction>(V))</td>
    <td class="lineNumber">1258</td>
    <td class="codeline">    if (auto *I = dyn_cast<Instruction>(V))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1259</td>
    <td class="codeline">      return this->isOpType(I->getOpcode()) && L.match(I->getOperand(0)) &&</td>
    <td class="lineNumber">1259</td>
    <td class="codeline">      return this->isOpType(I->getOpcode()) && L.match(I->getOperand(0)) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1260</td>
    <td class="codeline">             R.match(I->getOperand(1));</td>
    <td class="lineNumber">1260</td>
    <td class="codeline">             R.match(I->getOperand(1));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1261</td>
    <td class="codeline">    if (auto *CE = dyn_cast<ConstantExpr>(V))</td>
    <td class="lineNumber">1261</td>
    <td class="codeline">    if (auto *CE = dyn_cast<ConstantExpr>(V))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1262</td>
    <td class="codeline">      return this->isOpType(CE->getOpcode()) && L.match(CE->getOperand(0)) &&</td>
    <td class="lineNumber">1262</td>
    <td class="codeline">      return this->isOpType(CE->getOpcode()) && L.match(CE->getOperand(0)) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1263</td>
    <td class="codeline">             R.match(CE->getOperand(1));</td>
    <td class="lineNumber">1263</td>
    <td class="codeline">             R.match(CE->getOperand(1));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1264</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1264</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1265</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1265</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1266</td>
    <td class="codeline">};</td>
    <td class="lineNumber">1266</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1267</td>
    <td class="codeline"></td>
    <td class="lineNumber">1267</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1268</td>
    <td class="codeline">struct is_shift_op {</td>
    <td class="lineNumber">1268</td>
    <td class="codeline">struct is_shift_op {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1269</td>
    <td class="codeline">  bool isOpType(unsigned Opcode) { return Instruction::isShift(Opcode); }</td>
    <td class="lineNumber">1269</td>
    <td class="codeline">  bool isOpType(unsigned Opcode) { return Instruction::isShift(Opcode); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1270</td>
    <td class="codeline">};</td>
    <td class="lineNumber">1270</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1271</td>
    <td class="codeline"></td>
    <td class="lineNumber">1271</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1272</td>
    <td class="codeline">struct is_right_shift_op {</td>
    <td class="lineNumber">1272</td>
    <td class="codeline">struct is_right_shift_op {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1273</td>
    <td class="codeline">  bool isOpType(unsigned Opcode) {</td>
    <td class="lineNumber">1273</td>
    <td class="codeline">  bool isOpType(unsigned Opcode) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1274</td>
    <td class="codeline">    return Opcode == Instruction::LShr || Opcode == Instruction::AShr;</td>
    <td class="lineNumber">1274</td>
    <td class="codeline">    return Opcode == Instruction::LShr || Opcode == Instruction::AShr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1275</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1275</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1276</td>
    <td class="codeline">};</td>
    <td class="lineNumber">1276</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1277</td>
    <td class="codeline"></td>
    <td class="lineNumber">1277</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1278</td>
    <td class="codeline">struct is_logical_shift_op {</td>
    <td class="lineNumber">1278</td>
    <td class="codeline">struct is_logical_shift_op {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1279</td>
    <td class="codeline">  bool isOpType(unsigned Opcode) {</td>
    <td class="lineNumber">1279</td>
    <td class="codeline">  bool isOpType(unsigned Opcode) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1280</td>
    <td class="codeline">    return Opcode == Instruction::LShr || Opcode == Instruction::Shl;</td>
    <td class="lineNumber">1280</td>
    <td class="codeline">    return Opcode == Instruction::LShr || Opcode == Instruction::Shl;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1281</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1281</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1282</td>
    <td class="codeline">};</td>
    <td class="lineNumber">1282</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1283</td>
    <td class="codeline"></td>
    <td class="lineNumber">1283</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1284</td>
    <td class="codeline">struct is_bitwiselogic_op {</td>
    <td class="lineNumber">1284</td>
    <td class="codeline">struct is_bitwiselogic_op {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1285</td>
    <td class="codeline">  bool isOpType(unsigned Opcode) {</td>
    <td class="lineNumber">1285</td>
    <td class="codeline">  bool isOpType(unsigned Opcode) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1286</td>
    <td class="codeline">    return Instruction::isBitwiseLogicOp(Opcode);</td>
    <td class="lineNumber">1286</td>
    <td class="codeline">    return Instruction::isBitwiseLogicOp(Opcode);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1287</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1287</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1288</td>
    <td class="codeline">};</td>
    <td class="lineNumber">1288</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1289</td>
    <td class="codeline"></td>
    <td class="lineNumber">1289</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1290</td>
    <td class="codeline">struct is_idiv_op {</td>
    <td class="lineNumber">1290</td>
    <td class="codeline">struct is_idiv_op {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1291</td>
    <td class="codeline">  bool isOpType(unsigned Opcode) {</td>
    <td class="lineNumber">1291</td>
    <td class="codeline">  bool isOpType(unsigned Opcode) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1292</td>
    <td class="codeline">    return Opcode == Instruction::SDiv || Opcode == Instruction::UDiv;</td>
    <td class="lineNumber">1292</td>
    <td class="codeline">    return Opcode == Instruction::SDiv || Opcode == Instruction::UDiv;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1293</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1293</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1294</td>
    <td class="codeline">};</td>
    <td class="lineNumber">1294</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1295</td>
    <td class="codeline"></td>
    <td class="lineNumber">1295</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1296</td>
    <td class="codeline">struct is_irem_op {</td>
    <td class="lineNumber">1296</td>
    <td class="codeline">struct is_irem_op {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1297</td>
    <td class="codeline">  bool isOpType(unsigned Opcode) {</td>
    <td class="lineNumber">1297</td>
    <td class="codeline">  bool isOpType(unsigned Opcode) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1298</td>
    <td class="codeline">    return Opcode == Instruction::SRem || Opcode == Instruction::URem;</td>
    <td class="lineNumber">1298</td>
    <td class="codeline">    return Opcode == Instruction::SRem || Opcode == Instruction::URem;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1299</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1299</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1300</td>
    <td class="codeline">};</td>
    <td class="lineNumber">1300</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1301</td>
    <td class="codeline"></td>
    <td class="lineNumber">1301</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1302</td>
    <td class="codeline">/// Matches shift operations.</td>
    <td class="lineNumber">1302</td>
    <td class="codeline">/// Matches shift operations.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1303</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
    <td class="lineNumber">1303</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1304</td>
    <td class="codeline">inline BinOpPred_match<LHS, RHS, is_shift_op> m_Shift(const LHS &L,</td>
    <td class="lineNumber">1304</td>
    <td class="codeline">inline BinOpPred_match<LHS, RHS, is_shift_op> m_Shift(const LHS &L,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1305</td>
    <td class="codeline">                                                      const RHS &R) {</td>
    <td class="lineNumber">1305</td>
    <td class="codeline">                                                      const RHS &R) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1306</td>
    <td class="codeline">  return BinOpPred_match<LHS, RHS, is_shift_op>(L, R);</td>
    <td class="lineNumber">1306</td>
    <td class="codeline">  return BinOpPred_match<LHS, RHS, is_shift_op>(L, R);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1307</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1307</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1308</td>
    <td class="codeline"></td>
    <td class="lineNumber">1308</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1309</td>
    <td class="codeline">/// Matches logical shift operations.</td>
    <td class="lineNumber">1309</td>
    <td class="codeline">/// Matches logical shift operations.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1310</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
    <td class="lineNumber">1310</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1311</td>
    <td class="codeline">inline BinOpPred_match<LHS, RHS, is_right_shift_op> m_Shr(const LHS &L,</td>
    <td class="lineNumber">1311</td>
    <td class="codeline">inline BinOpPred_match<LHS, RHS, is_right_shift_op> m_Shr(const LHS &L,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1312</td>
    <td class="codeline">                                                          const RHS &R) {</td>
    <td class="lineNumber">1312</td>
    <td class="codeline">                                                          const RHS &R) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1313</td>
    <td class="codeline">  return BinOpPred_match<LHS, RHS, is_right_shift_op>(L, R);</td>
    <td class="lineNumber">1313</td>
    <td class="codeline">  return BinOpPred_match<LHS, RHS, is_right_shift_op>(L, R);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1314</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1314</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1315</td>
    <td class="codeline"></td>
    <td class="lineNumber">1315</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1316</td>
    <td class="codeline">/// Matches logical shift operations.</td>
    <td class="lineNumber">1316</td>
    <td class="codeline">/// Matches logical shift operations.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1317</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
    <td class="lineNumber">1317</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1318</td>
    <td class="codeline">inline BinOpPred_match<LHS, RHS, is_logical_shift_op></td>
    <td class="lineNumber">1318</td>
    <td class="codeline">inline BinOpPred_match<LHS, RHS, is_logical_shift_op></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1319</td>
    <td class="codeline">m_LogicalShift(const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">1319</td>
    <td class="codeline">m_LogicalShift(const LHS &L, const RHS &R) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1320</td>
    <td class="codeline">  return BinOpPred_match<LHS, RHS, is_logical_shift_op>(L, R);</td>
    <td class="lineNumber">1320</td>
    <td class="codeline">  return BinOpPred_match<LHS, RHS, is_logical_shift_op>(L, R);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1321</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1321</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1322</td>
    <td class="codeline"></td>
    <td class="lineNumber">1322</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1323</td>
    <td class="codeline">/// Matches bitwise logic operations.</td>
    <td class="lineNumber">1323</td>
    <td class="codeline">/// Matches bitwise logic operations.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1324</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
    <td class="lineNumber">1324</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1325</td>
    <td class="codeline">inline BinOpPred_match<LHS, RHS, is_bitwiselogic_op></td>
    <td class="lineNumber">1325</td>
    <td class="codeline">inline BinOpPred_match<LHS, RHS, is_bitwiselogic_op></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1326</td>
    <td class="codeline">m_BitwiseLogic(const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">1326</td>
    <td class="codeline">m_BitwiseLogic(const LHS &L, const RHS &R) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1327</td>
    <td class="codeline">  return BinOpPred_match<LHS, RHS, is_bitwiselogic_op>(L, R);</td>
    <td class="lineNumber">1327</td>
    <td class="codeline">  return BinOpPred_match<LHS, RHS, is_bitwiselogic_op>(L, R);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1328</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1328</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1329</td>
    <td class="codeline"></td>
    <td class="lineNumber">1329</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1330</td>
    <td class="codeline">/// Matches integer division operations.</td>
    <td class="lineNumber">1330</td>
    <td class="codeline">/// Matches integer division operations.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1331</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
    <td class="lineNumber">1331</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1332</td>
    <td class="codeline">inline BinOpPred_match<LHS, RHS, is_idiv_op> m_IDiv(const LHS &L,</td>
    <td class="lineNumber">1332</td>
    <td class="codeline">inline BinOpPred_match<LHS, RHS, is_idiv_op> m_IDiv(const LHS &L,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1333</td>
    <td class="codeline">                                                    const RHS &R) {</td>
    <td class="lineNumber">1333</td>
    <td class="codeline">                                                    const RHS &R) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1334</td>
    <td class="codeline">  return BinOpPred_match<LHS, RHS, is_idiv_op>(L, R);</td>
    <td class="lineNumber">1334</td>
    <td class="codeline">  return BinOpPred_match<LHS, RHS, is_idiv_op>(L, R);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1335</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1335</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1336</td>
    <td class="codeline"></td>
    <td class="lineNumber">1336</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1337</td>
    <td class="codeline">/// Matches integer remainder operations.</td>
    <td class="lineNumber">1337</td>
    <td class="codeline">/// Matches integer remainder operations.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1338</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
    <td class="lineNumber">1338</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1339</td>
    <td class="codeline">inline BinOpPred_match<LHS, RHS, is_irem_op> m_IRem(const LHS &L,</td>
    <td class="lineNumber">1339</td>
    <td class="codeline">inline BinOpPred_match<LHS, RHS, is_irem_op> m_IRem(const LHS &L,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1340</td>
    <td class="codeline">                                                    const RHS &R) {</td>
    <td class="lineNumber">1340</td>
    <td class="codeline">                                                    const RHS &R) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1341</td>
    <td class="codeline">  return BinOpPred_match<LHS, RHS, is_irem_op>(L, R);</td>
    <td class="lineNumber">1341</td>
    <td class="codeline">  return BinOpPred_match<LHS, RHS, is_irem_op>(L, R);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1342</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1342</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1343</td>
    <td class="codeline"></td>
    <td class="lineNumber">1343</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1344</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">1344</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1345</td>
    <td class="codeline">// Class that matches exact binary ops.</td>
    <td class="lineNumber">1345</td>
    <td class="codeline">// Class that matches exact binary ops.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1346</td>
    <td class="codeline">//</td>
    <td class="lineNumber">1346</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1347</td>
    <td class="codeline">template <typename SubPattern_t> struct Exact_match {</td>
    <td class="lineNumber">1347</td>
    <td class="codeline">template <typename SubPattern_t> struct Exact_match {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1348</td>
    <td class="codeline">  SubPattern_t SubPattern;</td>
    <td class="lineNumber">1348</td>
    <td class="codeline">  SubPattern_t SubPattern;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1349</td>
    <td class="codeline"></td>
    <td class="lineNumber">1349</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1350</td>
    <td class="codeline">  Exact_match(const SubPattern_t &SP) : SubPattern(SP) {}</td>
    <td class="lineNumber">1350</td>
    <td class="codeline">  Exact_match(const SubPattern_t &SP) : SubPattern(SP) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1351</td>
    <td class="codeline"></td>
    <td class="lineNumber">1351</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1352</td>
    <td class="codeline">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td class="lineNumber">1352</td>
    <td class="codeline">  template <typename OpTy> bool match(OpTy *V) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1353</td>
    <td class="codeline">    if (auto *PEO = dyn_cast<PossiblyExactOperator>(V))</td>
    <td class="lineNumber">1353</td>
    <td class="codeline">    if (auto *PEO = dyn_cast<PossiblyExactOperator>(V))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1354</td>
    <td class="codeline">      return PEO->isExact() && SubPattern.match(V);</td>
    <td class="lineNumber">1354</td>
    <td class="codeline">      return PEO->isExact() && SubPattern.match(V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1355</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1355</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1356</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1356</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1357</td>
    <td class="codeline">};</td>
    <td class="lineNumber">1357</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1358</td>
    <td class="codeline"></td>
    <td class="lineNumber">1358</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1359</td>
    <td class="codeline">template <typename T> inline Exact_match<T> m_Exact(const T &SubPattern) {</td>
    <td class="lineNumber">1359</td>
    <td class="codeline">template <typename T> inline Exact_match<T> m_Exact(const T &SubPattern) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1360</td>
    <td class="codeline">  return SubPattern;</td>
    <td class="lineNumber">1360</td>
    <td class="codeline">  return SubPattern;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1361</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1361</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1362</td>
    <td class="codeline"></td>
    <td class="lineNumber">1362</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1363</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">1363</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1364</td>
    <td class="codeline">// Matchers for CmpInst classes</td>
    <td class="lineNumber">1364</td>
    <td class="codeline">// Matchers for CmpInst classes</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1365</td>
    <td class="codeline">//</td>
    <td class="lineNumber">1365</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1366</td>
    <td class="codeline"></td>
    <td class="lineNumber">1366</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1367</td>
    <td class="codeline">template <typename LHS_t, typename RHS_t, typename Class, typename PredicateTy,</td>
    <td class="lineNumber">1367</td>
    <td class="codeline">template <typename LHS_t, typename RHS_t, typename Class, typename PredicateTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1368</td>
    <td class="codeline">          bool Commutable = false></td>
    <td class="lineNumber">1368</td>
    <td class="codeline">          bool Commutable = false></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1369</td>
    <td class="codeline">struct CmpClass_match {</td>
    <td class="lineNumber">1369</td>
    <td class="codeline">struct CmpClass_match {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1370</td>
    <td class="codeline">  PredicateTy &Predicate;</td>
    <td class="lineNumber">1370</td>
    <td class="codeline">  PredicateTy &Predicate;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1371</td>
    <td class="codeline">  LHS_t L;</td>
    <td class="lineNumber">1371</td>
    <td class="codeline">  LHS_t L;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1372</td>
    <td class="codeline">  RHS_t R;</td>
    <td class="lineNumber">1372</td>
    <td class="codeline">  RHS_t R;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1373</td>
    <td class="codeline"></td>
    <td class="lineNumber">1373</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1374</td>
    <td class="codeline">  // The evaluation order is always stable, regardless of Commutability.</td>
    <td class="lineNumber">1374</td>
    <td class="codeline">  // The evaluation order is always stable, regardless of Commutability.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1375</td>
    <td class="codeline">  // The LHS is always matched first.</td>
    <td class="lineNumber">1375</td>
    <td class="codeline">  // The LHS is always matched first.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1376</td>
    <td class="codeline">  CmpClass_match(PredicateTy &Pred, const LHS_t &LHS, const RHS_t &RHS)</td>
    <td class="lineNumber">1376</td>
    <td class="codeline">  CmpClass_match(PredicateTy &Pred, const LHS_t &LHS, const RHS_t &RHS)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1377</td>
    <td class="codeline">      : Predicate(Pred), L(LHS), R(RHS) {}</td>
    <td class="lineNumber">1377</td>
    <td class="codeline">      : Predicate(Pred), L(LHS), R(RHS) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1378</td>
    <td class="codeline"></td>
    <td class="lineNumber">1378</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1379</td>
    <td class="codeline">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td class="lineNumber">1379</td>
    <td class="codeline">  template <typename OpTy> bool match(OpTy *V) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1380</td>
    <td class="codeline">    if (auto *I = dyn_cast<Class>(V)) {</td>
    <td class="lineNumber">1380</td>
    <td class="codeline">    if (auto *I = dyn_cast<Class>(V)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1381</td>
    <td class="codeline">      if (L.match(I->getOperand(0)) && R.match(I->getOperand(1))) {</td>
    <td class="lineNumber">1381</td>
    <td class="codeline">      if (L.match(I->getOperand(0)) && R.match(I->getOperand(1))) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1382</td>
    <td class="codeline">        Predicate = I->getPredicate();</td>
    <td class="lineNumber">1382</td>
    <td class="codeline">        Predicate = I->getPredicate();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1383</td>
    <td class="codeline">        return true;</td>
    <td class="lineNumber">1383</td>
    <td class="codeline">        return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1384</td>
    <td class="codeline">      } else if (Commutable && L.match(I->getOperand(1)) &&</td>
    <td class="lineNumber">1384</td>
    <td class="codeline">      } else if (Commutable && L.match(I->getOperand(1)) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1385</td>
    <td class="codeline">                 R.match(I->getOperand(0))) {</td>
    <td class="lineNumber">1385</td>
    <td class="codeline">                 R.match(I->getOperand(0))) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1386</td>
    <td class="codeline">        Predicate = I->getSwappedPredicate();</td>
    <td class="lineNumber">1386</td>
    <td class="codeline">        Predicate = I->getSwappedPredicate();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1387</td>
    <td class="codeline">        return true;</td>
    <td class="lineNumber">1387</td>
    <td class="codeline">        return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1388</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1388</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1389</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1389</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1390</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1390</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1391</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1391</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1392</td>
    <td class="codeline">};</td>
    <td class="lineNumber">1392</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1393</td>
    <td class="codeline"></td>
    <td class="lineNumber">1393</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1394</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
    <td class="lineNumber">1394</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1395</td>
    <td class="codeline">inline CmpClass_match<LHS, RHS, CmpInst, CmpInst::Predicate></td>
    <td class="lineNumber">1395</td>
    <td class="codeline">inline CmpClass_match<LHS, RHS, CmpInst, CmpInst::Predicate></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1396</td>
    <td class="codeline">m_Cmp(CmpInst::Predicate &Pred, const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">1396</td>
    <td class="codeline">m_Cmp(CmpInst::Predicate &Pred, const LHS &L, const RHS &R) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1397</td>
    <td class="codeline">  return CmpClass_match<LHS, RHS, CmpInst, CmpInst::Predicate>(Pred, L, R);</td>
    <td class="lineNumber">1397</td>
    <td class="codeline">  return CmpClass_match<LHS, RHS, CmpInst, CmpInst::Predicate>(Pred, L, R);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1398</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1398</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1399</td>
    <td class="codeline"></td>
    <td class="lineNumber">1399</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1400</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
    <td class="lineNumber">1400</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1401</td>
    <td class="codeline">inline CmpClass_match<LHS, RHS, ICmpInst, ICmpInst::Predicate></td>
    <td class="lineNumber">1401</td>
    <td class="codeline">inline CmpClass_match<LHS, RHS, ICmpInst, ICmpInst::Predicate></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1402</td>
    <td class="codeline">m_ICmp(ICmpInst::Predicate &Pred, const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">1402</td>
    <td class="codeline">m_ICmp(ICmpInst::Predicate &Pred, const LHS &L, const RHS &R) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1403</td>
    <td class="codeline">  return CmpClass_match<LHS, RHS, ICmpInst, ICmpInst::Predicate>(Pred, L, R);</td>
    <td class="lineNumber">1403</td>
    <td class="codeline">  return CmpClass_match<LHS, RHS, ICmpInst, ICmpInst::Predicate>(Pred, L, R);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1404</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1404</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1405</td>
    <td class="codeline"></td>
    <td class="lineNumber">1405</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1406</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
    <td class="lineNumber">1406</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1407</td>
    <td class="codeline">inline CmpClass_match<LHS, RHS, FCmpInst, FCmpInst::Predicate></td>
    <td class="lineNumber">1407</td>
    <td class="codeline">inline CmpClass_match<LHS, RHS, FCmpInst, FCmpInst::Predicate></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1408</td>
    <td class="codeline">m_FCmp(FCmpInst::Predicate &Pred, const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">1408</td>
    <td class="codeline">m_FCmp(FCmpInst::Predicate &Pred, const LHS &L, const RHS &R) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1409</td>
    <td class="codeline">  return CmpClass_match<LHS, RHS, FCmpInst, FCmpInst::Predicate>(Pred, L, R);</td>
    <td class="lineNumber">1409</td>
    <td class="codeline">  return CmpClass_match<LHS, RHS, FCmpInst, FCmpInst::Predicate>(Pred, L, R);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1410</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1410</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1411</td>
    <td class="codeline"></td>
    <td class="lineNumber">1411</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1412</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">1412</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1413</td>
    <td class="codeline">// Matchers for instructions with a given opcode and number of operands.</td>
    <td class="lineNumber">1413</td>
    <td class="codeline">// Matchers for instructions with a given opcode and number of operands.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1414</td>
    <td class="codeline">//</td>
    <td class="lineNumber">1414</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1415</td>
    <td class="codeline"></td>
    <td class="lineNumber">1415</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1416</td>
    <td class="codeline">/// Matches instructions with Opcode and three operands.</td>
    <td class="lineNumber">1416</td>
    <td class="codeline">/// Matches instructions with Opcode and three operands.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1417</td>
    <td class="codeline">template <typename T0, unsigned Opcode> struct OneOps_match {</td>
    <td class="lineNumber">1417</td>
    <td class="codeline">template <typename T0, unsigned Opcode> struct OneOps_match {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1418</td>
    <td class="codeline">  T0 Op1;</td>
    <td class="lineNumber">1418</td>
    <td class="codeline">  T0 Op1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1419</td>
    <td class="codeline"></td>
    <td class="lineNumber">1419</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1420</td>
    <td class="codeline">  OneOps_match(const T0 &Op1) : Op1(Op1) {}</td>
    <td class="lineNumber">1420</td>
    <td class="codeline">  OneOps_match(const T0 &Op1) : Op1(Op1) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1421</td>
    <td class="codeline"></td>
    <td class="lineNumber">1421</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1422</td>
    <td class="codeline">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td class="lineNumber">1422</td>
    <td class="codeline">  template <typename OpTy> bool match(OpTy *V) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1423</td>
    <td class="codeline">    if (V->getValueID() == Value::InstructionVal + Opcode) {</td>
    <td class="lineNumber">1423</td>
    <td class="codeline">    if (V->getValueID() == Value::InstructionVal + Opcode) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1424</td>
    <td class="codeline">      auto *I = cast<Instruction>(V);</td>
    <td class="lineNumber">1424</td>
    <td class="codeline">      auto *I = cast<Instruction>(V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1425</td>
    <td class="codeline">      return Op1.match(I->getOperand(0));</td>
    <td class="lineNumber">1425</td>
    <td class="codeline">      return Op1.match(I->getOperand(0));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1426</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1426</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1427</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1427</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1428</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1428</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1429</td>
    <td class="codeline">};</td>
    <td class="lineNumber">1429</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1430</td>
    <td class="codeline"></td>
    <td class="lineNumber">1430</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1431</td>
    <td class="codeline">/// Matches instructions with Opcode and three operands.</td>
    <td class="lineNumber">1431</td>
    <td class="codeline">/// Matches instructions with Opcode and three operands.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1432</td>
    <td class="codeline">template <typename T0, typename T1, unsigned Opcode> struct TwoOps_match {</td>
    <td class="lineNumber">1432</td>
    <td class="codeline">template <typename T0, typename T1, unsigned Opcode> struct TwoOps_match {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1433</td>
    <td class="codeline">  T0 Op1;</td>
    <td class="lineNumber">1433</td>
    <td class="codeline">  T0 Op1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1434</td>
    <td class="codeline">  T1 Op2;</td>
    <td class="lineNumber">1434</td>
    <td class="codeline">  T1 Op2;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1435</td>
    <td class="codeline"></td>
    <td class="lineNumber">1435</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1436</td>
    <td class="codeline">  TwoOps_match(const T0 &Op1, const T1 &Op2) : Op1(Op1), Op2(Op2) {}</td>
    <td class="lineNumber">1436</td>
    <td class="codeline">  TwoOps_match(const T0 &Op1, const T1 &Op2) : Op1(Op1), Op2(Op2) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1437</td>
    <td class="codeline"></td>
    <td class="lineNumber">1437</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1438</td>
    <td class="codeline">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td class="lineNumber">1438</td>
    <td class="codeline">  template <typename OpTy> bool match(OpTy *V) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1439</td>
    <td class="codeline">    if (V->getValueID() == Value::InstructionVal + Opcode) {</td>
    <td class="lineNumber">1439</td>
    <td class="codeline">    if (V->getValueID() == Value::InstructionVal + Opcode) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1440</td>
    <td class="codeline">      auto *I = cast<Instruction>(V);</td>
    <td class="lineNumber">1440</td>
    <td class="codeline">      auto *I = cast<Instruction>(V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1441</td>
    <td class="codeline">      return Op1.match(I->getOperand(0)) && Op2.match(I->getOperand(1));</td>
    <td class="lineNumber">1441</td>
    <td class="codeline">      return Op1.match(I->getOperand(0)) && Op2.match(I->getOperand(1));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1442</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1442</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1443</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1443</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1444</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1444</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1445</td>
    <td class="codeline">};</td>
    <td class="lineNumber">1445</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1446</td>
    <td class="codeline"></td>
    <td class="lineNumber">1446</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1447</td>
    <td class="codeline">/// Matches instructions with Opcode and three operands.</td>
    <td class="lineNumber">1447</td>
    <td class="codeline">/// Matches instructions with Opcode and three operands.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1448</td>
    <td class="codeline">template <typename T0, typename T1, typename T2, unsigned Opcode></td>
    <td class="lineNumber">1448</td>
    <td class="codeline">template <typename T0, typename T1, typename T2, unsigned Opcode></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1449</td>
    <td class="codeline">struct ThreeOps_match {</td>
    <td class="lineNumber">1449</td>
    <td class="codeline">struct ThreeOps_match {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1450</td>
    <td class="codeline">  T0 Op1;</td>
    <td class="lineNumber">1450</td>
    <td class="codeline">  T0 Op1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1451</td>
    <td class="codeline">  T1 Op2;</td>
    <td class="lineNumber">1451</td>
    <td class="codeline">  T1 Op2;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1452</td>
    <td class="codeline">  T2 Op3;</td>
    <td class="lineNumber">1452</td>
    <td class="codeline">  T2 Op3;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1453</td>
    <td class="codeline"></td>
    <td class="lineNumber">1453</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1454</td>
    <td class="codeline">  ThreeOps_match(const T0 &Op1, const T1 &Op2, const T2 &Op3)</td>
    <td class="lineNumber">1454</td>
    <td class="codeline">  ThreeOps_match(const T0 &Op1, const T1 &Op2, const T2 &Op3)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1455</td>
    <td class="codeline">      : Op1(Op1), Op2(Op2), Op3(Op3) {}</td>
    <td class="lineNumber">1455</td>
    <td class="codeline">      : Op1(Op1), Op2(Op2), Op3(Op3) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1456</td>
    <td class="codeline"></td>
    <td class="lineNumber">1456</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1457</td>
    <td class="codeline">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td class="lineNumber">1457</td>
    <td class="codeline">  template <typename OpTy> bool match(OpTy *V) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1458</td>
    <td class="codeline">    if (V->getValueID() == Value::InstructionVal + Opcode) {</td>
    <td class="lineNumber">1458</td>
    <td class="codeline">    if (V->getValueID() == Value::InstructionVal + Opcode) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1459</td>
    <td class="codeline">      auto *I = cast<Instruction>(V);</td>
    <td class="lineNumber">1459</td>
    <td class="codeline">      auto *I = cast<Instruction>(V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1460</td>
    <td class="codeline">      return Op1.match(I->getOperand(0)) && Op2.match(I->getOperand(1)) &&</td>
    <td class="lineNumber">1460</td>
    <td class="codeline">      return Op1.match(I->getOperand(0)) && Op2.match(I->getOperand(1)) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1461</td>
    <td class="codeline">             Op3.match(I->getOperand(2));</td>
    <td class="lineNumber">1461</td>
    <td class="codeline">             Op3.match(I->getOperand(2));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1462</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1462</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1463</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1463</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1464</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1464</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1465</td>
    <td class="codeline">};</td>
    <td class="lineNumber">1465</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1466</td>
    <td class="codeline"></td>
    <td class="lineNumber">1466</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1467</td>
    <td class="codeline">/// Matches SelectInst.</td>
    <td class="lineNumber">1467</td>
    <td class="codeline">/// Matches SelectInst.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1468</td>
    <td class="codeline">template <typename Cond, typename LHS, typename RHS></td>
    <td class="lineNumber">1468</td>
    <td class="codeline">template <typename Cond, typename LHS, typename RHS></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1469</td>
    <td class="codeline">inline ThreeOps_match<Cond, LHS, RHS, Instruction::Select></td>
    <td class="lineNumber">1469</td>
    <td class="codeline">inline ThreeOps_match<Cond, LHS, RHS, Instruction::Select></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1470</td>
    <td class="codeline">m_Select(const Cond &C, const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">1470</td>
    <td class="codeline">m_Select(const Cond &C, const LHS &L, const RHS &R) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1471</td>
    <td class="codeline">  return ThreeOps_match<Cond, LHS, RHS, Instruction::Select>(C, L, R);</td>
    <td class="lineNumber">1471</td>
    <td class="codeline">  return ThreeOps_match<Cond, LHS, RHS, Instruction::Select>(C, L, R);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1472</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1472</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1473</td>
    <td class="codeline"></td>
    <td class="lineNumber">1473</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1474</td>
    <td class="codeline">/// This matches a select of two constants, e.g.:</td>
    <td class="lineNumber">1474</td>
    <td class="codeline">/// This matches a select of two constants, e.g.:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1475</td>
    <td class="codeline">/// m_SelectCst<-1, 0>(m_Value(V))</td>
    <td class="lineNumber">1475</td>
    <td class="codeline">/// m_SelectCst<-1, 0>(m_Value(V))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1476</td>
    <td class="codeline">template <int64_t L, int64_t R, typename Cond></td>
    <td class="lineNumber">1476</td>
    <td class="codeline">template <int64_t L, int64_t R, typename Cond></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1477</td>
    <td class="codeline">inline ThreeOps_match<Cond, constantint_match<L>, constantint_match<R>,</td>
    <td class="lineNumber">1477</td>
    <td class="codeline">inline ThreeOps_match<Cond, constantint_match<L>, constantint_match<R>,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1478</td>
    <td class="codeline">                      Instruction::Select></td>
    <td class="lineNumber">1478</td>
    <td class="codeline">                      Instruction::Select></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1479</td>
    <td class="codeline">m_SelectCst(const Cond &C) {</td>
    <td class="lineNumber">1479</td>
    <td class="codeline">m_SelectCst(const Cond &C) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1480</td>
    <td class="codeline">  return m_Select(C, m_ConstantInt<L>(), m_ConstantInt<R>());</td>
    <td class="lineNumber">1480</td>
    <td class="codeline">  return m_Select(C, m_ConstantInt<L>(), m_ConstantInt<R>());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1481</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1481</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1482</td>
    <td class="codeline"></td>
    <td class="lineNumber">1482</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1483</td>
    <td class="codeline">/// Matches FreezeInst.</td>
    <td class="lineNumber">1483</td>
    <td class="codeline">/// Matches FreezeInst.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1484</td>
    <td class="codeline">template <typename OpTy></td>
    <td class="lineNumber">1484</td>
    <td class="codeline">template <typename OpTy></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1485</td>
    <td class="codeline">inline OneOps_match<OpTy, Instruction::Freeze> m_Freeze(const OpTy &Op) {</td>
    <td class="lineNumber">1485</td>
    <td class="codeline">inline OneOps_match<OpTy, Instruction::Freeze> m_Freeze(const OpTy &Op) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1486</td>
    <td class="codeline">  return OneOps_match<OpTy, Instruction::Freeze>(Op);</td>
    <td class="lineNumber">1486</td>
    <td class="codeline">  return OneOps_match<OpTy, Instruction::Freeze>(Op);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1487</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1487</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1488</td>
    <td class="codeline"></td>
    <td class="lineNumber">1488</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1489</td>
    <td class="codeline">/// Matches InsertElementInst.</td>
    <td class="lineNumber">1489</td>
    <td class="codeline">/// Matches InsertElementInst.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1490</td>
    <td class="codeline">template <typename Val_t, typename Elt_t, typename Idx_t></td>
    <td class="lineNumber">1490</td>
    <td class="codeline">template <typename Val_t, typename Elt_t, typename Idx_t></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1491</td>
    <td class="codeline">inline ThreeOps_match<Val_t, Elt_t, Idx_t, Instruction::InsertElement></td>
    <td class="lineNumber">1491</td>
    <td class="codeline">inline ThreeOps_match<Val_t, Elt_t, Idx_t, Instruction::InsertElement></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1492</td>
    <td class="codeline">m_InsertElt(const Val_t &Val, const Elt_t &Elt, const Idx_t &Idx) {</td>
    <td class="lineNumber">1492</td>
    <td class="codeline">m_InsertElt(const Val_t &Val, const Elt_t &Elt, const Idx_t &Idx) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1493</td>
    <td class="codeline">  return ThreeOps_match<Val_t, Elt_t, Idx_t, Instruction::InsertElement>(</td>
    <td class="lineNumber">1493</td>
    <td class="codeline">  return ThreeOps_match<Val_t, Elt_t, Idx_t, Instruction::InsertElement>(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1494</td>
    <td class="codeline">      Val, Elt, Idx);</td>
    <td class="lineNumber">1494</td>
    <td class="codeline">      Val, Elt, Idx);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1495</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1495</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1496</td>
    <td class="codeline"></td>
    <td class="lineNumber">1496</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1497</td>
    <td class="codeline">/// Matches ExtractElementInst.</td>
    <td class="lineNumber">1497</td>
    <td class="codeline">/// Matches ExtractElementInst.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1498</td>
    <td class="codeline">template <typename Val_t, typename Idx_t></td>
    <td class="lineNumber">1498</td>
    <td class="codeline">template <typename Val_t, typename Idx_t></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1499</td>
    <td class="codeline">inline TwoOps_match<Val_t, Idx_t, Instruction::ExtractElement></td>
    <td class="lineNumber">1499</td>
    <td class="codeline">inline TwoOps_match<Val_t, Idx_t, Instruction::ExtractElement></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1500</td>
    <td class="codeline">m_ExtractElt(const Val_t &Val, const Idx_t &Idx) {</td>
    <td class="lineNumber">1500</td>
    <td class="codeline">m_ExtractElt(const Val_t &Val, const Idx_t &Idx) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1501</td>
    <td class="codeline">  return TwoOps_match<Val_t, Idx_t, Instruction::ExtractElement>(Val, Idx);</td>
    <td class="lineNumber">1501</td>
    <td class="codeline">  return TwoOps_match<Val_t, Idx_t, Instruction::ExtractElement>(Val, Idx);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1502</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1502</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1503</td>
    <td class="codeline"></td>
    <td class="lineNumber">1503</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1504</td>
    <td class="codeline">/// Matches shuffle.</td>
    <td class="lineNumber">1504</td>
    <td class="codeline">/// Matches shuffle.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1505</td>
    <td class="codeline">template <typename T0, typename T1, typename T2> struct Shuffle_match {</td>
    <td class="lineNumber">1505</td>
    <td class="codeline">template <typename T0, typename T1, typename T2> struct Shuffle_match {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1506</td>
    <td class="codeline">  T0 Op1;</td>
    <td class="lineNumber">1506</td>
    <td class="codeline">  T0 Op1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1507</td>
    <td class="codeline">  T1 Op2;</td>
    <td class="lineNumber">1507</td>
    <td class="codeline">  T1 Op2;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1508</td>
    <td class="codeline">  T2 Mask;</td>
    <td class="lineNumber">1508</td>
    <td class="codeline">  T2 Mask;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1509</td>
    <td class="codeline"></td>
    <td class="lineNumber">1509</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1510</td>
    <td class="codeline">  Shuffle_match(const T0 &Op1, const T1 &Op2, const T2 &Mask)</td>
    <td class="lineNumber">1510</td>
    <td class="codeline">  Shuffle_match(const T0 &Op1, const T1 &Op2, const T2 &Mask)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1511</td>
    <td class="codeline">      : Op1(Op1), Op2(Op2), Mask(Mask) {}</td>
    <td class="lineNumber">1511</td>
    <td class="codeline">      : Op1(Op1), Op2(Op2), Mask(Mask) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1512</td>
    <td class="codeline"></td>
    <td class="lineNumber">1512</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1513</td>
    <td class="codeline">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td class="lineNumber">1513</td>
    <td class="codeline">  template <typename OpTy> bool match(OpTy *V) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1514</td>
    <td class="codeline">    if (auto *I = dyn_cast<ShuffleVectorInst>(V)) {</td>
    <td class="lineNumber">1514</td>
    <td class="codeline">    if (auto *I = dyn_cast<ShuffleVectorInst>(V)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1515</td>
    <td class="codeline">      return Op1.match(I->getOperand(0)) && Op2.match(I->getOperand(1)) &&</td>
    <td class="lineNumber">1515</td>
    <td class="codeline">      return Op1.match(I->getOperand(0)) && Op2.match(I->getOperand(1)) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1516</td>
    <td class="codeline">             Mask.match(I->getShuffleMask());</td>
    <td class="lineNumber">1516</td>
    <td class="codeline">             Mask.match(I->getShuffleMask());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1517</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1517</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1518</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1518</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1519</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1519</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1520</td>
    <td class="codeline">};</td>
    <td class="lineNumber">1520</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1521</td>
    <td class="codeline"></td>
    <td class="lineNumber">1521</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1522</td>
    <td class="codeline">struct m_Mask {</td>
    <td class="lineNumber">1522</td>
    <td class="codeline">struct m_Mask {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1523</td>
    <td class="codeline">  ArrayRef<int> &MaskRef;</td>
    <td class="lineNumber">1523</td>
    <td class="codeline">  ArrayRef<int> &MaskRef;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1524</td>
    <td class="codeline">  m_Mask(ArrayRef<int> &MaskRef) : MaskRef(MaskRef) {}</td>
    <td class="lineNumber">1524</td>
    <td class="codeline">  m_Mask(ArrayRef<int> &MaskRef) : MaskRef(MaskRef) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1525</td>
    <td class="codeline">  bool match(ArrayRef<int> Mask) {</td>
    <td class="lineNumber">1525</td>
    <td class="codeline">  bool match(ArrayRef<int> Mask) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1526</td>
    <td class="codeline">    MaskRef = Mask;</td>
    <td class="lineNumber">1526</td>
    <td class="codeline">    MaskRef = Mask;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1527</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">1527</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1528</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1528</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1529</td>
    <td class="codeline">};</td>
    <td class="lineNumber">1529</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1530</td>
    <td class="codeline"></td>
    <td class="lineNumber">1530</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1531</td>
    <td class="codeline">struct m_ZeroMask {</td>
    <td class="lineNumber">1531</td>
    <td class="codeline">struct m_ZeroMask {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1532</td>
    <td class="codeline">  bool match(ArrayRef<int> Mask) {</td>
    <td class="lineNumber">1532</td>
    <td class="codeline">  bool match(ArrayRef<int> Mask) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1533</td>
    <td class="codeline">    return all_of(Mask, [](int Elem) { return Elem == 0 || Elem == -1; });</td>
    <td class="lineNumber">1533</td>
    <td class="codeline">    return all_of(Mask, [](int Elem) { return Elem == 0 || Elem == -1; });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1534</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1534</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1535</td>
    <td class="codeline">};</td>
    <td class="lineNumber">1535</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1536</td>
    <td class="codeline"></td>
    <td class="lineNumber">1536</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1537</td>
    <td class="codeline">struct m_SpecificMask {</td>
    <td class="lineNumber">1537</td>
    <td class="codeline">struct m_SpecificMask {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1538</td>
    <td class="codeline">  ArrayRef<int> &MaskRef;</td>
    <td class="lineNumber">1538</td>
    <td class="codeline">  ArrayRef<int> &MaskRef;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1539</td>
    <td class="codeline">  m_SpecificMask(ArrayRef<int> &MaskRef) : MaskRef(MaskRef) {}</td>
    <td class="lineNumber">1539</td>
    <td class="codeline">  m_SpecificMask(ArrayRef<int> &MaskRef) : MaskRef(MaskRef) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1540</td>
    <td class="codeline">  bool match(ArrayRef<int> Mask) { return MaskRef == Mask; }</td>
    <td class="lineNumber">1540</td>
    <td class="codeline">  bool match(ArrayRef<int> Mask) { return MaskRef == Mask; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1541</td>
    <td class="codeline">};</td>
    <td class="lineNumber">1541</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1542</td>
    <td class="codeline"></td>
    <td class="lineNumber">1542</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1543</td>
    <td class="codeline">struct m_SplatOrUndefMask {</td>
    <td class="lineNumber">1543</td>
    <td class="codeline">struct m_SplatOrUndefMask {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1544</td>
    <td class="codeline">  int &SplatIndex;</td>
    <td class="lineNumber">1544</td>
    <td class="codeline">  int &SplatIndex;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1545</td>
    <td class="codeline">  m_SplatOrUndefMask(int &SplatIndex) : SplatIndex(SplatIndex) {}</td>
    <td class="lineNumber">1545</td>
    <td class="codeline">  m_SplatOrUndefMask(int &SplatIndex) : SplatIndex(SplatIndex) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1546</td>
    <td class="codeline">  bool match(ArrayRef<int> Mask) {</td>
    <td class="lineNumber">1546</td>
    <td class="codeline">  bool match(ArrayRef<int> Mask) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1547</td>
    <td class="codeline">    const auto *First = find_if(Mask, [](int Elem) { return Elem != -1; });</td>
    <td class="lineNumber">1547</td>
    <td class="codeline">    const auto *First = find_if(Mask, [](int Elem) { return Elem != -1; });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1548</td>
    <td class="codeline">    if (First == Mask.end())</td>
    <td class="lineNumber">1548</td>
    <td class="codeline">    if (First == Mask.end())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1549</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">1549</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1550</td>
    <td class="codeline">    SplatIndex = *First;</td>
    <td class="lineNumber">1550</td>
    <td class="codeline">    SplatIndex = *First;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1551</td>
    <td class="codeline">    return all_of(Mask,</td>
    <td class="lineNumber">1551</td>
    <td class="codeline">    return all_of(Mask,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1552</td>
    <td class="codeline">                  [First](int Elem) { return Elem == *First || Elem == -1; });</td>
    <td class="lineNumber">1552</td>
    <td class="codeline">                  [First](int Elem) { return Elem == *First || Elem == -1; });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1553</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1553</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1554</td>
    <td class="codeline">};</td>
    <td class="lineNumber">1554</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1555</td>
    <td class="codeline"></td>
    <td class="lineNumber">1555</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1556</td>
    <td class="codeline">/// Matches ShuffleVectorInst independently of mask value.</td>
    <td class="lineNumber">1556</td>
    <td class="codeline">/// Matches ShuffleVectorInst independently of mask value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1557</td>
    <td class="codeline">template <typename V1_t, typename V2_t></td>
    <td class="lineNumber">1557</td>
    <td class="codeline">template <typename V1_t, typename V2_t></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1558</td>
    <td class="codeline">inline TwoOps_match<V1_t, V2_t, Instruction::ShuffleVector></td>
    <td class="lineNumber">1558</td>
    <td class="codeline">inline TwoOps_match<V1_t, V2_t, Instruction::ShuffleVector></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1559</td>
    <td class="codeline">m_Shuffle(const V1_t &v1, const V2_t &v2) {</td>
    <td class="lineNumber">1559</td>
    <td class="codeline">m_Shuffle(const V1_t &v1, const V2_t &v2) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1560</td>
    <td class="codeline">  return TwoOps_match<V1_t, V2_t, Instruction::ShuffleVector>(v1, v2);</td>
    <td class="lineNumber">1560</td>
    <td class="codeline">  return TwoOps_match<V1_t, V2_t, Instruction::ShuffleVector>(v1, v2);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1561</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1561</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1562</td>
    <td class="codeline"></td>
    <td class="lineNumber">1562</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1563</td>
    <td class="codeline">template <typename V1_t, typename V2_t, typename Mask_t></td>
    <td class="lineNumber">1563</td>
    <td class="codeline">template <typename V1_t, typename V2_t, typename Mask_t></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1564</td>
    <td class="codeline">inline Shuffle_match<V1_t, V2_t, Mask_t></td>
    <td class="lineNumber">1564</td>
    <td class="codeline">inline Shuffle_match<V1_t, V2_t, Mask_t></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1565</td>
    <td class="codeline">m_Shuffle(const V1_t &v1, const V2_t &v2, const Mask_t &mask) {</td>
    <td class="lineNumber">1565</td>
    <td class="codeline">m_Shuffle(const V1_t &v1, const V2_t &v2, const Mask_t &mask) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1566</td>
    <td class="codeline">  return Shuffle_match<V1_t, V2_t, Mask_t>(v1, v2, mask);</td>
    <td class="lineNumber">1566</td>
    <td class="codeline">  return Shuffle_match<V1_t, V2_t, Mask_t>(v1, v2, mask);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1567</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1567</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1568</td>
    <td class="codeline"></td>
    <td class="lineNumber">1568</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1569</td>
    <td class="codeline">/// Matches LoadInst.</td>
    <td class="lineNumber">1569</td>
    <td class="codeline">/// Matches LoadInst.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1570</td>
    <td class="codeline">template <typename OpTy></td>
    <td class="lineNumber">1570</td>
    <td class="codeline">template <typename OpTy></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1571</td>
    <td class="codeline">inline OneOps_match<OpTy, Instruction::Load> m_Load(const OpTy &Op) {</td>
    <td class="lineNumber">1571</td>
    <td class="codeline">inline OneOps_match<OpTy, Instruction::Load> m_Load(const OpTy &Op) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1572</td>
    <td class="codeline">  return OneOps_match<OpTy, Instruction::Load>(Op);</td>
    <td class="lineNumber">1572</td>
    <td class="codeline">  return OneOps_match<OpTy, Instruction::Load>(Op);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1573</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1573</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1574</td>
    <td class="codeline"></td>
    <td class="lineNumber">1574</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1575</td>
    <td class="codeline">/// Matches StoreInst.</td>
    <td class="lineNumber">1575</td>
    <td class="codeline">/// Matches StoreInst.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1576</td>
    <td class="codeline">template <typename ValueOpTy, typename PointerOpTy></td>
    <td class="lineNumber">1576</td>
    <td class="codeline">template <typename ValueOpTy, typename PointerOpTy></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1577</td>
    <td class="codeline">inline TwoOps_match<ValueOpTy, PointerOpTy, Instruction::Store></td>
    <td class="lineNumber">1577</td>
    <td class="codeline">inline TwoOps_match<ValueOpTy, PointerOpTy, Instruction::Store></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1578</td>
    <td class="codeline">m_Store(const ValueOpTy &ValueOp, const PointerOpTy &PointerOp) {</td>
    <td class="lineNumber">1578</td>
    <td class="codeline">m_Store(const ValueOpTy &ValueOp, const PointerOpTy &PointerOp) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1579</td>
    <td class="codeline">  return TwoOps_match<ValueOpTy, PointerOpTy, Instruction::Store>(ValueOp,</td>
    <td class="lineNumber">1579</td>
    <td class="codeline">  return TwoOps_match<ValueOpTy, PointerOpTy, Instruction::Store>(ValueOp,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1580</td>
    <td class="codeline">                                                                  PointerOp);</td>
    <td class="lineNumber">1580</td>
    <td class="codeline">                                                                  PointerOp);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1581</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1581</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1582</td>
    <td class="codeline"></td>
    <td class="lineNumber">1582</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1583</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">1583</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1584</td>
    <td class="codeline">// Matchers for CastInst classes</td>
    <td class="lineNumber">1584</td>
    <td class="codeline">// Matchers for CastInst classes</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1585</td>
    <td class="codeline">//</td>
    <td class="lineNumber">1585</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1586</td>
    <td class="codeline"></td>
    <td class="lineNumber">1586</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1587</td>
    <td class="codeline">template <typename Op_t, unsigned Opcode> struct CastClass_match {</td>
    <td class="lineNumber">1587</td>
    <td class="codeline">template <typename Op_t, unsigned Opcode> struct CastClass_match {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1588</td>
    <td class="codeline">  Op_t Op;</td>
    <td class="lineNumber">1588</td>
    <td class="codeline">  Op_t Op;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1589</td>
    <td class="codeline"></td>
    <td class="lineNumber">1589</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1590</td>
    <td class="codeline">  CastClass_match(const Op_t &OpMatch) : Op(OpMatch) {}</td>
    <td class="lineNumber">1590</td>
    <td class="codeline">  CastClass_match(const Op_t &OpMatch) : Op(OpMatch) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1591</td>
    <td class="codeline"></td>
    <td class="lineNumber">1591</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1592</td>
    <td class="codeline">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td class="lineNumber">1592</td>
    <td class="codeline">  template <typename OpTy> bool match(OpTy *V) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1593</td>
    <td class="codeline">    if (auto *O = dyn_cast<Operator>(V))</td>
    <td class="lineNumber">1593</td>
    <td class="codeline">    if (auto *O = dyn_cast<Operator>(V))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1594</td>
    <td class="codeline">      return O->getOpcode() == Opcode && Op.match(O->getOperand(0));</td>
    <td class="lineNumber">1594</td>
    <td class="codeline">      return O->getOpcode() == Opcode && Op.match(O->getOperand(0));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1595</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1595</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1596</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1596</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1597</td>
    <td class="codeline">};</td>
    <td class="lineNumber">1597</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1598</td>
    <td class="codeline"></td>
    <td class="lineNumber">1598</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1599</td>
    <td class="codeline">template <typename Op_t> struct PtrToIntSameSize_match {</td>
    <td class="lineNumber">1599</td>
    <td class="codeline">template <typename Op_t> struct PtrToIntSameSize_match {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1600</td>
    <td class="codeline">  const DataLayout &DL;</td>
    <td class="lineNumber">1600</td>
    <td class="codeline">  const DataLayout &DL;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1601</td>
    <td class="codeline">  Op_t Op;</td>
    <td class="lineNumber">1601</td>
    <td class="codeline">  Op_t Op;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1602</td>
    <td class="codeline"></td>
    <td class="lineNumber">1602</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1603</td>
    <td class="codeline">  PtrToIntSameSize_match(const DataLayout &DL, const Op_t &OpMatch)</td>
    <td class="lineNumber">1603</td>
    <td class="codeline">  PtrToIntSameSize_match(const DataLayout &DL, const Op_t &OpMatch)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1604</td>
    <td class="codeline">      : DL(DL), Op(OpMatch) {}</td>
    <td class="lineNumber">1604</td>
    <td class="codeline">      : DL(DL), Op(OpMatch) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1605</td>
    <td class="codeline"></td>
    <td class="lineNumber">1605</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1606</td>
    <td class="codeline">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td class="lineNumber">1606</td>
    <td class="codeline">  template <typename OpTy> bool match(OpTy *V) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1607</td>
    <td class="codeline">    if (auto *O = dyn_cast<Operator>(V))</td>
    <td class="lineNumber">1607</td>
    <td class="codeline">    if (auto *O = dyn_cast<Operator>(V))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1608</td>
    <td class="codeline">      return O->getOpcode() == Instruction::PtrToInt &&</td>
    <td class="lineNumber">1608</td>
    <td class="codeline">      return O->getOpcode() == Instruction::PtrToInt &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1609</td>
    <td class="codeline">             DL.getTypeSizeInBits(O->getType()) ==</td>
    <td class="lineNumber">1609</td>
    <td class="codeline">             DL.getTypeSizeInBits(O->getType()) ==</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1610</td>
    <td class="codeline">                 DL.getTypeSizeInBits(O->getOperand(0)->getType()) &&</td>
    <td class="lineNumber">1610</td>
    <td class="codeline">                 DL.getTypeSizeInBits(O->getOperand(0)->getType()) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1611</td>
    <td class="codeline">             Op.match(O->getOperand(0));</td>
    <td class="lineNumber">1611</td>
    <td class="codeline">             Op.match(O->getOperand(0));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1612</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1612</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1613</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1613</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1614</td>
    <td class="codeline">};</td>
    <td class="lineNumber">1614</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1615</td>
    <td class="codeline"></td>
    <td class="lineNumber">1615</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1616</td>
    <td class="codeline">/// Matches BitCast.</td>
    <td class="lineNumber">1616</td>
    <td class="codeline">/// Matches BitCast.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1617</td>
    <td class="codeline">template <typename OpTy></td>
    <td class="lineNumber">1617</td>
    <td class="codeline">template <typename OpTy></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1618</td>
    <td class="codeline">inline CastClass_match<OpTy, Instruction::BitCast> m_BitCast(const OpTy &Op) {</td>
    <td class="lineNumber">1618</td>
    <td class="codeline">inline CastClass_match<OpTy, Instruction::BitCast> m_BitCast(const OpTy &Op) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1619</td>
    <td class="codeline">  return CastClass_match<OpTy, Instruction::BitCast>(Op);</td>
    <td class="lineNumber">1619</td>
    <td class="codeline">  return CastClass_match<OpTy, Instruction::BitCast>(Op);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1620</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1620</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1621</td>
    <td class="codeline"></td>
    <td class="lineNumber">1621</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1622</td>
    <td class="codeline">/// Matches PtrToInt.</td>
    <td class="lineNumber">1622</td>
    <td class="codeline">/// Matches PtrToInt.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1623</td>
    <td class="codeline">template <typename OpTy></td>
    <td class="lineNumber">1623</td>
    <td class="codeline">template <typename OpTy></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1624</td>
    <td class="codeline">inline CastClass_match<OpTy, Instruction::PtrToInt> m_PtrToInt(const OpTy &Op) {</td>
    <td class="lineNumber">1624</td>
    <td class="codeline">inline CastClass_match<OpTy, Instruction::PtrToInt> m_PtrToInt(const OpTy &Op) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1625</td>
    <td class="codeline">  return CastClass_match<OpTy, Instruction::PtrToInt>(Op);</td>
    <td class="lineNumber">1625</td>
    <td class="codeline">  return CastClass_match<OpTy, Instruction::PtrToInt>(Op);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1626</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1626</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1627</td>
    <td class="codeline"></td>
    <td class="lineNumber">1627</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1628</td>
    <td class="codeline">template <typename OpTy></td>
    <td class="lineNumber">1628</td>
    <td class="codeline">template <typename OpTy></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1629</td>
    <td class="codeline">inline PtrToIntSameSize_match<OpTy> m_PtrToIntSameSize(const DataLayout &DL,</td>
    <td class="lineNumber">1629</td>
    <td class="codeline">inline PtrToIntSameSize_match<OpTy> m_PtrToIntSameSize(const DataLayout &DL,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1630</td>
    <td class="codeline">                                                       const OpTy &Op) {</td>
    <td class="lineNumber">1630</td>
    <td class="codeline">                                                       const OpTy &Op) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1631</td>
    <td class="codeline">  return PtrToIntSameSize_match<OpTy>(DL, Op);</td>
    <td class="lineNumber">1631</td>
    <td class="codeline">  return PtrToIntSameSize_match<OpTy>(DL, Op);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1632</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1632</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1633</td>
    <td class="codeline"></td>
    <td class="lineNumber">1633</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1634</td>
    <td class="codeline">/// Matches IntToPtr.</td>
    <td class="lineNumber">1634</td>
    <td class="codeline">/// Matches IntToPtr.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1635</td>
    <td class="codeline">template <typename OpTy></td>
    <td class="lineNumber">1635</td>
    <td class="codeline">template <typename OpTy></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1636</td>
    <td class="codeline">inline CastClass_match<OpTy, Instruction::IntToPtr> m_IntToPtr(const OpTy &Op) {</td>
    <td class="lineNumber">1636</td>
    <td class="codeline">inline CastClass_match<OpTy, Instruction::IntToPtr> m_IntToPtr(const OpTy &Op) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1637</td>
    <td class="codeline">  return CastClass_match<OpTy, Instruction::IntToPtr>(Op);</td>
    <td class="lineNumber">1637</td>
    <td class="codeline">  return CastClass_match<OpTy, Instruction::IntToPtr>(Op);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1638</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1638</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1639</td>
    <td class="codeline"></td>
    <td class="lineNumber">1639</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1640</td>
    <td class="codeline">/// Matches Trunc.</td>
    <td class="lineNumber">1640</td>
    <td class="codeline">/// Matches Trunc.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1641</td>
    <td class="codeline">template <typename OpTy></td>
    <td class="lineNumber">1641</td>
    <td class="codeline">template <typename OpTy></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1642</td>
    <td class="codeline">inline CastClass_match<OpTy, Instruction::Trunc> m_Trunc(const OpTy &Op) {</td>
    <td class="lineNumber">1642</td>
    <td class="codeline">inline CastClass_match<OpTy, Instruction::Trunc> m_Trunc(const OpTy &Op) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1643</td>
    <td class="codeline">  return CastClass_match<OpTy, Instruction::Trunc>(Op);</td>
    <td class="lineNumber">1643</td>
    <td class="codeline">  return CastClass_match<OpTy, Instruction::Trunc>(Op);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1644</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1644</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1645</td>
    <td class="codeline"></td>
    <td class="lineNumber">1645</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1646</td>
    <td class="codeline">template <typename OpTy></td>
    <td class="lineNumber">1646</td>
    <td class="codeline">template <typename OpTy></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1647</td>
    <td class="codeline">inline match_combine_or<CastClass_match<OpTy, Instruction::Trunc>, OpTy></td>
    <td class="lineNumber">1647</td>
    <td class="codeline">inline match_combine_or<CastClass_match<OpTy, Instruction::Trunc>, OpTy></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1648</td>
    <td class="codeline">m_TruncOrSelf(const OpTy &Op) {</td>
    <td class="lineNumber">1648</td>
    <td class="codeline">m_TruncOrSelf(const OpTy &Op) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1649</td>
    <td class="codeline">  return m_CombineOr(m_Trunc(Op), Op);</td>
    <td class="lineNumber">1649</td>
    <td class="codeline">  return m_CombineOr(m_Trunc(Op), Op);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1650</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1650</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1651</td>
    <td class="codeline"></td>
    <td class="lineNumber">1651</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1652</td>
    <td class="codeline">/// Matches SExt.</td>
    <td class="lineNumber">1652</td>
    <td class="codeline">/// Matches SExt.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1653</td>
    <td class="codeline">template <typename OpTy></td>
    <td class="lineNumber">1653</td>
    <td class="codeline">template <typename OpTy></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1654</td>
    <td class="codeline">inline CastClass_match<OpTy, Instruction::SExt> m_SExt(const OpTy &Op) {</td>
    <td class="lineNumber">1654</td>
    <td class="codeline">inline CastClass_match<OpTy, Instruction::SExt> m_SExt(const OpTy &Op) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1655</td>
    <td class="codeline">  return CastClass_match<OpTy, Instruction::SExt>(Op);</td>
    <td class="lineNumber">1655</td>
    <td class="codeline">  return CastClass_match<OpTy, Instruction::SExt>(Op);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1656</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1656</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1657</td>
    <td class="codeline"></td>
    <td class="lineNumber">1657</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1658</td>
    <td class="codeline">/// Matches ZExt.</td>
    <td class="lineNumber">1658</td>
    <td class="codeline">/// Matches ZExt.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1659</td>
    <td class="codeline">template <typename OpTy></td>
    <td class="lineNumber">1659</td>
    <td class="codeline">template <typename OpTy></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1660</td>
    <td class="codeline">inline CastClass_match<OpTy, Instruction::ZExt> m_ZExt(const OpTy &Op) {</td>
    <td class="lineNumber">1660</td>
    <td class="codeline">inline CastClass_match<OpTy, Instruction::ZExt> m_ZExt(const OpTy &Op) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1661</td>
    <td class="codeline">  return CastClass_match<OpTy, Instruction::ZExt>(Op);</td>
    <td class="lineNumber">1661</td>
    <td class="codeline">  return CastClass_match<OpTy, Instruction::ZExt>(Op);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1662</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1662</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1663</td>
    <td class="codeline"></td>
    <td class="lineNumber">1663</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1664</td>
    <td class="codeline">template <typename OpTy></td>
    <td class="lineNumber">1664</td>
    <td class="codeline">template <typename OpTy></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1665</td>
    <td class="codeline">inline match_combine_or<CastClass_match<OpTy, Instruction::ZExt>, OpTy></td>
    <td class="lineNumber">1665</td>
    <td class="codeline">inline match_combine_or<CastClass_match<OpTy, Instruction::ZExt>, OpTy></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1666</td>
    <td class="codeline">m_ZExtOrSelf(const OpTy &Op) {</td>
    <td class="lineNumber">1666</td>
    <td class="codeline">m_ZExtOrSelf(const OpTy &Op) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1667</td>
    <td class="codeline">  return m_CombineOr(m_ZExt(Op), Op);</td>
    <td class="lineNumber">1667</td>
    <td class="codeline">  return m_CombineOr(m_ZExt(Op), Op);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1668</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1668</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1669</td>
    <td class="codeline"></td>
    <td class="lineNumber">1669</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1670</td>
    <td class="codeline">template <typename OpTy></td>
    <td class="lineNumber">1670</td>
    <td class="codeline">template <typename OpTy></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1671</td>
    <td class="codeline">inline match_combine_or<CastClass_match<OpTy, Instruction::SExt>, OpTy></td>
    <td class="lineNumber">1671</td>
    <td class="codeline">inline match_combine_or<CastClass_match<OpTy, Instruction::SExt>, OpTy></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1672</td>
    <td class="codeline">m_SExtOrSelf(const OpTy &Op) {</td>
    <td class="lineNumber">1672</td>
    <td class="codeline">m_SExtOrSelf(const OpTy &Op) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1673</td>
    <td class="codeline">  return m_CombineOr(m_SExt(Op), Op);</td>
    <td class="lineNumber">1673</td>
    <td class="codeline">  return m_CombineOr(m_SExt(Op), Op);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1674</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1674</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1675</td>
    <td class="codeline"></td>
    <td class="lineNumber">1675</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1676</td>
    <td class="codeline">template <typename OpTy></td>
    <td class="lineNumber">1676</td>
    <td class="codeline">template <typename OpTy></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1677</td>
    <td class="codeline">inline match_combine_or<CastClass_match<OpTy, Instruction::ZExt>,</td>
    <td class="lineNumber">1677</td>
    <td class="codeline">inline match_combine_or<CastClass_match<OpTy, Instruction::ZExt>,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1678</td>
    <td class="codeline">                        CastClass_match<OpTy, Instruction::SExt>></td>
    <td class="lineNumber">1678</td>
    <td class="codeline">                        CastClass_match<OpTy, Instruction::SExt>></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1679</td>
    <td class="codeline">m_ZExtOrSExt(const OpTy &Op) {</td>
    <td class="lineNumber">1679</td>
    <td class="codeline">m_ZExtOrSExt(const OpTy &Op) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1680</td>
    <td class="codeline">  return m_CombineOr(m_ZExt(Op), m_SExt(Op));</td>
    <td class="lineNumber">1680</td>
    <td class="codeline">  return m_CombineOr(m_ZExt(Op), m_SExt(Op));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1681</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1681</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1682</td>
    <td class="codeline"></td>
    <td class="lineNumber">1682</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1683</td>
    <td class="codeline">template <typename OpTy></td>
    <td class="lineNumber">1683</td>
    <td class="codeline">template <typename OpTy></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1684</td>
    <td class="codeline">inline match_combine_or<</td>
    <td class="lineNumber">1684</td>
    <td class="codeline">inline match_combine_or<</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1685</td>
    <td class="codeline">    match_combine_or<CastClass_match<OpTy, Instruction::ZExt>,</td>
    <td class="lineNumber">1685</td>
    <td class="codeline">    match_combine_or<CastClass_match<OpTy, Instruction::ZExt>,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1686</td>
    <td class="codeline">                     CastClass_match<OpTy, Instruction::SExt>>,</td>
    <td class="lineNumber">1686</td>
    <td class="codeline">                     CastClass_match<OpTy, Instruction::SExt>>,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1687</td>
    <td class="codeline">    OpTy></td>
    <td class="lineNumber">1687</td>
    <td class="codeline">    OpTy></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1688</td>
    <td class="codeline">m_ZExtOrSExtOrSelf(const OpTy &Op) {</td>
    <td class="lineNumber">1688</td>
    <td class="codeline">m_ZExtOrSExtOrSelf(const OpTy &Op) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1689</td>
    <td class="codeline">  return m_CombineOr(m_ZExtOrSExt(Op), Op);</td>
    <td class="lineNumber">1689</td>
    <td class="codeline">  return m_CombineOr(m_ZExtOrSExt(Op), Op);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1690</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1690</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1691</td>
    <td class="codeline"></td>
    <td class="lineNumber">1691</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1692</td>
    <td class="codeline">template <typename OpTy></td>
    <td class="lineNumber">1692</td>
    <td class="codeline">template <typename OpTy></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1693</td>
    <td class="codeline">inline CastClass_match<OpTy, Instruction::UIToFP> m_UIToFP(const OpTy &Op) {</td>
    <td class="lineNumber">1693</td>
    <td class="codeline">inline CastClass_match<OpTy, Instruction::UIToFP> m_UIToFP(const OpTy &Op) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1694</td>
    <td class="codeline">  return CastClass_match<OpTy, Instruction::UIToFP>(Op);</td>
    <td class="lineNumber">1694</td>
    <td class="codeline">  return CastClass_match<OpTy, Instruction::UIToFP>(Op);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1695</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1695</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1696</td>
    <td class="codeline"></td>
    <td class="lineNumber">1696</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1697</td>
    <td class="codeline">template <typename OpTy></td>
    <td class="lineNumber">1697</td>
    <td class="codeline">template <typename OpTy></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1698</td>
    <td class="codeline">inline CastClass_match<OpTy, Instruction::SIToFP> m_SIToFP(const OpTy &Op) {</td>
    <td class="lineNumber">1698</td>
    <td class="codeline">inline CastClass_match<OpTy, Instruction::SIToFP> m_SIToFP(const OpTy &Op) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1699</td>
    <td class="codeline">  return CastClass_match<OpTy, Instruction::SIToFP>(Op);</td>
    <td class="lineNumber">1699</td>
    <td class="codeline">  return CastClass_match<OpTy, Instruction::SIToFP>(Op);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1700</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1700</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1701</td>
    <td class="codeline"></td>
    <td class="lineNumber">1701</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1702</td>
    <td class="codeline">template <typename OpTy></td>
    <td class="lineNumber">1702</td>
    <td class="codeline">template <typename OpTy></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1703</td>
    <td class="codeline">inline CastClass_match<OpTy, Instruction::FPToUI> m_FPToUI(const OpTy &Op) {</td>
    <td class="lineNumber">1703</td>
    <td class="codeline">inline CastClass_match<OpTy, Instruction::FPToUI> m_FPToUI(const OpTy &Op) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1704</td>
    <td class="codeline">  return CastClass_match<OpTy, Instruction::FPToUI>(Op);</td>
    <td class="lineNumber">1704</td>
    <td class="codeline">  return CastClass_match<OpTy, Instruction::FPToUI>(Op);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1705</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1705</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1706</td>
    <td class="codeline"></td>
    <td class="lineNumber">1706</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1707</td>
    <td class="codeline">template <typename OpTy></td>
    <td class="lineNumber">1707</td>
    <td class="codeline">template <typename OpTy></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1708</td>
    <td class="codeline">inline CastClass_match<OpTy, Instruction::FPToSI> m_FPToSI(const OpTy &Op) {</td>
    <td class="lineNumber">1708</td>
    <td class="codeline">inline CastClass_match<OpTy, Instruction::FPToSI> m_FPToSI(const OpTy &Op) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1709</td>
    <td class="codeline">  return CastClass_match<OpTy, Instruction::FPToSI>(Op);</td>
    <td class="lineNumber">1709</td>
    <td class="codeline">  return CastClass_match<OpTy, Instruction::FPToSI>(Op);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1710</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1710</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1711</td>
    <td class="codeline"></td>
    <td class="lineNumber">1711</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1712</td>
    <td class="codeline">template <typename OpTy></td>
    <td class="lineNumber">1712</td>
    <td class="codeline">template <typename OpTy></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1713</td>
    <td class="codeline">inline CastClass_match<OpTy, Instruction::FPTrunc> m_FPTrunc(const OpTy &Op) {</td>
    <td class="lineNumber">1713</td>
    <td class="codeline">inline CastClass_match<OpTy, Instruction::FPTrunc> m_FPTrunc(const OpTy &Op) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1714</td>
    <td class="codeline">  return CastClass_match<OpTy, Instruction::FPTrunc>(Op);</td>
    <td class="lineNumber">1714</td>
    <td class="codeline">  return CastClass_match<OpTy, Instruction::FPTrunc>(Op);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1715</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1715</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1716</td>
    <td class="codeline"></td>
    <td class="lineNumber">1716</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1717</td>
    <td class="codeline">template <typename OpTy></td>
    <td class="lineNumber">1717</td>
    <td class="codeline">template <typename OpTy></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1718</td>
    <td class="codeline">inline CastClass_match<OpTy, Instruction::FPExt> m_FPExt(const OpTy &Op) {</td>
    <td class="lineNumber">1718</td>
    <td class="codeline">inline CastClass_match<OpTy, Instruction::FPExt> m_FPExt(const OpTy &Op) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1719</td>
    <td class="codeline">  return CastClass_match<OpTy, Instruction::FPExt>(Op);</td>
    <td class="lineNumber">1719</td>
    <td class="codeline">  return CastClass_match<OpTy, Instruction::FPExt>(Op);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1720</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1720</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1721</td>
    <td class="codeline"></td>
    <td class="lineNumber">1721</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1722</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">1722</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1723</td>
    <td class="codeline">// Matchers for control flow.</td>
    <td class="lineNumber">1723</td>
    <td class="codeline">// Matchers for control flow.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1724</td>
    <td class="codeline">//</td>
    <td class="lineNumber">1724</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1725</td>
    <td class="codeline"></td>
    <td class="lineNumber">1725</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1726</td>
    <td class="codeline">struct br_match {</td>
    <td class="lineNumber">1726</td>
    <td class="codeline">struct br_match {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1727</td>
    <td class="codeline">  BasicBlock *&Succ;</td>
    <td class="lineNumber">1727</td>
    <td class="codeline">  BasicBlock *&Succ;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1728</td>
    <td class="codeline"></td>
    <td class="lineNumber">1728</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1729</td>
    <td class="codeline">  br_match(BasicBlock *&Succ) : Succ(Succ) {}</td>
    <td class="lineNumber">1729</td>
    <td class="codeline">  br_match(BasicBlock *&Succ) : Succ(Succ) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1730</td>
    <td class="codeline"></td>
    <td class="lineNumber">1730</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1731</td>
    <td class="codeline">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td class="lineNumber">1731</td>
    <td class="codeline">  template <typename OpTy> bool match(OpTy *V) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1732</td>
    <td class="codeline">    if (auto *BI = dyn_cast<BranchInst>(V))</td>
    <td class="lineNumber">1732</td>
    <td class="codeline">    if (auto *BI = dyn_cast<BranchInst>(V))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1733</td>
    <td class="codeline">      if (BI->isUnconditional()) {</td>
    <td class="lineNumber">1733</td>
    <td class="codeline">      if (BI->isUnconditional()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1734</td>
    <td class="codeline">        Succ = BI->getSuccessor(0);</td>
    <td class="lineNumber">1734</td>
    <td class="codeline">        Succ = BI->getSuccessor(0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1735</td>
    <td class="codeline">        return true;</td>
    <td class="lineNumber">1735</td>
    <td class="codeline">        return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1736</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1736</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1737</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1737</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1738</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1738</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1739</td>
    <td class="codeline">};</td>
    <td class="lineNumber">1739</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1740</td>
    <td class="codeline"></td>
    <td class="lineNumber">1740</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1741</td>
    <td class="codeline">inline br_match m_UnconditionalBr(BasicBlock *&Succ) { return br_match(Succ); }</td>
    <td class="lineNumber">1741</td>
    <td class="codeline">inline br_match m_UnconditionalBr(BasicBlock *&Succ) { return br_match(Succ); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1742</td>
    <td class="codeline"></td>
    <td class="lineNumber">1742</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1743</td>
    <td class="codeline">template <typename Cond_t, typename TrueBlock_t, typename FalseBlock_t></td>
    <td class="lineNumber">1743</td>
    <td class="codeline">template <typename Cond_t, typename TrueBlock_t, typename FalseBlock_t></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1744</td>
    <td class="codeline">struct brc_match {</td>
    <td class="lineNumber">1744</td>
    <td class="codeline">struct brc_match {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1745</td>
    <td class="codeline">  Cond_t Cond;</td>
    <td class="lineNumber">1745</td>
    <td class="codeline">  Cond_t Cond;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1746</td>
    <td class="codeline">  TrueBlock_t T;</td>
    <td class="lineNumber">1746</td>
    <td class="codeline">  TrueBlock_t T;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1747</td>
    <td class="codeline">  FalseBlock_t F;</td>
    <td class="lineNumber">1747</td>
    <td class="codeline">  FalseBlock_t F;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1748</td>
    <td class="codeline"></td>
    <td class="lineNumber">1748</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1749</td>
    <td class="codeline">  brc_match(const Cond_t &C, const TrueBlock_t &t, const FalseBlock_t &f)</td>
    <td class="lineNumber">1749</td>
    <td class="codeline">  brc_match(const Cond_t &C, const TrueBlock_t &t, const FalseBlock_t &f)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1750</td>
    <td class="codeline">      : Cond(C), T(t), F(f) {}</td>
    <td class="lineNumber">1750</td>
    <td class="codeline">      : Cond(C), T(t), F(f) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1751</td>
    <td class="codeline"></td>
    <td class="lineNumber">1751</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1752</td>
    <td class="codeline">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td class="lineNumber">1752</td>
    <td class="codeline">  template <typename OpTy> bool match(OpTy *V) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1753</td>
    <td class="codeline">    if (auto *BI = dyn_cast<BranchInst>(V))</td>
    <td class="lineNumber">1753</td>
    <td class="codeline">    if (auto *BI = dyn_cast<BranchInst>(V))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1754</td>
    <td class="codeline">      if (BI->isConditional() && Cond.match(BI->getCondition()))</td>
    <td class="lineNumber">1754</td>
    <td class="codeline">      if (BI->isConditional() && Cond.match(BI->getCondition()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1755</td>
    <td class="codeline">        return T.match(BI->getSuccessor(0)) && F.match(BI->getSuccessor(1));</td>
    <td class="lineNumber">1755</td>
    <td class="codeline">        return T.match(BI->getSuccessor(0)) && F.match(BI->getSuccessor(1));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1756</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1756</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1757</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1757</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1758</td>
    <td class="codeline">};</td>
    <td class="lineNumber">1758</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1759</td>
    <td class="codeline"></td>
    <td class="lineNumber">1759</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1760</td>
    <td class="codeline">template <typename Cond_t></td>
    <td class="lineNumber">1760</td>
    <td class="codeline">template <typename Cond_t></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1761</td>
    <td class="codeline">inline brc_match<Cond_t, bind_ty<BasicBlock>, bind_ty<BasicBlock>></td>
    <td class="lineNumber">1761</td>
    <td class="codeline">inline brc_match<Cond_t, bind_ty<BasicBlock>, bind_ty<BasicBlock>></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1762</td>
    <td class="codeline">m_Br(const Cond_t &C, BasicBlock *&T, BasicBlock *&F) {</td>
    <td class="lineNumber">1762</td>
    <td class="codeline">m_Br(const Cond_t &C, BasicBlock *&T, BasicBlock *&F) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1763</td>
    <td class="codeline">  return brc_match<Cond_t, bind_ty<BasicBlock>, bind_ty<BasicBlock>>(</td>
    <td class="lineNumber">1763</td>
    <td class="codeline">  return brc_match<Cond_t, bind_ty<BasicBlock>, bind_ty<BasicBlock>>(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1764</td>
    <td class="codeline">      C, m_BasicBlock(T), m_BasicBlock(F));</td>
    <td class="lineNumber">1764</td>
    <td class="codeline">      C, m_BasicBlock(T), m_BasicBlock(F));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1765</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1765</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1766</td>
    <td class="codeline"></td>
    <td class="lineNumber">1766</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1767</td>
    <td class="codeline">template <typename Cond_t, typename TrueBlock_t, typename FalseBlock_t></td>
    <td class="lineNumber">1767</td>
    <td class="codeline">template <typename Cond_t, typename TrueBlock_t, typename FalseBlock_t></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1768</td>
    <td class="codeline">inline brc_match<Cond_t, TrueBlock_t, FalseBlock_t></td>
    <td class="lineNumber">1768</td>
    <td class="codeline">inline brc_match<Cond_t, TrueBlock_t, FalseBlock_t></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1769</td>
    <td class="codeline">m_Br(const Cond_t &C, const TrueBlock_t &T, const FalseBlock_t &F) {</td>
    <td class="lineNumber">1769</td>
    <td class="codeline">m_Br(const Cond_t &C, const TrueBlock_t &T, const FalseBlock_t &F) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1770</td>
    <td class="codeline">  return brc_match<Cond_t, TrueBlock_t, FalseBlock_t>(C, T, F);</td>
    <td class="lineNumber">1770</td>
    <td class="codeline">  return brc_match<Cond_t, TrueBlock_t, FalseBlock_t>(C, T, F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1771</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1771</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1772</td>
    <td class="codeline"></td>
    <td class="lineNumber">1772</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1773</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">1773</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1774</td>
    <td class="codeline">// Matchers for max/min idioms, eg: "select (sgt x, y), x, y" -> smax(x,y).</td>
    <td class="lineNumber">1774</td>
    <td class="codeline">// Matchers for max/min idioms, eg: "select (sgt x, y), x, y" -> smax(x,y).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1775</td>
    <td class="codeline">//</td>
    <td class="lineNumber">1775</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1776</td>
    <td class="codeline"></td>
    <td class="lineNumber">1776</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1777</td>
    <td class="codeline">template <typename CmpInst_t, typename LHS_t, typename RHS_t, typename Pred_t,</td>
    <td class="lineNumber">1777</td>
    <td class="codeline">template <typename CmpInst_t, typename LHS_t, typename RHS_t, typename Pred_t,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1778</td>
    <td class="codeline">          bool Commutable = false></td>
    <td class="lineNumber">1778</td>
    <td class="codeline">          bool Commutable = false></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1779</td>
    <td class="codeline">struct MaxMin_match {</td>
    <td class="lineNumber">1779</td>
    <td class="codeline">struct MaxMin_match {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1780</td>
    <td class="codeline">  using PredType = Pred_t;</td>
    <td class="lineNumber">1780</td>
    <td class="codeline">  using PredType = Pred_t;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1781</td>
    <td class="codeline">  LHS_t L;</td>
    <td class="lineNumber">1781</td>
    <td class="codeline">  LHS_t L;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1782</td>
    <td class="codeline">  RHS_t R;</td>
    <td class="lineNumber">1782</td>
    <td class="codeline">  RHS_t R;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1783</td>
    <td class="codeline"></td>
    <td class="lineNumber">1783</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1784</td>
    <td class="codeline">  // The evaluation order is always stable, regardless of Commutability.</td>
    <td class="lineNumber">1784</td>
    <td class="codeline">  // The evaluation order is always stable, regardless of Commutability.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1785</td>
    <td class="codeline">  // The LHS is always matched first.</td>
    <td class="lineNumber">1785</td>
    <td class="codeline">  // The LHS is always matched first.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1786</td>
    <td class="codeline">  MaxMin_match(const LHS_t &LHS, const RHS_t &RHS) : L(LHS), R(RHS) {}</td>
    <td class="lineNumber">1786</td>
    <td class="codeline">  MaxMin_match(const LHS_t &LHS, const RHS_t &RHS) : L(LHS), R(RHS) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1787</td>
    <td class="codeline"></td>
    <td class="lineNumber">1787</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1788</td>
    <td class="codeline">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td class="lineNumber">1788</td>
    <td class="codeline">  template <typename OpTy> bool match(OpTy *V) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1789</td>
    <td class="codeline">    if (auto *II = dyn_cast<IntrinsicInst>(V)) {</td>
    <td class="lineNumber">1789</td>
    <td class="codeline">    if (auto *II = dyn_cast<IntrinsicInst>(V)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1790</td>
    <td class="codeline">      Intrinsic::ID IID = II->getIntrinsicID();</td>
    <td class="lineNumber">1790</td>
    <td class="codeline">      Intrinsic::ID IID = II->getIntrinsicID();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1791</td>
    <td class="codeline">      if ((IID == Intrinsic::smax && Pred_t::match(ICmpInst::ICMP_SGT)) ||</td>
    <td class="lineNumber">1791</td>
    <td class="codeline">      if ((IID == Intrinsic::smax && Pred_t::match(ICmpInst::ICMP_SGT)) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1792</td>
    <td class="codeline">          (IID == Intrinsic::smin && Pred_t::match(ICmpInst::ICMP_SLT)) ||</td>
    <td class="lineNumber">1792</td>
    <td class="codeline">          (IID == Intrinsic::smin && Pred_t::match(ICmpInst::ICMP_SLT)) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1793</td>
    <td class="codeline">          (IID == Intrinsic::umax && Pred_t::match(ICmpInst::ICMP_UGT)) ||</td>
    <td class="lineNumber">1793</td>
    <td class="codeline">          (IID == Intrinsic::umax && Pred_t::match(ICmpInst::ICMP_UGT)) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1794</td>
    <td class="codeline">          (IID == Intrinsic::umin && Pred_t::match(ICmpInst::ICMP_ULT))) {</td>
    <td class="lineNumber">1794</td>
    <td class="codeline">          (IID == Intrinsic::umin && Pred_t::match(ICmpInst::ICMP_ULT))) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1795</td>
    <td class="codeline">        Value *LHS = II->getOperand(0), *RHS = II->getOperand(1);</td>
    <td class="lineNumber">1795</td>
    <td class="codeline">        Value *LHS = II->getOperand(0), *RHS = II->getOperand(1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1796</td>
    <td class="codeline">        return (L.match(LHS) && R.match(RHS)) ||</td>
    <td class="lineNumber">1796</td>
    <td class="codeline">        return (L.match(LHS) && R.match(RHS)) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1797</td>
    <td class="codeline">               (Commutable && L.match(RHS) && R.match(LHS));</td>
    <td class="lineNumber">1797</td>
    <td class="codeline">               (Commutable && L.match(RHS) && R.match(LHS));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1798</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1798</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1799</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1799</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1800</td>
    <td class="codeline">    // Look for "(x pred y) ? x : y" or "(x pred y) ? y : x".</td>
    <td class="lineNumber">1800</td>
    <td class="codeline">    // Look for "(x pred y) ? x : y" or "(x pred y) ? y : x".</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1801</td>
    <td class="codeline">    auto *SI = dyn_cast<SelectInst>(V);</td>
    <td class="lineNumber">1801</td>
    <td class="codeline">    auto *SI = dyn_cast<SelectInst>(V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1802</td>
    <td class="codeline">    if (!SI)</td>
    <td class="lineNumber">1802</td>
    <td class="codeline">    if (!SI)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1803</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">1803</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1804</td>
    <td class="codeline">    auto *Cmp = dyn_cast<CmpInst_t>(SI->getCondition());</td>
    <td class="lineNumber">1804</td>
    <td class="codeline">    auto *Cmp = dyn_cast<CmpInst_t>(SI->getCondition());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1805</td>
    <td class="codeline">    if (!Cmp)</td>
    <td class="lineNumber">1805</td>
    <td class="codeline">    if (!Cmp)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1806</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">1806</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1807</td>
    <td class="codeline">    // At this point we have a select conditioned on a comparison.  Check that</td>
    <td class="lineNumber">1807</td>
    <td class="codeline">    // At this point we have a select conditioned on a comparison.  Check that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1808</td>
    <td class="codeline">    // it is the values returned by the select that are being compared.</td>
    <td class="lineNumber">1808</td>
    <td class="codeline">    // it is the values returned by the select that are being compared.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1809</td>
    <td class="codeline">    auto *TrueVal = SI->getTrueValue();</td>
    <td class="lineNumber">1809</td>
    <td class="codeline">    auto *TrueVal = SI->getTrueValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1810</td>
    <td class="codeline">    auto *FalseVal = SI->getFalseValue();</td>
    <td class="lineNumber">1810</td>
    <td class="codeline">    auto *FalseVal = SI->getFalseValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1811</td>
    <td class="codeline">    auto *LHS = Cmp->getOperand(0);</td>
    <td class="lineNumber">1811</td>
    <td class="codeline">    auto *LHS = Cmp->getOperand(0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1812</td>
    <td class="codeline">    auto *RHS = Cmp->getOperand(1);</td>
    <td class="lineNumber">1812</td>
    <td class="codeline">    auto *RHS = Cmp->getOperand(1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1813</td>
    <td class="codeline">    if ((TrueVal != LHS || FalseVal != RHS) &&</td>
    <td class="lineNumber">1813</td>
    <td class="codeline">    if ((TrueVal != LHS || FalseVal != RHS) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1814</td>
    <td class="codeline">        (TrueVal != RHS || FalseVal != LHS))</td>
    <td class="lineNumber">1814</td>
    <td class="codeline">        (TrueVal != RHS || FalseVal != LHS))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1815</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">1815</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1816</td>
    <td class="codeline">    typename CmpInst_t::Predicate Pred =</td>
    <td class="lineNumber">1816</td>
    <td class="codeline">    typename CmpInst_t::Predicate Pred =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1817</td>
    <td class="codeline">        LHS == TrueVal ? Cmp->getPredicate() : Cmp->getInversePredicate();</td>
    <td class="lineNumber">1817</td>
    <td class="codeline">        LHS == TrueVal ? Cmp->getPredicate() : Cmp->getInversePredicate();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1818</td>
    <td class="codeline">    // Does "(x pred y) ? x : y" represent the desired max/min operation?</td>
    <td class="lineNumber">1818</td>
    <td class="codeline">    // Does "(x pred y) ? x : y" represent the desired max/min operation?</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1819</td>
    <td class="codeline">    if (!Pred_t::match(Pred))</td>
    <td class="lineNumber">1819</td>
    <td class="codeline">    if (!Pred_t::match(Pred))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1820</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">1820</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1821</td>
    <td class="codeline">    // It does!  Bind the operands.</td>
    <td class="lineNumber">1821</td>
    <td class="codeline">    // It does!  Bind the operands.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1822</td>
    <td class="codeline">    return (L.match(LHS) && R.match(RHS)) ||</td>
    <td class="lineNumber">1822</td>
    <td class="codeline">    return (L.match(LHS) && R.match(RHS)) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1823</td>
    <td class="codeline">           (Commutable && L.match(RHS) && R.match(LHS));</td>
    <td class="lineNumber">1823</td>
    <td class="codeline">           (Commutable && L.match(RHS) && R.match(LHS));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1824</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1824</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1825</td>
    <td class="codeline">};</td>
    <td class="lineNumber">1825</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1826</td>
    <td class="codeline"></td>
    <td class="lineNumber">1826</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1827</td>
    <td class="codeline">/// Helper class for identifying signed max predicates.</td>
    <td class="lineNumber">1827</td>
    <td class="codeline">/// Helper class for identifying signed max predicates.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1828</td>
    <td class="codeline">struct smax_pred_ty {</td>
    <td class="lineNumber">1828</td>
    <td class="codeline">struct smax_pred_ty {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1829</td>
    <td class="codeline">  static bool match(ICmpInst::Predicate Pred) {</td>
    <td class="lineNumber">1829</td>
    <td class="codeline">  static bool match(ICmpInst::Predicate Pred) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1830</td>
    <td class="codeline">    return Pred == CmpInst::ICMP_SGT || Pred == CmpInst::ICMP_SGE;</td>
    <td class="lineNumber">1830</td>
    <td class="codeline">    return Pred == CmpInst::ICMP_SGT || Pred == CmpInst::ICMP_SGE;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1831</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1831</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1832</td>
    <td class="codeline">};</td>
    <td class="lineNumber">1832</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1833</td>
    <td class="codeline"></td>
    <td class="lineNumber">1833</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1834</td>
    <td class="codeline">/// Helper class for identifying signed min predicates.</td>
    <td class="lineNumber">1834</td>
    <td class="codeline">/// Helper class for identifying signed min predicates.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1835</td>
    <td class="codeline">struct smin_pred_ty {</td>
    <td class="lineNumber">1835</td>
    <td class="codeline">struct smin_pred_ty {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1836</td>
    <td class="codeline">  static bool match(ICmpInst::Predicate Pred) {</td>
    <td class="lineNumber">1836</td>
    <td class="codeline">  static bool match(ICmpInst::Predicate Pred) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1837</td>
    <td class="codeline">    return Pred == CmpInst::ICMP_SLT || Pred == CmpInst::ICMP_SLE;</td>
    <td class="lineNumber">1837</td>
    <td class="codeline">    return Pred == CmpInst::ICMP_SLT || Pred == CmpInst::ICMP_SLE;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1838</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1838</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1839</td>
    <td class="codeline">};</td>
    <td class="lineNumber">1839</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1840</td>
    <td class="codeline"></td>
    <td class="lineNumber">1840</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1841</td>
    <td class="codeline">/// Helper class for identifying unsigned max predicates.</td>
    <td class="lineNumber">1841</td>
    <td class="codeline">/// Helper class for identifying unsigned max predicates.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1842</td>
    <td class="codeline">struct umax_pred_ty {</td>
    <td class="lineNumber">1842</td>
    <td class="codeline">struct umax_pred_ty {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1843</td>
    <td class="codeline">  static bool match(ICmpInst::Predicate Pred) {</td>
    <td class="lineNumber">1843</td>
    <td class="codeline">  static bool match(ICmpInst::Predicate Pred) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1844</td>
    <td class="codeline">    return Pred == CmpInst::ICMP_UGT || Pred == CmpInst::ICMP_UGE;</td>
    <td class="lineNumber">1844</td>
    <td class="codeline">    return Pred == CmpInst::ICMP_UGT || Pred == CmpInst::ICMP_UGE;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1845</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1845</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1846</td>
    <td class="codeline">};</td>
    <td class="lineNumber">1846</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1847</td>
    <td class="codeline"></td>
    <td class="lineNumber">1847</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1848</td>
    <td class="codeline">/// Helper class for identifying unsigned min predicates.</td>
    <td class="lineNumber">1848</td>
    <td class="codeline">/// Helper class for identifying unsigned min predicates.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1849</td>
    <td class="codeline">struct umin_pred_ty {</td>
    <td class="lineNumber">1849</td>
    <td class="codeline">struct umin_pred_ty {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1850</td>
    <td class="codeline">  static bool match(ICmpInst::Predicate Pred) {</td>
    <td class="lineNumber">1850</td>
    <td class="codeline">  static bool match(ICmpInst::Predicate Pred) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1851</td>
    <td class="codeline">    return Pred == CmpInst::ICMP_ULT || Pred == CmpInst::ICMP_ULE;</td>
    <td class="lineNumber">1851</td>
    <td class="codeline">    return Pred == CmpInst::ICMP_ULT || Pred == CmpInst::ICMP_ULE;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1852</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1852</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1853</td>
    <td class="codeline">};</td>
    <td class="lineNumber">1853</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1854</td>
    <td class="codeline"></td>
    <td class="lineNumber">1854</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1855</td>
    <td class="codeline">/// Helper class for identifying ordered max predicates.</td>
    <td class="lineNumber">1855</td>
    <td class="codeline">/// Helper class for identifying ordered max predicates.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1856</td>
    <td class="codeline">struct ofmax_pred_ty {</td>
    <td class="lineNumber">1856</td>
    <td class="codeline">struct ofmax_pred_ty {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1857</td>
    <td class="codeline">  static bool match(FCmpInst::Predicate Pred) {</td>
    <td class="lineNumber">1857</td>
    <td class="codeline">  static bool match(FCmpInst::Predicate Pred) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1858</td>
    <td class="codeline">    return Pred == CmpInst::FCMP_OGT || Pred == CmpInst::FCMP_OGE;</td>
    <td class="lineNumber">1858</td>
    <td class="codeline">    return Pred == CmpInst::FCMP_OGT || Pred == CmpInst::FCMP_OGE;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1859</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1859</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1860</td>
    <td class="codeline">};</td>
    <td class="lineNumber">1860</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1861</td>
    <td class="codeline"></td>
    <td class="lineNumber">1861</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1862</td>
    <td class="codeline">/// Helper class for identifying ordered min predicates.</td>
    <td class="lineNumber">1862</td>
    <td class="codeline">/// Helper class for identifying ordered min predicates.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1863</td>
    <td class="codeline">struct ofmin_pred_ty {</td>
    <td class="lineNumber">1863</td>
    <td class="codeline">struct ofmin_pred_ty {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1864</td>
    <td class="codeline">  static bool match(FCmpInst::Predicate Pred) {</td>
    <td class="lineNumber">1864</td>
    <td class="codeline">  static bool match(FCmpInst::Predicate Pred) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1865</td>
    <td class="codeline">    return Pred == CmpInst::FCMP_OLT || Pred == CmpInst::FCMP_OLE;</td>
    <td class="lineNumber">1865</td>
    <td class="codeline">    return Pred == CmpInst::FCMP_OLT || Pred == CmpInst::FCMP_OLE;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1866</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1866</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1867</td>
    <td class="codeline">};</td>
    <td class="lineNumber">1867</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1868</td>
    <td class="codeline"></td>
    <td class="lineNumber">1868</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1869</td>
    <td class="codeline">/// Helper class for identifying unordered max predicates.</td>
    <td class="lineNumber">1869</td>
    <td class="codeline">/// Helper class for identifying unordered max predicates.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1870</td>
    <td class="codeline">struct ufmax_pred_ty {</td>
    <td class="lineNumber">1870</td>
    <td class="codeline">struct ufmax_pred_ty {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1871</td>
    <td class="codeline">  static bool match(FCmpInst::Predicate Pred) {</td>
    <td class="lineNumber">1871</td>
    <td class="codeline">  static bool match(FCmpInst::Predicate Pred) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1872</td>
    <td class="codeline">    return Pred == CmpInst::FCMP_UGT || Pred == CmpInst::FCMP_UGE;</td>
    <td class="lineNumber">1872</td>
    <td class="codeline">    return Pred == CmpInst::FCMP_UGT || Pred == CmpInst::FCMP_UGE;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1873</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1873</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1874</td>
    <td class="codeline">};</td>
    <td class="lineNumber">1874</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1875</td>
    <td class="codeline"></td>
    <td class="lineNumber">1875</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1876</td>
    <td class="codeline">/// Helper class for identifying unordered min predicates.</td>
    <td class="lineNumber">1876</td>
    <td class="codeline">/// Helper class for identifying unordered min predicates.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1877</td>
    <td class="codeline">struct ufmin_pred_ty {</td>
    <td class="lineNumber">1877</td>
    <td class="codeline">struct ufmin_pred_ty {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1878</td>
    <td class="codeline">  static bool match(FCmpInst::Predicate Pred) {</td>
    <td class="lineNumber">1878</td>
    <td class="codeline">  static bool match(FCmpInst::Predicate Pred) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1879</td>
    <td class="codeline">    return Pred == CmpInst::FCMP_ULT || Pred == CmpInst::FCMP_ULE;</td>
    <td class="lineNumber">1879</td>
    <td class="codeline">    return Pred == CmpInst::FCMP_ULT || Pred == CmpInst::FCMP_ULE;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1880</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1880</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1881</td>
    <td class="codeline">};</td>
    <td class="lineNumber">1881</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1882</td>
    <td class="codeline"></td>
    <td class="lineNumber">1882</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1883</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
    <td class="lineNumber">1883</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1884</td>
    <td class="codeline">inline MaxMin_match<ICmpInst, LHS, RHS, smax_pred_ty> m_SMax(const LHS &L,</td>
    <td class="lineNumber">1884</td>
    <td class="codeline">inline MaxMin_match<ICmpInst, LHS, RHS, smax_pred_ty> m_SMax(const LHS &L,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1885</td>
    <td class="codeline">                                                             const RHS &R) {</td>
    <td class="lineNumber">1885</td>
    <td class="codeline">                                                             const RHS &R) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1886</td>
    <td class="codeline">  return MaxMin_match<ICmpInst, LHS, RHS, smax_pred_ty>(L, R);</td>
    <td class="lineNumber">1886</td>
    <td class="codeline">  return MaxMin_match<ICmpInst, LHS, RHS, smax_pred_ty>(L, R);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1887</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1887</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1888</td>
    <td class="codeline"></td>
    <td class="lineNumber">1888</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1889</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
    <td class="lineNumber">1889</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1890</td>
    <td class="codeline">inline MaxMin_match<ICmpInst, LHS, RHS, smin_pred_ty> m_SMin(const LHS &L,</td>
    <td class="lineNumber">1890</td>
    <td class="codeline">inline MaxMin_match<ICmpInst, LHS, RHS, smin_pred_ty> m_SMin(const LHS &L,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1891</td>
    <td class="codeline">                                                             const RHS &R) {</td>
    <td class="lineNumber">1891</td>
    <td class="codeline">                                                             const RHS &R) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1892</td>
    <td class="codeline">  return MaxMin_match<ICmpInst, LHS, RHS, smin_pred_ty>(L, R);</td>
    <td class="lineNumber">1892</td>
    <td class="codeline">  return MaxMin_match<ICmpInst, LHS, RHS, smin_pred_ty>(L, R);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1893</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1893</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1894</td>
    <td class="codeline"></td>
    <td class="lineNumber">1894</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1895</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
    <td class="lineNumber">1895</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1896</td>
    <td class="codeline">inline MaxMin_match<ICmpInst, LHS, RHS, umax_pred_ty> m_UMax(const LHS &L,</td>
    <td class="lineNumber">1896</td>
    <td class="codeline">inline MaxMin_match<ICmpInst, LHS, RHS, umax_pred_ty> m_UMax(const LHS &L,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1897</td>
    <td class="codeline">                                                             const RHS &R) {</td>
    <td class="lineNumber">1897</td>
    <td class="codeline">                                                             const RHS &R) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1898</td>
    <td class="codeline">  return MaxMin_match<ICmpInst, LHS, RHS, umax_pred_ty>(L, R);</td>
    <td class="lineNumber">1898</td>
    <td class="codeline">  return MaxMin_match<ICmpInst, LHS, RHS, umax_pred_ty>(L, R);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1899</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1899</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1900</td>
    <td class="codeline"></td>
    <td class="lineNumber">1900</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1901</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
    <td class="lineNumber">1901</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1902</td>
    <td class="codeline">inline MaxMin_match<ICmpInst, LHS, RHS, umin_pred_ty> m_UMin(const LHS &L,</td>
    <td class="lineNumber">1902</td>
    <td class="codeline">inline MaxMin_match<ICmpInst, LHS, RHS, umin_pred_ty> m_UMin(const LHS &L,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1903</td>
    <td class="codeline">                                                             const RHS &R) {</td>
    <td class="lineNumber">1903</td>
    <td class="codeline">                                                             const RHS &R) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1904</td>
    <td class="codeline">  return MaxMin_match<ICmpInst, LHS, RHS, umin_pred_ty>(L, R);</td>
    <td class="lineNumber">1904</td>
    <td class="codeline">  return MaxMin_match<ICmpInst, LHS, RHS, umin_pred_ty>(L, R);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1905</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1905</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1906</td>
    <td class="codeline"></td>
    <td class="lineNumber">1906</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1907</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
    <td class="lineNumber">1907</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1908</td>
    <td class="codeline">inline match_combine_or<</td>
    <td class="lineNumber">1908</td>
    <td class="codeline">inline match_combine_or<</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1909</td>
    <td class="codeline">    match_combine_or<MaxMin_match<ICmpInst, LHS, RHS, smax_pred_ty>,</td>
    <td class="lineNumber">1909</td>
    <td class="codeline">    match_combine_or<MaxMin_match<ICmpInst, LHS, RHS, smax_pred_ty>,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1910</td>
    <td class="codeline">                     MaxMin_match<ICmpInst, LHS, RHS, smin_pred_ty>>,</td>
    <td class="lineNumber">1910</td>
    <td class="codeline">                     MaxMin_match<ICmpInst, LHS, RHS, smin_pred_ty>>,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1911</td>
    <td class="codeline">    match_combine_or<MaxMin_match<ICmpInst, LHS, RHS, umax_pred_ty>,</td>
    <td class="lineNumber">1911</td>
    <td class="codeline">    match_combine_or<MaxMin_match<ICmpInst, LHS, RHS, umax_pred_ty>,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1912</td>
    <td class="codeline">                     MaxMin_match<ICmpInst, LHS, RHS, umin_pred_ty>>></td>
    <td class="lineNumber">1912</td>
    <td class="codeline">                     MaxMin_match<ICmpInst, LHS, RHS, umin_pred_ty>>></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1913</td>
    <td class="codeline">m_MaxOrMin(const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">1913</td>
    <td class="codeline">m_MaxOrMin(const LHS &L, const RHS &R) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1914</td>
    <td class="codeline">  return m_CombineOr(m_CombineOr(m_SMax(L, R), m_SMin(L, R)),</td>
    <td class="lineNumber">1914</td>
    <td class="codeline">  return m_CombineOr(m_CombineOr(m_SMax(L, R), m_SMin(L, R)),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1915</td>
    <td class="codeline">                     m_CombineOr(m_UMax(L, R), m_UMin(L, R)));</td>
    <td class="lineNumber">1915</td>
    <td class="codeline">                     m_CombineOr(m_UMax(L, R), m_UMin(L, R)));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1916</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1916</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1917</td>
    <td class="codeline"></td>
    <td class="lineNumber">1917</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1918</td>
    <td class="codeline">/// Match an 'ordered' floating point maximum function.</td>
    <td class="lineNumber">1918</td>
    <td class="codeline">/// Match an 'ordered' floating point maximum function.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1919</td>
    <td class="codeline">/// Floating point has one special value 'NaN'. Therefore, there is no total</td>
    <td class="lineNumber">1919</td>
    <td class="codeline">/// Floating point has one special value 'NaN'. Therefore, there is no total</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1920</td>
    <td class="codeline">/// order. However, if we can ignore the 'NaN' value (for example, because of a</td>
    <td class="lineNumber">1920</td>
    <td class="codeline">/// order. However, if we can ignore the 'NaN' value (for example, because of a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1921</td>
    <td class="codeline">/// 'no-nans-float-math' flag) a combination of a fcmp and select has 'maximum'</td>
    <td class="lineNumber">1921</td>
    <td class="codeline">/// 'no-nans-float-math' flag) a combination of a fcmp and select has 'maximum'</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1922</td>
    <td class="codeline">/// semantics. In the presence of 'NaN' we have to preserve the original</td>
    <td class="lineNumber">1922</td>
    <td class="codeline">/// semantics. In the presence of 'NaN' we have to preserve the original</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1923</td>
    <td class="codeline">/// select(fcmp(ogt/ge, L, R), L, R) semantics matched by this predicate.</td>
    <td class="lineNumber">1923</td>
    <td class="codeline">/// select(fcmp(ogt/ge, L, R), L, R) semantics matched by this predicate.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1924</td>
    <td class="codeline">///</td>
    <td class="lineNumber">1924</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1925</td>
    <td class="codeline">///                         max(L, R)  iff L and R are not NaN</td>
    <td class="lineNumber">1925</td>
    <td class="codeline">///                         max(L, R)  iff L and R are not NaN</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1926</td>
    <td class="codeline">///  m_OrdFMax(L, R) =      R          iff L or R are NaN</td>
    <td class="lineNumber">1926</td>
    <td class="codeline">///  m_OrdFMax(L, R) =      R          iff L or R are NaN</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1927</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
    <td class="lineNumber">1927</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1928</td>
    <td class="codeline">inline MaxMin_match<FCmpInst, LHS, RHS, ofmax_pred_ty> m_OrdFMax(const LHS &L,</td>
    <td class="lineNumber">1928</td>
    <td class="codeline">inline MaxMin_match<FCmpInst, LHS, RHS, ofmax_pred_ty> m_OrdFMax(const LHS &L,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1929</td>
    <td class="codeline">                                                                 const RHS &R) {</td>
    <td class="lineNumber">1929</td>
    <td class="codeline">                                                                 const RHS &R) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1930</td>
    <td class="codeline">  return MaxMin_match<FCmpInst, LHS, RHS, ofmax_pred_ty>(L, R);</td>
    <td class="lineNumber">1930</td>
    <td class="codeline">  return MaxMin_match<FCmpInst, LHS, RHS, ofmax_pred_ty>(L, R);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1931</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1931</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1932</td>
    <td class="codeline"></td>
    <td class="lineNumber">1932</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1933</td>
    <td class="codeline">/// Match an 'ordered' floating point minimum function.</td>
    <td class="lineNumber">1933</td>
    <td class="codeline">/// Match an 'ordered' floating point minimum function.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1934</td>
    <td class="codeline">/// Floating point has one special value 'NaN'. Therefore, there is no total</td>
    <td class="lineNumber">1934</td>
    <td class="codeline">/// Floating point has one special value 'NaN'. Therefore, there is no total</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1935</td>
    <td class="codeline">/// order. However, if we can ignore the 'NaN' value (for example, because of a</td>
    <td class="lineNumber">1935</td>
    <td class="codeline">/// order. However, if we can ignore the 'NaN' value (for example, because of a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1936</td>
    <td class="codeline">/// 'no-nans-float-math' flag) a combination of a fcmp and select has 'minimum'</td>
    <td class="lineNumber">1936</td>
    <td class="codeline">/// 'no-nans-float-math' flag) a combination of a fcmp and select has 'minimum'</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1937</td>
    <td class="codeline">/// semantics. In the presence of 'NaN' we have to preserve the original</td>
    <td class="lineNumber">1937</td>
    <td class="codeline">/// semantics. In the presence of 'NaN' we have to preserve the original</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1938</td>
    <td class="codeline">/// select(fcmp(olt/le, L, R), L, R) semantics matched by this predicate.</td>
    <td class="lineNumber">1938</td>
    <td class="codeline">/// select(fcmp(olt/le, L, R), L, R) semantics matched by this predicate.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1939</td>
    <td class="codeline">///</td>
    <td class="lineNumber">1939</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1940</td>
    <td class="codeline">///                         min(L, R)  iff L and R are not NaN</td>
    <td class="lineNumber">1940</td>
    <td class="codeline">///                         min(L, R)  iff L and R are not NaN</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1941</td>
    <td class="codeline">///  m_OrdFMin(L, R) =      R          iff L or R are NaN</td>
    <td class="lineNumber">1941</td>
    <td class="codeline">///  m_OrdFMin(L, R) =      R          iff L or R are NaN</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1942</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
    <td class="lineNumber">1942</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1943</td>
    <td class="codeline">inline MaxMin_match<FCmpInst, LHS, RHS, ofmin_pred_ty> m_OrdFMin(const LHS &L,</td>
    <td class="lineNumber">1943</td>
    <td class="codeline">inline MaxMin_match<FCmpInst, LHS, RHS, ofmin_pred_ty> m_OrdFMin(const LHS &L,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1944</td>
    <td class="codeline">                                                                 const RHS &R) {</td>
    <td class="lineNumber">1944</td>
    <td class="codeline">                                                                 const RHS &R) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1945</td>
    <td class="codeline">  return MaxMin_match<FCmpInst, LHS, RHS, ofmin_pred_ty>(L, R);</td>
    <td class="lineNumber">1945</td>
    <td class="codeline">  return MaxMin_match<FCmpInst, LHS, RHS, ofmin_pred_ty>(L, R);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1946</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1946</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1947</td>
    <td class="codeline"></td>
    <td class="lineNumber">1947</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1948</td>
    <td class="codeline">/// Match an 'unordered' floating point maximum function.</td>
    <td class="lineNumber">1948</td>
    <td class="codeline">/// Match an 'unordered' floating point maximum function.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1949</td>
    <td class="codeline">/// Floating point has one special value 'NaN'. Therefore, there is no total</td>
    <td class="lineNumber">1949</td>
    <td class="codeline">/// Floating point has one special value 'NaN'. Therefore, there is no total</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1950</td>
    <td class="codeline">/// order. However, if we can ignore the 'NaN' value (for example, because of a</td>
    <td class="lineNumber">1950</td>
    <td class="codeline">/// order. However, if we can ignore the 'NaN' value (for example, because of a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1951</td>
    <td class="codeline">/// 'no-nans-float-math' flag) a combination of a fcmp and select has 'maximum'</td>
    <td class="lineNumber">1951</td>
    <td class="codeline">/// 'no-nans-float-math' flag) a combination of a fcmp and select has 'maximum'</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1952</td>
    <td class="codeline">/// semantics. In the presence of 'NaN' we have to preserve the original</td>
    <td class="lineNumber">1952</td>
    <td class="codeline">/// semantics. In the presence of 'NaN' we have to preserve the original</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1953</td>
    <td class="codeline">/// select(fcmp(ugt/ge, L, R), L, R) semantics matched by this predicate.</td>
    <td class="lineNumber">1953</td>
    <td class="codeline">/// select(fcmp(ugt/ge, L, R), L, R) semantics matched by this predicate.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1954</td>
    <td class="codeline">///</td>
    <td class="lineNumber">1954</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1955</td>
    <td class="codeline">///                         max(L, R)  iff L and R are not NaN</td>
    <td class="lineNumber">1955</td>
    <td class="codeline">///                         max(L, R)  iff L and R are not NaN</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1956</td>
    <td class="codeline">///  m_UnordFMax(L, R) =    L          iff L or R are NaN</td>
    <td class="lineNumber">1956</td>
    <td class="codeline">///  m_UnordFMax(L, R) =    L          iff L or R are NaN</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1957</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
    <td class="lineNumber">1957</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1958</td>
    <td class="codeline">inline MaxMin_match<FCmpInst, LHS, RHS, ufmax_pred_ty></td>
    <td class="lineNumber">1958</td>
    <td class="codeline">inline MaxMin_match<FCmpInst, LHS, RHS, ufmax_pred_ty></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1959</td>
    <td class="codeline">m_UnordFMax(const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">1959</td>
    <td class="codeline">m_UnordFMax(const LHS &L, const RHS &R) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1960</td>
    <td class="codeline">  return MaxMin_match<FCmpInst, LHS, RHS, ufmax_pred_ty>(L, R);</td>
    <td class="lineNumber">1960</td>
    <td class="codeline">  return MaxMin_match<FCmpInst, LHS, RHS, ufmax_pred_ty>(L, R);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1961</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1961</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1962</td>
    <td class="codeline"></td>
    <td class="lineNumber">1962</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1963</td>
    <td class="codeline">/// Match an 'unordered' floating point minimum function.</td>
    <td class="lineNumber">1963</td>
    <td class="codeline">/// Match an 'unordered' floating point minimum function.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1964</td>
    <td class="codeline">/// Floating point has one special value 'NaN'. Therefore, there is no total</td>
    <td class="lineNumber">1964</td>
    <td class="codeline">/// Floating point has one special value 'NaN'. Therefore, there is no total</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1965</td>
    <td class="codeline">/// order. However, if we can ignore the 'NaN' value (for example, because of a</td>
    <td class="lineNumber">1965</td>
    <td class="codeline">/// order. However, if we can ignore the 'NaN' value (for example, because of a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1966</td>
    <td class="codeline">/// 'no-nans-float-math' flag) a combination of a fcmp and select has 'minimum'</td>
    <td class="lineNumber">1966</td>
    <td class="codeline">/// 'no-nans-float-math' flag) a combination of a fcmp and select has 'minimum'</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1967</td>
    <td class="codeline">/// semantics. In the presence of 'NaN' we have to preserve the original</td>
    <td class="lineNumber">1967</td>
    <td class="codeline">/// semantics. In the presence of 'NaN' we have to preserve the original</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1968</td>
    <td class="codeline">/// select(fcmp(ult/le, L, R), L, R) semantics matched by this predicate.</td>
    <td class="lineNumber">1968</td>
    <td class="codeline">/// select(fcmp(ult/le, L, R), L, R) semantics matched by this predicate.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1969</td>
    <td class="codeline">///</td>
    <td class="lineNumber">1969</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1970</td>
    <td class="codeline">///                          min(L, R)  iff L and R are not NaN</td>
    <td class="lineNumber">1970</td>
    <td class="codeline">///                          min(L, R)  iff L and R are not NaN</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1971</td>
    <td class="codeline">///  m_UnordFMin(L, R) =     L          iff L or R are NaN</td>
    <td class="lineNumber">1971</td>
    <td class="codeline">///  m_UnordFMin(L, R) =     L          iff L or R are NaN</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1972</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
    <td class="lineNumber">1972</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1973</td>
    <td class="codeline">inline MaxMin_match<FCmpInst, LHS, RHS, ufmin_pred_ty></td>
    <td class="lineNumber">1973</td>
    <td class="codeline">inline MaxMin_match<FCmpInst, LHS, RHS, ufmin_pred_ty></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1974</td>
    <td class="codeline">m_UnordFMin(const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">1974</td>
    <td class="codeline">m_UnordFMin(const LHS &L, const RHS &R) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1975</td>
    <td class="codeline">  return MaxMin_match<FCmpInst, LHS, RHS, ufmin_pred_ty>(L, R);</td>
    <td class="lineNumber">1975</td>
    <td class="codeline">  return MaxMin_match<FCmpInst, LHS, RHS, ufmin_pred_ty>(L, R);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1976</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1976</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1977</td>
    <td class="codeline"></td>
    <td class="lineNumber">1977</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1978</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">1978</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1979</td>
    <td class="codeline">// Matchers for overflow check patterns: e.g. (a + b) u< a, (a ^ -1) <u b</td>
    <td class="lineNumber">1979</td>
    <td class="codeline">// Matchers for overflow check patterns: e.g. (a + b) u< a, (a ^ -1) <u b</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1980</td>
    <td class="codeline">// Note that S might be matched to other instructions than AddInst.</td>
    <td class="lineNumber">1980</td>
    <td class="codeline">// Note that S might be matched to other instructions than AddInst.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1981</td>
    <td class="codeline">//</td>
    <td class="lineNumber">1981</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1982</td>
    <td class="codeline"></td>
    <td class="lineNumber">1982</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1983</td>
    <td class="codeline">template <typename LHS_t, typename RHS_t, typename Sum_t></td>
    <td class="lineNumber">1983</td>
    <td class="codeline">template <typename LHS_t, typename RHS_t, typename Sum_t></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1984</td>
    <td class="codeline">struct UAddWithOverflow_match {</td>
    <td class="lineNumber">1984</td>
    <td class="codeline">struct UAddWithOverflow_match {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1985</td>
    <td class="codeline">  LHS_t L;</td>
    <td class="lineNumber">1985</td>
    <td class="codeline">  LHS_t L;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1986</td>
    <td class="codeline">  RHS_t R;</td>
    <td class="lineNumber">1986</td>
    <td class="codeline">  RHS_t R;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1987</td>
    <td class="codeline">  Sum_t S;</td>
    <td class="lineNumber">1987</td>
    <td class="codeline">  Sum_t S;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1988</td>
    <td class="codeline"></td>
    <td class="lineNumber">1988</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1989</td>
    <td class="codeline">  UAddWithOverflow_match(const LHS_t &L, const RHS_t &R, const Sum_t &S)</td>
    <td class="lineNumber">1989</td>
    <td class="codeline">  UAddWithOverflow_match(const LHS_t &L, const RHS_t &R, const Sum_t &S)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1990</td>
    <td class="codeline">      : L(L), R(R), S(S) {}</td>
    <td class="lineNumber">1990</td>
    <td class="codeline">      : L(L), R(R), S(S) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1991</td>
    <td class="codeline"></td>
    <td class="lineNumber">1991</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1992</td>
    <td class="codeline">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td class="lineNumber">1992</td>
    <td class="codeline">  template <typename OpTy> bool match(OpTy *V) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1993</td>
    <td class="codeline">    Value *ICmpLHS, *ICmpRHS;</td>
    <td class="lineNumber">1993</td>
    <td class="codeline">    Value *ICmpLHS, *ICmpRHS;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1994</td>
    <td class="codeline">    ICmpInst::Predicate Pred;</td>
    <td class="lineNumber">1994</td>
    <td class="codeline">    ICmpInst::Predicate Pred;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1995</td>
    <td class="codeline">    if (!m_ICmp(Pred, m_Value(ICmpLHS), m_Value(ICmpRHS)).match(V))</td>
    <td class="lineNumber">1995</td>
    <td class="codeline">    if (!m_ICmp(Pred, m_Value(ICmpLHS), m_Value(ICmpRHS)).match(V))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1996</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">1996</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1997</td>
    <td class="codeline"></td>
    <td class="lineNumber">1997</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1998</td>
    <td class="codeline">    Value *AddLHS, *AddRHS;</td>
    <td class="lineNumber">1998</td>
    <td class="codeline">    Value *AddLHS, *AddRHS;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1999</td>
    <td class="codeline">    auto AddExpr = m_Add(m_Value(AddLHS), m_Value(AddRHS));</td>
    <td class="lineNumber">1999</td>
    <td class="codeline">    auto AddExpr = m_Add(m_Value(AddLHS), m_Value(AddRHS));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2000</td>
    <td class="codeline"></td>
    <td class="lineNumber">2000</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2001</td>
    <td class="codeline">    // (a + b) u< a, (a + b) u< b</td>
    <td class="lineNumber">2001</td>
    <td class="codeline">    // (a + b) u< a, (a + b) u< b</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2002</td>
    <td class="codeline">    if (Pred == ICmpInst::ICMP_ULT)</td>
    <td class="lineNumber">2002</td>
    <td class="codeline">    if (Pred == ICmpInst::ICMP_ULT)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2003</td>
    <td class="codeline">      if (AddExpr.match(ICmpLHS) && (ICmpRHS == AddLHS || ICmpRHS == AddRHS))</td>
    <td class="lineNumber">2003</td>
    <td class="codeline">      if (AddExpr.match(ICmpLHS) && (ICmpRHS == AddLHS || ICmpRHS == AddRHS))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2004</td>
    <td class="codeline">        return L.match(AddLHS) && R.match(AddRHS) && S.match(ICmpLHS);</td>
    <td class="lineNumber">2004</td>
    <td class="codeline">        return L.match(AddLHS) && R.match(AddRHS) && S.match(ICmpLHS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2005</td>
    <td class="codeline"></td>
    <td class="lineNumber">2005</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2006</td>
    <td class="codeline">    // a >u (a + b), b >u (a + b)</td>
    <td class="lineNumber">2006</td>
    <td class="codeline">    // a >u (a + b), b >u (a + b)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2007</td>
    <td class="codeline">    if (Pred == ICmpInst::ICMP_UGT)</td>
    <td class="lineNumber">2007</td>
    <td class="codeline">    if (Pred == ICmpInst::ICMP_UGT)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2008</td>
    <td class="codeline">      if (AddExpr.match(ICmpRHS) && (ICmpLHS == AddLHS || ICmpLHS == AddRHS))</td>
    <td class="lineNumber">2008</td>
    <td class="codeline">      if (AddExpr.match(ICmpRHS) && (ICmpLHS == AddLHS || ICmpLHS == AddRHS))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2009</td>
    <td class="codeline">        return L.match(AddLHS) && R.match(AddRHS) && S.match(ICmpRHS);</td>
    <td class="lineNumber">2009</td>
    <td class="codeline">        return L.match(AddLHS) && R.match(AddRHS) && S.match(ICmpRHS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2010</td>
    <td class="codeline"></td>
    <td class="lineNumber">2010</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2011</td>
    <td class="codeline">    Value *Op1;</td>
    <td class="lineNumber">2011</td>
    <td class="codeline">    Value *Op1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2012</td>
    <td class="codeline">    auto XorExpr = m_OneUse(m_Xor(m_Value(Op1), m_AllOnes()));</td>
    <td class="lineNumber">2012</td>
    <td class="codeline">    auto XorExpr = m_OneUse(m_Xor(m_Value(Op1), m_AllOnes()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2013</td>
    <td class="codeline">    // (a ^ -1) <u b</td>
    <td class="lineNumber">2013</td>
    <td class="codeline">    // (a ^ -1) <u b</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2014</td>
    <td class="codeline">    if (Pred == ICmpInst::ICMP_ULT) {</td>
    <td class="lineNumber">2014</td>
    <td class="codeline">    if (Pred == ICmpInst::ICMP_ULT) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2015</td>
    <td class="codeline">      if (XorExpr.match(ICmpLHS))</td>
    <td class="lineNumber">2015</td>
    <td class="codeline">      if (XorExpr.match(ICmpLHS))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2016</td>
    <td class="codeline">        return L.match(Op1) && R.match(ICmpRHS) && S.match(ICmpLHS);</td>
    <td class="lineNumber">2016</td>
    <td class="codeline">        return L.match(Op1) && R.match(ICmpRHS) && S.match(ICmpLHS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2017</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2017</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2018</td>
    <td class="codeline">    //  b > u (a ^ -1)</td>
    <td class="lineNumber">2018</td>
    <td class="codeline">    //  b > u (a ^ -1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2019</td>
    <td class="codeline">    if (Pred == ICmpInst::ICMP_UGT) {</td>
    <td class="lineNumber">2019</td>
    <td class="codeline">    if (Pred == ICmpInst::ICMP_UGT) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2020</td>
    <td class="codeline">      if (XorExpr.match(ICmpRHS))</td>
    <td class="lineNumber">2020</td>
    <td class="codeline">      if (XorExpr.match(ICmpRHS))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2021</td>
    <td class="codeline">        return L.match(Op1) && R.match(ICmpLHS) && S.match(ICmpRHS);</td>
    <td class="lineNumber">2021</td>
    <td class="codeline">        return L.match(Op1) && R.match(ICmpLHS) && S.match(ICmpRHS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2022</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2022</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2023</td>
    <td class="codeline"></td>
    <td class="lineNumber">2023</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2024</td>
    <td class="codeline">    // Match special-case for increment-by-1.</td>
    <td class="lineNumber">2024</td>
    <td class="codeline">    // Match special-case for increment-by-1.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2025</td>
    <td class="codeline">    if (Pred == ICmpInst::ICMP_EQ) {</td>
    <td class="lineNumber">2025</td>
    <td class="codeline">    if (Pred == ICmpInst::ICMP_EQ) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2026</td>
    <td class="codeline">      // (a + 1) == 0</td>
    <td class="lineNumber">2026</td>
    <td class="codeline">      // (a + 1) == 0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2027</td>
    <td class="codeline">      // (1 + a) == 0</td>
    <td class="lineNumber">2027</td>
    <td class="codeline">      // (1 + a) == 0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2028</td>
    <td class="codeline">      if (AddExpr.match(ICmpLHS) && m_ZeroInt().match(ICmpRHS) &&</td>
    <td class="lineNumber">2028</td>
    <td class="codeline">      if (AddExpr.match(ICmpLHS) && m_ZeroInt().match(ICmpRHS) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2029</td>
    <td class="codeline">          (m_One().match(AddLHS) || m_One().match(AddRHS)))</td>
    <td class="lineNumber">2029</td>
    <td class="codeline">          (m_One().match(AddLHS) || m_One().match(AddRHS)))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2030</td>
    <td class="codeline">        return L.match(AddLHS) && R.match(AddRHS) && S.match(ICmpLHS);</td>
    <td class="lineNumber">2030</td>
    <td class="codeline">        return L.match(AddLHS) && R.match(AddRHS) && S.match(ICmpLHS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2031</td>
    <td class="codeline">      // 0 == (a + 1)</td>
    <td class="lineNumber">2031</td>
    <td class="codeline">      // 0 == (a + 1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2032</td>
    <td class="codeline">      // 0 == (1 + a)</td>
    <td class="lineNumber">2032</td>
    <td class="codeline">      // 0 == (1 + a)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2033</td>
    <td class="codeline">      if (m_ZeroInt().match(ICmpLHS) && AddExpr.match(ICmpRHS) &&</td>
    <td class="lineNumber">2033</td>
    <td class="codeline">      if (m_ZeroInt().match(ICmpLHS) && AddExpr.match(ICmpRHS) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2034</td>
    <td class="codeline">          (m_One().match(AddLHS) || m_One().match(AddRHS)))</td>
    <td class="lineNumber">2034</td>
    <td class="codeline">          (m_One().match(AddLHS) || m_One().match(AddRHS)))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2035</td>
    <td class="codeline">        return L.match(AddLHS) && R.match(AddRHS) && S.match(ICmpRHS);</td>
    <td class="lineNumber">2035</td>
    <td class="codeline">        return L.match(AddLHS) && R.match(AddRHS) && S.match(ICmpRHS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2036</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2036</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2037</td>
    <td class="codeline"></td>
    <td class="lineNumber">2037</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2038</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">2038</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2039</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2039</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2040</td>
    <td class="codeline">};</td>
    <td class="lineNumber">2040</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2041</td>
    <td class="codeline"></td>
    <td class="lineNumber">2041</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2042</td>
    <td class="codeline">/// Match an icmp instruction checking for unsigned overflow on addition.</td>
    <td class="lineNumber">2042</td>
    <td class="codeline">/// Match an icmp instruction checking for unsigned overflow on addition.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2043</td>
    <td class="codeline">///</td>
    <td class="lineNumber">2043</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2044</td>
    <td class="codeline">/// S is matched to the addition whose result is being checked for overflow, and</td>
    <td class="lineNumber">2044</td>
    <td class="codeline">/// S is matched to the addition whose result is being checked for overflow, and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2045</td>
    <td class="codeline">/// L and R are matched to the LHS and RHS of S.</td>
    <td class="lineNumber">2045</td>
    <td class="codeline">/// L and R are matched to the LHS and RHS of S.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2046</td>
    <td class="codeline">template <typename LHS_t, typename RHS_t, typename Sum_t></td>
    <td class="lineNumber">2046</td>
    <td class="codeline">template <typename LHS_t, typename RHS_t, typename Sum_t></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2047</td>
    <td class="codeline">UAddWithOverflow_match<LHS_t, RHS_t, Sum_t></td>
    <td class="lineNumber">2047</td>
    <td class="codeline">UAddWithOverflow_match<LHS_t, RHS_t, Sum_t></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2048</td>
    <td class="codeline">m_UAddWithOverflow(const LHS_t &L, const RHS_t &R, const Sum_t &S) {</td>
    <td class="lineNumber">2048</td>
    <td class="codeline">m_UAddWithOverflow(const LHS_t &L, const RHS_t &R, const Sum_t &S) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2049</td>
    <td class="codeline">  return UAddWithOverflow_match<LHS_t, RHS_t, Sum_t>(L, R, S);</td>
    <td class="lineNumber">2049</td>
    <td class="codeline">  return UAddWithOverflow_match<LHS_t, RHS_t, Sum_t>(L, R, S);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2050</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2050</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2051</td>
    <td class="codeline"></td>
    <td class="lineNumber">2051</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2052</td>
    <td class="codeline">template <typename Opnd_t> struct Argument_match {</td>
    <td class="lineNumber">2052</td>
    <td class="codeline">template <typename Opnd_t> struct Argument_match {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2053</td>
    <td class="codeline">  unsigned OpI;</td>
    <td class="lineNumber">2053</td>
    <td class="codeline">  unsigned OpI;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2054</td>
    <td class="codeline">  Opnd_t Val;</td>
    <td class="lineNumber">2054</td>
    <td class="codeline">  Opnd_t Val;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2055</td>
    <td class="codeline"></td>
    <td class="lineNumber">2055</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2056</td>
    <td class="codeline">  Argument_match(unsigned OpIdx, const Opnd_t &V) : OpI(OpIdx), Val(V) {}</td>
    <td class="lineNumber">2056</td>
    <td class="codeline">  Argument_match(unsigned OpIdx, const Opnd_t &V) : OpI(OpIdx), Val(V) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2057</td>
    <td class="codeline"></td>
    <td class="lineNumber">2057</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2058</td>
    <td class="codeline">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td class="lineNumber">2058</td>
    <td class="codeline">  template <typename OpTy> bool match(OpTy *V) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2059</td>
    <td class="codeline">    // FIXME: Should likely be switched to use `CallBase`.</td>
    <td class="lineNumber">2059</td>
    <td class="codeline">    // FIXME: Should likely be switched to use `CallBase`.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2060</td>
    <td class="codeline">    if (const auto *CI = dyn_cast<CallInst>(V))</td>
    <td class="lineNumber">2060</td>
    <td class="codeline">    if (const auto *CI = dyn_cast<CallInst>(V))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2061</td>
    <td class="codeline">      return Val.match(CI->getArgOperand(OpI));</td>
    <td class="lineNumber">2061</td>
    <td class="codeline">      return Val.match(CI->getArgOperand(OpI));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2062</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">2062</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2063</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2063</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2064</td>
    <td class="codeline">};</td>
    <td class="lineNumber">2064</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2065</td>
    <td class="codeline"></td>
    <td class="lineNumber">2065</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2066</td>
    <td class="codeline">/// Match an argument.</td>
    <td class="lineNumber">2066</td>
    <td class="codeline">/// Match an argument.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2067</td>
    <td class="codeline">template <unsigned OpI, typename Opnd_t></td>
    <td class="lineNumber">2067</td>
    <td class="codeline">template <unsigned OpI, typename Opnd_t></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2068</td>
    <td class="codeline">inline Argument_match<Opnd_t> m_Argument(const Opnd_t &Op) {</td>
    <td class="lineNumber">2068</td>
    <td class="codeline">inline Argument_match<Opnd_t> m_Argument(const Opnd_t &Op) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2069</td>
    <td class="codeline">  return Argument_match<Opnd_t>(OpI, Op);</td>
    <td class="lineNumber">2069</td>
    <td class="codeline">  return Argument_match<Opnd_t>(OpI, Op);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2070</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2070</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2071</td>
    <td class="codeline"></td>
    <td class="lineNumber">2071</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2072</td>
    <td class="codeline">/// Intrinsic matchers.</td>
    <td class="lineNumber">2072</td>
    <td class="codeline">/// Intrinsic matchers.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2073</td>
    <td class="codeline">struct IntrinsicID_match {</td>
    <td class="lineNumber">2073</td>
    <td class="codeline">struct IntrinsicID_match {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2074</td>
    <td class="codeline">  unsigned ID;</td>
    <td class="lineNumber">2074</td>
    <td class="codeline">  unsigned ID;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2075</td>
    <td class="codeline"></td>
    <td class="lineNumber">2075</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2076</td>
    <td class="codeline">  IntrinsicID_match(Intrinsic::ID IntrID) : ID(IntrID) {}</td>
    <td class="lineNumber">2076</td>
    <td class="codeline">  IntrinsicID_match(Intrinsic::ID IntrID) : ID(IntrID) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2077</td>
    <td class="codeline"></td>
    <td class="lineNumber">2077</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2078</td>
    <td class="codeline">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td class="lineNumber">2078</td>
    <td class="codeline">  template <typename OpTy> bool match(OpTy *V) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2079</td>
    <td class="codeline">    if (const auto *CI = dyn_cast<CallInst>(V))</td>
    <td class="lineNumber">2079</td>
    <td class="codeline">    if (const auto *CI = dyn_cast<CallInst>(V))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2080</td>
    <td class="codeline">      if (const auto *F = CI->getCalledFunction())</td>
    <td class="lineNumber">2080</td>
    <td class="codeline">      if (const auto *F = CI->getCalledFunction())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2081</td>
    <td class="codeline">        return F->getIntrinsicID() == ID;</td>
    <td class="lineNumber">2081</td>
    <td class="codeline">        return F->getIntrinsicID() == ID;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2082</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">2082</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2083</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2083</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2084</td>
    <td class="codeline">};</td>
    <td class="lineNumber">2084</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2085</td>
    <td class="codeline"></td>
    <td class="lineNumber">2085</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2086</td>
    <td class="codeline">/// Intrinsic matches are combinations of ID matchers, and argument</td>
    <td class="lineNumber">2086</td>
    <td class="codeline">/// Intrinsic matches are combinations of ID matchers, and argument</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2087</td>
    <td class="codeline">/// matchers. Higher arity matcher are defined recursively in terms of and-ing</td>
    <td class="lineNumber">2087</td>
    <td class="codeline">/// matchers. Higher arity matcher are defined recursively in terms of and-ing</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2088</td>
    <td class="codeline">/// them with lower arity matchers. Here's some convenient typedefs for up to</td>
    <td class="lineNumber">2088</td>
    <td class="codeline">/// them with lower arity matchers. Here's some convenient typedefs for up to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2089</td>
    <td class="codeline">/// several arguments, and more can be added as needed</td>
    <td class="lineNumber">2089</td>
    <td class="codeline">/// several arguments, and more can be added as needed</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2090</td>
    <td class="codeline">template <typename T0 = void, typename T1 = void, typename T2 = void,</td>
    <td class="lineNumber">2090</td>
    <td class="codeline">template <typename T0 = void, typename T1 = void, typename T2 = void,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2091</td>
    <td class="codeline">          typename T3 = void, typename T4 = void, typename T5 = void,</td>
    <td class="lineNumber">2091</td>
    <td class="codeline">          typename T3 = void, typename T4 = void, typename T5 = void,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2092</td>
    <td class="codeline">          typename T6 = void, typename T7 = void, typename T8 = void,</td>
    <td class="lineNumber">2092</td>
    <td class="codeline">          typename T6 = void, typename T7 = void, typename T8 = void,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2093</td>
    <td class="codeline">          typename T9 = void, typename T10 = void></td>
    <td class="lineNumber">2093</td>
    <td class="codeline">          typename T9 = void, typename T10 = void></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2094</td>
    <td class="codeline">struct m_Intrinsic_Ty;</td>
    <td class="lineNumber">2094</td>
    <td class="codeline">struct m_Intrinsic_Ty;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2095</td>
    <td class="codeline">template <typename T0> struct m_Intrinsic_Ty<T0> {</td>
    <td class="lineNumber">2095</td>
    <td class="codeline">template <typename T0> struct m_Intrinsic_Ty<T0> {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2096</td>
    <td class="codeline">  using Ty = match_combine_and<IntrinsicID_match, Argument_match<T0>>;</td>
    <td class="lineNumber">2096</td>
    <td class="codeline">  using Ty = match_combine_and<IntrinsicID_match, Argument_match<T0>>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2097</td>
    <td class="codeline">};</td>
    <td class="lineNumber">2097</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2098</td>
    <td class="codeline">template <typename T0, typename T1> struct m_Intrinsic_Ty<T0, T1> {</td>
    <td class="lineNumber">2098</td>
    <td class="codeline">template <typename T0, typename T1> struct m_Intrinsic_Ty<T0, T1> {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2099</td>
    <td class="codeline">  using Ty =</td>
    <td class="lineNumber">2099</td>
    <td class="codeline">  using Ty =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2100</td>
    <td class="codeline">      match_combine_and<typename m_Intrinsic_Ty<T0>::Ty, Argument_match<T1>>;</td>
    <td class="lineNumber">2100</td>
    <td class="codeline">      match_combine_and<typename m_Intrinsic_Ty<T0>::Ty, Argument_match<T1>>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2101</td>
    <td class="codeline">};</td>
    <td class="lineNumber">2101</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2102</td>
    <td class="codeline">template <typename T0, typename T1, typename T2></td>
    <td class="lineNumber">2102</td>
    <td class="codeline">template <typename T0, typename T1, typename T2></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2103</td>
    <td class="codeline">struct m_Intrinsic_Ty<T0, T1, T2> {</td>
    <td class="lineNumber">2103</td>
    <td class="codeline">struct m_Intrinsic_Ty<T0, T1, T2> {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2104</td>
    <td class="codeline">  using Ty = match_combine_and<typename m_Intrinsic_Ty<T0, T1>::Ty,</td>
    <td class="lineNumber">2104</td>
    <td class="codeline">  using Ty = match_combine_and<typename m_Intrinsic_Ty<T0, T1>::Ty,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2105</td>
    <td class="codeline">                               Argument_match<T2>>;</td>
    <td class="lineNumber">2105</td>
    <td class="codeline">                               Argument_match<T2>>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2106</td>
    <td class="codeline">};</td>
    <td class="lineNumber">2106</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2107</td>
    <td class="codeline">template <typename T0, typename T1, typename T2, typename T3></td>
    <td class="lineNumber">2107</td>
    <td class="codeline">template <typename T0, typename T1, typename T2, typename T3></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2108</td>
    <td class="codeline">struct m_Intrinsic_Ty<T0, T1, T2, T3> {</td>
    <td class="lineNumber">2108</td>
    <td class="codeline">struct m_Intrinsic_Ty<T0, T1, T2, T3> {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2109</td>
    <td class="codeline">  using Ty = match_combine_and<typename m_Intrinsic_Ty<T0, T1, T2>::Ty,</td>
    <td class="lineNumber">2109</td>
    <td class="codeline">  using Ty = match_combine_and<typename m_Intrinsic_Ty<T0, T1, T2>::Ty,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2110</td>
    <td class="codeline">                               Argument_match<T3>>;</td>
    <td class="lineNumber">2110</td>
    <td class="codeline">                               Argument_match<T3>>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2111</td>
    <td class="codeline">};</td>
    <td class="lineNumber">2111</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2112</td>
    <td class="codeline"></td>
    <td class="lineNumber">2112</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2113</td>
    <td class="codeline">template <typename T0, typename T1, typename T2, typename T3, typename T4></td>
    <td class="lineNumber">2113</td>
    <td class="codeline">template <typename T0, typename T1, typename T2, typename T3, typename T4></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2114</td>
    <td class="codeline">struct m_Intrinsic_Ty<T0, T1, T2, T3, T4> {</td>
    <td class="lineNumber">2114</td>
    <td class="codeline">struct m_Intrinsic_Ty<T0, T1, T2, T3, T4> {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2115</td>
    <td class="codeline">  using Ty = match_combine_and<typename m_Intrinsic_Ty<T0, T1, T2, T3>::Ty,</td>
    <td class="lineNumber">2115</td>
    <td class="codeline">  using Ty = match_combine_and<typename m_Intrinsic_Ty<T0, T1, T2, T3>::Ty,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2116</td>
    <td class="codeline">                               Argument_match<T4>>;</td>
    <td class="lineNumber">2116</td>
    <td class="codeline">                               Argument_match<T4>>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2117</td>
    <td class="codeline">};</td>
    <td class="lineNumber">2117</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2118</td>
    <td class="codeline"></td>
    <td class="lineNumber">2118</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2119</td>
    <td class="codeline">template <typename T0, typename T1, typename T2, typename T3, typename T4,</td>
    <td class="lineNumber">2119</td>
    <td class="codeline">template <typename T0, typename T1, typename T2, typename T3, typename T4,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2120</td>
    <td class="codeline">          typename T5></td>
    <td class="lineNumber">2120</td>
    <td class="codeline">          typename T5></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2121</td>
    <td class="codeline">struct m_Intrinsic_Ty<T0, T1, T2, T3, T4, T5> {</td>
    <td class="lineNumber">2121</td>
    <td class="codeline">struct m_Intrinsic_Ty<T0, T1, T2, T3, T4, T5> {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2122</td>
    <td class="codeline">  using Ty = match_combine_and<typename m_Intrinsic_Ty<T0, T1, T2, T3, T4>::Ty,</td>
    <td class="lineNumber">2122</td>
    <td class="codeline">  using Ty = match_combine_and<typename m_Intrinsic_Ty<T0, T1, T2, T3, T4>::Ty,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2123</td>
    <td class="codeline">                               Argument_match<T5>>;</td>
    <td class="lineNumber">2123</td>
    <td class="codeline">                               Argument_match<T5>>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2124</td>
    <td class="codeline">};</td>
    <td class="lineNumber">2124</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2125</td>
    <td class="codeline"></td>
    <td class="lineNumber">2125</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2126</td>
    <td class="codeline">/// Match intrinsic calls like this:</td>
    <td class="lineNumber">2126</td>
    <td class="codeline">/// Match intrinsic calls like this:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2127</td>
    <td class="codeline">/// m_Intrinsic<Intrinsic::fabs>(m_Value(X))</td>
    <td class="lineNumber">2127</td>
    <td class="codeline">/// m_Intrinsic<Intrinsic::fabs>(m_Value(X))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2128</td>
    <td class="codeline">template <Intrinsic::ID IntrID> inline IntrinsicID_match m_Intrinsic() {</td>
    <td class="lineNumber">2128</td>
    <td class="codeline">template <Intrinsic::ID IntrID> inline IntrinsicID_match m_Intrinsic() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2129</td>
    <td class="codeline">  return IntrinsicID_match(IntrID);</td>
    <td class="lineNumber">2129</td>
    <td class="codeline">  return IntrinsicID_match(IntrID);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2130</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2130</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2131</td>
    <td class="codeline"></td>
    <td class="lineNumber">2131</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2132</td>
    <td class="codeline">/// Matches MaskedLoad Intrinsic.</td>
    <td class="lineNumber">2132</td>
    <td class="codeline">/// Matches MaskedLoad Intrinsic.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2133</td>
    <td class="codeline">template <typename Opnd0, typename Opnd1, typename Opnd2, typename Opnd3></td>
    <td class="lineNumber">2133</td>
    <td class="codeline">template <typename Opnd0, typename Opnd1, typename Opnd2, typename Opnd3></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2134</td>
    <td class="codeline">inline typename m_Intrinsic_Ty<Opnd0, Opnd1, Opnd2, Opnd3>::Ty</td>
    <td class="lineNumber">2134</td>
    <td class="codeline">inline typename m_Intrinsic_Ty<Opnd0, Opnd1, Opnd2, Opnd3>::Ty</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2135</td>
    <td class="codeline">m_MaskedLoad(const Opnd0 &Op0, const Opnd1 &Op1, const Opnd2 &Op2,</td>
    <td class="lineNumber">2135</td>
    <td class="codeline">m_MaskedLoad(const Opnd0 &Op0, const Opnd1 &Op1, const Opnd2 &Op2,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2136</td>
    <td class="codeline">             const Opnd3 &Op3) {</td>
    <td class="lineNumber">2136</td>
    <td class="codeline">             const Opnd3 &Op3) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2137</td>
    <td class="codeline">  return m_Intrinsic<Intrinsic::masked_load>(Op0, Op1, Op2, Op3);</td>
    <td class="lineNumber">2137</td>
    <td class="codeline">  return m_Intrinsic<Intrinsic::masked_load>(Op0, Op1, Op2, Op3);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2138</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2138</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2139</td>
    <td class="codeline"></td>
    <td class="lineNumber">2139</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2140</td>
    <td class="codeline">/// Matches MaskedGather Intrinsic.</td>
    <td class="lineNumber">2140</td>
    <td class="codeline">/// Matches MaskedGather Intrinsic.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2141</td>
    <td class="codeline">template <typename Opnd0, typename Opnd1, typename Opnd2, typename Opnd3></td>
    <td class="lineNumber">2141</td>
    <td class="codeline">template <typename Opnd0, typename Opnd1, typename Opnd2, typename Opnd3></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2142</td>
    <td class="codeline">inline typename m_Intrinsic_Ty<Opnd0, Opnd1, Opnd2, Opnd3>::Ty</td>
    <td class="lineNumber">2142</td>
    <td class="codeline">inline typename m_Intrinsic_Ty<Opnd0, Opnd1, Opnd2, Opnd3>::Ty</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2143</td>
    <td class="codeline">m_MaskedGather(const Opnd0 &Op0, const Opnd1 &Op1, const Opnd2 &Op2,</td>
    <td class="lineNumber">2143</td>
    <td class="codeline">m_MaskedGather(const Opnd0 &Op0, const Opnd1 &Op1, const Opnd2 &Op2,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2144</td>
    <td class="codeline">               const Opnd3 &Op3) {</td>
    <td class="lineNumber">2144</td>
    <td class="codeline">               const Opnd3 &Op3) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2145</td>
    <td class="codeline">  return m_Intrinsic<Intrinsic::masked_gather>(Op0, Op1, Op2, Op3);</td>
    <td class="lineNumber">2145</td>
    <td class="codeline">  return m_Intrinsic<Intrinsic::masked_gather>(Op0, Op1, Op2, Op3);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2146</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2146</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2147</td>
    <td class="codeline"></td>
    <td class="lineNumber">2147</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2148</td>
    <td class="codeline">template <Intrinsic::ID IntrID, typename T0></td>
    <td class="lineNumber">2148</td>
    <td class="codeline">template <Intrinsic::ID IntrID, typename T0></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2149</td>
    <td class="codeline">inline typename m_Intrinsic_Ty<T0>::Ty m_Intrinsic(const T0 &Op0) {</td>
    <td class="lineNumber">2149</td>
    <td class="codeline">inline typename m_Intrinsic_Ty<T0>::Ty m_Intrinsic(const T0 &Op0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2150</td>
    <td class="codeline">  return m_CombineAnd(m_Intrinsic<IntrID>(), m_Argument<0>(Op0));</td>
    <td class="lineNumber">2150</td>
    <td class="codeline">  return m_CombineAnd(m_Intrinsic<IntrID>(), m_Argument<0>(Op0));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2151</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2151</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2152</td>
    <td class="codeline"></td>
    <td class="lineNumber">2152</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2153</td>
    <td class="codeline">template <Intrinsic::ID IntrID, typename T0, typename T1></td>
    <td class="lineNumber">2153</td>
    <td class="codeline">template <Intrinsic::ID IntrID, typename T0, typename T1></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2154</td>
    <td class="codeline">inline typename m_Intrinsic_Ty<T0, T1>::Ty m_Intrinsic(const T0 &Op0,</td>
    <td class="lineNumber">2154</td>
    <td class="codeline">inline typename m_Intrinsic_Ty<T0, T1>::Ty m_Intrinsic(const T0 &Op0,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2155</td>
    <td class="codeline">                                                       const T1 &Op1) {</td>
    <td class="lineNumber">2155</td>
    <td class="codeline">                                                       const T1 &Op1) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2156</td>
    <td class="codeline">  return m_CombineAnd(m_Intrinsic<IntrID>(Op0), m_Argument<1>(Op1));</td>
    <td class="lineNumber">2156</td>
    <td class="codeline">  return m_CombineAnd(m_Intrinsic<IntrID>(Op0), m_Argument<1>(Op1));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2157</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2157</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2158</td>
    <td class="codeline"></td>
    <td class="lineNumber">2158</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2159</td>
    <td class="codeline">template <Intrinsic::ID IntrID, typename T0, typename T1, typename T2></td>
    <td class="lineNumber">2159</td>
    <td class="codeline">template <Intrinsic::ID IntrID, typename T0, typename T1, typename T2></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2160</td>
    <td class="codeline">inline typename m_Intrinsic_Ty<T0, T1, T2>::Ty</td>
    <td class="lineNumber">2160</td>
    <td class="codeline">inline typename m_Intrinsic_Ty<T0, T1, T2>::Ty</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2161</td>
    <td class="codeline">m_Intrinsic(const T0 &Op0, const T1 &Op1, const T2 &Op2) {</td>
    <td class="lineNumber">2161</td>
    <td class="codeline">m_Intrinsic(const T0 &Op0, const T1 &Op1, const T2 &Op2) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2162</td>
    <td class="codeline">  return m_CombineAnd(m_Intrinsic<IntrID>(Op0, Op1), m_Argument<2>(Op2));</td>
    <td class="lineNumber">2162</td>
    <td class="codeline">  return m_CombineAnd(m_Intrinsic<IntrID>(Op0, Op1), m_Argument<2>(Op2));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2163</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2163</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2164</td>
    <td class="codeline"></td>
    <td class="lineNumber">2164</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2165</td>
    <td class="codeline">template <Intrinsic::ID IntrID, typename T0, typename T1, typename T2,</td>
    <td class="lineNumber">2165</td>
    <td class="codeline">template <Intrinsic::ID IntrID, typename T0, typename T1, typename T2,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2166</td>
    <td class="codeline">          typename T3></td>
    <td class="lineNumber">2166</td>
    <td class="codeline">          typename T3></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2167</td>
    <td class="codeline">inline typename m_Intrinsic_Ty<T0, T1, T2, T3>::Ty</td>
    <td class="lineNumber">2167</td>
    <td class="codeline">inline typename m_Intrinsic_Ty<T0, T1, T2, T3>::Ty</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2168</td>
    <td class="codeline">m_Intrinsic(const T0 &Op0, const T1 &Op1, const T2 &Op2, const T3 &Op3) {</td>
    <td class="lineNumber">2168</td>
    <td class="codeline">m_Intrinsic(const T0 &Op0, const T1 &Op1, const T2 &Op2, const T3 &Op3) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2169</td>
    <td class="codeline">  return m_CombineAnd(m_Intrinsic<IntrID>(Op0, Op1, Op2), m_Argument<3>(Op3));</td>
    <td class="lineNumber">2169</td>
    <td class="codeline">  return m_CombineAnd(m_Intrinsic<IntrID>(Op0, Op1, Op2), m_Argument<3>(Op3));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2170</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2170</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2171</td>
    <td class="codeline"></td>
    <td class="lineNumber">2171</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2172</td>
    <td class="codeline">template <Intrinsic::ID IntrID, typename T0, typename T1, typename T2,</td>
    <td class="lineNumber">2172</td>
    <td class="codeline">template <Intrinsic::ID IntrID, typename T0, typename T1, typename T2,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2173</td>
    <td class="codeline">          typename T3, typename T4></td>
    <td class="lineNumber">2173</td>
    <td class="codeline">          typename T3, typename T4></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2174</td>
    <td class="codeline">inline typename m_Intrinsic_Ty<T0, T1, T2, T3, T4>::Ty</td>
    <td class="lineNumber">2174</td>
    <td class="codeline">inline typename m_Intrinsic_Ty<T0, T1, T2, T3, T4>::Ty</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2175</td>
    <td class="codeline">m_Intrinsic(const T0 &Op0, const T1 &Op1, const T2 &Op2, const T3 &Op3,</td>
    <td class="lineNumber">2175</td>
    <td class="codeline">m_Intrinsic(const T0 &Op0, const T1 &Op1, const T2 &Op2, const T3 &Op3,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2176</td>
    <td class="codeline">            const T4 &Op4) {</td>
    <td class="lineNumber">2176</td>
    <td class="codeline">            const T4 &Op4) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2177</td>
    <td class="codeline">  return m_CombineAnd(m_Intrinsic<IntrID>(Op0, Op1, Op2, Op3),</td>
    <td class="lineNumber">2177</td>
    <td class="codeline">  return m_CombineAnd(m_Intrinsic<IntrID>(Op0, Op1, Op2, Op3),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2178</td>
    <td class="codeline">                      m_Argument<4>(Op4));</td>
    <td class="lineNumber">2178</td>
    <td class="codeline">                      m_Argument<4>(Op4));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2179</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2179</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2180</td>
    <td class="codeline"></td>
    <td class="lineNumber">2180</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2181</td>
    <td class="codeline">template <Intrinsic::ID IntrID, typename T0, typename T1, typename T2,</td>
    <td class="lineNumber">2181</td>
    <td class="codeline">template <Intrinsic::ID IntrID, typename T0, typename T1, typename T2,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2182</td>
    <td class="codeline">          typename T3, typename T4, typename T5></td>
    <td class="lineNumber">2182</td>
    <td class="codeline">          typename T3, typename T4, typename T5></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2183</td>
    <td class="codeline">inline typename m_Intrinsic_Ty<T0, T1, T2, T3, T4, T5>::Ty</td>
    <td class="lineNumber">2183</td>
    <td class="codeline">inline typename m_Intrinsic_Ty<T0, T1, T2, T3, T4, T5>::Ty</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2184</td>
    <td class="codeline">m_Intrinsic(const T0 &Op0, const T1 &Op1, const T2 &Op2, const T3 &Op3,</td>
    <td class="lineNumber">2184</td>
    <td class="codeline">m_Intrinsic(const T0 &Op0, const T1 &Op1, const T2 &Op2, const T3 &Op3,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2185</td>
    <td class="codeline">            const T4 &Op4, const T5 &Op5) {</td>
    <td class="lineNumber">2185</td>
    <td class="codeline">            const T4 &Op4, const T5 &Op5) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2186</td>
    <td class="codeline">  return m_CombineAnd(m_Intrinsic<IntrID>(Op0, Op1, Op2, Op3, Op4),</td>
    <td class="lineNumber">2186</td>
    <td class="codeline">  return m_CombineAnd(m_Intrinsic<IntrID>(Op0, Op1, Op2, Op3, Op4),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2187</td>
    <td class="codeline">                      m_Argument<5>(Op5));</td>
    <td class="lineNumber">2187</td>
    <td class="codeline">                      m_Argument<5>(Op5));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2188</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2188</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2189</td>
    <td class="codeline"></td>
    <td class="lineNumber">2189</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2190</td>
    <td class="codeline">// Helper intrinsic matching specializations.</td>
    <td class="lineNumber">2190</td>
    <td class="codeline">// Helper intrinsic matching specializations.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2191</td>
    <td class="codeline">template <typename Opnd0></td>
    <td class="lineNumber">2191</td>
    <td class="codeline">template <typename Opnd0></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2192</td>
    <td class="codeline">inline typename m_Intrinsic_Ty<Opnd0>::Ty m_BitReverse(const Opnd0 &Op0) {</td>
    <td class="lineNumber">2192</td>
    <td class="codeline">inline typename m_Intrinsic_Ty<Opnd0>::Ty m_BitReverse(const Opnd0 &Op0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2193</td>
    <td class="codeline">  return m_Intrinsic<Intrinsic::bitreverse>(Op0);</td>
    <td class="lineNumber">2193</td>
    <td class="codeline">  return m_Intrinsic<Intrinsic::bitreverse>(Op0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2194</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2194</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2195</td>
    <td class="codeline"></td>
    <td class="lineNumber">2195</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2196</td>
    <td class="codeline">template <typename Opnd0></td>
    <td class="lineNumber">2196</td>
    <td class="codeline">template <typename Opnd0></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2197</td>
    <td class="codeline">inline typename m_Intrinsic_Ty<Opnd0>::Ty m_BSwap(const Opnd0 &Op0) {</td>
    <td class="lineNumber">2197</td>
    <td class="codeline">inline typename m_Intrinsic_Ty<Opnd0>::Ty m_BSwap(const Opnd0 &Op0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2198</td>
    <td class="codeline">  return m_Intrinsic<Intrinsic::bswap>(Op0);</td>
    <td class="lineNumber">2198</td>
    <td class="codeline">  return m_Intrinsic<Intrinsic::bswap>(Op0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2199</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2199</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2200</td>
    <td class="codeline"></td>
    <td class="lineNumber">2200</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2201</td>
    <td class="codeline">template <typename Opnd0></td>
    <td class="lineNumber">2201</td>
    <td class="codeline">template <typename Opnd0></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2202</td>
    <td class="codeline">inline typename m_Intrinsic_Ty<Opnd0>::Ty m_FAbs(const Opnd0 &Op0) {</td>
    <td class="lineNumber">2202</td>
    <td class="codeline">inline typename m_Intrinsic_Ty<Opnd0>::Ty m_FAbs(const Opnd0 &Op0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2203</td>
    <td class="codeline">  return m_Intrinsic<Intrinsic::fabs>(Op0);</td>
    <td class="lineNumber">2203</td>
    <td class="codeline">  return m_Intrinsic<Intrinsic::fabs>(Op0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2204</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2204</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2205</td>
    <td class="codeline"></td>
    <td class="lineNumber">2205</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2206</td>
    <td class="codeline">template <typename Opnd0></td>
    <td class="lineNumber">2206</td>
    <td class="codeline">template <typename Opnd0></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2207</td>
    <td class="codeline">inline typename m_Intrinsic_Ty<Opnd0>::Ty m_FCanonicalize(const Opnd0 &Op0) {</td>
    <td class="lineNumber">2207</td>
    <td class="codeline">inline typename m_Intrinsic_Ty<Opnd0>::Ty m_FCanonicalize(const Opnd0 &Op0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2208</td>
    <td class="codeline">  return m_Intrinsic<Intrinsic::canonicalize>(Op0);</td>
    <td class="lineNumber">2208</td>
    <td class="codeline">  return m_Intrinsic<Intrinsic::canonicalize>(Op0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2209</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2209</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2210</td>
    <td class="codeline"></td>
    <td class="lineNumber">2210</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2211</td>
    <td class="codeline">template <typename Opnd0, typename Opnd1></td>
    <td class="lineNumber">2211</td>
    <td class="codeline">template <typename Opnd0, typename Opnd1></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2212</td>
    <td class="codeline">inline typename m_Intrinsic_Ty<Opnd0, Opnd1>::Ty m_FMin(const Opnd0 &Op0,</td>
    <td class="lineNumber">2212</td>
    <td class="codeline">inline typename m_Intrinsic_Ty<Opnd0, Opnd1>::Ty m_FMin(const Opnd0 &Op0,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2213</td>
    <td class="codeline">                                                        const Opnd1 &Op1) {</td>
    <td class="lineNumber">2213</td>
    <td class="codeline">                                                        const Opnd1 &Op1) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2214</td>
    <td class="codeline">  return m_Intrinsic<Intrinsic::minnum>(Op0, Op1);</td>
    <td class="lineNumber">2214</td>
    <td class="codeline">  return m_Intrinsic<Intrinsic::minnum>(Op0, Op1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2215</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2215</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2216</td>
    <td class="codeline"></td>
    <td class="lineNumber">2216</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2217</td>
    <td class="codeline">template <typename Opnd0, typename Opnd1></td>
    <td class="lineNumber">2217</td>
    <td class="codeline">template <typename Opnd0, typename Opnd1></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2218</td>
    <td class="codeline">inline typename m_Intrinsic_Ty<Opnd0, Opnd1>::Ty m_FMax(const Opnd0 &Op0,</td>
    <td class="lineNumber">2218</td>
    <td class="codeline">inline typename m_Intrinsic_Ty<Opnd0, Opnd1>::Ty m_FMax(const Opnd0 &Op0,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2219</td>
    <td class="codeline">                                                        const Opnd1 &Op1) {</td>
    <td class="lineNumber">2219</td>
    <td class="codeline">                                                        const Opnd1 &Op1) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2220</td>
    <td class="codeline">  return m_Intrinsic<Intrinsic::maxnum>(Op0, Op1);</td>
    <td class="lineNumber">2220</td>
    <td class="codeline">  return m_Intrinsic<Intrinsic::maxnum>(Op0, Op1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2221</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2221</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2222</td>
    <td class="codeline"></td>
    <td class="lineNumber">2222</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2223</td>
    <td class="codeline">template <typename Opnd0, typename Opnd1, typename Opnd2></td>
    <td class="lineNumber">2223</td>
    <td class="codeline">template <typename Opnd0, typename Opnd1, typename Opnd2></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2224</td>
    <td class="codeline">inline typename m_Intrinsic_Ty<Opnd0, Opnd1, Opnd2>::Ty</td>
    <td class="lineNumber">2224</td>
    <td class="codeline">inline typename m_Intrinsic_Ty<Opnd0, Opnd1, Opnd2>::Ty</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2225</td>
    <td class="codeline">m_FShl(const Opnd0 &Op0, const Opnd1 &Op1, const Opnd2 &Op2) {</td>
    <td class="lineNumber">2225</td>
    <td class="codeline">m_FShl(const Opnd0 &Op0, const Opnd1 &Op1, const Opnd2 &Op2) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2226</td>
    <td class="codeline">  return m_Intrinsic<Intrinsic::fshl>(Op0, Op1, Op2);</td>
    <td class="lineNumber">2226</td>
    <td class="codeline">  return m_Intrinsic<Intrinsic::fshl>(Op0, Op1, Op2);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2227</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2227</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2228</td>
    <td class="codeline"></td>
    <td class="lineNumber">2228</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2229</td>
    <td class="codeline">template <typename Opnd0, typename Opnd1, typename Opnd2></td>
    <td class="lineNumber">2229</td>
    <td class="codeline">template <typename Opnd0, typename Opnd1, typename Opnd2></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2230</td>
    <td class="codeline">inline typename m_Intrinsic_Ty<Opnd0, Opnd1, Opnd2>::Ty</td>
    <td class="lineNumber">2230</td>
    <td class="codeline">inline typename m_Intrinsic_Ty<Opnd0, Opnd1, Opnd2>::Ty</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2231</td>
    <td class="codeline">m_FShr(const Opnd0 &Op0, const Opnd1 &Op1, const Opnd2 &Op2) {</td>
    <td class="lineNumber">2231</td>
    <td class="codeline">m_FShr(const Opnd0 &Op0, const Opnd1 &Op1, const Opnd2 &Op2) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2232</td>
    <td class="codeline">  return m_Intrinsic<Intrinsic::fshr>(Op0, Op1, Op2);</td>
    <td class="lineNumber">2232</td>
    <td class="codeline">  return m_Intrinsic<Intrinsic::fshr>(Op0, Op1, Op2);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2233</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2233</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2234</td>
    <td class="codeline"></td>
    <td class="lineNumber">2234</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2235</td>
    <td class="codeline">template <typename Opnd0></td>
    <td class="lineNumber">2235</td>
    <td class="codeline">template <typename Opnd0></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2236</td>
    <td class="codeline">inline typename m_Intrinsic_Ty<Opnd0>::Ty m_Sqrt(const Opnd0 &Op0) {</td>
    <td class="lineNumber">2236</td>
    <td class="codeline">inline typename m_Intrinsic_Ty<Opnd0>::Ty m_Sqrt(const Opnd0 &Op0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2237</td>
    <td class="codeline">  return m_Intrinsic<Intrinsic::sqrt>(Op0);</td>
    <td class="lineNumber">2237</td>
    <td class="codeline">  return m_Intrinsic<Intrinsic::sqrt>(Op0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2238</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2238</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2239</td>
    <td class="codeline"></td>
    <td class="lineNumber">2239</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2240</td>
    <td class="codeline">template <typename Opnd0, typename Opnd1></td>
    <td class="lineNumber">2240</td>
    <td class="codeline">template <typename Opnd0, typename Opnd1></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2241</td>
    <td class="codeline">inline typename m_Intrinsic_Ty<Opnd0, Opnd1>::Ty m_CopySign(const Opnd0 &Op0,</td>
    <td class="lineNumber">2241</td>
    <td class="codeline">inline typename m_Intrinsic_Ty<Opnd0, Opnd1>::Ty m_CopySign(const Opnd0 &Op0,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2242</td>
    <td class="codeline">                                                            const Opnd1 &Op1) {</td>
    <td class="lineNumber">2242</td>
    <td class="codeline">                                                            const Opnd1 &Op1) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2243</td>
    <td class="codeline">  return m_Intrinsic<Intrinsic::copysign>(Op0, Op1);</td>
    <td class="lineNumber">2243</td>
    <td class="codeline">  return m_Intrinsic<Intrinsic::copysign>(Op0, Op1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2244</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2244</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2245</td>
    <td class="codeline"></td>
    <td class="lineNumber">2245</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2246</td>
    <td class="codeline">template <typename Opnd0></td>
    <td class="lineNumber">2246</td>
    <td class="codeline">template <typename Opnd0></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2247</td>
    <td class="codeline">inline typename m_Intrinsic_Ty<Opnd0>::Ty m_VecReverse(const Opnd0 &Op0) {</td>
    <td class="lineNumber">2247</td>
    <td class="codeline">inline typename m_Intrinsic_Ty<Opnd0>::Ty m_VecReverse(const Opnd0 &Op0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2248</td>
    <td class="codeline">  return m_Intrinsic<Intrinsic::experimental_vector_reverse>(Op0);</td>
    <td class="lineNumber">2248</td>
    <td class="codeline">  return m_Intrinsic<Intrinsic::experimental_vector_reverse>(Op0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2249</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2249</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2250</td>
    <td class="codeline"></td>
    <td class="lineNumber">2250</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2251</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">2251</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2252</td>
    <td class="codeline">// Matchers for two-operands operators with the operators in either order</td>
    <td class="lineNumber">2252</td>
    <td class="codeline">// Matchers for two-operands operators with the operators in either order</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2253</td>
    <td class="codeline">//</td>
    <td class="lineNumber">2253</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2254</td>
    <td class="codeline"></td>
    <td class="lineNumber">2254</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2255</td>
    <td class="codeline">/// Matches a BinaryOperator with LHS and RHS in either order.</td>
    <td class="lineNumber">2255</td>
    <td class="codeline">/// Matches a BinaryOperator with LHS and RHS in either order.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2256</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
    <td class="lineNumber">2256</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2257</td>
    <td class="codeline">inline AnyBinaryOp_match<LHS, RHS, true> m_c_BinOp(const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">2257</td>
    <td class="codeline">inline AnyBinaryOp_match<LHS, RHS, true> m_c_BinOp(const LHS &L, const RHS &R) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2258</td>
    <td class="codeline">  return AnyBinaryOp_match<LHS, RHS, true>(L, R);</td>
    <td class="lineNumber">2258</td>
    <td class="codeline">  return AnyBinaryOp_match<LHS, RHS, true>(L, R);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2259</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2259</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2260</td>
    <td class="codeline"></td>
    <td class="lineNumber">2260</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2261</td>
    <td class="codeline">/// Matches an ICmp with a predicate over LHS and RHS in either order.</td>
    <td class="lineNumber">2261</td>
    <td class="codeline">/// Matches an ICmp with a predicate over LHS and RHS in either order.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2262</td>
    <td class="codeline">/// Swaps the predicate if operands are commuted.</td>
    <td class="lineNumber">2262</td>
    <td class="codeline">/// Swaps the predicate if operands are commuted.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2263</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
    <td class="lineNumber">2263</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2264</td>
    <td class="codeline">inline CmpClass_match<LHS, RHS, ICmpInst, ICmpInst::Predicate, true></td>
    <td class="lineNumber">2264</td>
    <td class="codeline">inline CmpClass_match<LHS, RHS, ICmpInst, ICmpInst::Predicate, true></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2265</td>
    <td class="codeline">m_c_ICmp(ICmpInst::Predicate &Pred, const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">2265</td>
    <td class="codeline">m_c_ICmp(ICmpInst::Predicate &Pred, const LHS &L, const RHS &R) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2266</td>
    <td class="codeline">  return CmpClass_match<LHS, RHS, ICmpInst, ICmpInst::Predicate, true>(Pred, L,</td>
    <td class="lineNumber">2266</td>
    <td class="codeline">  return CmpClass_match<LHS, RHS, ICmpInst, ICmpInst::Predicate, true>(Pred, L,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2267</td>
    <td class="codeline">                                                                       R);</td>
    <td class="lineNumber">2267</td>
    <td class="codeline">                                                                       R);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2268</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2268</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2269</td>
    <td class="codeline"></td>
    <td class="lineNumber">2269</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2270</td>
    <td class="codeline">/// Matches a specific opcode with LHS and RHS in either order.</td>
    <td class="lineNumber">2270</td>
    <td class="codeline">/// Matches a specific opcode with LHS and RHS in either order.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2271</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
    <td class="lineNumber">2271</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2272</td>
    <td class="codeline">inline SpecificBinaryOp_match<LHS, RHS, true></td>
    <td class="lineNumber">2272</td>
    <td class="codeline">inline SpecificBinaryOp_match<LHS, RHS, true></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2273</td>
    <td class="codeline">m_c_BinOp(unsigned Opcode, const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">2273</td>
    <td class="codeline">m_c_BinOp(unsigned Opcode, const LHS &L, const RHS &R) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2274</td>
    <td class="codeline">  return SpecificBinaryOp_match<LHS, RHS, true>(Opcode, L, R);</td>
    <td class="lineNumber">2274</td>
    <td class="codeline">  return SpecificBinaryOp_match<LHS, RHS, true>(Opcode, L, R);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2275</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2275</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2276</td>
    <td class="codeline"></td>
    <td class="lineNumber">2276</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2277</td>
    <td class="codeline">/// Matches a Add with LHS and RHS in either order.</td>
    <td class="lineNumber">2277</td>
    <td class="codeline">/// Matches a Add with LHS and RHS in either order.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2278</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
    <td class="lineNumber">2278</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2279</td>
    <td class="codeline">inline BinaryOp_match<LHS, RHS, Instruction::Add, true> m_c_Add(const LHS &L,</td>
    <td class="lineNumber">2279</td>
    <td class="codeline">inline BinaryOp_match<LHS, RHS, Instruction::Add, true> m_c_Add(const LHS &L,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2280</td>
    <td class="codeline">                                                                const RHS &R) {</td>
    <td class="lineNumber">2280</td>
    <td class="codeline">                                                                const RHS &R) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2281</td>
    <td class="codeline">  return BinaryOp_match<LHS, RHS, Instruction::Add, true>(L, R);</td>
    <td class="lineNumber">2281</td>
    <td class="codeline">  return BinaryOp_match<LHS, RHS, Instruction::Add, true>(L, R);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2282</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2282</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2283</td>
    <td class="codeline"></td>
    <td class="lineNumber">2283</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2284</td>
    <td class="codeline">/// Matches a Mul with LHS and RHS in either order.</td>
    <td class="lineNumber">2284</td>
    <td class="codeline">/// Matches a Mul with LHS and RHS in either order.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2285</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
    <td class="lineNumber">2285</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2286</td>
    <td class="codeline">inline BinaryOp_match<LHS, RHS, Instruction::Mul, true> m_c_Mul(const LHS &L,</td>
    <td class="lineNumber">2286</td>
    <td class="codeline">inline BinaryOp_match<LHS, RHS, Instruction::Mul, true> m_c_Mul(const LHS &L,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2287</td>
    <td class="codeline">                                                                const RHS &R) {</td>
    <td class="lineNumber">2287</td>
    <td class="codeline">                                                                const RHS &R) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2288</td>
    <td class="codeline">  return BinaryOp_match<LHS, RHS, Instruction::Mul, true>(L, R);</td>
    <td class="lineNumber">2288</td>
    <td class="codeline">  return BinaryOp_match<LHS, RHS, Instruction::Mul, true>(L, R);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2289</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2289</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2290</td>
    <td class="codeline"></td>
    <td class="lineNumber">2290</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2291</td>
    <td class="codeline">/// Matches an And with LHS and RHS in either order.</td>
    <td class="lineNumber">2291</td>
    <td class="codeline">/// Matches an And with LHS and RHS in either order.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2292</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
    <td class="lineNumber">2292</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2293</td>
    <td class="codeline">inline BinaryOp_match<LHS, RHS, Instruction::And, true> m_c_And(const LHS &L,</td>
    <td class="lineNumber">2293</td>
    <td class="codeline">inline BinaryOp_match<LHS, RHS, Instruction::And, true> m_c_And(const LHS &L,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2294</td>
    <td class="codeline">                                                                const RHS &R) {</td>
    <td class="lineNumber">2294</td>
    <td class="codeline">                                                                const RHS &R) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2295</td>
    <td class="codeline">  return BinaryOp_match<LHS, RHS, Instruction::And, true>(L, R);</td>
    <td class="lineNumber">2295</td>
    <td class="codeline">  return BinaryOp_match<LHS, RHS, Instruction::And, true>(L, R);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2296</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2296</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2297</td>
    <td class="codeline"></td>
    <td class="lineNumber">2297</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2298</td>
    <td class="codeline">/// Matches an Or with LHS and RHS in either order.</td>
    <td class="lineNumber">2298</td>
    <td class="codeline">/// Matches an Or with LHS and RHS in either order.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2299</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
    <td class="lineNumber">2299</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2300</td>
    <td class="codeline">inline BinaryOp_match<LHS, RHS, Instruction::Or, true> m_c_Or(const LHS &L,</td>
    <td class="lineNumber">2300</td>
    <td class="codeline">inline BinaryOp_match<LHS, RHS, Instruction::Or, true> m_c_Or(const LHS &L,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2301</td>
    <td class="codeline">                                                              const RHS &R) {</td>
    <td class="lineNumber">2301</td>
    <td class="codeline">                                                              const RHS &R) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2302</td>
    <td class="codeline">  return BinaryOp_match<LHS, RHS, Instruction::Or, true>(L, R);</td>
    <td class="lineNumber">2302</td>
    <td class="codeline">  return BinaryOp_match<LHS, RHS, Instruction::Or, true>(L, R);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2303</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2303</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2304</td>
    <td class="codeline"></td>
    <td class="lineNumber">2304</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2305</td>
    <td class="codeline">/// Matches an Xor with LHS and RHS in either order.</td>
    <td class="lineNumber">2305</td>
    <td class="codeline">/// Matches an Xor with LHS and RHS in either order.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2306</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
    <td class="lineNumber">2306</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2307</td>
    <td class="codeline">inline BinaryOp_match<LHS, RHS, Instruction::Xor, true> m_c_Xor(const LHS &L,</td>
    <td class="lineNumber">2307</td>
    <td class="codeline">inline BinaryOp_match<LHS, RHS, Instruction::Xor, true> m_c_Xor(const LHS &L,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2308</td>
    <td class="codeline">                                                                const RHS &R) {</td>
    <td class="lineNumber">2308</td>
    <td class="codeline">                                                                const RHS &R) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2309</td>
    <td class="codeline">  return BinaryOp_match<LHS, RHS, Instruction::Xor, true>(L, R);</td>
    <td class="lineNumber">2309</td>
    <td class="codeline">  return BinaryOp_match<LHS, RHS, Instruction::Xor, true>(L, R);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2310</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2310</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2311</td>
    <td class="codeline"></td>
    <td class="lineNumber">2311</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2312</td>
    <td class="codeline">/// Matches a 'Neg' as 'sub 0, V'.</td>
    <td class="lineNumber">2312</td>
    <td class="codeline">/// Matches a 'Neg' as 'sub 0, V'.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2313</td>
    <td class="codeline">template <typename ValTy></td>
    <td class="lineNumber">2313</td>
    <td class="codeline">template <typename ValTy></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2314</td>
    <td class="codeline">inline BinaryOp_match<cst_pred_ty<is_zero_int>, ValTy, Instruction::Sub></td>
    <td class="lineNumber">2314</td>
    <td class="codeline">inline BinaryOp_match<cst_pred_ty<is_zero_int>, ValTy, Instruction::Sub></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2315</td>
    <td class="codeline">m_Neg(const ValTy &V) {</td>
    <td class="lineNumber">2315</td>
    <td class="codeline">m_Neg(const ValTy &V) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2316</td>
    <td class="codeline">  return m_Sub(m_ZeroInt(), V);</td>
    <td class="lineNumber">2316</td>
    <td class="codeline">  return m_Sub(m_ZeroInt(), V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2317</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2317</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2318</td>
    <td class="codeline"></td>
    <td class="lineNumber">2318</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2319</td>
    <td class="codeline">/// Matches a 'Neg' as 'sub nsw 0, V'.</td>
    <td class="lineNumber">2319</td>
    <td class="codeline">/// Matches a 'Neg' as 'sub nsw 0, V'.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2320</td>
    <td class="codeline">template <typename ValTy></td>
    <td class="lineNumber">2320</td>
    <td class="codeline">template <typename ValTy></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2321</td>
    <td class="codeline">inline OverflowingBinaryOp_match<cst_pred_ty<is_zero_int>, ValTy,</td>
    <td class="lineNumber">2321</td>
    <td class="codeline">inline OverflowingBinaryOp_match<cst_pred_ty<is_zero_int>, ValTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2322</td>
    <td class="codeline">                                 Instruction::Sub,</td>
    <td class="lineNumber">2322</td>
    <td class="codeline">                                 Instruction::Sub,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2323</td>
    <td class="codeline">                                 OverflowingBinaryOperator::NoSignedWrap></td>
    <td class="lineNumber">2323</td>
    <td class="codeline">                                 OverflowingBinaryOperator::NoSignedWrap></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2324</td>
    <td class="codeline">m_NSWNeg(const ValTy &V) {</td>
    <td class="lineNumber">2324</td>
    <td class="codeline">m_NSWNeg(const ValTy &V) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2325</td>
    <td class="codeline">  return m_NSWSub(m_ZeroInt(), V);</td>
    <td class="lineNumber">2325</td>
    <td class="codeline">  return m_NSWSub(m_ZeroInt(), V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2326</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2326</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2327</td>
    <td class="codeline"></td>
    <td class="lineNumber">2327</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2328</td>
    <td class="codeline">/// Matches a 'Not' as 'xor V, -1' or 'xor -1, V'.</td>
    <td class="lineNumber">2328</td>
    <td class="codeline">/// Matches a 'Not' as 'xor V, -1' or 'xor -1, V'.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2329</td>
    <td class="codeline">/// NOTE: we first match the 'Not' (by matching '-1'),</td>
    <td class="lineNumber">2329</td>
    <td class="codeline">/// NOTE: we first match the 'Not' (by matching '-1'),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2330</td>
    <td class="codeline">/// and only then match the inner matcher!</td>
    <td class="lineNumber">2330</td>
    <td class="codeline">/// and only then match the inner matcher!</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2331</td>
    <td class="codeline">template <typename ValTy></td>
    <td class="lineNumber">2331</td>
    <td class="codeline">template <typename ValTy></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2332</td>
    <td class="codeline">inline BinaryOp_match<cst_pred_ty<is_all_ones>, ValTy, Instruction::Xor, true></td>
    <td class="lineNumber">2332</td>
    <td class="codeline">inline BinaryOp_match<cst_pred_ty<is_all_ones>, ValTy, Instruction::Xor, true></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2333</td>
    <td class="codeline">m_Not(const ValTy &V) {</td>
    <td class="lineNumber">2333</td>
    <td class="codeline">m_Not(const ValTy &V) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2334</td>
    <td class="codeline">  return m_c_Xor(m_AllOnes(), V);</td>
    <td class="lineNumber">2334</td>
    <td class="codeline">  return m_c_Xor(m_AllOnes(), V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2335</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2335</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2336</td>
    <td class="codeline"></td>
    <td class="lineNumber">2336</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2337</td>
    <td class="codeline">template <typename ValTy> struct NotForbidUndef_match {</td>
    <td class="lineNumber">2337</td>
    <td class="codeline">template <typename ValTy> struct NotForbidUndef_match {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2338</td>
    <td class="codeline">  ValTy Val;</td>
    <td class="lineNumber">2338</td>
    <td class="codeline">  ValTy Val;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2339</td>
    <td class="codeline">  NotForbidUndef_match(const ValTy &V) : Val(V) {}</td>
    <td class="lineNumber">2339</td>
    <td class="codeline">  NotForbidUndef_match(const ValTy &V) : Val(V) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2340</td>
    <td class="codeline"></td>
    <td class="lineNumber">2340</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2341</td>
    <td class="codeline">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td class="lineNumber">2341</td>
    <td class="codeline">  template <typename OpTy> bool match(OpTy *V) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2342</td>
    <td class="codeline">    // We do not use m_c_Xor because that could match an arbitrary APInt that is</td>
    <td class="lineNumber">2342</td>
    <td class="codeline">    // We do not use m_c_Xor because that could match an arbitrary APInt that is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2343</td>
    <td class="codeline">    // not -1 as C and then fail to match the other operand if it is -1.</td>
    <td class="lineNumber">2343</td>
    <td class="codeline">    // not -1 as C and then fail to match the other operand if it is -1.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2344</td>
    <td class="codeline">    // This code should still work even when both operands are constants.</td>
    <td class="lineNumber">2344</td>
    <td class="codeline">    // This code should still work even when both operands are constants.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2345</td>
    <td class="codeline">    Value *X;</td>
    <td class="lineNumber">2345</td>
    <td class="codeline">    Value *X;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2346</td>
    <td class="codeline">    const APInt *C;</td>
    <td class="lineNumber">2346</td>
    <td class="codeline">    const APInt *C;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2347</td>
    <td class="codeline">    if (m_Xor(m_Value(X), m_APIntForbidUndef(C)).match(V) && C->isAllOnes())</td>
    <td class="lineNumber">2347</td>
    <td class="codeline">    if (m_Xor(m_Value(X), m_APIntForbidUndef(C)).match(V) && C->isAllOnes())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2348</td>
    <td class="codeline">      return Val.match(X);</td>
    <td class="lineNumber">2348</td>
    <td class="codeline">      return Val.match(X);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2349</td>
    <td class="codeline">    if (m_Xor(m_APIntForbidUndef(C), m_Value(X)).match(V) && C->isAllOnes())</td>
    <td class="lineNumber">2349</td>
    <td class="codeline">    if (m_Xor(m_APIntForbidUndef(C), m_Value(X)).match(V) && C->isAllOnes())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2350</td>
    <td class="codeline">      return Val.match(X);</td>
    <td class="lineNumber">2350</td>
    <td class="codeline">      return Val.match(X);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2351</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">2351</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2352</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2352</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2353</td>
    <td class="codeline">};</td>
    <td class="lineNumber">2353</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2354</td>
    <td class="codeline"></td>
    <td class="lineNumber">2354</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2355</td>
    <td class="codeline">/// Matches a bitwise 'not' as 'xor V, -1' or 'xor -1, V'. For vectors, the</td>
    <td class="lineNumber">2355</td>
    <td class="codeline">/// Matches a bitwise 'not' as 'xor V, -1' or 'xor -1, V'. For vectors, the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2356</td>
    <td class="codeline">/// constant value must be composed of only -1 scalar elements.</td>
    <td class="lineNumber">2356</td>
    <td class="codeline">/// constant value must be composed of only -1 scalar elements.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2357</td>
    <td class="codeline">template <typename ValTy></td>
    <td class="lineNumber">2357</td>
    <td class="codeline">template <typename ValTy></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2358</td>
    <td class="codeline">inline NotForbidUndef_match<ValTy> m_NotForbidUndef(const ValTy &V) {</td>
    <td class="lineNumber">2358</td>
    <td class="codeline">inline NotForbidUndef_match<ValTy> m_NotForbidUndef(const ValTy &V) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2359</td>
    <td class="codeline">  return NotForbidUndef_match<ValTy>(V);</td>
    <td class="lineNumber">2359</td>
    <td class="codeline">  return NotForbidUndef_match<ValTy>(V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2360</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2360</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2361</td>
    <td class="codeline"></td>
    <td class="lineNumber">2361</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2362</td>
    <td class="codeline">/// Matches an SMin with LHS and RHS in either order.</td>
    <td class="lineNumber">2362</td>
    <td class="codeline">/// Matches an SMin with LHS and RHS in either order.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2363</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
    <td class="lineNumber">2363</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2364</td>
    <td class="codeline">inline MaxMin_match<ICmpInst, LHS, RHS, smin_pred_ty, true></td>
    <td class="lineNumber">2364</td>
    <td class="codeline">inline MaxMin_match<ICmpInst, LHS, RHS, smin_pred_ty, true></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2365</td>
    <td class="codeline">m_c_SMin(const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">2365</td>
    <td class="codeline">m_c_SMin(const LHS &L, const RHS &R) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2366</td>
    <td class="codeline">  return MaxMin_match<ICmpInst, LHS, RHS, smin_pred_ty, true>(L, R);</td>
    <td class="lineNumber">2366</td>
    <td class="codeline">  return MaxMin_match<ICmpInst, LHS, RHS, smin_pred_ty, true>(L, R);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2367</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2367</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2368</td>
    <td class="codeline">/// Matches an SMax with LHS and RHS in either order.</td>
    <td class="lineNumber">2368</td>
    <td class="codeline">/// Matches an SMax with LHS and RHS in either order.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2369</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
    <td class="lineNumber">2369</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2370</td>
    <td class="codeline">inline MaxMin_match<ICmpInst, LHS, RHS, smax_pred_ty, true></td>
    <td class="lineNumber">2370</td>
    <td class="codeline">inline MaxMin_match<ICmpInst, LHS, RHS, smax_pred_ty, true></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2371</td>
    <td class="codeline">m_c_SMax(const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">2371</td>
    <td class="codeline">m_c_SMax(const LHS &L, const RHS &R) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2372</td>
    <td class="codeline">  return MaxMin_match<ICmpInst, LHS, RHS, smax_pred_ty, true>(L, R);</td>
    <td class="lineNumber">2372</td>
    <td class="codeline">  return MaxMin_match<ICmpInst, LHS, RHS, smax_pred_ty, true>(L, R);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2373</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2373</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2374</td>
    <td class="codeline">/// Matches a UMin with LHS and RHS in either order.</td>
    <td class="lineNumber">2374</td>
    <td class="codeline">/// Matches a UMin with LHS and RHS in either order.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2375</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
    <td class="lineNumber">2375</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2376</td>
    <td class="codeline">inline MaxMin_match<ICmpInst, LHS, RHS, umin_pred_ty, true></td>
    <td class="lineNumber">2376</td>
    <td class="codeline">inline MaxMin_match<ICmpInst, LHS, RHS, umin_pred_ty, true></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2377</td>
    <td class="codeline">m_c_UMin(const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">2377</td>
    <td class="codeline">m_c_UMin(const LHS &L, const RHS &R) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2378</td>
    <td class="codeline">  return MaxMin_match<ICmpInst, LHS, RHS, umin_pred_ty, true>(L, R);</td>
    <td class="lineNumber">2378</td>
    <td class="codeline">  return MaxMin_match<ICmpInst, LHS, RHS, umin_pred_ty, true>(L, R);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2379</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2379</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2380</td>
    <td class="codeline">/// Matches a UMax with LHS and RHS in either order.</td>
    <td class="lineNumber">2380</td>
    <td class="codeline">/// Matches a UMax with LHS and RHS in either order.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2381</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
    <td class="lineNumber">2381</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2382</td>
    <td class="codeline">inline MaxMin_match<ICmpInst, LHS, RHS, umax_pred_ty, true></td>
    <td class="lineNumber">2382</td>
    <td class="codeline">inline MaxMin_match<ICmpInst, LHS, RHS, umax_pred_ty, true></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2383</td>
    <td class="codeline">m_c_UMax(const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">2383</td>
    <td class="codeline">m_c_UMax(const LHS &L, const RHS &R) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2384</td>
    <td class="codeline">  return MaxMin_match<ICmpInst, LHS, RHS, umax_pred_ty, true>(L, R);</td>
    <td class="lineNumber">2384</td>
    <td class="codeline">  return MaxMin_match<ICmpInst, LHS, RHS, umax_pred_ty, true>(L, R);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2385</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2385</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2386</td>
    <td class="codeline"></td>
    <td class="lineNumber">2386</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2387</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
    <td class="lineNumber">2387</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2388</td>
    <td class="codeline">inline match_combine_or<</td>
    <td class="lineNumber">2388</td>
    <td class="codeline">inline match_combine_or<</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2389</td>
    <td class="codeline">    match_combine_or<MaxMin_match<ICmpInst, LHS, RHS, smax_pred_ty, true>,</td>
    <td class="lineNumber">2389</td>
    <td class="codeline">    match_combine_or<MaxMin_match<ICmpInst, LHS, RHS, smax_pred_ty, true>,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2390</td>
    <td class="codeline">                     MaxMin_match<ICmpInst, LHS, RHS, smin_pred_ty, true>>,</td>
    <td class="lineNumber">2390</td>
    <td class="codeline">                     MaxMin_match<ICmpInst, LHS, RHS, smin_pred_ty, true>>,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2391</td>
    <td class="codeline">    match_combine_or<MaxMin_match<ICmpInst, LHS, RHS, umax_pred_ty, true>,</td>
    <td class="lineNumber">2391</td>
    <td class="codeline">    match_combine_or<MaxMin_match<ICmpInst, LHS, RHS, umax_pred_ty, true>,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2392</td>
    <td class="codeline">                     MaxMin_match<ICmpInst, LHS, RHS, umin_pred_ty, true>>></td>
    <td class="lineNumber">2392</td>
    <td class="codeline">                     MaxMin_match<ICmpInst, LHS, RHS, umin_pred_ty, true>>></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2393</td>
    <td class="codeline">m_c_MaxOrMin(const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">2393</td>
    <td class="codeline">m_c_MaxOrMin(const LHS &L, const RHS &R) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2394</td>
    <td class="codeline">  return m_CombineOr(m_CombineOr(m_c_SMax(L, R), m_c_SMin(L, R)),</td>
    <td class="lineNumber">2394</td>
    <td class="codeline">  return m_CombineOr(m_CombineOr(m_c_SMax(L, R), m_c_SMin(L, R)),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2395</td>
    <td class="codeline">                     m_CombineOr(m_c_UMax(L, R), m_c_UMin(L, R)));</td>
    <td class="lineNumber">2395</td>
    <td class="codeline">                     m_CombineOr(m_c_UMax(L, R), m_c_UMin(L, R)));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2396</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2396</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2397</td>
    <td class="codeline"></td>
    <td class="lineNumber">2397</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2398</td>
    <td class="codeline">template <Intrinsic::ID IntrID, typename T0, typename T1></td>
    <td class="lineNumber">2398</td>
    <td class="codeline">template <Intrinsic::ID IntrID, typename T0, typename T1></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2399</td>
    <td class="codeline">inline match_combine_or<typename m_Intrinsic_Ty<T0, T1>::Ty,</td>
    <td class="lineNumber">2399</td>
    <td class="codeline">inline match_combine_or<typename m_Intrinsic_Ty<T0, T1>::Ty,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2400</td>
    <td class="codeline">                        typename m_Intrinsic_Ty<T1, T0>::Ty></td>
    <td class="lineNumber">2400</td>
    <td class="codeline">                        typename m_Intrinsic_Ty<T1, T0>::Ty></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2401</td>
    <td class="codeline">m_c_Intrinsic(const T0 &Op0, const T1 &Op1) {</td>
    <td class="lineNumber">2401</td>
    <td class="codeline">m_c_Intrinsic(const T0 &Op0, const T1 &Op1) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2402</td>
    <td class="codeline">  return m_CombineOr(m_Intrinsic<IntrID>(Op0, Op1),</td>
    <td class="lineNumber">2402</td>
    <td class="codeline">  return m_CombineOr(m_Intrinsic<IntrID>(Op0, Op1),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2403</td>
    <td class="codeline">                     m_Intrinsic<IntrID>(Op1, Op0));</td>
    <td class="lineNumber">2403</td>
    <td class="codeline">                     m_Intrinsic<IntrID>(Op1, Op0));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2404</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2404</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2405</td>
    <td class="codeline"></td>
    <td class="lineNumber">2405</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2406</td>
    <td class="codeline">/// Matches FAdd with LHS and RHS in either order.</td>
    <td class="lineNumber">2406</td>
    <td class="codeline">/// Matches FAdd with LHS and RHS in either order.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2407</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
    <td class="lineNumber">2407</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2408</td>
    <td class="codeline">inline BinaryOp_match<LHS, RHS, Instruction::FAdd, true></td>
    <td class="lineNumber">2408</td>
    <td class="codeline">inline BinaryOp_match<LHS, RHS, Instruction::FAdd, true></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2409</td>
    <td class="codeline">m_c_FAdd(const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">2409</td>
    <td class="codeline">m_c_FAdd(const LHS &L, const RHS &R) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2410</td>
    <td class="codeline">  return BinaryOp_match<LHS, RHS, Instruction::FAdd, true>(L, R);</td>
    <td class="lineNumber">2410</td>
    <td class="codeline">  return BinaryOp_match<LHS, RHS, Instruction::FAdd, true>(L, R);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2411</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2411</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2412</td>
    <td class="codeline"></td>
    <td class="lineNumber">2412</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2413</td>
    <td class="codeline">/// Matches FMul with LHS and RHS in either order.</td>
    <td class="lineNumber">2413</td>
    <td class="codeline">/// Matches FMul with LHS and RHS in either order.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2414</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
    <td class="lineNumber">2414</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2415</td>
    <td class="codeline">inline BinaryOp_match<LHS, RHS, Instruction::FMul, true></td>
    <td class="lineNumber">2415</td>
    <td class="codeline">inline BinaryOp_match<LHS, RHS, Instruction::FMul, true></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2416</td>
    <td class="codeline">m_c_FMul(const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">2416</td>
    <td class="codeline">m_c_FMul(const LHS &L, const RHS &R) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2417</td>
    <td class="codeline">  return BinaryOp_match<LHS, RHS, Instruction::FMul, true>(L, R);</td>
    <td class="lineNumber">2417</td>
    <td class="codeline">  return BinaryOp_match<LHS, RHS, Instruction::FMul, true>(L, R);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2418</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2418</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2419</td>
    <td class="codeline"></td>
    <td class="lineNumber">2419</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2420</td>
    <td class="codeline">template <typename Opnd_t> struct Signum_match {</td>
    <td class="lineNumber">2420</td>
    <td class="codeline">template <typename Opnd_t> struct Signum_match {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2421</td>
    <td class="codeline">  Opnd_t Val;</td>
    <td class="lineNumber">2421</td>
    <td class="codeline">  Opnd_t Val;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2422</td>
    <td class="codeline">  Signum_match(const Opnd_t &V) : Val(V) {}</td>
    <td class="lineNumber">2422</td>
    <td class="codeline">  Signum_match(const Opnd_t &V) : Val(V) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2423</td>
    <td class="codeline"></td>
    <td class="lineNumber">2423</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2424</td>
    <td class="codeline">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td class="lineNumber">2424</td>
    <td class="codeline">  template <typename OpTy> bool match(OpTy *V) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2425</td>
    <td class="codeline">    unsigned TypeSize = V->getType()->getScalarSizeInBits();</td>
    <td class="lineNumber">2425</td>
    <td class="codeline">    unsigned TypeSize = V->getType()->getScalarSizeInBits();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2426</td>
    <td class="codeline">    if (TypeSize == 0)</td>
    <td class="lineNumber">2426</td>
    <td class="codeline">    if (TypeSize == 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2427</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">2427</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2428</td>
    <td class="codeline"></td>
    <td class="lineNumber">2428</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2429</td>
    <td class="codeline">    unsigned ShiftWidth = TypeSize - 1;</td>
    <td class="lineNumber">2429</td>
    <td class="codeline">    unsigned ShiftWidth = TypeSize - 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2430</td>
    <td class="codeline">    Value *OpL = nullptr, *OpR = nullptr;</td>
    <td class="lineNumber">2430</td>
    <td class="codeline">    Value *OpL = nullptr, *OpR = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2431</td>
    <td class="codeline"></td>
    <td class="lineNumber">2431</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2432</td>
    <td class="codeline">    // This is the representation of signum we match:</td>
    <td class="lineNumber">2432</td>
    <td class="codeline">    // This is the representation of signum we match:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2433</td>
    <td class="codeline">    //</td>
    <td class="lineNumber">2433</td>
    <td class="codeline">    //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2434</td>
    <td class="codeline">    //  signum(x) == (x >> 63) | (-x >>u 63)</td>
    <td class="lineNumber">2434</td>
    <td class="codeline">    //  signum(x) == (x >> 63) | (-x >>u 63)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2435</td>
    <td class="codeline">    //</td>
    <td class="lineNumber">2435</td>
    <td class="codeline">    //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2436</td>
    <td class="codeline">    // An i1 value is its own signum, so it's correct to match</td>
    <td class="lineNumber">2436</td>
    <td class="codeline">    // An i1 value is its own signum, so it's correct to match</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2437</td>
    <td class="codeline">    //</td>
    <td class="lineNumber">2437</td>
    <td class="codeline">    //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2438</td>
    <td class="codeline">    //  signum(x) == (x >> 0)  | (-x >>u 0)</td>
    <td class="lineNumber">2438</td>
    <td class="codeline">    //  signum(x) == (x >> 0)  | (-x >>u 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2439</td>
    <td class="codeline">    //</td>
    <td class="lineNumber">2439</td>
    <td class="codeline">    //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2440</td>
    <td class="codeline">    // for i1 values.</td>
    <td class="lineNumber">2440</td>
    <td class="codeline">    // for i1 values.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2441</td>
    <td class="codeline"></td>
    <td class="lineNumber">2441</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2442</td>
    <td class="codeline">    auto LHS = m_AShr(m_Value(OpL), m_SpecificInt(ShiftWidth));</td>
    <td class="lineNumber">2442</td>
    <td class="codeline">    auto LHS = m_AShr(m_Value(OpL), m_SpecificInt(ShiftWidth));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2443</td>
    <td class="codeline">    auto RHS = m_LShr(m_Neg(m_Value(OpR)), m_SpecificInt(ShiftWidth));</td>
    <td class="lineNumber">2443</td>
    <td class="codeline">    auto RHS = m_LShr(m_Neg(m_Value(OpR)), m_SpecificInt(ShiftWidth));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2444</td>
    <td class="codeline">    auto Signum = m_Or(LHS, RHS);</td>
    <td class="lineNumber">2444</td>
    <td class="codeline">    auto Signum = m_Or(LHS, RHS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2445</td>
    <td class="codeline"></td>
    <td class="lineNumber">2445</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2446</td>
    <td class="codeline">    return Signum.match(V) && OpL == OpR && Val.match(OpL);</td>
    <td class="lineNumber">2446</td>
    <td class="codeline">    return Signum.match(V) && OpL == OpR && Val.match(OpL);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2447</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2447</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2448</td>
    <td class="codeline">};</td>
    <td class="lineNumber">2448</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2449</td>
    <td class="codeline"></td>
    <td class="lineNumber">2449</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2450</td>
    <td class="codeline">/// Matches a signum pattern.</td>
    <td class="lineNumber">2450</td>
    <td class="codeline">/// Matches a signum pattern.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2451</td>
    <td class="codeline">///</td>
    <td class="lineNumber">2451</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2452</td>
    <td class="codeline">/// signum(x) =</td>
    <td class="lineNumber">2452</td>
    <td class="codeline">/// signum(x) =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2453</td>
    <td class="codeline">///      x >  0  ->  1</td>
    <td class="lineNumber">2453</td>
    <td class="codeline">///      x >  0  ->  1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2454</td>
    <td class="codeline">///      x == 0  ->  0</td>
    <td class="lineNumber">2454</td>
    <td class="codeline">///      x == 0  ->  0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2455</td>
    <td class="codeline">///      x <  0  -> -1</td>
    <td class="lineNumber">2455</td>
    <td class="codeline">///      x <  0  -> -1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2456</td>
    <td class="codeline">template <typename Val_t> inline Signum_match<Val_t> m_Signum(const Val_t &V) {</td>
    <td class="lineNumber">2456</td>
    <td class="codeline">template <typename Val_t> inline Signum_match<Val_t> m_Signum(const Val_t &V) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2457</td>
    <td class="codeline">  return Signum_match<Val_t>(V);</td>
    <td class="lineNumber">2457</td>
    <td class="codeline">  return Signum_match<Val_t>(V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2458</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2458</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2459</td>
    <td class="codeline"></td>
    <td class="lineNumber">2459</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2460</td>
    <td class="codeline">template <int Ind, typename Opnd_t> struct ExtractValue_match {</td>
    <td class="lineNumber">2460</td>
    <td class="codeline">template <int Ind, typename Opnd_t> struct ExtractValue_match {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2461</td>
    <td class="codeline">  Opnd_t Val;</td>
    <td class="lineNumber">2461</td>
    <td class="codeline">  Opnd_t Val;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2462</td>
    <td class="codeline">  ExtractValue_match(const Opnd_t &V) : Val(V) {}</td>
    <td class="lineNumber">2462</td>
    <td class="codeline">  ExtractValue_match(const Opnd_t &V) : Val(V) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2463</td>
    <td class="codeline"></td>
    <td class="lineNumber">2463</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2464</td>
    <td class="codeline">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td class="lineNumber">2464</td>
    <td class="codeline">  template <typename OpTy> bool match(OpTy *V) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2465</td>
    <td class="codeline">    if (auto *I = dyn_cast<ExtractValueInst>(V)) {</td>
    <td class="lineNumber">2465</td>
    <td class="codeline">    if (auto *I = dyn_cast<ExtractValueInst>(V)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2466</td>
    <td class="codeline">      // If Ind is -1, don't inspect indices</td>
    <td class="lineNumber">2466</td>
    <td class="codeline">      // If Ind is -1, don't inspect indices</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2467</td>
    <td class="codeline">      if (Ind != -1 &&</td>
    <td class="lineNumber">2467</td>
    <td class="codeline">      if (Ind != -1 &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2468</td>
    <td class="codeline">          !(I->getNumIndices() == 1 && I->getIndices()[0] == (unsigned)Ind))</td>
    <td class="lineNumber">2468</td>
    <td class="codeline">          !(I->getNumIndices() == 1 && I->getIndices()[0] == (unsigned)Ind))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2469</td>
    <td class="codeline">        return false;</td>
    <td class="lineNumber">2469</td>
    <td class="codeline">        return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2470</td>
    <td class="codeline">      return Val.match(I->getAggregateOperand());</td>
    <td class="lineNumber">2470</td>
    <td class="codeline">      return Val.match(I->getAggregateOperand());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2471</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2471</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2472</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">2472</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2473</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2473</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2474</td>
    <td class="codeline">};</td>
    <td class="lineNumber">2474</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2475</td>
    <td class="codeline"></td>
    <td class="lineNumber">2475</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2476</td>
    <td class="codeline">/// Match a single index ExtractValue instruction.</td>
    <td class="lineNumber">2476</td>
    <td class="codeline">/// Match a single index ExtractValue instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2477</td>
    <td class="codeline">/// For example m_ExtractValue<1>(...)</td>
    <td class="lineNumber">2477</td>
    <td class="codeline">/// For example m_ExtractValue<1>(...)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2478</td>
    <td class="codeline">template <int Ind, typename Val_t></td>
    <td class="lineNumber">2478</td>
    <td class="codeline">template <int Ind, typename Val_t></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2479</td>
    <td class="codeline">inline ExtractValue_match<Ind, Val_t> m_ExtractValue(const Val_t &V) {</td>
    <td class="lineNumber">2479</td>
    <td class="codeline">inline ExtractValue_match<Ind, Val_t> m_ExtractValue(const Val_t &V) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2480</td>
    <td class="codeline">  return ExtractValue_match<Ind, Val_t>(V);</td>
    <td class="lineNumber">2480</td>
    <td class="codeline">  return ExtractValue_match<Ind, Val_t>(V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2481</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2481</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2482</td>
    <td class="codeline"></td>
    <td class="lineNumber">2482</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2483</td>
    <td class="codeline">/// Match an ExtractValue instruction with any index.</td>
    <td class="lineNumber">2483</td>
    <td class="codeline">/// Match an ExtractValue instruction with any index.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2484</td>
    <td class="codeline">/// For example m_ExtractValue(...)</td>
    <td class="lineNumber">2484</td>
    <td class="codeline">/// For example m_ExtractValue(...)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2485</td>
    <td class="codeline">template <typename Val_t></td>
    <td class="lineNumber">2485</td>
    <td class="codeline">template <typename Val_t></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2486</td>
    <td class="codeline">inline ExtractValue_match<-1, Val_t> m_ExtractValue(const Val_t &V) {</td>
    <td class="lineNumber">2486</td>
    <td class="codeline">inline ExtractValue_match<-1, Val_t> m_ExtractValue(const Val_t &V) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2487</td>
    <td class="codeline">  return ExtractValue_match<-1, Val_t>(V);</td>
    <td class="lineNumber">2487</td>
    <td class="codeline">  return ExtractValue_match<-1, Val_t>(V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2488</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2488</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2489</td>
    <td class="codeline"></td>
    <td class="lineNumber">2489</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2490</td>
    <td class="codeline">/// Matcher for a single index InsertValue instruction.</td>
    <td class="lineNumber">2490</td>
    <td class="codeline">/// Matcher for a single index InsertValue instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2491</td>
    <td class="codeline">template <int Ind, typename T0, typename T1> struct InsertValue_match {</td>
    <td class="lineNumber">2491</td>
    <td class="codeline">template <int Ind, typename T0, typename T1> struct InsertValue_match {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2492</td>
    <td class="codeline">  T0 Op0;</td>
    <td class="lineNumber">2492</td>
    <td class="codeline">  T0 Op0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2493</td>
    <td class="codeline">  T1 Op1;</td>
    <td class="lineNumber">2493</td>
    <td class="codeline">  T1 Op1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2494</td>
    <td class="codeline"></td>
    <td class="lineNumber">2494</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2495</td>
    <td class="codeline">  InsertValue_match(const T0 &Op0, const T1 &Op1) : Op0(Op0), Op1(Op1) {}</td>
    <td class="lineNumber">2495</td>
    <td class="codeline">  InsertValue_match(const T0 &Op0, const T1 &Op1) : Op0(Op0), Op1(Op1) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2496</td>
    <td class="codeline"></td>
    <td class="lineNumber">2496</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2497</td>
    <td class="codeline">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td class="lineNumber">2497</td>
    <td class="codeline">  template <typename OpTy> bool match(OpTy *V) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2498</td>
    <td class="codeline">    if (auto *I = dyn_cast<InsertValueInst>(V)) {</td>
    <td class="lineNumber">2498</td>
    <td class="codeline">    if (auto *I = dyn_cast<InsertValueInst>(V)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2499</td>
    <td class="codeline">      return Op0.match(I->getOperand(0)) && Op1.match(I->getOperand(1)) &&</td>
    <td class="lineNumber">2499</td>
    <td class="codeline">      return Op0.match(I->getOperand(0)) && Op1.match(I->getOperand(1)) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2500</td>
    <td class="codeline">             I->getNumIndices() == 1 && Ind == I->getIndices()[0];</td>
    <td class="lineNumber">2500</td>
    <td class="codeline">             I->getNumIndices() == 1 && Ind == I->getIndices()[0];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2501</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2501</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2502</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">2502</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2503</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2503</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2504</td>
    <td class="codeline">};</td>
    <td class="lineNumber">2504</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2505</td>
    <td class="codeline"></td>
    <td class="lineNumber">2505</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2506</td>
    <td class="codeline">/// Matches a single index InsertValue instruction.</td>
    <td class="lineNumber">2506</td>
    <td class="codeline">/// Matches a single index InsertValue instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2507</td>
    <td class="codeline">template <int Ind, typename Val_t, typename Elt_t></td>
    <td class="lineNumber">2507</td>
    <td class="codeline">template <int Ind, typename Val_t, typename Elt_t></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2508</td>
    <td class="codeline">inline InsertValue_match<Ind, Val_t, Elt_t> m_InsertValue(const Val_t &Val,</td>
    <td class="lineNumber">2508</td>
    <td class="codeline">inline InsertValue_match<Ind, Val_t, Elt_t> m_InsertValue(const Val_t &Val,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2509</td>
    <td class="codeline">                                                          const Elt_t &Elt) {</td>
    <td class="lineNumber">2509</td>
    <td class="codeline">                                                          const Elt_t &Elt) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2510</td>
    <td class="codeline">  return InsertValue_match<Ind, Val_t, Elt_t>(Val, Elt);</td>
    <td class="lineNumber">2510</td>
    <td class="codeline">  return InsertValue_match<Ind, Val_t, Elt_t>(Val, Elt);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2511</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2511</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2512</td>
    <td class="codeline"></td>
    <td class="lineNumber">2512</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2513</td>
    <td class="codeline">/// Matches patterns for `vscale`. This can either be a call to `llvm.vscale` or</td>
    <td class="lineNumber">2513</td>
    <td class="codeline">/// Matches patterns for `vscale`. This can either be a call to `llvm.vscale` or</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2514</td>
    <td class="codeline">/// the constant expression</td>
    <td class="lineNumber">2514</td>
    <td class="codeline">/// the constant expression</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2515</td>
    <td class="codeline">///  `ptrtoint(gep <vscale x 1 x i8>, <vscale x 1 x i8>* null, i32 1>`</td>
    <td class="lineNumber">2515</td>
    <td class="codeline">///  `ptrtoint(gep <vscale x 1 x i8>, <vscale x 1 x i8>* null, i32 1>`</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2516</td>
    <td class="codeline">/// under the right conditions determined by DataLayout.</td>
    <td class="lineNumber">2516</td>
    <td class="codeline">/// under the right conditions determined by DataLayout.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2517</td>
    <td class="codeline">struct VScaleVal_match {</td>
    <td class="lineNumber">2517</td>
    <td class="codeline">struct VScaleVal_match {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2518</td>
    <td class="codeline">  template <typename ITy> bool match(ITy *V) {</td>
    <td class="lineNumber">2518</td>
    <td class="codeline">  template <typename ITy> bool match(ITy *V) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2519</td>
    <td class="codeline">    if (m_Intrinsic<Intrinsic::vscale>().match(V))</td>
    <td class="lineNumber">2519</td>
    <td class="codeline">    if (m_Intrinsic<Intrinsic::vscale>().match(V))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2520</td>
    <td class="codeline">      return true;</td>
    <td class="lineNumber">2520</td>
    <td class="codeline">      return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2521</td>
    <td class="codeline"></td>
    <td class="lineNumber">2521</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2522</td>
    <td class="codeline">    Value *Ptr;</td>
    <td class="lineNumber">2522</td>
    <td class="codeline">    Value *Ptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2523</td>
    <td class="codeline">    if (m_PtrToInt(m_Value(Ptr)).match(V)) {</td>
    <td class="lineNumber">2523</td>
    <td class="codeline">    if (m_PtrToInt(m_Value(Ptr)).match(V)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2524</td>
    <td class="codeline">      if (auto *GEP = dyn_cast<GEPOperator>(Ptr)) {</td>
    <td class="lineNumber">2524</td>
    <td class="codeline">      if (auto *GEP = dyn_cast<GEPOperator>(Ptr)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2525</td>
    <td class="codeline">        auto *DerefTy =</td>
    <td class="lineNumber">2525</td>
    <td class="codeline">        auto *DerefTy =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2526</td>
    <td class="codeline">            dyn_cast<ScalableVectorType>(GEP->getSourceElementType());</td>
    <td class="lineNumber">2526</td>
    <td class="codeline">            dyn_cast<ScalableVectorType>(GEP->getSourceElementType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2527</td>
    <td class="codeline">        if (GEP->getNumIndices() == 1 && DerefTy &&</td>
    <td class="lineNumber">2527</td>
    <td class="codeline">        if (GEP->getNumIndices() == 1 && DerefTy &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2528</td>
    <td class="codeline">            DerefTy->getElementType()->isIntegerTy(8) &&</td>
    <td class="lineNumber">2528</td>
    <td class="codeline">            DerefTy->getElementType()->isIntegerTy(8) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2529</td>
    <td class="codeline">            m_Zero().match(GEP->getPointerOperand()) &&</td>
    <td class="lineNumber">2529</td>
    <td class="codeline">            m_Zero().match(GEP->getPointerOperand()) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2530</td>
    <td class="codeline">            m_SpecificInt(1).match(GEP->idx_begin()->get()))</td>
    <td class="lineNumber">2530</td>
    <td class="codeline">            m_SpecificInt(1).match(GEP->idx_begin()->get()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2531</td>
    <td class="codeline">          return true;</td>
    <td class="lineNumber">2531</td>
    <td class="codeline">          return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2532</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">2532</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2533</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2533</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2534</td>
    <td class="codeline"></td>
    <td class="lineNumber">2534</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2535</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">2535</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2536</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2536</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2537</td>
    <td class="codeline">};</td>
    <td class="lineNumber">2537</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2538</td>
    <td class="codeline"></td>
    <td class="lineNumber">2538</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2539</td>
    <td class="codeline">inline VScaleVal_match m_VScale() {</td>
    <td class="lineNumber">2539</td>
    <td class="codeline">inline VScaleVal_match m_VScale() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2540</td>
    <td class="codeline">  return VScaleVal_match();</td>
    <td class="lineNumber">2540</td>
    <td class="codeline">  return VScaleVal_match();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2541</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2541</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2542</td>
    <td class="codeline"></td>
    <td class="lineNumber">2542</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2543</td>
    <td class="codeline">template <typename LHS, typename RHS, unsigned Opcode, bool Commutable = false></td>
    <td class="lineNumber">2543</td>
    <td class="codeline">template <typename LHS, typename RHS, unsigned Opcode, bool Commutable = false></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2544</td>
    <td class="codeline">struct LogicalOp_match {</td>
    <td class="lineNumber">2544</td>
    <td class="codeline">struct LogicalOp_match {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2545</td>
    <td class="codeline">  LHS L;</td>
    <td class="lineNumber">2545</td>
    <td class="codeline">  LHS L;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2546</td>
    <td class="codeline">  RHS R;</td>
    <td class="lineNumber">2546</td>
    <td class="codeline">  RHS R;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2547</td>
    <td class="codeline"></td>
    <td class="lineNumber">2547</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2548</td>
    <td class="codeline">  LogicalOp_match(const LHS &L, const RHS &R) : L(L), R(R) {}</td>
    <td class="lineNumber">2548</td>
    <td class="codeline">  LogicalOp_match(const LHS &L, const RHS &R) : L(L), R(R) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2549</td>
    <td class="codeline"></td>
    <td class="lineNumber">2549</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2550</td>
    <td class="codeline">  template <typename T> bool match(T *V) {</td>
    <td class="lineNumber">2550</td>
    <td class="codeline">  template <typename T> bool match(T *V) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2551</td>
    <td class="codeline">    auto *I = dyn_cast<Instruction>(V);</td>
    <td class="lineNumber">2551</td>
    <td class="codeline">    auto *I = dyn_cast<Instruction>(V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2552</td>
    <td class="codeline">    if (!I || !I->getType()->isIntOrIntVectorTy(1))</td>
    <td class="lineNumber">2552</td>
    <td class="codeline">    if (!I || !I->getType()->isIntOrIntVectorTy(1))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2553</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">2553</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2554</td>
    <td class="codeline"></td>
    <td class="lineNumber">2554</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2555</td>
    <td class="codeline">    if (I->getOpcode() == Opcode) {</td>
    <td class="lineNumber">2555</td>
    <td class="codeline">    if (I->getOpcode() == Opcode) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2556</td>
    <td class="codeline">      auto *Op0 = I->getOperand(0);</td>
    <td class="lineNumber">2556</td>
    <td class="codeline">      auto *Op0 = I->getOperand(0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2557</td>
    <td class="codeline">      auto *Op1 = I->getOperand(1);</td>
    <td class="lineNumber">2557</td>
    <td class="codeline">      auto *Op1 = I->getOperand(1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2558</td>
    <td class="codeline">      return (L.match(Op0) && R.match(Op1)) ||</td>
    <td class="lineNumber">2558</td>
    <td class="codeline">      return (L.match(Op0) && R.match(Op1)) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2559</td>
    <td class="codeline">             (Commutable && L.match(Op1) && R.match(Op0));</td>
    <td class="lineNumber">2559</td>
    <td class="codeline">             (Commutable && L.match(Op1) && R.match(Op0));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2560</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2560</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2561</td>
    <td class="codeline"></td>
    <td class="lineNumber">2561</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2562</td>
    <td class="codeline">    if (auto *Select = dyn_cast<SelectInst>(I)) {</td>
    <td class="lineNumber">2562</td>
    <td class="codeline">    if (auto *Select = dyn_cast<SelectInst>(I)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2563</td>
    <td class="codeline">      auto *Cond = Select->getCondition();</td>
    <td class="lineNumber">2563</td>
    <td class="codeline">      auto *Cond = Select->getCondition();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2564</td>
    <td class="codeline">      auto *TVal = Select->getTrueValue();</td>
    <td class="lineNumber">2564</td>
    <td class="codeline">      auto *TVal = Select->getTrueValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2565</td>
    <td class="codeline">      auto *FVal = Select->getFalseValue();</td>
    <td class="lineNumber">2565</td>
    <td class="codeline">      auto *FVal = Select->getFalseValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2566</td>
    <td class="codeline"></td>
    <td class="lineNumber">2566</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2567</td>
    <td class="codeline">      // Don't match a scalar select of bool vectors.</td>
    <td class="lineNumber">2567</td>
    <td class="codeline">      // Don't match a scalar select of bool vectors.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2568</td>
    <td class="codeline">      // Transforms expect a single type for operands if this matches.</td>
    <td class="lineNumber">2568</td>
    <td class="codeline">      // Transforms expect a single type for operands if this matches.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2569</td>
    <td class="codeline">      if (Cond->getType() != Select->getType())</td>
    <td class="lineNumber">2569</td>
    <td class="codeline">      if (Cond->getType() != Select->getType())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2570</td>
    <td class="codeline">        return false;</td>
    <td class="lineNumber">2570</td>
    <td class="codeline">        return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2571</td>
    <td class="codeline"></td>
    <td class="lineNumber">2571</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2572</td>
    <td class="codeline">      if (Opcode == Instruction::And) {</td>
    <td class="lineNumber">2572</td>
    <td class="codeline">      if (Opcode == Instruction::And) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2573</td>
    <td class="codeline">        auto *C = dyn_cast<Constant>(FVal);</td>
    <td class="lineNumber">2573</td>
    <td class="codeline">        auto *C = dyn_cast<Constant>(FVal);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2574</td>
    <td class="codeline">        if (C && C->isNullValue())</td>
    <td class="lineNumber">2574</td>
    <td class="codeline">        if (C && C->isNullValue())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2575</td>
    <td class="codeline">          return (L.match(Cond) && R.match(TVal)) ||</td>
    <td class="lineNumber">2575</td>
    <td class="codeline">          return (L.match(Cond) && R.match(TVal)) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2576</td>
    <td class="codeline">                 (Commutable && L.match(TVal) && R.match(Cond));</td>
    <td class="lineNumber">2576</td>
    <td class="codeline">                 (Commutable && L.match(TVal) && R.match(Cond));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2577</td>
    <td class="codeline">      } else {</td>
    <td class="lineNumber">2577</td>
    <td class="codeline">      } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2578</td>
    <td class="codeline">        assert(Opcode == Instruction::Or);</td>
    <td class="lineNumber">2578</td>
    <td class="codeline">        assert(Opcode == Instruction::Or);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2579</td>
    <td class="codeline">        auto *C = dyn_cast<Constant>(TVal);</td>
    <td class="lineNumber">2579</td>
    <td class="codeline">        auto *C = dyn_cast<Constant>(TVal);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2580</td>
    <td class="codeline">        if (C && C->isOneValue())</td>
    <td class="lineNumber">2580</td>
    <td class="codeline">        if (C && C->isOneValue())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2581</td>
    <td class="codeline">          return (L.match(Cond) && R.match(FVal)) ||</td>
    <td class="lineNumber">2581</td>
    <td class="codeline">          return (L.match(Cond) && R.match(FVal)) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2582</td>
    <td class="codeline">                 (Commutable && L.match(FVal) && R.match(Cond));</td>
    <td class="lineNumber">2582</td>
    <td class="codeline">                 (Commutable && L.match(FVal) && R.match(Cond));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2583</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">2583</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2584</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2584</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2585</td>
    <td class="codeline"></td>
    <td class="lineNumber">2585</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2586</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">2586</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2587</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2587</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2588</td>
    <td class="codeline">};</td>
    <td class="lineNumber">2588</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2589</td>
    <td class="codeline"></td>
    <td class="lineNumber">2589</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2590</td>
    <td class="codeline">/// Matches L && R either in the form of L & R or L ? R : false.</td>
    <td class="lineNumber">2590</td>
    <td class="codeline">/// Matches L && R either in the form of L & R or L ? R : false.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2591</td>
    <td class="codeline">/// Note that the latter form is poison-blocking.</td>
    <td class="lineNumber">2591</td>
    <td class="codeline">/// Note that the latter form is poison-blocking.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2592</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
    <td class="lineNumber">2592</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2593</td>
    <td class="codeline">inline LogicalOp_match<LHS, RHS, Instruction::And> m_LogicalAnd(const LHS &L,</td>
    <td class="lineNumber">2593</td>
    <td class="codeline">inline LogicalOp_match<LHS, RHS, Instruction::And> m_LogicalAnd(const LHS &L,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2594</td>
    <td class="codeline">                                                                const RHS &R) {</td>
    <td class="lineNumber">2594</td>
    <td class="codeline">                                                                const RHS &R) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2595</td>
    <td class="codeline">  return LogicalOp_match<LHS, RHS, Instruction::And>(L, R);</td>
    <td class="lineNumber">2595</td>
    <td class="codeline">  return LogicalOp_match<LHS, RHS, Instruction::And>(L, R);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2596</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2596</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2597</td>
    <td class="codeline"></td>
    <td class="lineNumber">2597</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2598</td>
    <td class="codeline">/// Matches L && R where L and R are arbitrary values.</td>
    <td class="lineNumber">2598</td>
    <td class="codeline">/// Matches L && R where L and R are arbitrary values.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2599</td>
    <td class="codeline">inline auto m_LogicalAnd() { return m_LogicalAnd(m_Value(), m_Value()); }</td>
    <td class="lineNumber">2599</td>
    <td class="codeline">inline auto m_LogicalAnd() { return m_LogicalAnd(m_Value(), m_Value()); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2600</td>
    <td class="codeline"></td>
    <td class="lineNumber">2600</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2601</td>
    <td class="codeline">/// Matches L && R with LHS and RHS in either order.</td>
    <td class="lineNumber">2601</td>
    <td class="codeline">/// Matches L && R with LHS and RHS in either order.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2602</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
    <td class="lineNumber">2602</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2603</td>
    <td class="codeline">inline LogicalOp_match<LHS, RHS, Instruction::And, true></td>
    <td class="lineNumber">2603</td>
    <td class="codeline">inline LogicalOp_match<LHS, RHS, Instruction::And, true></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2604</td>
    <td class="codeline">m_c_LogicalAnd(const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">2604</td>
    <td class="codeline">m_c_LogicalAnd(const LHS &L, const RHS &R) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2605</td>
    <td class="codeline">  return LogicalOp_match<LHS, RHS, Instruction::And, true>(L, R);</td>
    <td class="lineNumber">2605</td>
    <td class="codeline">  return LogicalOp_match<LHS, RHS, Instruction::And, true>(L, R);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2606</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2606</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2607</td>
    <td class="codeline"></td>
    <td class="lineNumber">2607</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2608</td>
    <td class="codeline">/// Matches L || R either in the form of L | R or L ? true : R.</td>
    <td class="lineNumber">2608</td>
    <td class="codeline">/// Matches L || R either in the form of L | R or L ? true : R.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2609</td>
    <td class="codeline">/// Note that the latter form is poison-blocking.</td>
    <td class="lineNumber">2609</td>
    <td class="codeline">/// Note that the latter form is poison-blocking.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2610</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
    <td class="lineNumber">2610</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2611</td>
    <td class="codeline">inline LogicalOp_match<LHS, RHS, Instruction::Or> m_LogicalOr(const LHS &L,</td>
    <td class="lineNumber">2611</td>
    <td class="codeline">inline LogicalOp_match<LHS, RHS, Instruction::Or> m_LogicalOr(const LHS &L,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2612</td>
    <td class="codeline">                                                              const RHS &R) {</td>
    <td class="lineNumber">2612</td>
    <td class="codeline">                                                              const RHS &R) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2613</td>
    <td class="codeline">  return LogicalOp_match<LHS, RHS, Instruction::Or>(L, R);</td>
    <td class="lineNumber">2613</td>
    <td class="codeline">  return LogicalOp_match<LHS, RHS, Instruction::Or>(L, R);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2614</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2614</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2615</td>
    <td class="codeline"></td>
    <td class="lineNumber">2615</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2616</td>
    <td class="codeline">/// Matches L || R where L and R are arbitrary values.</td>
    <td class="lineNumber">2616</td>
    <td class="codeline">/// Matches L || R where L and R are arbitrary values.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2617</td>
    <td class="codeline">inline auto m_LogicalOr() { return m_LogicalOr(m_Value(), m_Value()); }</td>
    <td class="lineNumber">2617</td>
    <td class="codeline">inline auto m_LogicalOr() { return m_LogicalOr(m_Value(), m_Value()); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2618</td>
    <td class="codeline"></td>
    <td class="lineNumber">2618</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2619</td>
    <td class="codeline">/// Matches L || R with LHS and RHS in either order.</td>
    <td class="lineNumber">2619</td>
    <td class="codeline">/// Matches L || R with LHS and RHS in either order.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2620</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
    <td class="lineNumber">2620</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2621</td>
    <td class="codeline">inline LogicalOp_match<LHS, RHS, Instruction::Or, true></td>
    <td class="lineNumber">2621</td>
    <td class="codeline">inline LogicalOp_match<LHS, RHS, Instruction::Or, true></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2622</td>
    <td class="codeline">m_c_LogicalOr(const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">2622</td>
    <td class="codeline">m_c_LogicalOr(const LHS &L, const RHS &R) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2623</td>
    <td class="codeline">  return LogicalOp_match<LHS, RHS, Instruction::Or, true>(L, R);</td>
    <td class="lineNumber">2623</td>
    <td class="codeline">  return LogicalOp_match<LHS, RHS, Instruction::Or, true>(L, R);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2624</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2624</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2625</td>
    <td class="codeline"></td>
    <td class="lineNumber">2625</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2626</td>
    <td class="codeline">/// Matches either L && R or L || R,</td>
    <td class="lineNumber">2626</td>
    <td class="codeline">/// Matches either L && R or L || R,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2627</td>
    <td class="codeline">/// either one being in the either binary or logical form.</td>
    <td class="lineNumber">2627</td>
    <td class="codeline">/// either one being in the either binary or logical form.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2628</td>
    <td class="codeline">/// Note that the latter form is poison-blocking.</td>
    <td class="lineNumber">2628</td>
    <td class="codeline">/// Note that the latter form is poison-blocking.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2629</td>
    <td class="codeline">template <typename LHS, typename RHS, bool Commutable = false></td>
    <td class="lineNumber">2629</td>
    <td class="codeline">template <typename LHS, typename RHS, bool Commutable = false></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2630</td>
    <td class="codeline">inline auto m_LogicalOp(const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">2630</td>
    <td class="codeline">inline auto m_LogicalOp(const LHS &L, const RHS &R) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2631</td>
    <td class="codeline">  return m_CombineOr(</td>
    <td class="lineNumber">2631</td>
    <td class="codeline">  return m_CombineOr(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2632</td>
    <td class="codeline">      LogicalOp_match<LHS, RHS, Instruction::And, Commutable>(L, R),</td>
    <td class="lineNumber">2632</td>
    <td class="codeline">      LogicalOp_match<LHS, RHS, Instruction::And, Commutable>(L, R),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2633</td>
    <td class="codeline">      LogicalOp_match<LHS, RHS, Instruction::Or, Commutable>(L, R));</td>
    <td class="lineNumber">2633</td>
    <td class="codeline">      LogicalOp_match<LHS, RHS, Instruction::Or, Commutable>(L, R));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2634</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2634</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2635</td>
    <td class="codeline"></td>
    <td class="lineNumber">2635</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2636</td>
    <td class="codeline">/// Matches either L && R or L || R where L and R are arbitrary values.</td>
    <td class="lineNumber">2636</td>
    <td class="codeline">/// Matches either L && R or L || R where L and R are arbitrary values.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2637</td>
    <td class="codeline">inline auto m_LogicalOp() { return m_LogicalOp(m_Value(), m_Value()); }</td>
    <td class="lineNumber">2637</td>
    <td class="codeline">inline auto m_LogicalOp() { return m_LogicalOp(m_Value(), m_Value()); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2638</td>
    <td class="codeline"></td>
    <td class="lineNumber">2638</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2639</td>
    <td class="codeline">/// Matches either L && R or L || R with LHS and RHS in either order.</td>
    <td class="lineNumber">2639</td>
    <td class="codeline">/// Matches either L && R or L || R with LHS and RHS in either order.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2640</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
    <td class="lineNumber">2640</td>
    <td class="codeline">template <typename LHS, typename RHS></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2641</td>
    <td class="codeline">inline auto m_c_LogicalOp(const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">2641</td>
    <td class="codeline">inline auto m_c_LogicalOp(const LHS &L, const RHS &R) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2642</td>
    <td class="codeline">  return m_LogicalOp<LHS, RHS, /*Commutable=*/true>(L, R);</td>
    <td class="lineNumber">2642</td>
    <td class="codeline">  return m_LogicalOp<LHS, RHS, /*Commutable=*/true>(L, R);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2643</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2643</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2644</td>
    <td class="codeline"></td>
    <td class="lineNumber">2644</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2645</td>
    <td class="codeline">} // end namespace PatternMatch</td>
    <td class="lineNumber">2645</td>
    <td class="codeline">} // end namespace PatternMatch</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2646</td>
    <td class="codeline">} // end namespace llvm</td>
    <td class="lineNumber">2646</td>
    <td class="codeline">} // end namespace llvm</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2647</td>
    <td class="codeline"></td>
    <td class="lineNumber">2647</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2648</td>
    <td class="codeline">#endif // LLVM_IR_PATTERNMATCH_H</td>
    <td class="lineNumber">2648</td>
    <td class="codeline">#endif // LLVM_IR_PATTERNMATCH_H</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2649</td>
    <td class="codeline"></td>
    <td class="lineNumber">2649</td>
    <td class="codeline"></td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Side By Side Comparison</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Side By Side Comparison</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </th>
    <th class="mainTh">Hit count</th>
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </th>
    <th class="mainTh">Hit count</th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="codeLine">//===- PatternMatch.h - Match on the LLVM IR --------------------*- C++ -*-===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1</td>
    <td class="codeLine">//===- PatternMatch.h - Match on the LLVM IR --------------------*- C++ -*-===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="codeLine">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3</td>
    <td class="codeLine">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="codeLine">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4</td>
    <td class="codeLine">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="codeLine">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5</td>
    <td class="codeLine">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">6</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">7</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">8</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="codeLine">// This file provides a simple and efficient mechanism for performing general</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">9</td>
    <td class="codeLine">// This file provides a simple and efficient mechanism for performing general</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="codeLine">// tree-based pattern matches on the LLVM IR. The power of these routines is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">10</td>
    <td class="codeLine">// tree-based pattern matches on the LLVM IR. The power of these routines is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="codeLine">// that it allows you to write concise patterns that are expressive and easy to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">11</td>
    <td class="codeLine">// that it allows you to write concise patterns that are expressive and easy to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="codeLine">// understand. The other major advantage of this is that it allows you to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">12</td>
    <td class="codeLine">// understand. The other major advantage of this is that it allows you to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="codeLine">// trivially capture/bind elements in the pattern to variables. For example,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">13</td>
    <td class="codeLine">// trivially capture/bind elements in the pattern to variables. For example,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="codeLine">// you can do something like this:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">14</td>
    <td class="codeLine">// you can do something like this:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">15</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="codeLine">//  Value *Exp = ...</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">16</td>
    <td class="codeLine">//  Value *Exp = ...</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="codeLine">//  Value *X, *Y;  ConstantInt *C1, *C2;      // (X & C1) | (Y & C2)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">17</td>
    <td class="codeLine">//  Value *X, *Y;  ConstantInt *C1, *C2;      // (X & C1) | (Y & C2)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="codeLine">//  if (match(Exp, m_Or(m_And(m_Value(X), m_ConstantInt(C1)),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">18</td>
    <td class="codeLine">//  if (match(Exp, m_Or(m_And(m_Value(X), m_ConstantInt(C1)),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="codeLine">//                      m_And(m_Value(Y), m_ConstantInt(C2))))) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">19</td>
    <td class="codeLine">//                      m_And(m_Value(Y), m_ConstantInt(C2))))) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="codeLine">//    ... Pattern is matched and variables are bound ...</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">20</td>
    <td class="codeLine">//    ... Pattern is matched and variables are bound ...</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="codeLine">//  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">21</td>
    <td class="codeLine">//  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">22</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="codeLine">// This is primarily useful to things like the instruction combiner, but can</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">23</td>
    <td class="codeLine">// This is primarily useful to things like the instruction combiner, but can</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="codeLine">// also be useful for static analysis tools or code generators.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">24</td>
    <td class="codeLine">// also be useful for static analysis tools or code generators.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">25</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">26</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">27</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="codeLine">#ifndef LLVM_IR_PATTERNMATCH_H</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">28</td>
    <td class="codeLine">#ifndef LLVM_IR_PATTERNMATCH_H</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="codeLine">#define LLVM_IR_PATTERNMATCH_H</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">29</td>
    <td class="codeLine">#define LLVM_IR_PATTERNMATCH_H</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">30</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="codeLine">#include "llvm/ADT/APFloat.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">31</td>
    <td class="codeLine">#include "llvm/ADT/APFloat.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="codeLine">#include "llvm/ADT/APInt.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">32</td>
    <td class="codeLine">#include "llvm/ADT/APInt.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="codeLine">#include "llvm/IR/Constant.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">33</td>
    <td class="codeLine">#include "llvm/IR/Constant.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="codeLine">#include "llvm/IR/Constants.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">34</td>
    <td class="codeLine">#include "llvm/IR/Constants.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="codeLine">#include "llvm/IR/DataLayout.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">35</td>
    <td class="codeLine">#include "llvm/IR/DataLayout.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="codeLine">#include "llvm/IR/InstrTypes.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">36</td>
    <td class="codeLine">#include "llvm/IR/InstrTypes.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="codeLine">#include "llvm/IR/Instruction.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">37</td>
    <td class="codeLine">#include "llvm/IR/Instruction.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="codeLine">#include "llvm/IR/Instructions.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">38</td>
    <td class="codeLine">#include "llvm/IR/Instructions.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="codeLine">#include "llvm/IR/IntrinsicInst.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">39</td>
    <td class="codeLine">#include "llvm/IR/IntrinsicInst.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="codeLine">#include "llvm/IR/Intrinsics.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">40</td>
    <td class="codeLine">#include "llvm/IR/Intrinsics.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="codeLine">#include "llvm/IR/Operator.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">41</td>
    <td class="codeLine">#include "llvm/IR/Operator.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="codeLine">#include "llvm/IR/Value.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">42</td>
    <td class="codeLine">#include "llvm/IR/Value.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="codeLine">#include "llvm/Support/Casting.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">43</td>
    <td class="codeLine">#include "llvm/Support/Casting.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="codeLine">#include <cstdint></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">44</td>
    <td class="codeLine">#include <cstdint></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">45</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="codeLine">namespace llvm {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">46</td>
    <td class="codeLine">namespace llvm {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="codeLine">namespace PatternMatch {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">47</td>
    <td class="codeLine">namespace PatternMatch {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">48</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="codeLine coveredLine">template <typename Val, typename Pattern> bool match(Val *V, const Pattern &P) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">49</td>
    <td class="codeLine coveredLine">template <typename Val, typename Pattern> bool match(Val *V, const Pattern &P) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="codeLine coveredLine">  return const_cast<Pattern &>(P).match(V);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">50</td>
    <td class="codeLine coveredLine">  return const_cast<Pattern &>(P).match(V);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">51</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">52</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="codeLine">template <typename Pattern> bool match(ArrayRef<int> Mask, const Pattern &P) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">53</td>
    <td class="codeLine">template <typename Pattern> bool match(ArrayRef<int> Mask, const Pattern &P) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="codeLine">  return const_cast<Pattern &>(P).match(Mask);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">54</td>
    <td class="codeLine">  return const_cast<Pattern &>(P).match(Mask);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">55</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">56</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="codeLine">template <typename SubPattern_t> struct OneUse_match {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">57</td>
    <td class="codeLine">template <typename SubPattern_t> struct OneUse_match {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="codeLine">  SubPattern_t SubPattern;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">58</td>
    <td class="codeLine">  SubPattern_t SubPattern;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">59</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="codeLine">  OneUse_match(const SubPattern_t &SP) : SubPattern(SP) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">60</td>
    <td class="codeLine">  OneUse_match(const SubPattern_t &SP) : SubPattern(SP) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">61</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="codeLine">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">62</td>
    <td class="codeLine">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="codeLine">    return V->hasOneUse() && SubPattern.match(V);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">63</td>
    <td class="codeLine">    return V->hasOneUse() && SubPattern.match(V);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">64</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">65</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">66</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="codeLine">template <typename T> inline OneUse_match<T> m_OneUse(const T &SubPattern) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">67</td>
    <td class="codeLine">template <typename T> inline OneUse_match<T> m_OneUse(const T &SubPattern) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="codeLine">  return SubPattern;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">68</td>
    <td class="codeLine">  return SubPattern;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">69</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">70</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="codeLine">template <typename Class> struct class_match {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">71</td>
    <td class="codeLine">template <typename Class> struct class_match {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="codeLine">  template <typename ITy> bool match(ITy *V) { return isa<Class>(V); }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">72</td>
    <td class="codeLine">  template <typename ITy> bool match(ITy *V) { return isa<Class>(V); }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">73</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">74</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="codeLine">/// Match an arbitrary value and ignore it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">75</td>
    <td class="codeLine">/// Match an arbitrary value and ignore it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="codeLine">inline class_match<Value> m_Value() { return class_match<Value>(); }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">76</td>
    <td class="codeLine">inline class_match<Value> m_Value() { return class_match<Value>(); }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">77</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="codeLine">/// Match an arbitrary unary operation and ignore it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">78</td>
    <td class="codeLine">/// Match an arbitrary unary operation and ignore it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="codeLine">inline class_match<UnaryOperator> m_UnOp() {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">79</td>
    <td class="codeLine">inline class_match<UnaryOperator> m_UnOp() {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="codeLine">  return class_match<UnaryOperator>();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">80</td>
    <td class="codeLine">  return class_match<UnaryOperator>();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">81</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">82</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="codeLine">/// Match an arbitrary binary operation and ignore it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">83</td>
    <td class="codeLine">/// Match an arbitrary binary operation and ignore it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="codeLine">inline class_match<BinaryOperator> m_BinOp() {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">84</td>
    <td class="codeLine">inline class_match<BinaryOperator> m_BinOp() {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="codeLine">  return class_match<BinaryOperator>();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">85</td>
    <td class="codeLine">  return class_match<BinaryOperator>();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">86</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">87</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="codeLine">/// Matches any compare instruction and ignore it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">88</td>
    <td class="codeLine">/// Matches any compare instruction and ignore it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="codeLine">inline class_match<CmpInst> m_Cmp() { return class_match<CmpInst>(); }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">89</td>
    <td class="codeLine">inline class_match<CmpInst> m_Cmp() { return class_match<CmpInst>(); }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">90</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="codeLine">struct undef_match {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">91</td>
    <td class="codeLine">struct undef_match {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="codeLine">  static bool check(const Value *V) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">92</td>
    <td class="codeLine">  static bool check(const Value *V) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="codeLine">    if (isa<UndefValue>(V))</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">93</td>
    <td class="codeLine">    if (isa<UndefValue>(V))</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">94</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">95</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="codeLine">    const auto *CA = dyn_cast<ConstantAggregate>(V);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">96</td>
    <td class="codeLine">    const auto *CA = dyn_cast<ConstantAggregate>(V);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="codeLine">    if (!CA)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">97</td>
    <td class="codeLine">    if (!CA)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">98</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">99</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="codeLine">    SmallPtrSet<const ConstantAggregate *, 8> Seen;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">100</td>
    <td class="codeLine">    SmallPtrSet<const ConstantAggregate *, 8> Seen;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="codeLine">    SmallVector<const ConstantAggregate *, 8> Worklist;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">101</td>
    <td class="codeLine">    SmallVector<const ConstantAggregate *, 8> Worklist;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">102</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="codeLine">    // Either UndefValue, PoisonValue, or an aggregate that only contains</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">103</td>
    <td class="codeLine">    // Either UndefValue, PoisonValue, or an aggregate that only contains</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="codeLine">    // these is accepted by matcher.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">104</td>
    <td class="codeLine">    // these is accepted by matcher.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="codeLine">    // CheckValue returns false if CA cannot satisfy this constraint.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">105</td>
    <td class="codeLine">    // CheckValue returns false if CA cannot satisfy this constraint.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="codeLine">    auto CheckValue = [&](const ConstantAggregate *CA) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">106</td>
    <td class="codeLine">    auto CheckValue = [&](const ConstantAggregate *CA) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="codeLine">      for (const Value *Op : CA->operand_values()) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">107</td>
    <td class="codeLine">      for (const Value *Op : CA->operand_values()) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="codeLine">        if (isa<UndefValue>(Op))</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">108</td>
    <td class="codeLine">        if (isa<UndefValue>(Op))</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">109</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">110</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="codeLine">        const auto *CA = dyn_cast<ConstantAggregate>(Op);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">111</td>
    <td class="codeLine">        const auto *CA = dyn_cast<ConstantAggregate>(Op);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="codeLine">        if (!CA)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">112</td>
    <td class="codeLine">        if (!CA)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="codeLine">          return false;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">113</td>
    <td class="codeLine">          return false;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="codeLine">        if (Seen.insert(CA).second)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">114</td>
    <td class="codeLine">        if (Seen.insert(CA).second)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="codeLine">          Worklist.emplace_back(CA);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">115</td>
    <td class="codeLine">          Worklist.emplace_back(CA);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">116</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">117</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">118</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="codeLine">    };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">119</td>
    <td class="codeLine">    };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">120</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="codeLine">    if (!CheckValue(CA))</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">121</td>
    <td class="codeLine">    if (!CheckValue(CA))</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">122</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">123</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="codeLine">    while (!Worklist.empty()) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">124</td>
    <td class="codeLine">    while (!Worklist.empty()) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="codeLine">      if (!CheckValue(Worklist.pop_back_val()))</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">125</td>
    <td class="codeLine">      if (!CheckValue(Worklist.pop_back_val()))</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="codeLine">        return false;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">126</td>
    <td class="codeLine">        return false;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">127</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">128</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">129</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="codeLine">  template <typename ITy> bool match(ITy *V) { return check(V); }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">130</td>
    <td class="codeLine">  template <typename ITy> bool match(ITy *V) { return check(V); }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">131</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">132</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="codeLine">/// Match an arbitrary undef constant. This matches poison as well.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">133</td>
    <td class="codeLine">/// Match an arbitrary undef constant. This matches poison as well.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="codeLine">/// If this is an aggregate and contains a non-aggregate element that is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">134</td>
    <td class="codeLine">/// If this is an aggregate and contains a non-aggregate element that is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="codeLine">/// neither undef nor poison, the aggregate is not matched.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">135</td>
    <td class="codeLine">/// neither undef nor poison, the aggregate is not matched.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="codeLine">inline auto m_Undef() { return undef_match(); }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">136</td>
    <td class="codeLine">inline auto m_Undef() { return undef_match(); }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">137</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="codeLine">/// Match an arbitrary poison constant.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">138</td>
    <td class="codeLine">/// Match an arbitrary poison constant.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="codeLine">inline class_match<PoisonValue> m_Poison() {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">139</td>
    <td class="codeLine">inline class_match<PoisonValue> m_Poison() {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="codeLine">  return class_match<PoisonValue>();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">140</td>
    <td class="codeLine">  return class_match<PoisonValue>();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">141</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">142</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="codeLine">/// Match an arbitrary Constant and ignore it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">143</td>
    <td class="codeLine">/// Match an arbitrary Constant and ignore it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="codeLine">inline class_match<Constant> m_Constant() { return class_match<Constant>(); }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">144</td>
    <td class="codeLine">inline class_match<Constant> m_Constant() { return class_match<Constant>(); }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">145</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="codeLine">/// Match an arbitrary ConstantInt and ignore it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">146</td>
    <td class="codeLine">/// Match an arbitrary ConstantInt and ignore it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="codeLine">inline class_match<ConstantInt> m_ConstantInt() {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">147</td>
    <td class="codeLine">inline class_match<ConstantInt> m_ConstantInt() {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="codeLine">  return class_match<ConstantInt>();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">148</td>
    <td class="codeLine">  return class_match<ConstantInt>();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">149</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">150</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="codeLine">/// Match an arbitrary ConstantFP and ignore it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">151</td>
    <td class="codeLine">/// Match an arbitrary ConstantFP and ignore it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="codeLine">inline class_match<ConstantFP> m_ConstantFP() {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">152</td>
    <td class="codeLine">inline class_match<ConstantFP> m_ConstantFP() {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="codeLine">  return class_match<ConstantFP>();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">153</td>
    <td class="codeLine">  return class_match<ConstantFP>();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">154</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">155</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="codeLine">struct constantexpr_match {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">156</td>
    <td class="codeLine">struct constantexpr_match {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="codeLine">  template <typename ITy> bool match(ITy *V) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">157</td>
    <td class="codeLine">  template <typename ITy> bool match(ITy *V) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="codeLine">    auto *C = dyn_cast<Constant>(V);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">158</td>
    <td class="codeLine">    auto *C = dyn_cast<Constant>(V);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="codeLine">    return C && (isa<ConstantExpr>(C) || C->containsConstantExpression());</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">159</td>
    <td class="codeLine">    return C && (isa<ConstantExpr>(C) || C->containsConstantExpression());</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">160</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">161</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">162</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="codeLine">/// Match a constant expression or a constant that contains a constant</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">163</td>
    <td class="codeLine">/// Match a constant expression or a constant that contains a constant</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="codeLine">/// expression.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">164</td>
    <td class="codeLine">/// expression.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="codeLine">inline constantexpr_match m_ConstantExpr() { return constantexpr_match(); }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">165</td>
    <td class="codeLine">inline constantexpr_match m_ConstantExpr() { return constantexpr_match(); }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">166</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="codeLine">/// Match an arbitrary basic block value and ignore it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">167</td>
    <td class="codeLine">/// Match an arbitrary basic block value and ignore it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="codeLine">inline class_match<BasicBlock> m_BasicBlock() {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">168</td>
    <td class="codeLine">inline class_match<BasicBlock> m_BasicBlock() {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="codeLine">  return class_match<BasicBlock>();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">169</td>
    <td class="codeLine">  return class_match<BasicBlock>();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">170</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">171</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="codeLine">/// Inverting matcher</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">172</td>
    <td class="codeLine">/// Inverting matcher</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="codeLine">template <typename Ty> struct match_unless {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">173</td>
    <td class="codeLine">template <typename Ty> struct match_unless {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="codeLine">  Ty M;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">174</td>
    <td class="codeLine">  Ty M;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">175</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="codeLine">  match_unless(const Ty &Matcher) : M(Matcher) {}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">176</td>
    <td class="codeLine">  match_unless(const Ty &Matcher) : M(Matcher) {}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">177</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="codeLine">  template <typename ITy> bool match(ITy *V) { return !M.match(V); }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">178</td>
    <td class="codeLine">  template <typename ITy> bool match(ITy *V) { return !M.match(V); }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">179</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">180</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="codeLine">/// Match if the inner matcher does *NOT* match.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">181</td>
    <td class="codeLine">/// Match if the inner matcher does *NOT* match.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="codeLine">template <typename Ty> inline match_unless<Ty> m_Unless(const Ty &M) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">182</td>
    <td class="codeLine">template <typename Ty> inline match_unless<Ty> m_Unless(const Ty &M) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="codeLine">  return match_unless<Ty>(M);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">183</td>
    <td class="codeLine">  return match_unless<Ty>(M);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">184</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">185</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="codeLine">/// Matching combinators</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">186</td>
    <td class="codeLine">/// Matching combinators</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="codeLine">template <typename LTy, typename RTy> struct match_combine_or {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">187</td>
    <td class="codeLine">template <typename LTy, typename RTy> struct match_combine_or {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="codeLine">  LTy L;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">188</td>
    <td class="codeLine">  LTy L;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="codeLine">  RTy R;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">189</td>
    <td class="codeLine">  RTy R;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">190</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="codeLine">  match_combine_or(const LTy &Left, const RTy &Right) : L(Left), R(Right) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">191</td>
    <td class="codeLine">  match_combine_or(const LTy &Left, const RTy &Right) : L(Left), R(Right) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">192</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="codeLine">  template <typename ITy> bool match(ITy *V) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">193</td>
    <td class="codeLine">  template <typename ITy> bool match(ITy *V) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="codeLine">    if (L.match(V))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">194</td>
    <td class="codeLine">    if (L.match(V))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">195</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="codeLine">    if (R.match(V))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">196</td>
    <td class="codeLine">    if (R.match(V))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">197</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">198</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">199</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">200</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">201</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="codeLine">template <typename LTy, typename RTy> struct match_combine_and {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">202</td>
    <td class="codeLine">template <typename LTy, typename RTy> struct match_combine_and {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="codeLine">  LTy L;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">203</td>
    <td class="codeLine">  LTy L;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="codeLine">  RTy R;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">204</td>
    <td class="codeLine">  RTy R;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">205</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="codeLine">  match_combine_and(const LTy &Left, const RTy &Right) : L(Left), R(Right) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">206</td>
    <td class="codeLine">  match_combine_and(const LTy &Left, const RTy &Right) : L(Left), R(Right) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">207</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="codeLine">  template <typename ITy> bool match(ITy *V) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">208</td>
    <td class="codeLine">  template <typename ITy> bool match(ITy *V) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="codeLine">    if (L.match(V))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">209</td>
    <td class="codeLine">    if (L.match(V))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="codeLine">      if (R.match(V))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">210</td>
    <td class="codeLine">      if (R.match(V))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="codeLine">        return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">211</td>
    <td class="codeLine">        return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">212</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">213</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">214</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">215</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="codeLine">/// Combine two pattern matchers matching L || R</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">216</td>
    <td class="codeLine">/// Combine two pattern matchers matching L || R</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="codeLine">template <typename LTy, typename RTy></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">217</td>
    <td class="codeLine">template <typename LTy, typename RTy></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="codeLine">inline match_combine_or<LTy, RTy> m_CombineOr(const LTy &L, const RTy &R) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">218</td>
    <td class="codeLine">inline match_combine_or<LTy, RTy> m_CombineOr(const LTy &L, const RTy &R) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="codeLine">  return match_combine_or<LTy, RTy>(L, R);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">219</td>
    <td class="codeLine">  return match_combine_or<LTy, RTy>(L, R);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">220</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">221</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="codeLine">/// Combine two pattern matchers matching L && R</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">222</td>
    <td class="codeLine">/// Combine two pattern matchers matching L && R</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="codeLine">template <typename LTy, typename RTy></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">223</td>
    <td class="codeLine">template <typename LTy, typename RTy></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="codeLine">inline match_combine_and<LTy, RTy> m_CombineAnd(const LTy &L, const RTy &R) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">224</td>
    <td class="codeLine">inline match_combine_and<LTy, RTy> m_CombineAnd(const LTy &L, const RTy &R) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="codeLine">  return match_combine_and<LTy, RTy>(L, R);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">225</td>
    <td class="codeLine">  return match_combine_and<LTy, RTy>(L, R);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">226</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">227</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="codeLine">struct apint_match {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">228</td>
    <td class="codeLine">struct apint_match {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="codeLine">  const APInt *&Res;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">229</td>
    <td class="codeLine">  const APInt *&Res;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="codeLine">  bool AllowUndef;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">230</td>
    <td class="codeLine">  bool AllowUndef;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">231</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="codeLine">  apint_match(const APInt *&Res, bool AllowUndef)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">232</td>
    <td class="codeLine">  apint_match(const APInt *&Res, bool AllowUndef)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="codeLine">      : Res(Res), AllowUndef(AllowUndef) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">233</td>
    <td class="codeLine">      : Res(Res), AllowUndef(AllowUndef) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">234</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="codeLine">  template <typename ITy> bool match(ITy *V) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">235</td>
    <td class="codeLine">  template <typename ITy> bool match(ITy *V) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="codeLine">    if (auto *CI = dyn_cast<ConstantInt>(V)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">236</td>
    <td class="codeLine">    if (auto *CI = dyn_cast<ConstantInt>(V)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="codeLine">      Res = &CI->getValue();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">237</td>
    <td class="codeLine">      Res = &CI->getValue();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">238</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">239</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="codeLine">    if (V->getType()->isVectorTy())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">240</td>
    <td class="codeLine">    if (V->getType()->isVectorTy())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="codeLine">      if (const auto *C = dyn_cast<Constant>(V))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">241</td>
    <td class="codeLine">      if (const auto *C = dyn_cast<Constant>(V))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="codeLine">        if (auto *CI =</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">242</td>
    <td class="codeLine">        if (auto *CI =</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="codeLine">                dyn_cast_or_null<ConstantInt>(C->getSplatValue(AllowUndef))) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">243</td>
    <td class="codeLine">                dyn_cast_or_null<ConstantInt>(C->getSplatValue(AllowUndef))) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="codeLine">          Res = &CI->getValue();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">244</td>
    <td class="codeLine">          Res = &CI->getValue();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="codeLine">          return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">245</td>
    <td class="codeLine">          return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">246</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">247</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">248</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">249</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="codeLine">// Either constexpr if or renaming ConstantFP::getValueAPF to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">250</td>
    <td class="codeLine">// Either constexpr if or renaming ConstantFP::getValueAPF to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="codeLine">// ConstantFP::getValue is needed to do it via single template</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">251</td>
    <td class="codeLine">// ConstantFP::getValue is needed to do it via single template</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="codeLine">// function for both apint/apfloat.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">252</td>
    <td class="codeLine">// function for both apint/apfloat.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="codeLine">struct apfloat_match {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">253</td>
    <td class="codeLine">struct apfloat_match {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="codeLine">  const APFloat *&Res;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">254</td>
    <td class="codeLine">  const APFloat *&Res;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="codeLine">  bool AllowUndef;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">255</td>
    <td class="codeLine">  bool AllowUndef;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">256</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="codeLine">  apfloat_match(const APFloat *&Res, bool AllowUndef)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">257</td>
    <td class="codeLine">  apfloat_match(const APFloat *&Res, bool AllowUndef)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="codeLine">      : Res(Res), AllowUndef(AllowUndef) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">258</td>
    <td class="codeLine">      : Res(Res), AllowUndef(AllowUndef) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">259</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="codeLine">  template <typename ITy> bool match(ITy *V) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">260</td>
    <td class="codeLine">  template <typename ITy> bool match(ITy *V) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="codeLine">    if (auto *CI = dyn_cast<ConstantFP>(V)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">261</td>
    <td class="codeLine">    if (auto *CI = dyn_cast<ConstantFP>(V)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="codeLine">      Res = &CI->getValueAPF();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">262</td>
    <td class="codeLine">      Res = &CI->getValueAPF();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">263</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">264</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="codeLine">    if (V->getType()->isVectorTy())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">265</td>
    <td class="codeLine">    if (V->getType()->isVectorTy())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="codeLine">      if (const auto *C = dyn_cast<Constant>(V))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">266</td>
    <td class="codeLine">      if (const auto *C = dyn_cast<Constant>(V))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="codeLine">        if (auto *CI =</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">267</td>
    <td class="codeLine">        if (auto *CI =</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="codeLine">                dyn_cast_or_null<ConstantFP>(C->getSplatValue(AllowUndef))) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">268</td>
    <td class="codeLine">                dyn_cast_or_null<ConstantFP>(C->getSplatValue(AllowUndef))) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="codeLine">          Res = &CI->getValueAPF();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">269</td>
    <td class="codeLine">          Res = &CI->getValueAPF();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="codeLine">          return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">270</td>
    <td class="codeLine">          return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">271</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">272</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">273</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">274</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">275</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="codeLine">/// Match a ConstantInt or splatted ConstantVector, binding the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">276</td>
    <td class="codeLine">/// Match a ConstantInt or splatted ConstantVector, binding the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="codeLine">/// specified pointer to the contained APInt.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">277</td>
    <td class="codeLine">/// specified pointer to the contained APInt.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="codeLine">inline apint_match m_APInt(const APInt *&Res) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">278</td>
    <td class="codeLine">inline apint_match m_APInt(const APInt *&Res) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="codeLine">  // Forbid undefs by default to maintain previous behavior.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">279</td>
    <td class="codeLine">  // Forbid undefs by default to maintain previous behavior.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="codeLine">  return apint_match(Res, /* AllowUndef */ false);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">280</td>
    <td class="codeLine">  return apint_match(Res, /* AllowUndef */ false);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">281</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">282</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="codeLine">/// Match APInt while allowing undefs in splat vector constants.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">283</td>
    <td class="codeLine">/// Match APInt while allowing undefs in splat vector constants.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="codeLine">inline apint_match m_APIntAllowUndef(const APInt *&Res) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">284</td>
    <td class="codeLine">inline apint_match m_APIntAllowUndef(const APInt *&Res) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="codeLine">  return apint_match(Res, /* AllowUndef */ true);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">285</td>
    <td class="codeLine">  return apint_match(Res, /* AllowUndef */ true);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">286</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">287</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="codeLine">/// Match APInt while forbidding undefs in splat vector constants.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">288</td>
    <td class="codeLine">/// Match APInt while forbidding undefs in splat vector constants.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="codeLine">inline apint_match m_APIntForbidUndef(const APInt *&Res) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">289</td>
    <td class="codeLine">inline apint_match m_APIntForbidUndef(const APInt *&Res) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="codeLine">  return apint_match(Res, /* AllowUndef */ false);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">290</td>
    <td class="codeLine">  return apint_match(Res, /* AllowUndef */ false);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">291</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">292</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="codeLine">/// Match a ConstantFP or splatted ConstantVector, binding the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">293</td>
    <td class="codeLine">/// Match a ConstantFP or splatted ConstantVector, binding the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="codeLine">/// specified pointer to the contained APFloat.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">294</td>
    <td class="codeLine">/// specified pointer to the contained APFloat.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="codeLine">inline apfloat_match m_APFloat(const APFloat *&Res) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">295</td>
    <td class="codeLine">inline apfloat_match m_APFloat(const APFloat *&Res) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="codeLine">  // Forbid undefs by default to maintain previous behavior.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">296</td>
    <td class="codeLine">  // Forbid undefs by default to maintain previous behavior.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="codeLine">  return apfloat_match(Res, /* AllowUndef */ false);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">297</td>
    <td class="codeLine">  return apfloat_match(Res, /* AllowUndef */ false);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">298</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">299</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="codeLine">/// Match APFloat while allowing undefs in splat vector constants.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">300</td>
    <td class="codeLine">/// Match APFloat while allowing undefs in splat vector constants.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="codeLine">inline apfloat_match m_APFloatAllowUndef(const APFloat *&Res) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">301</td>
    <td class="codeLine">inline apfloat_match m_APFloatAllowUndef(const APFloat *&Res) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="codeLine">  return apfloat_match(Res, /* AllowUndef */ true);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">302</td>
    <td class="codeLine">  return apfloat_match(Res, /* AllowUndef */ true);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">303</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">304</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="codeLine">/// Match APFloat while forbidding undefs in splat vector constants.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">305</td>
    <td class="codeLine">/// Match APFloat while forbidding undefs in splat vector constants.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="codeLine">inline apfloat_match m_APFloatForbidUndef(const APFloat *&Res) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">306</td>
    <td class="codeLine">inline apfloat_match m_APFloatForbidUndef(const APFloat *&Res) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="codeLine">  return apfloat_match(Res, /* AllowUndef */ false);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">307</td>
    <td class="codeLine">  return apfloat_match(Res, /* AllowUndef */ false);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">308</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">309</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="codeLine">template <int64_t Val> struct constantint_match {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">310</td>
    <td class="codeLine">template <int64_t Val> struct constantint_match {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="codeLine">  template <typename ITy> bool match(ITy *V) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">311</td>
    <td class="codeLine">  template <typename ITy> bool match(ITy *V) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="codeLine">    if (const auto *CI = dyn_cast<ConstantInt>(V)) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">312</td>
    <td class="codeLine">    if (const auto *CI = dyn_cast<ConstantInt>(V)) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="codeLine">      const APInt &CIV = CI->getValue();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">313</td>
    <td class="codeLine">      const APInt &CIV = CI->getValue();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="codeLine">      if (Val >= 0)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">314</td>
    <td class="codeLine">      if (Val >= 0)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="codeLine">        return CIV == static_cast<uint64_t>(Val);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">315</td>
    <td class="codeLine">        return CIV == static_cast<uint64_t>(Val);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="codeLine">      // If Val is negative, and CI is shorter than it, truncate to the right</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">316</td>
    <td class="codeLine">      // If Val is negative, and CI is shorter than it, truncate to the right</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="codeLine">      // number of bits.  If it is larger, then we have to sign extend.  Just</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">317</td>
    <td class="codeLine">      // number of bits.  If it is larger, then we have to sign extend.  Just</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="codeLine">      // compare their negated values.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">318</td>
    <td class="codeLine">      // compare their negated values.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="codeLine">      return -CIV == -Val;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">319</td>
    <td class="codeLine">      return -CIV == -Val;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">320</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">321</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">322</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">323</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">324</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="codeLine">/// Match a ConstantInt with a specific value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">325</td>
    <td class="codeLine">/// Match a ConstantInt with a specific value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="codeLine">template <int64_t Val> inline constantint_match<Val> m_ConstantInt() {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">326</td>
    <td class="codeLine">template <int64_t Val> inline constantint_match<Val> m_ConstantInt() {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="codeLine">  return constantint_match<Val>();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">327</td>
    <td class="codeLine">  return constantint_match<Val>();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">328</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">329</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="codeLine">/// This helper class is used to match constant scalars, vector splats,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">330</td>
    <td class="codeLine">/// This helper class is used to match constant scalars, vector splats,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="codeLine">/// and fixed width vectors that satisfy a specified predicate.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">331</td>
    <td class="codeLine">/// and fixed width vectors that satisfy a specified predicate.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="codeLine">/// For fixed width vector constants, undefined elements are ignored.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">332</td>
    <td class="codeLine">/// For fixed width vector constants, undefined elements are ignored.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="codeLine">template <typename Predicate, typename ConstantVal></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">333</td>
    <td class="codeLine">template <typename Predicate, typename ConstantVal></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="codeLine">struct cstval_pred_ty : public Predicate {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">334</td>
    <td class="codeLine">struct cstval_pred_ty : public Predicate {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="codeLine">  template <typename ITy> bool match(ITy *V) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">335</td>
    <td class="codeLine">  template <typename ITy> bool match(ITy *V) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="codeLine">    if (const auto *CV = dyn_cast<ConstantVal>(V))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">336</td>
    <td class="codeLine">    if (const auto *CV = dyn_cast<ConstantVal>(V))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="codeLine">      return this->isValue(CV->getValue());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">337</td>
    <td class="codeLine">      return this->isValue(CV->getValue());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="codeLine">    if (const auto *VTy = dyn_cast<VectorType>(V->getType())) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">338</td>
    <td class="codeLine">    if (const auto *VTy = dyn_cast<VectorType>(V->getType())) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="codeLine">      if (const auto *C = dyn_cast<Constant>(V)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">339</td>
    <td class="codeLine">      if (const auto *C = dyn_cast<Constant>(V)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="codeLine">        if (const auto *CV = dyn_cast_or_null<ConstantVal>(C->getSplatValue()))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">340</td>
    <td class="codeLine">        if (const auto *CV = dyn_cast_or_null<ConstantVal>(C->getSplatValue()))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="codeLine">          return this->isValue(CV->getValue());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">341</td>
    <td class="codeLine">          return this->isValue(CV->getValue());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">342</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="codeLine">        // Number of elements of a scalable vector unknown at compile time</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">343</td>
    <td class="codeLine">        // Number of elements of a scalable vector unknown at compile time</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="codeLine">        auto *FVTy = dyn_cast<FixedVectorType>(VTy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">344</td>
    <td class="codeLine">        auto *FVTy = dyn_cast<FixedVectorType>(VTy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="codeLine">        if (!FVTy)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">345</td>
    <td class="codeLine">        if (!FVTy)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="codeLine">          return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">346</td>
    <td class="codeLine">          return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">347</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="codeLine">        // Non-splat vector constant: check each element for a match.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">348</td>
    <td class="codeLine">        // Non-splat vector constant: check each element for a match.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="codeLine">        unsigned NumElts = FVTy->getNumElements();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">349</td>
    <td class="codeLine">        unsigned NumElts = FVTy->getNumElements();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="codeLine">        assert(NumElts != 0 && "Constant vector with no elements?");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">350</td>
    <td class="codeLine">        assert(NumElts != 0 && "Constant vector with no elements?");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="codeLine">        bool HasNonUndefElements = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">351</td>
    <td class="codeLine">        bool HasNonUndefElements = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="codeLine">        for (unsigned i = 0; i != NumElts; ++i) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">352</td>
    <td class="codeLine">        for (unsigned i = 0; i != NumElts; ++i) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="codeLine">          Constant *Elt = C->getAggregateElement(i);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">353</td>
    <td class="codeLine">          Constant *Elt = C->getAggregateElement(i);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="codeLine">          if (!Elt)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">354</td>
    <td class="codeLine">          if (!Elt)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="codeLine">            return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">355</td>
    <td class="codeLine">            return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="codeLine">          if (isa<UndefValue>(Elt))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">356</td>
    <td class="codeLine">          if (isa<UndefValue>(Elt))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="codeLine">            continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">357</td>
    <td class="codeLine">            continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="codeLine">          auto *CV = dyn_cast<ConstantVal>(Elt);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">358</td>
    <td class="codeLine">          auto *CV = dyn_cast<ConstantVal>(Elt);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="codeLine">          if (!CV || !this->isValue(CV->getValue()))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">359</td>
    <td class="codeLine">          if (!CV || !this->isValue(CV->getValue()))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="codeLine">            return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">360</td>
    <td class="codeLine">            return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="codeLine">          HasNonUndefElements = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">361</td>
    <td class="codeLine">          HasNonUndefElements = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">362</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="codeLine">        return HasNonUndefElements;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">363</td>
    <td class="codeLine">        return HasNonUndefElements;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">364</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">365</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">366</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">367</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">368</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">369</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="codeLine">/// specialization of cstval_pred_ty for ConstantInt</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">370</td>
    <td class="codeLine">/// specialization of cstval_pred_ty for ConstantInt</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="codeLine">template <typename Predicate></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">371</td>
    <td class="codeLine">template <typename Predicate></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="codeLine">using cst_pred_ty = cstval_pred_ty<Predicate, ConstantInt>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">372</td>
    <td class="codeLine">using cst_pred_ty = cstval_pred_ty<Predicate, ConstantInt>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">373</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="codeLine">/// specialization of cstval_pred_ty for ConstantFP</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">374</td>
    <td class="codeLine">/// specialization of cstval_pred_ty for ConstantFP</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="codeLine">template <typename Predicate></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">375</td>
    <td class="codeLine">template <typename Predicate></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="codeLine">using cstfp_pred_ty = cstval_pred_ty<Predicate, ConstantFP>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">376</td>
    <td class="codeLine">using cstfp_pred_ty = cstval_pred_ty<Predicate, ConstantFP>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">377</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="codeLine">/// This helper class is used to match scalar and vector constants that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">378</td>
    <td class="codeLine">/// This helper class is used to match scalar and vector constants that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="codeLine">/// satisfy a specified predicate, and bind them to an APInt.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">379</td>
    <td class="codeLine">/// satisfy a specified predicate, and bind them to an APInt.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="codeLine">template <typename Predicate> struct api_pred_ty : public Predicate {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">380</td>
    <td class="codeLine">template <typename Predicate> struct api_pred_ty : public Predicate {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="codeLine">  const APInt *&Res;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">381</td>
    <td class="codeLine">  const APInt *&Res;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">382</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="codeLine">  api_pred_ty(const APInt *&R) : Res(R) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">383</td>
    <td class="codeLine">  api_pred_ty(const APInt *&R) : Res(R) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">384</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="codeLine">  template <typename ITy> bool match(ITy *V) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">385</td>
    <td class="codeLine">  template <typename ITy> bool match(ITy *V) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="codeLine">    if (const auto *CI = dyn_cast<ConstantInt>(V))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">386</td>
    <td class="codeLine">    if (const auto *CI = dyn_cast<ConstantInt>(V))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="codeLine">      if (this->isValue(CI->getValue())) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">387</td>
    <td class="codeLine">      if (this->isValue(CI->getValue())) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="codeLine">        Res = &CI->getValue();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">388</td>
    <td class="codeLine">        Res = &CI->getValue();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="codeLine">        return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">389</td>
    <td class="codeLine">        return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">390</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="codeLine">    if (V->getType()->isVectorTy())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">391</td>
    <td class="codeLine">    if (V->getType()->isVectorTy())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="codeLine">      if (const auto *C = dyn_cast<Constant>(V))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">392</td>
    <td class="codeLine">      if (const auto *C = dyn_cast<Constant>(V))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="codeLine">        if (auto *CI = dyn_cast_or_null<ConstantInt>(C->getSplatValue()))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">393</td>
    <td class="codeLine">        if (auto *CI = dyn_cast_or_null<ConstantInt>(C->getSplatValue()))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="codeLine">          if (this->isValue(CI->getValue())) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">394</td>
    <td class="codeLine">          if (this->isValue(CI->getValue())) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="codeLine">            Res = &CI->getValue();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">395</td>
    <td class="codeLine">            Res = &CI->getValue();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="codeLine">            return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">396</td>
    <td class="codeLine">            return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">397</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">398</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">399</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">400</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">401</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">402</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="codeLine">/// This helper class is used to match scalar and vector constants that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">403</td>
    <td class="codeLine">/// This helper class is used to match scalar and vector constants that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="codeLine">/// satisfy a specified predicate, and bind them to an APFloat.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">404</td>
    <td class="codeLine">/// satisfy a specified predicate, and bind them to an APFloat.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="codeLine">/// Undefs are allowed in splat vector constants.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">405</td>
    <td class="codeLine">/// Undefs are allowed in splat vector constants.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="codeLine">template <typename Predicate> struct apf_pred_ty : public Predicate {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">406</td>
    <td class="codeLine">template <typename Predicate> struct apf_pred_ty : public Predicate {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="codeLine">  const APFloat *&Res;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">407</td>
    <td class="codeLine">  const APFloat *&Res;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">408</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="codeLine">  apf_pred_ty(const APFloat *&R) : Res(R) {}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">409</td>
    <td class="codeLine">  apf_pred_ty(const APFloat *&R) : Res(R) {}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">410</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="codeLine">  template <typename ITy> bool match(ITy *V) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">411</td>
    <td class="codeLine">  template <typename ITy> bool match(ITy *V) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="codeLine">    if (const auto *CI = dyn_cast<ConstantFP>(V))</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">412</td>
    <td class="codeLine">    if (const auto *CI = dyn_cast<ConstantFP>(V))</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="codeLine">      if (this->isValue(CI->getValue())) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">413</td>
    <td class="codeLine">      if (this->isValue(CI->getValue())) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="codeLine">        Res = &CI->getValue();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">414</td>
    <td class="codeLine">        Res = &CI->getValue();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="codeLine">        return true;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">415</td>
    <td class="codeLine">        return true;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">416</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="codeLine">    if (V->getType()->isVectorTy())</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">417</td>
    <td class="codeLine">    if (V->getType()->isVectorTy())</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="codeLine">      if (const auto *C = dyn_cast<Constant>(V))</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">418</td>
    <td class="codeLine">      if (const auto *C = dyn_cast<Constant>(V))</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="codeLine">        if (auto *CI = dyn_cast_or_null<ConstantFP>(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">419</td>
    <td class="codeLine">        if (auto *CI = dyn_cast_or_null<ConstantFP>(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="codeLine">                C->getSplatValue(/* AllowUndef */ true)))</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">420</td>
    <td class="codeLine">                C->getSplatValue(/* AllowUndef */ true)))</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="codeLine">          if (this->isValue(CI->getValue())) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">421</td>
    <td class="codeLine">          if (this->isValue(CI->getValue())) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="codeLine">            Res = &CI->getValue();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">422</td>
    <td class="codeLine">            Res = &CI->getValue();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="codeLine">            return true;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">423</td>
    <td class="codeLine">            return true;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">424</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">425</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">426</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">427</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">428</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">429</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="codeLine">///////////////////////////////////////////////////////////////////////////////</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">430</td>
    <td class="codeLine">///////////////////////////////////////////////////////////////////////////////</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">431</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="codeLine">// Encapsulate constant value queries for use in templated predicate matchers.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">432</td>
    <td class="codeLine">// Encapsulate constant value queries for use in templated predicate matchers.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="codeLine">// This allows checking if constants match using compound predicates and works</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">433</td>
    <td class="codeLine">// This allows checking if constants match using compound predicates and works</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="codeLine">// with vector constants, possibly with relaxed constraints. For example, ignore</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">434</td>
    <td class="codeLine">// with vector constants, possibly with relaxed constraints. For example, ignore</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="codeLine">// undef values.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">435</td>
    <td class="codeLine">// undef values.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">436</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="codeLine">///////////////////////////////////////////////////////////////////////////////</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">437</td>
    <td class="codeLine">///////////////////////////////////////////////////////////////////////////////</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">438</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="codeLine">struct is_any_apint {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">439</td>
    <td class="codeLine">struct is_any_apint {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="codeLine">  bool isValue(const APInt &C) { return true; }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">440</td>
    <td class="codeLine">  bool isValue(const APInt &C) { return true; }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">441</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="codeLine">/// Match an integer or vector with any integral constant.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">442</td>
    <td class="codeLine">/// Match an integer or vector with any integral constant.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="codeLine">/// For vectors, this includes constants with undefined elements.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">443</td>
    <td class="codeLine">/// For vectors, this includes constants with undefined elements.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="codeLine">inline cst_pred_ty<is_any_apint> m_AnyIntegralConstant() {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">444</td>
    <td class="codeLine">inline cst_pred_ty<is_any_apint> m_AnyIntegralConstant() {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="codeLine">  return cst_pred_ty<is_any_apint>();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">445</td>
    <td class="codeLine">  return cst_pred_ty<is_any_apint>();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">446</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">447</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="codeLine">struct is_shifted_mask {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">448</td>
    <td class="codeLine">struct is_shifted_mask {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="codeLine">  bool isValue(const APInt &C) { return C.isShiftedMask(); }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">449</td>
    <td class="codeLine">  bool isValue(const APInt &C) { return C.isShiftedMask(); }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">450</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">451</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="codeLine">inline cst_pred_ty<is_shifted_mask> m_ShiftedMask() {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">452</td>
    <td class="codeLine">inline cst_pred_ty<is_shifted_mask> m_ShiftedMask() {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="codeLine">  return cst_pred_ty<is_shifted_mask>();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">453</td>
    <td class="codeLine">  return cst_pred_ty<is_shifted_mask>();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">454</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">455</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="codeLine">struct is_all_ones {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">456</td>
    <td class="codeLine">struct is_all_ones {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="codeLine">  bool isValue(const APInt &C) { return C.isAllOnes(); }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">457</td>
    <td class="codeLine">  bool isValue(const APInt &C) { return C.isAllOnes(); }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">458</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="codeLine">/// Match an integer or vector with all bits set.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">459</td>
    <td class="codeLine">/// Match an integer or vector with all bits set.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="codeLine">/// For vectors, this includes constants with undefined elements.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">460</td>
    <td class="codeLine">/// For vectors, this includes constants with undefined elements.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="codeLine">inline cst_pred_ty<is_all_ones> m_AllOnes() {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">461</td>
    <td class="codeLine">inline cst_pred_ty<is_all_ones> m_AllOnes() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="codeLine">  return cst_pred_ty<is_all_ones>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">462</td>
    <td class="codeLine">  return cst_pred_ty<is_all_ones>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">463</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">464</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="codeLine">struct is_maxsignedvalue {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">465</td>
    <td class="codeLine">struct is_maxsignedvalue {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="codeLine">  bool isValue(const APInt &C) { return C.isMaxSignedValue(); }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">466</td>
    <td class="codeLine">  bool isValue(const APInt &C) { return C.isMaxSignedValue(); }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">467</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="codeLine">/// Match an integer or vector with values having all bits except for the high</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">468</td>
    <td class="codeLine">/// Match an integer or vector with values having all bits except for the high</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="codeLine">/// bit set (0x7f...).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">469</td>
    <td class="codeLine">/// bit set (0x7f...).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="codeLine">/// For vectors, this includes constants with undefined elements.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">470</td>
    <td class="codeLine">/// For vectors, this includes constants with undefined elements.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="codeLine">inline cst_pred_ty<is_maxsignedvalue> m_MaxSignedValue() {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">471</td>
    <td class="codeLine">inline cst_pred_ty<is_maxsignedvalue> m_MaxSignedValue() {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="codeLine">  return cst_pred_ty<is_maxsignedvalue>();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">472</td>
    <td class="codeLine">  return cst_pred_ty<is_maxsignedvalue>();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">473</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="codeLine">inline api_pred_ty<is_maxsignedvalue> m_MaxSignedValue(const APInt *&V) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">474</td>
    <td class="codeLine">inline api_pred_ty<is_maxsignedvalue> m_MaxSignedValue(const APInt *&V) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="codeLine">  return V;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">475</td>
    <td class="codeLine">  return V;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">476</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">477</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="codeLine">struct is_negative {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">478</td>
    <td class="codeLine">struct is_negative {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="codeLine">  bool isValue(const APInt &C) { return C.isNegative(); }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">479</td>
    <td class="codeLine">  bool isValue(const APInt &C) { return C.isNegative(); }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">480</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="codeLine">/// Match an integer or vector of negative values.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">481</td>
    <td class="codeLine">/// Match an integer or vector of negative values.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="codeLine">/// For vectors, this includes constants with undefined elements.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">482</td>
    <td class="codeLine">/// For vectors, this includes constants with undefined elements.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="codeLine">inline cst_pred_ty<is_negative> m_Negative() {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">483</td>
    <td class="codeLine">inline cst_pred_ty<is_negative> m_Negative() {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="codeLine">  return cst_pred_ty<is_negative>();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">484</td>
    <td class="codeLine">  return cst_pred_ty<is_negative>();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">485</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="codeLine">inline api_pred_ty<is_negative> m_Negative(const APInt *&V) { return V; }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">486</td>
    <td class="codeLine">inline api_pred_ty<is_negative> m_Negative(const APInt *&V) { return V; }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">487</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="codeLine">struct is_nonnegative {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">488</td>
    <td class="codeLine">struct is_nonnegative {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="codeLine">  bool isValue(const APInt &C) { return C.isNonNegative(); }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">489</td>
    <td class="codeLine">  bool isValue(const APInt &C) { return C.isNonNegative(); }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">490</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="codeLine">/// Match an integer or vector of non-negative values.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">491</td>
    <td class="codeLine">/// Match an integer or vector of non-negative values.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="codeLine">/// For vectors, this includes constants with undefined elements.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">492</td>
    <td class="codeLine">/// For vectors, this includes constants with undefined elements.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="codeLine">inline cst_pred_ty<is_nonnegative> m_NonNegative() {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">493</td>
    <td class="codeLine">inline cst_pred_ty<is_nonnegative> m_NonNegative() {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="codeLine">  return cst_pred_ty<is_nonnegative>();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">494</td>
    <td class="codeLine">  return cst_pred_ty<is_nonnegative>();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">495</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="codeLine">inline api_pred_ty<is_nonnegative> m_NonNegative(const APInt *&V) { return V; }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">496</td>
    <td class="codeLine">inline api_pred_ty<is_nonnegative> m_NonNegative(const APInt *&V) { return V; }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">497</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="codeLine">struct is_strictlypositive {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">498</td>
    <td class="codeLine">struct is_strictlypositive {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="codeLine">  bool isValue(const APInt &C) { return C.isStrictlyPositive(); }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">499</td>
    <td class="codeLine">  bool isValue(const APInt &C) { return C.isStrictlyPositive(); }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">500</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="codeLine">/// Match an integer or vector of strictly positive values.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">501</td>
    <td class="codeLine">/// Match an integer or vector of strictly positive values.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="codeLine">/// For vectors, this includes constants with undefined elements.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">502</td>
    <td class="codeLine">/// For vectors, this includes constants with undefined elements.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="codeLine">inline cst_pred_ty<is_strictlypositive> m_StrictlyPositive() {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">503</td>
    <td class="codeLine">inline cst_pred_ty<is_strictlypositive> m_StrictlyPositive() {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class="codeLine">  return cst_pred_ty<is_strictlypositive>();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">504</td>
    <td class="codeLine">  return cst_pred_ty<is_strictlypositive>();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">505</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="codeLine">inline api_pred_ty<is_strictlypositive> m_StrictlyPositive(const APInt *&V) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">506</td>
    <td class="codeLine">inline api_pred_ty<is_strictlypositive> m_StrictlyPositive(const APInt *&V) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="codeLine">  return V;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">507</td>
    <td class="codeLine">  return V;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">508</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">509</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="codeLine">struct is_nonpositive {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">510</td>
    <td class="codeLine">struct is_nonpositive {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="codeLine">  bool isValue(const APInt &C) { return C.isNonPositive(); }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">511</td>
    <td class="codeLine">  bool isValue(const APInt &C) { return C.isNonPositive(); }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">512</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class="codeLine">/// Match an integer or vector of non-positive values.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">513</td>
    <td class="codeLine">/// Match an integer or vector of non-positive values.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="codeLine">/// For vectors, this includes constants with undefined elements.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">514</td>
    <td class="codeLine">/// For vectors, this includes constants with undefined elements.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="codeLine">inline cst_pred_ty<is_nonpositive> m_NonPositive() {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">515</td>
    <td class="codeLine">inline cst_pred_ty<is_nonpositive> m_NonPositive() {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="codeLine">  return cst_pred_ty<is_nonpositive>();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">516</td>
    <td class="codeLine">  return cst_pred_ty<is_nonpositive>();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">517</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="codeLine">inline api_pred_ty<is_nonpositive> m_NonPositive(const APInt *&V) { return V; }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">518</td>
    <td class="codeLine">inline api_pred_ty<is_nonpositive> m_NonPositive(const APInt *&V) { return V; }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">519</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class="codeLine">struct is_one {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">520</td>
    <td class="codeLine">struct is_one {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="codeLine">  bool isValue(const APInt &C) { return C.isOne(); }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">521</td>
    <td class="codeLine">  bool isValue(const APInt &C) { return C.isOne(); }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">522</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="codeLine">/// Match an integer 1 or a vector with all elements equal to 1.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">523</td>
    <td class="codeLine">/// Match an integer 1 or a vector with all elements equal to 1.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="codeLine">/// For vectors, this includes constants with undefined elements.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">524</td>
    <td class="codeLine">/// For vectors, this includes constants with undefined elements.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="codeLine">inline cst_pred_ty<is_one> m_One() { return cst_pred_ty<is_one>(); }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">525</td>
    <td class="codeLine">inline cst_pred_ty<is_one> m_One() { return cst_pred_ty<is_one>(); }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">526</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="codeLine">struct is_zero_int {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">527</td>
    <td class="codeLine">struct is_zero_int {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="codeLine">  bool isValue(const APInt &C) { return C.isZero(); }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">528</td>
    <td class="codeLine">  bool isValue(const APInt &C) { return C.isZero(); }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">529</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="codeLine">/// Match an integer 0 or a vector with all elements equal to 0.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">530</td>
    <td class="codeLine">/// Match an integer 0 or a vector with all elements equal to 0.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="codeLine">/// For vectors, this includes constants with undefined elements.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">531</td>
    <td class="codeLine">/// For vectors, this includes constants with undefined elements.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="codeLine">inline cst_pred_ty<is_zero_int> m_ZeroInt() {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">532</td>
    <td class="codeLine">inline cst_pred_ty<is_zero_int> m_ZeroInt() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class="codeLine">  return cst_pred_ty<is_zero_int>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">533</td>
    <td class="codeLine">  return cst_pred_ty<is_zero_int>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">534</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">535</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="codeLine">struct is_zero {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">536</td>
    <td class="codeLine">struct is_zero {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="codeLine">  template <typename ITy> bool match(ITy *V) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">537</td>
    <td class="codeLine">  template <typename ITy> bool match(ITy *V) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="codeLine">    auto *C = dyn_cast<Constant>(V);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">538</td>
    <td class="codeLine">    auto *C = dyn_cast<Constant>(V);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="codeLine">    // FIXME: this should be able to do something for scalable vectors</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">539</td>
    <td class="codeLine">    // FIXME: this should be able to do something for scalable vectors</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class="codeLine">    return C && (C->isNullValue() || cst_pred_ty<is_zero_int>().match(C));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">540</td>
    <td class="codeLine">    return C && (C->isNullValue() || cst_pred_ty<is_zero_int>().match(C));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">541</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">542</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="codeLine">/// Match any null constant or a vector with all elements equal to 0.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">543</td>
    <td class="codeLine">/// Match any null constant or a vector with all elements equal to 0.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="codeLine">/// For vectors, this includes constants with undefined elements.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">544</td>
    <td class="codeLine">/// For vectors, this includes constants with undefined elements.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="codeLine">inline is_zero m_Zero() { return is_zero(); }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">545</td>
    <td class="codeLine">inline is_zero m_Zero() { return is_zero(); }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">546</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="codeLine">struct is_power2 {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">547</td>
    <td class="codeLine">struct is_power2 {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="codeLine">  bool isValue(const APInt &C) { return C.isPowerOf2(); }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">548</td>
    <td class="codeLine">  bool isValue(const APInt &C) { return C.isPowerOf2(); }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">549</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="codeLine">/// Match an integer or vector power-of-2.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">550</td>
    <td class="codeLine">/// Match an integer or vector power-of-2.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="codeLine">/// For vectors, this includes constants with undefined elements.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">551</td>
    <td class="codeLine">/// For vectors, this includes constants with undefined elements.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="codeLine">inline cst_pred_ty<is_power2> m_Power2() { return cst_pred_ty<is_power2>(); }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">552</td>
    <td class="codeLine">inline cst_pred_ty<is_power2> m_Power2() { return cst_pred_ty<is_power2>(); }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="codeLine">inline api_pred_ty<is_power2> m_Power2(const APInt *&V) { return V; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">553</td>
    <td class="codeLine">inline api_pred_ty<is_power2> m_Power2(const APInt *&V) { return V; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">554</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="codeLine">struct is_negated_power2 {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">555</td>
    <td class="codeLine">struct is_negated_power2 {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="codeLine">  bool isValue(const APInt &C) { return C.isNegatedPowerOf2(); }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">556</td>
    <td class="codeLine">  bool isValue(const APInt &C) { return C.isNegatedPowerOf2(); }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">557</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="codeLine">/// Match a integer or vector negated power-of-2.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">558</td>
    <td class="codeLine">/// Match a integer or vector negated power-of-2.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="codeLine">/// For vectors, this includes constants with undefined elements.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">559</td>
    <td class="codeLine">/// For vectors, this includes constants with undefined elements.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="codeLine">inline cst_pred_ty<is_negated_power2> m_NegatedPower2() {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">560</td>
    <td class="codeLine">inline cst_pred_ty<is_negated_power2> m_NegatedPower2() {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="codeLine">  return cst_pred_ty<is_negated_power2>();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">561</td>
    <td class="codeLine">  return cst_pred_ty<is_negated_power2>();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">562</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="codeLine">inline api_pred_ty<is_negated_power2> m_NegatedPower2(const APInt *&V) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">563</td>
    <td class="codeLine">inline api_pred_ty<is_negated_power2> m_NegatedPower2(const APInt *&V) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="codeLine">  return V;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">564</td>
    <td class="codeLine">  return V;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">565</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">566</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="codeLine">struct is_power2_or_zero {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">567</td>
    <td class="codeLine">struct is_power2_or_zero {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="codeLine">  bool isValue(const APInt &C) { return !C || C.isPowerOf2(); }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">568</td>
    <td class="codeLine">  bool isValue(const APInt &C) { return !C || C.isPowerOf2(); }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">569</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="codeLine">/// Match an integer or vector of 0 or power-of-2 values.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">570</td>
    <td class="codeLine">/// Match an integer or vector of 0 or power-of-2 values.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="codeLine">/// For vectors, this includes constants with undefined elements.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">571</td>
    <td class="codeLine">/// For vectors, this includes constants with undefined elements.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="codeLine">inline cst_pred_ty<is_power2_or_zero> m_Power2OrZero() {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">572</td>
    <td class="codeLine">inline cst_pred_ty<is_power2_or_zero> m_Power2OrZero() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="codeLine">  return cst_pred_ty<is_power2_or_zero>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">573</td>
    <td class="codeLine">  return cst_pred_ty<is_power2_or_zero>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">574</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="codeLine">inline api_pred_ty<is_power2_or_zero> m_Power2OrZero(const APInt *&V) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">575</td>
    <td class="codeLine">inline api_pred_ty<is_power2_or_zero> m_Power2OrZero(const APInt *&V) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="codeLine">  return V;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">576</td>
    <td class="codeLine">  return V;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">577</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">578</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class="codeLine">struct is_sign_mask {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">579</td>
    <td class="codeLine">struct is_sign_mask {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="codeLine">  bool isValue(const APInt &C) { return C.isSignMask(); }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">580</td>
    <td class="codeLine">  bool isValue(const APInt &C) { return C.isSignMask(); }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">581</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class="codeLine">/// Match an integer or vector with only the sign bit(s) set.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">582</td>
    <td class="codeLine">/// Match an integer or vector with only the sign bit(s) set.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="codeLine">/// For vectors, this includes constants with undefined elements.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">583</td>
    <td class="codeLine">/// For vectors, this includes constants with undefined elements.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="codeLine">inline cst_pred_ty<is_sign_mask> m_SignMask() {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">584</td>
    <td class="codeLine">inline cst_pred_ty<is_sign_mask> m_SignMask() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="codeLine">  return cst_pred_ty<is_sign_mask>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">585</td>
    <td class="codeLine">  return cst_pred_ty<is_sign_mask>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">586</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">587</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="codeLine">struct is_lowbit_mask {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">588</td>
    <td class="codeLine">struct is_lowbit_mask {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="codeLine">  bool isValue(const APInt &C) { return C.isMask(); }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">589</td>
    <td class="codeLine">  bool isValue(const APInt &C) { return C.isMask(); }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">590</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="codeLine">/// Match an integer or vector with only the low bit(s) set.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">591</td>
    <td class="codeLine">/// Match an integer or vector with only the low bit(s) set.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="codeLine">/// For vectors, this includes constants with undefined elements.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">592</td>
    <td class="codeLine">/// For vectors, this includes constants with undefined elements.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="codeLine">inline cst_pred_ty<is_lowbit_mask> m_LowBitMask() {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">593</td>
    <td class="codeLine">inline cst_pred_ty<is_lowbit_mask> m_LowBitMask() {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="codeLine">  return cst_pred_ty<is_lowbit_mask>();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">594</td>
    <td class="codeLine">  return cst_pred_ty<is_lowbit_mask>();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">595</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="codeLine">inline api_pred_ty<is_lowbit_mask> m_LowBitMask(const APInt *&V) { return V; }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">596</td>
    <td class="codeLine">inline api_pred_ty<is_lowbit_mask> m_LowBitMask(const APInt *&V) { return V; }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">597</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="codeLine">struct icmp_pred_with_threshold {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">598</td>
    <td class="codeLine">struct icmp_pred_with_threshold {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="codeLine">  ICmpInst::Predicate Pred;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">599</td>
    <td class="codeLine">  ICmpInst::Predicate Pred;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="codeLine">  const APInt *Thr;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">600</td>
    <td class="codeLine">  const APInt *Thr;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="codeLine">  bool isValue(const APInt &C) { return ICmpInst::compare(C, *Thr, Pred); }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">601</td>
    <td class="codeLine">  bool isValue(const APInt &C) { return ICmpInst::compare(C, *Thr, Pred); }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">602</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="codeLine">/// Match an integer or vector with every element comparing 'pred' (eg/ne/...)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">603</td>
    <td class="codeLine">/// Match an integer or vector with every element comparing 'pred' (eg/ne/...)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="codeLine">/// to Threshold. For vectors, this includes constants with undefined elements.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">604</td>
    <td class="codeLine">/// to Threshold. For vectors, this includes constants with undefined elements.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="codeLine">inline cst_pred_ty<icmp_pred_with_threshold></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">605</td>
    <td class="codeLine">inline cst_pred_ty<icmp_pred_with_threshold></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="codeLine">m_SpecificInt_ICMP(ICmpInst::Predicate Predicate, const APInt &Threshold) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">606</td>
    <td class="codeLine">m_SpecificInt_ICMP(ICmpInst::Predicate Predicate, const APInt &Threshold) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="codeLine">  cst_pred_ty<icmp_pred_with_threshold> P;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">607</td>
    <td class="codeLine">  cst_pred_ty<icmp_pred_with_threshold> P;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="codeLine">  P.Pred = Predicate;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">608</td>
    <td class="codeLine">  P.Pred = Predicate;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="codeLine">  P.Thr = &Threshold;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">609</td>
    <td class="codeLine">  P.Thr = &Threshold;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="codeLine">  return P;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">610</td>
    <td class="codeLine">  return P;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">611</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">612</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class="codeLine">struct is_nan {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">613</td>
    <td class="codeLine">struct is_nan {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class="codeLine">  bool isValue(const APFloat &C) { return C.isNaN(); }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">614</td>
    <td class="codeLine">  bool isValue(const APFloat &C) { return C.isNaN(); }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">615</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="codeLine">/// Match an arbitrary NaN constant. This includes quiet and signalling nans.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">616</td>
    <td class="codeLine">/// Match an arbitrary NaN constant. This includes quiet and signalling nans.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="codeLine">/// For vectors, this includes constants with undefined elements.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">617</td>
    <td class="codeLine">/// For vectors, this includes constants with undefined elements.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class="codeLine">inline cstfp_pred_ty<is_nan> m_NaN() { return cstfp_pred_ty<is_nan>(); }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">618</td>
    <td class="codeLine">inline cstfp_pred_ty<is_nan> m_NaN() { return cstfp_pred_ty<is_nan>(); }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">619</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="codeLine">struct is_nonnan {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">620</td>
    <td class="codeLine">struct is_nonnan {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class="codeLine">  bool isValue(const APFloat &C) { return !C.isNaN(); }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">621</td>
    <td class="codeLine">  bool isValue(const APFloat &C) { return !C.isNaN(); }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">622</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="codeLine">/// Match a non-NaN FP constant.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">623</td>
    <td class="codeLine">/// Match a non-NaN FP constant.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="codeLine">/// For vectors, this includes constants with undefined elements.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">624</td>
    <td class="codeLine">/// For vectors, this includes constants with undefined elements.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="codeLine">inline cstfp_pred_ty<is_nonnan> m_NonNaN() {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">625</td>
    <td class="codeLine">inline cstfp_pred_ty<is_nonnan> m_NonNaN() {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="codeLine">  return cstfp_pred_ty<is_nonnan>();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">626</td>
    <td class="codeLine">  return cstfp_pred_ty<is_nonnan>();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">627</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">628</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="codeLine">struct is_inf {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">629</td>
    <td class="codeLine">struct is_inf {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class="codeLine">  bool isValue(const APFloat &C) { return C.isInfinity(); }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">630</td>
    <td class="codeLine">  bool isValue(const APFloat &C) { return C.isInfinity(); }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">631</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="codeLine">/// Match a positive or negative infinity FP constant.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">632</td>
    <td class="codeLine">/// Match a positive or negative infinity FP constant.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="codeLine">/// For vectors, this includes constants with undefined elements.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">633</td>
    <td class="codeLine">/// For vectors, this includes constants with undefined elements.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="codeLine">inline cstfp_pred_ty<is_inf> m_Inf() { return cstfp_pred_ty<is_inf>(); }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">634</td>
    <td class="codeLine">inline cstfp_pred_ty<is_inf> m_Inf() { return cstfp_pred_ty<is_inf>(); }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">635</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="codeLine">struct is_noninf {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">636</td>
    <td class="codeLine">struct is_noninf {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="codeLine">  bool isValue(const APFloat &C) { return !C.isInfinity(); }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">637</td>
    <td class="codeLine">  bool isValue(const APFloat &C) { return !C.isInfinity(); }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">638</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="codeLine">/// Match a non-infinity FP constant, i.e. finite or NaN.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">639</td>
    <td class="codeLine">/// Match a non-infinity FP constant, i.e. finite or NaN.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="codeLine">/// For vectors, this includes constants with undefined elements.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">640</td>
    <td class="codeLine">/// For vectors, this includes constants with undefined elements.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="codeLine">inline cstfp_pred_ty<is_noninf> m_NonInf() {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">641</td>
    <td class="codeLine">inline cstfp_pred_ty<is_noninf> m_NonInf() {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="codeLine">  return cstfp_pred_ty<is_noninf>();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">642</td>
    <td class="codeLine">  return cstfp_pred_ty<is_noninf>();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">643</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">644</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="codeLine">struct is_finite {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">645</td>
    <td class="codeLine">struct is_finite {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="codeLine">  bool isValue(const APFloat &C) { return C.isFinite(); }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">646</td>
    <td class="codeLine">  bool isValue(const APFloat &C) { return C.isFinite(); }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">647</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="codeLine">/// Match a finite FP constant, i.e. not infinity or NaN.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">648</td>
    <td class="codeLine">/// Match a finite FP constant, i.e. not infinity or NaN.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="codeLine">/// For vectors, this includes constants with undefined elements.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">649</td>
    <td class="codeLine">/// For vectors, this includes constants with undefined elements.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="codeLine">inline cstfp_pred_ty<is_finite> m_Finite() {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">650</td>
    <td class="codeLine">inline cstfp_pred_ty<is_finite> m_Finite() {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="codeLine">  return cstfp_pred_ty<is_finite>();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">651</td>
    <td class="codeLine">  return cstfp_pred_ty<is_finite>();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">652</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="codeLine">inline apf_pred_ty<is_finite> m_Finite(const APFloat *&V) { return V; }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">653</td>
    <td class="codeLine">inline apf_pred_ty<is_finite> m_Finite(const APFloat *&V) { return V; }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">654</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="codeLine">struct is_finitenonzero {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">655</td>
    <td class="codeLine">struct is_finitenonzero {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="codeLine">  bool isValue(const APFloat &C) { return C.isFiniteNonZero(); }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">656</td>
    <td class="codeLine">  bool isValue(const APFloat &C) { return C.isFiniteNonZero(); }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">657</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="codeLine">/// Match a finite non-zero FP constant.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">658</td>
    <td class="codeLine">/// Match a finite non-zero FP constant.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="codeLine">/// For vectors, this includes constants with undefined elements.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">659</td>
    <td class="codeLine">/// For vectors, this includes constants with undefined elements.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="codeLine">inline cstfp_pred_ty<is_finitenonzero> m_FiniteNonZero() {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">660</td>
    <td class="codeLine">inline cstfp_pred_ty<is_finitenonzero> m_FiniteNonZero() {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="codeLine">  return cstfp_pred_ty<is_finitenonzero>();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">661</td>
    <td class="codeLine">  return cstfp_pred_ty<is_finitenonzero>();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">662</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="codeLine">inline apf_pred_ty<is_finitenonzero> m_FiniteNonZero(const APFloat *&V) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">663</td>
    <td class="codeLine">inline apf_pred_ty<is_finitenonzero> m_FiniteNonZero(const APFloat *&V) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="codeLine">  return V;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">664</td>
    <td class="codeLine">  return V;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">665</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">666</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="codeLine">struct is_any_zero_fp {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">667</td>
    <td class="codeLine">struct is_any_zero_fp {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="codeLine">  bool isValue(const APFloat &C) { return C.isZero(); }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">668</td>
    <td class="codeLine">  bool isValue(const APFloat &C) { return C.isZero(); }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">669</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="codeLine">/// Match a floating-point negative zero or positive zero.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">670</td>
    <td class="codeLine">/// Match a floating-point negative zero or positive zero.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="codeLine">/// For vectors, this includes constants with undefined elements.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">671</td>
    <td class="codeLine">/// For vectors, this includes constants with undefined elements.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class="codeLine">inline cstfp_pred_ty<is_any_zero_fp> m_AnyZeroFP() {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">672</td>
    <td class="codeLine">inline cstfp_pred_ty<is_any_zero_fp> m_AnyZeroFP() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="codeLine">  return cstfp_pred_ty<is_any_zero_fp>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">673</td>
    <td class="codeLine">  return cstfp_pred_ty<is_any_zero_fp>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">674</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">675</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class="codeLine">struct is_pos_zero_fp {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">676</td>
    <td class="codeLine">struct is_pos_zero_fp {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="codeLine">  bool isValue(const APFloat &C) { return C.isPosZero(); }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">677</td>
    <td class="codeLine">  bool isValue(const APFloat &C) { return C.isPosZero(); }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">678</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="codeLine">/// Match a floating-point positive zero.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">679</td>
    <td class="codeLine">/// Match a floating-point positive zero.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="codeLine">/// For vectors, this includes constants with undefined elements.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">680</td>
    <td class="codeLine">/// For vectors, this includes constants with undefined elements.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="codeLine">inline cstfp_pred_ty<is_pos_zero_fp> m_PosZeroFP() {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">681</td>
    <td class="codeLine">inline cstfp_pred_ty<is_pos_zero_fp> m_PosZeroFP() {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="codeLine">  return cstfp_pred_ty<is_pos_zero_fp>();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">682</td>
    <td class="codeLine">  return cstfp_pred_ty<is_pos_zero_fp>();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">683</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">684</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class="codeLine">struct is_neg_zero_fp {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">685</td>
    <td class="codeLine">struct is_neg_zero_fp {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="codeLine">  bool isValue(const APFloat &C) { return C.isNegZero(); }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">686</td>
    <td class="codeLine">  bool isValue(const APFloat &C) { return C.isNegZero(); }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">687</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class="codeLine">/// Match a floating-point negative zero.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">688</td>
    <td class="codeLine">/// Match a floating-point negative zero.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class="codeLine">/// For vectors, this includes constants with undefined elements.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">689</td>
    <td class="codeLine">/// For vectors, this includes constants with undefined elements.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class="codeLine">inline cstfp_pred_ty<is_neg_zero_fp> m_NegZeroFP() {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">690</td>
    <td class="codeLine">inline cstfp_pred_ty<is_neg_zero_fp> m_NegZeroFP() {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class="codeLine">  return cstfp_pred_ty<is_neg_zero_fp>();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">691</td>
    <td class="codeLine">  return cstfp_pred_ty<is_neg_zero_fp>();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">692</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">693</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class="codeLine">struct is_non_zero_fp {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">694</td>
    <td class="codeLine">struct is_non_zero_fp {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="codeLine">  bool isValue(const APFloat &C) { return C.isNonZero(); }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">695</td>
    <td class="codeLine">  bool isValue(const APFloat &C) { return C.isNonZero(); }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">696</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class="codeLine">/// Match a floating-point non-zero.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">697</td>
    <td class="codeLine">/// Match a floating-point non-zero.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class="codeLine">/// For vectors, this includes constants with undefined elements.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">698</td>
    <td class="codeLine">/// For vectors, this includes constants with undefined elements.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class="codeLine">inline cstfp_pred_ty<is_non_zero_fp> m_NonZeroFP() {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">699</td>
    <td class="codeLine">inline cstfp_pred_ty<is_non_zero_fp> m_NonZeroFP() {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="codeLine">  return cstfp_pred_ty<is_non_zero_fp>();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">700</td>
    <td class="codeLine">  return cstfp_pred_ty<is_non_zero_fp>();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">701</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">702</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="codeLine">///////////////////////////////////////////////////////////////////////////////</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">703</td>
    <td class="codeLine">///////////////////////////////////////////////////////////////////////////////</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">704</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="codeLine">template <typename Class> struct bind_ty {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">705</td>
    <td class="codeLine">template <typename Class> struct bind_ty {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class="codeLine">  Class *&VR;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">706</td>
    <td class="codeLine">  Class *&VR;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">707</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class="codeLine coveredLine">  bind_ty(Class *&V) : VR(V) {}</td>
    <td class="lineNumber">4</td>
    <td class="lineNumber">708</td>
    <td class="codeLine coveredLine">  bind_ty(Class *&V) : VR(V) {}</td>
    <td class="lineNumber">4</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">709</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="codeLine">  template <typename ITy> bool match(ITy *V) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">710</td>
    <td class="codeLine">  template <typename ITy> bool match(ITy *V) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class="codeLine">    if (auto *CV = dyn_cast<Class>(V)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">711</td>
    <td class="codeLine">    if (auto *CV = dyn_cast<Class>(V)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class="codeLine">      VR = CV;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">712</td>
    <td class="codeLine">      VR = CV;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">713</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">714</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">715</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">716</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">717</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">718</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class="codeLine">/// Match a value, capturing it if we match.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">719</td>
    <td class="codeLine">/// Match a value, capturing it if we match.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class="codeLine">inline bind_ty<Value> m_Value(Value *&V) { return V; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">720</td>
    <td class="codeLine">inline bind_ty<Value> m_Value(Value *&V) { return V; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="codeLine coveredLine">inline bind_ty<const Value> m_Value(const Value *&V) { return V; }</td>
    <td class="lineNumber">4</td>
    <td class="lineNumber">721</td>
    <td class="codeLine coveredLine">inline bind_ty<const Value> m_Value(const Value *&V) { return V; }</td>
    <td class="lineNumber">4</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">722</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="codeLine">/// Match an instruction, capturing it if we match.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">723</td>
    <td class="codeLine">/// Match an instruction, capturing it if we match.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class="codeLine">inline bind_ty<Instruction> m_Instruction(Instruction *&I) { return I; }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">724</td>
    <td class="codeLine">inline bind_ty<Instruction> m_Instruction(Instruction *&I) { return I; }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="codeLine">/// Match a unary operator, capturing it if we match.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">725</td>
    <td class="codeLine">/// Match a unary operator, capturing it if we match.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class="codeLine">inline bind_ty<UnaryOperator> m_UnOp(UnaryOperator *&I) { return I; }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">726</td>
    <td class="codeLine">inline bind_ty<UnaryOperator> m_UnOp(UnaryOperator *&I) { return I; }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class="codeLine">/// Match a binary operator, capturing it if we match.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">727</td>
    <td class="codeLine">/// Match a binary operator, capturing it if we match.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class="codeLine">inline bind_ty<BinaryOperator> m_BinOp(BinaryOperator *&I) { return I; }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">728</td>
    <td class="codeLine">inline bind_ty<BinaryOperator> m_BinOp(BinaryOperator *&I) { return I; }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="codeLine">/// Match a with overflow intrinsic, capturing it if we match.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">729</td>
    <td class="codeLine">/// Match a with overflow intrinsic, capturing it if we match.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class="codeLine">inline bind_ty<WithOverflowInst> m_WithOverflowInst(WithOverflowInst *&I) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">730</td>
    <td class="codeLine">inline bind_ty<WithOverflowInst> m_WithOverflowInst(WithOverflowInst *&I) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class="codeLine">  return I;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">731</td>
    <td class="codeLine">  return I;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">732</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="codeLine">inline bind_ty<const WithOverflowInst></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">733</td>
    <td class="codeLine">inline bind_ty<const WithOverflowInst></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="codeLine">m_WithOverflowInst(const WithOverflowInst *&I) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">734</td>
    <td class="codeLine">m_WithOverflowInst(const WithOverflowInst *&I) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class="codeLine">  return I;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">735</td>
    <td class="codeLine">  return I;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">736</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">737</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class="codeLine">/// Match a Constant, capturing the value if we match.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">738</td>
    <td class="codeLine">/// Match a Constant, capturing the value if we match.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class="codeLine">inline bind_ty<Constant> m_Constant(Constant *&C) { return C; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">739</td>
    <td class="codeLine">inline bind_ty<Constant> m_Constant(Constant *&C) { return C; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">740</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class="codeLine">/// Match a ConstantInt, capturing the value if we match.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">741</td>
    <td class="codeLine">/// Match a ConstantInt, capturing the value if we match.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class="codeLine">inline bind_ty<ConstantInt> m_ConstantInt(ConstantInt *&CI) { return CI; }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">742</td>
    <td class="codeLine">inline bind_ty<ConstantInt> m_ConstantInt(ConstantInt *&CI) { return CI; }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">743</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="codeLine">/// Match a ConstantFP, capturing the value if we match.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">744</td>
    <td class="codeLine">/// Match a ConstantFP, capturing the value if we match.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="codeLine">inline bind_ty<ConstantFP> m_ConstantFP(ConstantFP *&C) { return C; }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">745</td>
    <td class="codeLine">inline bind_ty<ConstantFP> m_ConstantFP(ConstantFP *&C) { return C; }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">746</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class="codeLine">/// Match a ConstantExpr, capturing the value if we match.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">747</td>
    <td class="codeLine">/// Match a ConstantExpr, capturing the value if we match.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="codeLine">inline bind_ty<ConstantExpr> m_ConstantExpr(ConstantExpr *&C) { return C; }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">748</td>
    <td class="codeLine">inline bind_ty<ConstantExpr> m_ConstantExpr(ConstantExpr *&C) { return C; }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">749</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="codeLine">/// Match a basic block value, capturing it if we match.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">750</td>
    <td class="codeLine">/// Match a basic block value, capturing it if we match.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class="codeLine">inline bind_ty<BasicBlock> m_BasicBlock(BasicBlock *&V) { return V; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">751</td>
    <td class="codeLine">inline bind_ty<BasicBlock> m_BasicBlock(BasicBlock *&V) { return V; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class="codeLine">inline bind_ty<const BasicBlock> m_BasicBlock(const BasicBlock *&V) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">752</td>
    <td class="codeLine">inline bind_ty<const BasicBlock> m_BasicBlock(const BasicBlock *&V) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class="codeLine">  return V;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">753</td>
    <td class="codeLine">  return V;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">754</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">755</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="codeLine">/// Match an arbitrary immediate Constant and ignore it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">756</td>
    <td class="codeLine">/// Match an arbitrary immediate Constant and ignore it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="codeLine">inline match_combine_and<class_match<Constant>,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">757</td>
    <td class="codeLine">inline match_combine_and<class_match<Constant>,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="codeLine">                         match_unless<constantexpr_match>></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">758</td>
    <td class="codeLine">                         match_unless<constantexpr_match>></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="codeLine">m_ImmConstant() {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">759</td>
    <td class="codeLine">m_ImmConstant() {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class="codeLine">  return m_CombineAnd(m_Constant(), m_Unless(m_ConstantExpr()));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">760</td>
    <td class="codeLine">  return m_CombineAnd(m_Constant(), m_Unless(m_ConstantExpr()));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">761</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">762</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="codeLine">/// Match an immediate Constant, capturing the value if we match.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">763</td>
    <td class="codeLine">/// Match an immediate Constant, capturing the value if we match.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class="codeLine">inline match_combine_and<bind_ty<Constant>,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">764</td>
    <td class="codeLine">inline match_combine_and<bind_ty<Constant>,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class="codeLine">                         match_unless<constantexpr_match>></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">765</td>
    <td class="codeLine">                         match_unless<constantexpr_match>></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class="codeLine">m_ImmConstant(Constant *&C) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">766</td>
    <td class="codeLine">m_ImmConstant(Constant *&C) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="codeLine">  return m_CombineAnd(m_Constant(C), m_Unless(m_ConstantExpr()));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">767</td>
    <td class="codeLine">  return m_CombineAnd(m_Constant(C), m_Unless(m_ConstantExpr()));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">768</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">769</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="codeLine">/// Match a specified Value*.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">770</td>
    <td class="codeLine">/// Match a specified Value*.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class="codeLine">struct specificval_ty {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">771</td>
    <td class="codeLine">struct specificval_ty {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="codeLine">  const Value *Val;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">772</td>
    <td class="codeLine">  const Value *Val;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">773</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="codeLine">  specificval_ty(const Value *V) : Val(V) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">774</td>
    <td class="codeLine">  specificval_ty(const Value *V) : Val(V) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">775</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class="codeLine">  template <typename ITy> bool match(ITy *V) { return V == Val; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">776</td>
    <td class="codeLine">  template <typename ITy> bool match(ITy *V) { return V == Val; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">777</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">778</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="codeLine">/// Match if we have a specific specified value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">779</td>
    <td class="codeLine">/// Match if we have a specific specified value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class="codeLine">inline specificval_ty m_Specific(const Value *V) { return V; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">780</td>
    <td class="codeLine">inline specificval_ty m_Specific(const Value *V) { return V; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">781</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="codeLine">/// Stores a reference to the Value *, not the Value * itself,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">782</td>
    <td class="codeLine">/// Stores a reference to the Value *, not the Value * itself,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="codeLine">/// thus can be used in commutative matchers.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">783</td>
    <td class="codeLine">/// thus can be used in commutative matchers.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class="codeLine">template <typename Class> struct deferredval_ty {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">784</td>
    <td class="codeLine">template <typename Class> struct deferredval_ty {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class="codeLine">  Class *const &Val;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">785</td>
    <td class="codeLine">  Class *const &Val;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">786</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class="codeLine">  deferredval_ty(Class *const &V) : Val(V) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">787</td>
    <td class="codeLine">  deferredval_ty(Class *const &V) : Val(V) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">788</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class="codeLine">  template <typename ITy> bool match(ITy *const V) { return V == Val; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">789</td>
    <td class="codeLine">  template <typename ITy> bool match(ITy *const V) { return V == Val; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">790</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">791</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class="codeLine">/// Like m_Specific(), but works if the specific value to match is determined</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">792</td>
    <td class="codeLine">/// Like m_Specific(), but works if the specific value to match is determined</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="codeLine">/// as part of the same match() expression. For example:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">793</td>
    <td class="codeLine">/// as part of the same match() expression. For example:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class="codeLine">/// m_Add(m_Value(X), m_Specific(X)) is incorrect, because m_Specific() will</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">794</td>
    <td class="codeLine">/// m_Add(m_Value(X), m_Specific(X)) is incorrect, because m_Specific() will</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="codeLine">/// bind X before the pattern match starts.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">795</td>
    <td class="codeLine">/// bind X before the pattern match starts.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class="codeLine">/// m_Add(m_Value(X), m_Deferred(X)) is correct, and will check against</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">796</td>
    <td class="codeLine">/// m_Add(m_Value(X), m_Deferred(X)) is correct, and will check against</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class="codeLine">/// whichever value m_Value(X) populated.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">797</td>
    <td class="codeLine">/// whichever value m_Value(X) populated.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class="codeLine">inline deferredval_ty<Value> m_Deferred(Value *const &V) { return V; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">798</td>
    <td class="codeLine">inline deferredval_ty<Value> m_Deferred(Value *const &V) { return V; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class="codeLine">inline deferredval_ty<const Value> m_Deferred(const Value *const &V) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">799</td>
    <td class="codeLine">inline deferredval_ty<const Value> m_Deferred(const Value *const &V) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class="codeLine">  return V;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">800</td>
    <td class="codeLine">  return V;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">801</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">802</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class="codeLine">/// Match a specified floating point value or vector of all elements of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">803</td>
    <td class="codeLine">/// Match a specified floating point value or vector of all elements of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class="codeLine">/// that value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">804</td>
    <td class="codeLine">/// that value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class="codeLine">struct specific_fpval {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">805</td>
    <td class="codeLine">struct specific_fpval {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class="codeLine">  double Val;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">806</td>
    <td class="codeLine">  double Val;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">807</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class="codeLine">  specific_fpval(double V) : Val(V) {}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">808</td>
    <td class="codeLine">  specific_fpval(double V) : Val(V) {}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">809</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class="codeLine">  template <typename ITy> bool match(ITy *V) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">810</td>
    <td class="codeLine">  template <typename ITy> bool match(ITy *V) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class="codeLine">    if (const auto *CFP = dyn_cast<ConstantFP>(V))</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">811</td>
    <td class="codeLine">    if (const auto *CFP = dyn_cast<ConstantFP>(V))</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class="codeLine">      return CFP->isExactlyValue(Val);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">812</td>
    <td class="codeLine">      return CFP->isExactlyValue(Val);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class="codeLine">    if (V->getType()->isVectorTy())</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">813</td>
    <td class="codeLine">    if (V->getType()->isVectorTy())</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class="codeLine">      if (const auto *C = dyn_cast<Constant>(V))</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">814</td>
    <td class="codeLine">      if (const auto *C = dyn_cast<Constant>(V))</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class="codeLine">        if (auto *CFP = dyn_cast_or_null<ConstantFP>(C->getSplatValue()))</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">815</td>
    <td class="codeLine">        if (auto *CFP = dyn_cast_or_null<ConstantFP>(C->getSplatValue()))</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class="codeLine">          return CFP->isExactlyValue(Val);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">816</td>
    <td class="codeLine">          return CFP->isExactlyValue(Val);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">817</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">818</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">819</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">820</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class="codeLine">/// Match a specific floating point value or vector with all elements</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">821</td>
    <td class="codeLine">/// Match a specific floating point value or vector with all elements</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class="codeLine">/// equal to the value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">822</td>
    <td class="codeLine">/// equal to the value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class="codeLine">inline specific_fpval m_SpecificFP(double V) { return specific_fpval(V); }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">823</td>
    <td class="codeLine">inline specific_fpval m_SpecificFP(double V) { return specific_fpval(V); }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">824</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class="codeLine">/// Match a float 1.0 or vector with all elements equal to 1.0.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">825</td>
    <td class="codeLine">/// Match a float 1.0 or vector with all elements equal to 1.0.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class="codeLine">inline specific_fpval m_FPOne() { return m_SpecificFP(1.0); }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">826</td>
    <td class="codeLine">inline specific_fpval m_FPOne() { return m_SpecificFP(1.0); }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">827</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class="codeLine">struct bind_const_intval_ty {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">828</td>
    <td class="codeLine">struct bind_const_intval_ty {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class="codeLine">  uint64_t &VR;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">829</td>
    <td class="codeLine">  uint64_t &VR;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">830</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class="codeLine">  bind_const_intval_ty(uint64_t &V) : VR(V) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">831</td>
    <td class="codeLine">  bind_const_intval_ty(uint64_t &V) : VR(V) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">832</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class="codeLine">  template <typename ITy> bool match(ITy *V) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">833</td>
    <td class="codeLine">  template <typename ITy> bool match(ITy *V) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class="codeLine">    if (const auto *CV = dyn_cast<ConstantInt>(V))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">834</td>
    <td class="codeLine">    if (const auto *CV = dyn_cast<ConstantInt>(V))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class="codeLine">      if (CV->getValue().ule(UINT64_MAX)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">835</td>
    <td class="codeLine">      if (CV->getValue().ule(UINT64_MAX)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class="codeLine">        VR = CV->getZExtValue();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">836</td>
    <td class="codeLine">        VR = CV->getZExtValue();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class="codeLine">        return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">837</td>
    <td class="codeLine">        return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">838</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">839</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">840</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">841</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">842</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class="codeLine">/// Match a specified integer value or vector of all elements of that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">843</td>
    <td class="codeLine">/// Match a specified integer value or vector of all elements of that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class="codeLine">/// value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">844</td>
    <td class="codeLine">/// value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class="codeLine">template <bool AllowUndefs> struct specific_intval {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">845</td>
    <td class="codeLine">template <bool AllowUndefs> struct specific_intval {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class="codeLine">  APInt Val;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">846</td>
    <td class="codeLine">  APInt Val;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">847</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class="codeLine">  specific_intval(APInt V) : Val(std::move(V)) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">848</td>
    <td class="codeLine">  specific_intval(APInt V) : Val(std::move(V)) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">849</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class="codeLine">  template <typename ITy> bool match(ITy *V) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">850</td>
    <td class="codeLine">  template <typename ITy> bool match(ITy *V) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class="codeLine">    const auto *CI = dyn_cast<ConstantInt>(V);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">851</td>
    <td class="codeLine">    const auto *CI = dyn_cast<ConstantInt>(V);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class="codeLine">    if (!CI && V->getType()->isVectorTy())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">852</td>
    <td class="codeLine">    if (!CI && V->getType()->isVectorTy())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class="codeLine">      if (const auto *C = dyn_cast<Constant>(V))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">853</td>
    <td class="codeLine">      if (const auto *C = dyn_cast<Constant>(V))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class="codeLine">        CI = dyn_cast_or_null<ConstantInt>(C->getSplatValue(AllowUndefs));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">854</td>
    <td class="codeLine">        CI = dyn_cast_or_null<ConstantInt>(C->getSplatValue(AllowUndefs));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">855</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class="codeLine">    return CI && APInt::isSameValue(CI->getValue(), Val);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">856</td>
    <td class="codeLine">    return CI && APInt::isSameValue(CI->getValue(), Val);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">857</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">858</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">859</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class="codeLine">/// Match a specific integer value or vector with all elements equal to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">860</td>
    <td class="codeLine">/// Match a specific integer value or vector with all elements equal to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class="codeLine">/// the value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">861</td>
    <td class="codeLine">/// the value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class="codeLine">inline specific_intval<false> m_SpecificInt(APInt V) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">862</td>
    <td class="codeLine">inline specific_intval<false> m_SpecificInt(APInt V) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class="codeLine">  return specific_intval<false>(std::move(V));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">863</td>
    <td class="codeLine">  return specific_intval<false>(std::move(V));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">864</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">865</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class="codeLine">inline specific_intval<false> m_SpecificInt(uint64_t V) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">866</td>
    <td class="codeLine">inline specific_intval<false> m_SpecificInt(uint64_t V) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class="codeLine">  return m_SpecificInt(APInt(64, V));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">867</td>
    <td class="codeLine">  return m_SpecificInt(APInt(64, V));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">868</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">869</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="codeLine">inline specific_intval<true> m_SpecificIntAllowUndef(APInt V) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">870</td>
    <td class="codeLine">inline specific_intval<true> m_SpecificIntAllowUndef(APInt V) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class="codeLine">  return specific_intval<true>(std::move(V));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">871</td>
    <td class="codeLine">  return specific_intval<true>(std::move(V));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">872</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">872</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">873</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">873</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">874</td>
    <td class="codeLine">inline specific_intval<true> m_SpecificIntAllowUndef(uint64_t V) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">874</td>
    <td class="codeLine">inline specific_intval<true> m_SpecificIntAllowUndef(uint64_t V) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">875</td>
    <td class="codeLine">  return m_SpecificIntAllowUndef(APInt(64, V));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">875</td>
    <td class="codeLine">  return m_SpecificIntAllowUndef(APInt(64, V));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">876</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">876</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">877</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">877</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">878</td>
    <td class="codeLine">/// Match a ConstantInt and bind to its value.  This does not match</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">878</td>
    <td class="codeLine">/// Match a ConstantInt and bind to its value.  This does not match</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">879</td>
    <td class="codeLine">/// ConstantInts wider than 64-bits.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">879</td>
    <td class="codeLine">/// ConstantInts wider than 64-bits.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">880</td>
    <td class="codeLine">inline bind_const_intval_ty m_ConstantInt(uint64_t &V) { return V; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">880</td>
    <td class="codeLine">inline bind_const_intval_ty m_ConstantInt(uint64_t &V) { return V; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">881</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">881</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">882</td>
    <td class="codeLine">/// Match a specified basic block value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">882</td>
    <td class="codeLine">/// Match a specified basic block value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">883</td>
    <td class="codeLine">struct specific_bbval {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">883</td>
    <td class="codeLine">struct specific_bbval {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">884</td>
    <td class="codeLine">  BasicBlock *Val;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">884</td>
    <td class="codeLine">  BasicBlock *Val;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">885</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">885</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">886</td>
    <td class="codeLine">  specific_bbval(BasicBlock *Val) : Val(Val) {}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">886</td>
    <td class="codeLine">  specific_bbval(BasicBlock *Val) : Val(Val) {}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">887</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">887</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">888</td>
    <td class="codeLine">  template <typename ITy> bool match(ITy *V) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">888</td>
    <td class="codeLine">  template <typename ITy> bool match(ITy *V) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">889</td>
    <td class="codeLine">    const auto *BB = dyn_cast<BasicBlock>(V);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">889</td>
    <td class="codeLine">    const auto *BB = dyn_cast<BasicBlock>(V);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">890</td>
    <td class="codeLine">    return BB && BB == Val;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">890</td>
    <td class="codeLine">    return BB && BB == Val;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">891</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">891</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">892</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">892</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">893</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">893</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">894</td>
    <td class="codeLine">/// Match a specific basic block value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">894</td>
    <td class="codeLine">/// Match a specific basic block value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">895</td>
    <td class="codeLine">inline specific_bbval m_SpecificBB(BasicBlock *BB) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">895</td>
    <td class="codeLine">inline specific_bbval m_SpecificBB(BasicBlock *BB) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">896</td>
    <td class="codeLine">  return specific_bbval(BB);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">896</td>
    <td class="codeLine">  return specific_bbval(BB);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">897</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">897</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">898</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">898</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">899</td>
    <td class="codeLine">/// A commutative-friendly version of m_Specific().</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">899</td>
    <td class="codeLine">/// A commutative-friendly version of m_Specific().</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">900</td>
    <td class="codeLine">inline deferredval_ty<BasicBlock> m_Deferred(BasicBlock *const &BB) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">900</td>
    <td class="codeLine">inline deferredval_ty<BasicBlock> m_Deferred(BasicBlock *const &BB) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">901</td>
    <td class="codeLine">  return BB;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">901</td>
    <td class="codeLine">  return BB;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">902</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">902</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">903</td>
    <td class="codeLine">inline deferredval_ty<const BasicBlock></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">903</td>
    <td class="codeLine">inline deferredval_ty<const BasicBlock></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">904</td>
    <td class="codeLine">m_Deferred(const BasicBlock *const &BB) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">904</td>
    <td class="codeLine">m_Deferred(const BasicBlock *const &BB) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">905</td>
    <td class="codeLine">  return BB;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">905</td>
    <td class="codeLine">  return BB;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">906</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">906</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">907</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">907</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">908</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">908</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">909</td>
    <td class="codeLine">// Matcher for any binary operator.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">909</td>
    <td class="codeLine">// Matcher for any binary operator.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">910</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">910</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">911</td>
    <td class="codeLine">template <typename LHS_t, typename RHS_t, bool Commutable = false></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">911</td>
    <td class="codeLine">template <typename LHS_t, typename RHS_t, bool Commutable = false></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">912</td>
    <td class="codeLine">struct AnyBinaryOp_match {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">912</td>
    <td class="codeLine">struct AnyBinaryOp_match {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">913</td>
    <td class="codeLine">  LHS_t L;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">913</td>
    <td class="codeLine">  LHS_t L;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">914</td>
    <td class="codeLine">  RHS_t R;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">914</td>
    <td class="codeLine">  RHS_t R;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">915</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">915</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">916</td>
    <td class="codeLine">  // The evaluation order is always stable, regardless of Commutability.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">916</td>
    <td class="codeLine">  // The evaluation order is always stable, regardless of Commutability.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">917</td>
    <td class="codeLine">  // The LHS is always matched first.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">917</td>
    <td class="codeLine">  // The LHS is always matched first.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">918</td>
    <td class="codeLine">  AnyBinaryOp_match(const LHS_t &LHS, const RHS_t &RHS) : L(LHS), R(RHS) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">918</td>
    <td class="codeLine">  AnyBinaryOp_match(const LHS_t &LHS, const RHS_t &RHS) : L(LHS), R(RHS) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">919</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">919</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">920</td>
    <td class="codeLine">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">920</td>
    <td class="codeLine">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">921</td>
    <td class="codeLine">    if (auto *I = dyn_cast<BinaryOperator>(V))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">921</td>
    <td class="codeLine">    if (auto *I = dyn_cast<BinaryOperator>(V))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">922</td>
    <td class="codeLine">      return (L.match(I->getOperand(0)) && R.match(I->getOperand(1))) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">922</td>
    <td class="codeLine">      return (L.match(I->getOperand(0)) && R.match(I->getOperand(1))) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">923</td>
    <td class="codeLine">             (Commutable && L.match(I->getOperand(1)) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">923</td>
    <td class="codeLine">             (Commutable && L.match(I->getOperand(1)) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">924</td>
    <td class="codeLine">              R.match(I->getOperand(0)));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">924</td>
    <td class="codeLine">              R.match(I->getOperand(0)));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">925</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">925</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">926</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">926</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">927</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">927</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">928</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">928</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">929</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">929</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">930</td>
    <td class="codeLine">inline AnyBinaryOp_match<LHS, RHS> m_BinOp(const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">930</td>
    <td class="codeLine">inline AnyBinaryOp_match<LHS, RHS> m_BinOp(const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">931</td>
    <td class="codeLine">  return AnyBinaryOp_match<LHS, RHS>(L, R);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">931</td>
    <td class="codeLine">  return AnyBinaryOp_match<LHS, RHS>(L, R);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">932</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">932</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">933</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">933</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">934</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">934</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">935</td>
    <td class="codeLine">// Matcher for any unary operator.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">935</td>
    <td class="codeLine">// Matcher for any unary operator.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">936</td>
    <td class="codeLine">// TODO fuse unary, binary matcher into n-ary matcher</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">936</td>
    <td class="codeLine">// TODO fuse unary, binary matcher into n-ary matcher</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">937</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">937</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">938</td>
    <td class="codeLine">template <typename OP_t> struct AnyUnaryOp_match {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">938</td>
    <td class="codeLine">template <typename OP_t> struct AnyUnaryOp_match {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">939</td>
    <td class="codeLine">  OP_t X;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">939</td>
    <td class="codeLine">  OP_t X;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">940</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">940</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">941</td>
    <td class="codeLine">  AnyUnaryOp_match(const OP_t &X) : X(X) {}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">941</td>
    <td class="codeLine">  AnyUnaryOp_match(const OP_t &X) : X(X) {}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">942</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">942</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">943</td>
    <td class="codeLine">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">943</td>
    <td class="codeLine">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">944</td>
    <td class="codeLine">    if (auto *I = dyn_cast<UnaryOperator>(V))</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">944</td>
    <td class="codeLine">    if (auto *I = dyn_cast<UnaryOperator>(V))</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">945</td>
    <td class="codeLine">      return X.match(I->getOperand(0));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">945</td>
    <td class="codeLine">      return X.match(I->getOperand(0));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">946</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">946</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">947</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">947</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">948</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">948</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">949</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">949</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">950</td>
    <td class="codeLine">template <typename OP_t> inline AnyUnaryOp_match<OP_t> m_UnOp(const OP_t &X) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">950</td>
    <td class="codeLine">template <typename OP_t> inline AnyUnaryOp_match<OP_t> m_UnOp(const OP_t &X) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">951</td>
    <td class="codeLine">  return AnyUnaryOp_match<OP_t>(X);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">951</td>
    <td class="codeLine">  return AnyUnaryOp_match<OP_t>(X);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">952</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">952</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">953</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">953</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">954</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">954</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">955</td>
    <td class="codeLine">// Matchers for specific binary operators.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">955</td>
    <td class="codeLine">// Matchers for specific binary operators.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">956</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">956</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">957</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">957</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">958</td>
    <td class="codeLine">template <typename LHS_t, typename RHS_t, unsigned Opcode,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">958</td>
    <td class="codeLine">template <typename LHS_t, typename RHS_t, unsigned Opcode,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">959</td>
    <td class="codeLine">          bool Commutable = false></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">959</td>
    <td class="codeLine">          bool Commutable = false></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">960</td>
    <td class="codeLine">struct BinaryOp_match {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">960</td>
    <td class="codeLine">struct BinaryOp_match {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">961</td>
    <td class="codeLine">  LHS_t L;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">961</td>
    <td class="codeLine">  LHS_t L;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">962</td>
    <td class="codeLine">  RHS_t R;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">962</td>
    <td class="codeLine">  RHS_t R;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">963</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">963</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">964</td>
    <td class="codeLine">  // The evaluation order is always stable, regardless of Commutability.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">964</td>
    <td class="codeLine">  // The evaluation order is always stable, regardless of Commutability.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">965</td>
    <td class="codeLine">  // The LHS is always matched first.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">965</td>
    <td class="codeLine">  // The LHS is always matched first.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">966</td>
    <td class="codeLine">  BinaryOp_match(const LHS_t &LHS, const RHS_t &RHS) : L(LHS), R(RHS) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">966</td>
    <td class="codeLine">  BinaryOp_match(const LHS_t &LHS, const RHS_t &RHS) : L(LHS), R(RHS) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">967</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">967</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">968</td>
    <td class="codeLine">  template <typename OpTy> inline bool match(unsigned Opc, OpTy *V) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">968</td>
    <td class="codeLine">  template <typename OpTy> inline bool match(unsigned Opc, OpTy *V) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">969</td>
    <td class="codeLine">    if (V->getValueID() == Value::InstructionVal + Opc) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">969</td>
    <td class="codeLine">    if (V->getValueID() == Value::InstructionVal + Opc) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">970</td>
    <td class="codeLine">      auto *I = cast<BinaryOperator>(V);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">970</td>
    <td class="codeLine">      auto *I = cast<BinaryOperator>(V);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">971</td>
    <td class="codeLine">      return (L.match(I->getOperand(0)) && R.match(I->getOperand(1))) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">971</td>
    <td class="codeLine">      return (L.match(I->getOperand(0)) && R.match(I->getOperand(1))) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">972</td>
    <td class="codeLine">             (Commutable && L.match(I->getOperand(1)) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">972</td>
    <td class="codeLine">             (Commutable && L.match(I->getOperand(1)) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">973</td>
    <td class="codeLine">              R.match(I->getOperand(0)));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">973</td>
    <td class="codeLine">              R.match(I->getOperand(0)));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">974</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">974</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">975</td>
    <td class="codeLine">    if (auto *CE = dyn_cast<ConstantExpr>(V))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">975</td>
    <td class="codeLine">    if (auto *CE = dyn_cast<ConstantExpr>(V))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">976</td>
    <td class="codeLine">      return CE->getOpcode() == Opc &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">976</td>
    <td class="codeLine">      return CE->getOpcode() == Opc &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">977</td>
    <td class="codeLine">             ((L.match(CE->getOperand(0)) && R.match(CE->getOperand(1))) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">977</td>
    <td class="codeLine">             ((L.match(CE->getOperand(0)) && R.match(CE->getOperand(1))) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">978</td>
    <td class="codeLine">              (Commutable && L.match(CE->getOperand(1)) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">978</td>
    <td class="codeLine">              (Commutable && L.match(CE->getOperand(1)) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">979</td>
    <td class="codeLine">               R.match(CE->getOperand(0))));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">979</td>
    <td class="codeLine">               R.match(CE->getOperand(0))));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">980</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">980</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">981</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">981</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">982</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">982</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">983</td>
    <td class="codeLine">  template <typename OpTy> bool match(OpTy *V) { return match(Opcode, V); }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">983</td>
    <td class="codeLine">  template <typename OpTy> bool match(OpTy *V) { return match(Opcode, V); }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">984</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">984</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">985</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">985</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">986</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">986</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">987</td>
    <td class="codeLine">inline BinaryOp_match<LHS, RHS, Instruction::Add> m_Add(const LHS &L,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">987</td>
    <td class="codeLine">inline BinaryOp_match<LHS, RHS, Instruction::Add> m_Add(const LHS &L,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">988</td>
    <td class="codeLine">                                                        const RHS &R) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">988</td>
    <td class="codeLine">                                                        const RHS &R) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">989</td>
    <td class="codeLine">  return BinaryOp_match<LHS, RHS, Instruction::Add>(L, R);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">989</td>
    <td class="codeLine">  return BinaryOp_match<LHS, RHS, Instruction::Add>(L, R);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">990</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">990</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">991</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">991</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">992</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">992</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">993</td>
    <td class="codeLine">inline BinaryOp_match<LHS, RHS, Instruction::FAdd> m_FAdd(const LHS &L,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">993</td>
    <td class="codeLine">inline BinaryOp_match<LHS, RHS, Instruction::FAdd> m_FAdd(const LHS &L,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">994</td>
    <td class="codeLine">                                                          const RHS &R) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">994</td>
    <td class="codeLine">                                                          const RHS &R) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">995</td>
    <td class="codeLine">  return BinaryOp_match<LHS, RHS, Instruction::FAdd>(L, R);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">995</td>
    <td class="codeLine">  return BinaryOp_match<LHS, RHS, Instruction::FAdd>(L, R);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">996</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">996</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">997</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">997</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">998</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">998</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">999</td>
    <td class="codeLine">inline BinaryOp_match<LHS, RHS, Instruction::Sub> m_Sub(const LHS &L,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">999</td>
    <td class="codeLine">inline BinaryOp_match<LHS, RHS, Instruction::Sub> m_Sub(const LHS &L,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1000</td>
    <td class="codeLine">                                                        const RHS &R) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1000</td>
    <td class="codeLine">                                                        const RHS &R) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1001</td>
    <td class="codeLine">  return BinaryOp_match<LHS, RHS, Instruction::Sub>(L, R);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1001</td>
    <td class="codeLine">  return BinaryOp_match<LHS, RHS, Instruction::Sub>(L, R);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1002</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1002</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1003</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1003</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1004</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1004</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1005</td>
    <td class="codeLine">inline BinaryOp_match<LHS, RHS, Instruction::FSub> m_FSub(const LHS &L,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1005</td>
    <td class="codeLine">inline BinaryOp_match<LHS, RHS, Instruction::FSub> m_FSub(const LHS &L,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1006</td>
    <td class="codeLine">                                                          const RHS &R) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1006</td>
    <td class="codeLine">                                                          const RHS &R) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1007</td>
    <td class="codeLine">  return BinaryOp_match<LHS, RHS, Instruction::FSub>(L, R);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1007</td>
    <td class="codeLine">  return BinaryOp_match<LHS, RHS, Instruction::FSub>(L, R);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1008</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1008</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1009</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1009</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1010</td>
    <td class="codeLine">template <typename Op_t> struct FNeg_match {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1010</td>
    <td class="codeLine">template <typename Op_t> struct FNeg_match {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1011</td>
    <td class="codeLine">  Op_t X;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1011</td>
    <td class="codeLine">  Op_t X;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1012</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1012</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1013</td>
    <td class="codeLine">  FNeg_match(const Op_t &Op) : X(Op) {}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1013</td>
    <td class="codeLine">  FNeg_match(const Op_t &Op) : X(Op) {}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1014</td>
    <td class="codeLine">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1014</td>
    <td class="codeLine">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1015</td>
    <td class="codeLine">    auto *FPMO = dyn_cast<FPMathOperator>(V);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1015</td>
    <td class="codeLine">    auto *FPMO = dyn_cast<FPMathOperator>(V);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1016</td>
    <td class="codeLine">    if (!FPMO)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1016</td>
    <td class="codeLine">    if (!FPMO)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1017</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1017</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1018</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1018</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1019</td>
    <td class="codeLine">    if (FPMO->getOpcode() == Instruction::FNeg)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1019</td>
    <td class="codeLine">    if (FPMO->getOpcode() == Instruction::FNeg)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1020</td>
    <td class="codeLine">      return X.match(FPMO->getOperand(0));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1020</td>
    <td class="codeLine">      return X.match(FPMO->getOperand(0));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1021</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1021</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1022</td>
    <td class="codeLine">    if (FPMO->getOpcode() == Instruction::FSub) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1022</td>
    <td class="codeLine">    if (FPMO->getOpcode() == Instruction::FSub) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1023</td>
    <td class="codeLine">      if (FPMO->hasNoSignedZeros()) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1023</td>
    <td class="codeLine">      if (FPMO->hasNoSignedZeros()) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1024</td>
    <td class="codeLine">        // With 'nsz', any zero goes.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1024</td>
    <td class="codeLine">        // With 'nsz', any zero goes.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1025</td>
    <td class="codeLine">        if (!cstfp_pred_ty<is_any_zero_fp>().match(FPMO->getOperand(0)))</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1025</td>
    <td class="codeLine">        if (!cstfp_pred_ty<is_any_zero_fp>().match(FPMO->getOperand(0)))</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1026</td>
    <td class="codeLine">          return false;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1026</td>
    <td class="codeLine">          return false;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1027</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1027</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1028</td>
    <td class="codeLine">        // Without 'nsz', we need fsub -0.0, X exactly.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1028</td>
    <td class="codeLine">        // Without 'nsz', we need fsub -0.0, X exactly.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1029</td>
    <td class="codeLine">        if (!cstfp_pred_ty<is_neg_zero_fp>().match(FPMO->getOperand(0)))</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1029</td>
    <td class="codeLine">        if (!cstfp_pred_ty<is_neg_zero_fp>().match(FPMO->getOperand(0)))</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1030</td>
    <td class="codeLine">          return false;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1030</td>
    <td class="codeLine">          return false;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1031</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1031</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1032</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1032</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1033</td>
    <td class="codeLine">      return X.match(FPMO->getOperand(1));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1033</td>
    <td class="codeLine">      return X.match(FPMO->getOperand(1));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1034</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1034</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1035</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1035</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1036</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1036</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1037</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1037</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1038</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1038</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1039</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1039</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1040</td>
    <td class="codeLine">/// Match 'fneg X' as 'fsub -0.0, X'.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1040</td>
    <td class="codeLine">/// Match 'fneg X' as 'fsub -0.0, X'.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1041</td>
    <td class="codeLine">template <typename OpTy> inline FNeg_match<OpTy> m_FNeg(const OpTy &X) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1041</td>
    <td class="codeLine">template <typename OpTy> inline FNeg_match<OpTy> m_FNeg(const OpTy &X) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1042</td>
    <td class="codeLine">  return FNeg_match<OpTy>(X);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1042</td>
    <td class="codeLine">  return FNeg_match<OpTy>(X);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1043</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1043</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1044</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1044</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1045</td>
    <td class="codeLine">/// Match 'fneg X' as 'fsub +-0.0, X'.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1045</td>
    <td class="codeLine">/// Match 'fneg X' as 'fsub +-0.0, X'.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1046</td>
    <td class="codeLine">template <typename RHS></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1046</td>
    <td class="codeLine">template <typename RHS></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1047</td>
    <td class="codeLine">inline BinaryOp_match<cstfp_pred_ty<is_any_zero_fp>, RHS, Instruction::FSub></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1047</td>
    <td class="codeLine">inline BinaryOp_match<cstfp_pred_ty<is_any_zero_fp>, RHS, Instruction::FSub></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1048</td>
    <td class="codeLine">m_FNegNSZ(const RHS &X) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1048</td>
    <td class="codeLine">m_FNegNSZ(const RHS &X) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1049</td>
    <td class="codeLine">  return m_FSub(m_AnyZeroFP(), X);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1049</td>
    <td class="codeLine">  return m_FSub(m_AnyZeroFP(), X);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1050</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1050</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1051</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1051</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1052</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1052</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1053</td>
    <td class="codeLine">inline BinaryOp_match<LHS, RHS, Instruction::Mul> m_Mul(const LHS &L,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1053</td>
    <td class="codeLine">inline BinaryOp_match<LHS, RHS, Instruction::Mul> m_Mul(const LHS &L,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1054</td>
    <td class="codeLine">                                                        const RHS &R) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1054</td>
    <td class="codeLine">                                                        const RHS &R) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1055</td>
    <td class="codeLine">  return BinaryOp_match<LHS, RHS, Instruction::Mul>(L, R);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1055</td>
    <td class="codeLine">  return BinaryOp_match<LHS, RHS, Instruction::Mul>(L, R);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1056</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1056</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1057</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1057</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1058</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1058</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1059</td>
    <td class="codeLine">inline BinaryOp_match<LHS, RHS, Instruction::FMul> m_FMul(const LHS &L,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1059</td>
    <td class="codeLine">inline BinaryOp_match<LHS, RHS, Instruction::FMul> m_FMul(const LHS &L,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1060</td>
    <td class="codeLine">                                                          const RHS &R) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1060</td>
    <td class="codeLine">                                                          const RHS &R) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1061</td>
    <td class="codeLine">  return BinaryOp_match<LHS, RHS, Instruction::FMul>(L, R);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1061</td>
    <td class="codeLine">  return BinaryOp_match<LHS, RHS, Instruction::FMul>(L, R);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1062</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1062</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1063</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1063</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1064</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1064</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1065</td>
    <td class="codeLine">inline BinaryOp_match<LHS, RHS, Instruction::UDiv> m_UDiv(const LHS &L,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1065</td>
    <td class="codeLine">inline BinaryOp_match<LHS, RHS, Instruction::UDiv> m_UDiv(const LHS &L,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1066</td>
    <td class="codeLine">                                                          const RHS &R) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1066</td>
    <td class="codeLine">                                                          const RHS &R) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1067</td>
    <td class="codeLine">  return BinaryOp_match<LHS, RHS, Instruction::UDiv>(L, R);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1067</td>
    <td class="codeLine">  return BinaryOp_match<LHS, RHS, Instruction::UDiv>(L, R);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1068</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1068</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1069</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1069</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1070</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1070</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1071</td>
    <td class="codeLine">inline BinaryOp_match<LHS, RHS, Instruction::SDiv> m_SDiv(const LHS &L,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1071</td>
    <td class="codeLine">inline BinaryOp_match<LHS, RHS, Instruction::SDiv> m_SDiv(const LHS &L,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1072</td>
    <td class="codeLine">                                                          const RHS &R) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1072</td>
    <td class="codeLine">                                                          const RHS &R) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1073</td>
    <td class="codeLine">  return BinaryOp_match<LHS, RHS, Instruction::SDiv>(L, R);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1073</td>
    <td class="codeLine">  return BinaryOp_match<LHS, RHS, Instruction::SDiv>(L, R);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1074</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1074</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1075</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1075</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1076</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1076</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1077</td>
    <td class="codeLine">inline BinaryOp_match<LHS, RHS, Instruction::FDiv> m_FDiv(const LHS &L,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1077</td>
    <td class="codeLine">inline BinaryOp_match<LHS, RHS, Instruction::FDiv> m_FDiv(const LHS &L,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1078</td>
    <td class="codeLine">                                                          const RHS &R) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1078</td>
    <td class="codeLine">                                                          const RHS &R) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1079</td>
    <td class="codeLine">  return BinaryOp_match<LHS, RHS, Instruction::FDiv>(L, R);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1079</td>
    <td class="codeLine">  return BinaryOp_match<LHS, RHS, Instruction::FDiv>(L, R);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1080</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1080</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1081</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1081</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1082</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1082</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1083</td>
    <td class="codeLine">inline BinaryOp_match<LHS, RHS, Instruction::URem> m_URem(const LHS &L,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1083</td>
    <td class="codeLine">inline BinaryOp_match<LHS, RHS, Instruction::URem> m_URem(const LHS &L,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1084</td>
    <td class="codeLine">                                                          const RHS &R) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1084</td>
    <td class="codeLine">                                                          const RHS &R) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1085</td>
    <td class="codeLine">  return BinaryOp_match<LHS, RHS, Instruction::URem>(L, R);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1085</td>
    <td class="codeLine">  return BinaryOp_match<LHS, RHS, Instruction::URem>(L, R);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1086</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1086</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1087</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1087</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1088</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1088</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1089</td>
    <td class="codeLine">inline BinaryOp_match<LHS, RHS, Instruction::SRem> m_SRem(const LHS &L,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1089</td>
    <td class="codeLine">inline BinaryOp_match<LHS, RHS, Instruction::SRem> m_SRem(const LHS &L,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1090</td>
    <td class="codeLine">                                                          const RHS &R) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1090</td>
    <td class="codeLine">                                                          const RHS &R) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1091</td>
    <td class="codeLine">  return BinaryOp_match<LHS, RHS, Instruction::SRem>(L, R);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1091</td>
    <td class="codeLine">  return BinaryOp_match<LHS, RHS, Instruction::SRem>(L, R);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1092</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1092</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1093</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1093</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1094</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1094</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1095</td>
    <td class="codeLine">inline BinaryOp_match<LHS, RHS, Instruction::FRem> m_FRem(const LHS &L,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1095</td>
    <td class="codeLine">inline BinaryOp_match<LHS, RHS, Instruction::FRem> m_FRem(const LHS &L,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1096</td>
    <td class="codeLine">                                                          const RHS &R) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1096</td>
    <td class="codeLine">                                                          const RHS &R) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1097</td>
    <td class="codeLine">  return BinaryOp_match<LHS, RHS, Instruction::FRem>(L, R);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1097</td>
    <td class="codeLine">  return BinaryOp_match<LHS, RHS, Instruction::FRem>(L, R);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1098</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1098</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1099</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1099</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1100</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1100</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1101</td>
    <td class="codeLine">inline BinaryOp_match<LHS, RHS, Instruction::And> m_And(const LHS &L,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1101</td>
    <td class="codeLine">inline BinaryOp_match<LHS, RHS, Instruction::And> m_And(const LHS &L,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1102</td>
    <td class="codeLine">                                                        const RHS &R) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1102</td>
    <td class="codeLine">                                                        const RHS &R) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1103</td>
    <td class="codeLine">  return BinaryOp_match<LHS, RHS, Instruction::And>(L, R);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1103</td>
    <td class="codeLine">  return BinaryOp_match<LHS, RHS, Instruction::And>(L, R);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1104</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1104</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1105</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1105</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1106</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1106</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1107</td>
    <td class="codeLine">inline BinaryOp_match<LHS, RHS, Instruction::Or> m_Or(const LHS &L,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1107</td>
    <td class="codeLine">inline BinaryOp_match<LHS, RHS, Instruction::Or> m_Or(const LHS &L,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1108</td>
    <td class="codeLine">                                                      const RHS &R) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1108</td>
    <td class="codeLine">                                                      const RHS &R) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1109</td>
    <td class="codeLine">  return BinaryOp_match<LHS, RHS, Instruction::Or>(L, R);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1109</td>
    <td class="codeLine">  return BinaryOp_match<LHS, RHS, Instruction::Or>(L, R);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1110</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1110</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1111</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1111</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1112</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1112</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1113</td>
    <td class="codeLine">inline BinaryOp_match<LHS, RHS, Instruction::Xor> m_Xor(const LHS &L,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1113</td>
    <td class="codeLine">inline BinaryOp_match<LHS, RHS, Instruction::Xor> m_Xor(const LHS &L,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1114</td>
    <td class="codeLine">                                                        const RHS &R) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1114</td>
    <td class="codeLine">                                                        const RHS &R) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1115</td>
    <td class="codeLine">  return BinaryOp_match<LHS, RHS, Instruction::Xor>(L, R);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1115</td>
    <td class="codeLine">  return BinaryOp_match<LHS, RHS, Instruction::Xor>(L, R);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1116</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1116</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1117</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1117</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1118</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1118</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1119</td>
    <td class="codeLine">inline BinaryOp_match<LHS, RHS, Instruction::Shl> m_Shl(const LHS &L,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1119</td>
    <td class="codeLine">inline BinaryOp_match<LHS, RHS, Instruction::Shl> m_Shl(const LHS &L,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1120</td>
    <td class="codeLine">                                                        const RHS &R) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1120</td>
    <td class="codeLine">                                                        const RHS &R) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1121</td>
    <td class="codeLine">  return BinaryOp_match<LHS, RHS, Instruction::Shl>(L, R);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1121</td>
    <td class="codeLine">  return BinaryOp_match<LHS, RHS, Instruction::Shl>(L, R);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1122</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1122</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1123</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1123</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1124</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1124</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1125</td>
    <td class="codeLine">inline BinaryOp_match<LHS, RHS, Instruction::LShr> m_LShr(const LHS &L,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1125</td>
    <td class="codeLine">inline BinaryOp_match<LHS, RHS, Instruction::LShr> m_LShr(const LHS &L,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1126</td>
    <td class="codeLine">                                                          const RHS &R) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1126</td>
    <td class="codeLine">                                                          const RHS &R) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1127</td>
    <td class="codeLine">  return BinaryOp_match<LHS, RHS, Instruction::LShr>(L, R);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1127</td>
    <td class="codeLine">  return BinaryOp_match<LHS, RHS, Instruction::LShr>(L, R);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1128</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1128</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1129</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1129</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1130</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1130</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1131</td>
    <td class="codeLine">inline BinaryOp_match<LHS, RHS, Instruction::AShr> m_AShr(const LHS &L,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1131</td>
    <td class="codeLine">inline BinaryOp_match<LHS, RHS, Instruction::AShr> m_AShr(const LHS &L,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1132</td>
    <td class="codeLine">                                                          const RHS &R) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1132</td>
    <td class="codeLine">                                                          const RHS &R) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1133</td>
    <td class="codeLine">  return BinaryOp_match<LHS, RHS, Instruction::AShr>(L, R);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1133</td>
    <td class="codeLine">  return BinaryOp_match<LHS, RHS, Instruction::AShr>(L, R);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1134</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1134</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1135</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1135</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1136</td>
    <td class="codeLine">template <typename LHS_t, typename RHS_t, unsigned Opcode,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1136</td>
    <td class="codeLine">template <typename LHS_t, typename RHS_t, unsigned Opcode,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1137</td>
    <td class="codeLine">          unsigned WrapFlags = 0></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1137</td>
    <td class="codeLine">          unsigned WrapFlags = 0></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1138</td>
    <td class="codeLine">struct OverflowingBinaryOp_match {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1138</td>
    <td class="codeLine">struct OverflowingBinaryOp_match {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1139</td>
    <td class="codeLine">  LHS_t L;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1139</td>
    <td class="codeLine">  LHS_t L;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1140</td>
    <td class="codeLine">  RHS_t R;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1140</td>
    <td class="codeLine">  RHS_t R;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1141</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1141</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1142</td>
    <td class="codeLine">  OverflowingBinaryOp_match(const LHS_t &LHS, const RHS_t &RHS)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1142</td>
    <td class="codeLine">  OverflowingBinaryOp_match(const LHS_t &LHS, const RHS_t &RHS)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1143</td>
    <td class="codeLine">      : L(LHS), R(RHS) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1143</td>
    <td class="codeLine">      : L(LHS), R(RHS) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1144</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1144</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1145</td>
    <td class="codeLine">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1145</td>
    <td class="codeLine">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1146</td>
    <td class="codeLine">    if (auto *Op = dyn_cast<OverflowingBinaryOperator>(V)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1146</td>
    <td class="codeLine">    if (auto *Op = dyn_cast<OverflowingBinaryOperator>(V)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1147</td>
    <td class="codeLine">      if (Op->getOpcode() != Opcode)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1147</td>
    <td class="codeLine">      if (Op->getOpcode() != Opcode)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1148</td>
    <td class="codeLine">        return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1148</td>
    <td class="codeLine">        return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1149</td>
    <td class="codeLine">      if ((WrapFlags & OverflowingBinaryOperator::NoUnsignedWrap) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1149</td>
    <td class="codeLine">      if ((WrapFlags & OverflowingBinaryOperator::NoUnsignedWrap) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1150</td>
    <td class="codeLine">          !Op->hasNoUnsignedWrap())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1150</td>
    <td class="codeLine">          !Op->hasNoUnsignedWrap())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1151</td>
    <td class="codeLine">        return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1151</td>
    <td class="codeLine">        return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1152</td>
    <td class="codeLine">      if ((WrapFlags & OverflowingBinaryOperator::NoSignedWrap) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1152</td>
    <td class="codeLine">      if ((WrapFlags & OverflowingBinaryOperator::NoSignedWrap) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1153</td>
    <td class="codeLine">          !Op->hasNoSignedWrap())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1153</td>
    <td class="codeLine">          !Op->hasNoSignedWrap())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1154</td>
    <td class="codeLine">        return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1154</td>
    <td class="codeLine">        return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1155</td>
    <td class="codeLine">      return L.match(Op->getOperand(0)) && R.match(Op->getOperand(1));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1155</td>
    <td class="codeLine">      return L.match(Op->getOperand(0)) && R.match(Op->getOperand(1));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1156</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1156</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1157</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1157</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1158</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1158</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1159</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1159</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1160</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1160</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1161</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1161</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1162</td>
    <td class="codeLine">inline OverflowingBinaryOp_match<LHS, RHS, Instruction::Add,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1162</td>
    <td class="codeLine">inline OverflowingBinaryOp_match<LHS, RHS, Instruction::Add,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1163</td>
    <td class="codeLine">                                 OverflowingBinaryOperator::NoSignedWrap></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1163</td>
    <td class="codeLine">                                 OverflowingBinaryOperator::NoSignedWrap></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1164</td>
    <td class="codeLine">m_NSWAdd(const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1164</td>
    <td class="codeLine">m_NSWAdd(const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1165</td>
    <td class="codeLine">  return OverflowingBinaryOp_match<LHS, RHS, Instruction::Add,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1165</td>
    <td class="codeLine">  return OverflowingBinaryOp_match<LHS, RHS, Instruction::Add,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1166</td>
    <td class="codeLine">                                   OverflowingBinaryOperator::NoSignedWrap>(L,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1166</td>
    <td class="codeLine">                                   OverflowingBinaryOperator::NoSignedWrap>(L,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1167</td>
    <td class="codeLine">                                                                            R);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1167</td>
    <td class="codeLine">                                                                            R);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1168</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1168</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1169</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1169</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1170</td>
    <td class="codeLine">inline OverflowingBinaryOp_match<LHS, RHS, Instruction::Sub,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1170</td>
    <td class="codeLine">inline OverflowingBinaryOp_match<LHS, RHS, Instruction::Sub,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1171</td>
    <td class="codeLine">                                 OverflowingBinaryOperator::NoSignedWrap></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1171</td>
    <td class="codeLine">                                 OverflowingBinaryOperator::NoSignedWrap></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1172</td>
    <td class="codeLine">m_NSWSub(const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1172</td>
    <td class="codeLine">m_NSWSub(const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1173</td>
    <td class="codeLine">  return OverflowingBinaryOp_match<LHS, RHS, Instruction::Sub,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1173</td>
    <td class="codeLine">  return OverflowingBinaryOp_match<LHS, RHS, Instruction::Sub,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1174</td>
    <td class="codeLine">                                   OverflowingBinaryOperator::NoSignedWrap>(L,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1174</td>
    <td class="codeLine">                                   OverflowingBinaryOperator::NoSignedWrap>(L,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1175</td>
    <td class="codeLine">                                                                            R);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1175</td>
    <td class="codeLine">                                                                            R);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1176</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1176</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1177</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1177</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1178</td>
    <td class="codeLine">inline OverflowingBinaryOp_match<LHS, RHS, Instruction::Mul,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1178</td>
    <td class="codeLine">inline OverflowingBinaryOp_match<LHS, RHS, Instruction::Mul,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1179</td>
    <td class="codeLine">                                 OverflowingBinaryOperator::NoSignedWrap></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1179</td>
    <td class="codeLine">                                 OverflowingBinaryOperator::NoSignedWrap></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1180</td>
    <td class="codeLine">m_NSWMul(const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1180</td>
    <td class="codeLine">m_NSWMul(const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1181</td>
    <td class="codeLine">  return OverflowingBinaryOp_match<LHS, RHS, Instruction::Mul,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1181</td>
    <td class="codeLine">  return OverflowingBinaryOp_match<LHS, RHS, Instruction::Mul,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1182</td>
    <td class="codeLine">                                   OverflowingBinaryOperator::NoSignedWrap>(L,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1182</td>
    <td class="codeLine">                                   OverflowingBinaryOperator::NoSignedWrap>(L,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1183</td>
    <td class="codeLine">                                                                            R);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1183</td>
    <td class="codeLine">                                                                            R);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1184</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1184</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1185</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1185</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1186</td>
    <td class="codeLine">inline OverflowingBinaryOp_match<LHS, RHS, Instruction::Shl,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1186</td>
    <td class="codeLine">inline OverflowingBinaryOp_match<LHS, RHS, Instruction::Shl,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1187</td>
    <td class="codeLine">                                 OverflowingBinaryOperator::NoSignedWrap></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1187</td>
    <td class="codeLine">                                 OverflowingBinaryOperator::NoSignedWrap></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1188</td>
    <td class="codeLine">m_NSWShl(const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1188</td>
    <td class="codeLine">m_NSWShl(const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1189</td>
    <td class="codeLine">  return OverflowingBinaryOp_match<LHS, RHS, Instruction::Shl,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1189</td>
    <td class="codeLine">  return OverflowingBinaryOp_match<LHS, RHS, Instruction::Shl,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1190</td>
    <td class="codeLine">                                   OverflowingBinaryOperator::NoSignedWrap>(L,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1190</td>
    <td class="codeLine">                                   OverflowingBinaryOperator::NoSignedWrap>(L,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1191</td>
    <td class="codeLine">                                                                            R);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1191</td>
    <td class="codeLine">                                                                            R);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1192</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1192</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1193</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1193</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1194</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1194</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1195</td>
    <td class="codeLine">inline OverflowingBinaryOp_match<LHS, RHS, Instruction::Add,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1195</td>
    <td class="codeLine">inline OverflowingBinaryOp_match<LHS, RHS, Instruction::Add,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1196</td>
    <td class="codeLine">                                 OverflowingBinaryOperator::NoUnsignedWrap></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1196</td>
    <td class="codeLine">                                 OverflowingBinaryOperator::NoUnsignedWrap></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1197</td>
    <td class="codeLine">m_NUWAdd(const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1197</td>
    <td class="codeLine">m_NUWAdd(const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1198</td>
    <td class="codeLine">  return OverflowingBinaryOp_match<LHS, RHS, Instruction::Add,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1198</td>
    <td class="codeLine">  return OverflowingBinaryOp_match<LHS, RHS, Instruction::Add,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1199</td>
    <td class="codeLine">                                   OverflowingBinaryOperator::NoUnsignedWrap>(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1199</td>
    <td class="codeLine">                                   OverflowingBinaryOperator::NoUnsignedWrap>(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1200</td>
    <td class="codeLine">      L, R);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1200</td>
    <td class="codeLine">      L, R);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1201</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1201</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1202</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1202</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1203</td>
    <td class="codeLine">inline OverflowingBinaryOp_match<LHS, RHS, Instruction::Sub,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1203</td>
    <td class="codeLine">inline OverflowingBinaryOp_match<LHS, RHS, Instruction::Sub,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1204</td>
    <td class="codeLine">                                 OverflowingBinaryOperator::NoUnsignedWrap></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1204</td>
    <td class="codeLine">                                 OverflowingBinaryOperator::NoUnsignedWrap></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1205</td>
    <td class="codeLine">m_NUWSub(const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1205</td>
    <td class="codeLine">m_NUWSub(const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1206</td>
    <td class="codeLine">  return OverflowingBinaryOp_match<LHS, RHS, Instruction::Sub,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1206</td>
    <td class="codeLine">  return OverflowingBinaryOp_match<LHS, RHS, Instruction::Sub,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1207</td>
    <td class="codeLine">                                   OverflowingBinaryOperator::NoUnsignedWrap>(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1207</td>
    <td class="codeLine">                                   OverflowingBinaryOperator::NoUnsignedWrap>(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1208</td>
    <td class="codeLine">      L, R);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1208</td>
    <td class="codeLine">      L, R);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1209</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1209</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1210</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1210</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1211</td>
    <td class="codeLine">inline OverflowingBinaryOp_match<LHS, RHS, Instruction::Mul,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1211</td>
    <td class="codeLine">inline OverflowingBinaryOp_match<LHS, RHS, Instruction::Mul,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1212</td>
    <td class="codeLine">                                 OverflowingBinaryOperator::NoUnsignedWrap></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1212</td>
    <td class="codeLine">                                 OverflowingBinaryOperator::NoUnsignedWrap></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1213</td>
    <td class="codeLine">m_NUWMul(const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1213</td>
    <td class="codeLine">m_NUWMul(const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1214</td>
    <td class="codeLine">  return OverflowingBinaryOp_match<LHS, RHS, Instruction::Mul,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1214</td>
    <td class="codeLine">  return OverflowingBinaryOp_match<LHS, RHS, Instruction::Mul,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1215</td>
    <td class="codeLine">                                   OverflowingBinaryOperator::NoUnsignedWrap>(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1215</td>
    <td class="codeLine">                                   OverflowingBinaryOperator::NoUnsignedWrap>(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1216</td>
    <td class="codeLine">      L, R);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1216</td>
    <td class="codeLine">      L, R);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1217</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1217</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1218</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1218</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1219</td>
    <td class="codeLine">inline OverflowingBinaryOp_match<LHS, RHS, Instruction::Shl,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1219</td>
    <td class="codeLine">inline OverflowingBinaryOp_match<LHS, RHS, Instruction::Shl,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1220</td>
    <td class="codeLine">                                 OverflowingBinaryOperator::NoUnsignedWrap></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1220</td>
    <td class="codeLine">                                 OverflowingBinaryOperator::NoUnsignedWrap></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1221</td>
    <td class="codeLine">m_NUWShl(const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1221</td>
    <td class="codeLine">m_NUWShl(const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1222</td>
    <td class="codeLine">  return OverflowingBinaryOp_match<LHS, RHS, Instruction::Shl,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1222</td>
    <td class="codeLine">  return OverflowingBinaryOp_match<LHS, RHS, Instruction::Shl,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1223</td>
    <td class="codeLine">                                   OverflowingBinaryOperator::NoUnsignedWrap>(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1223</td>
    <td class="codeLine">                                   OverflowingBinaryOperator::NoUnsignedWrap>(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1224</td>
    <td class="codeLine">      L, R);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1224</td>
    <td class="codeLine">      L, R);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1225</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1225</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1226</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1226</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1227</td>
    <td class="codeLine">template <typename LHS_t, typename RHS_t, bool Commutable = false></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1227</td>
    <td class="codeLine">template <typename LHS_t, typename RHS_t, bool Commutable = false></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1228</td>
    <td class="codeLine">struct SpecificBinaryOp_match</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1228</td>
    <td class="codeLine">struct SpecificBinaryOp_match</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1229</td>
    <td class="codeLine">    : public BinaryOp_match<LHS_t, RHS_t, 0, Commutable> {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1229</td>
    <td class="codeLine">    : public BinaryOp_match<LHS_t, RHS_t, 0, Commutable> {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1230</td>
    <td class="codeLine">  unsigned Opcode;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1230</td>
    <td class="codeLine">  unsigned Opcode;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1231</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1231</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1232</td>
    <td class="codeLine">  SpecificBinaryOp_match(unsigned Opcode, const LHS_t &LHS, const RHS_t &RHS)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1232</td>
    <td class="codeLine">  SpecificBinaryOp_match(unsigned Opcode, const LHS_t &LHS, const RHS_t &RHS)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1233</td>
    <td class="codeLine">      : BinaryOp_match<LHS_t, RHS_t, 0, Commutable>(LHS, RHS), Opcode(Opcode) {}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1233</td>
    <td class="codeLine">      : BinaryOp_match<LHS_t, RHS_t, 0, Commutable>(LHS, RHS), Opcode(Opcode) {}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1234</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1234</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1235</td>
    <td class="codeLine">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1235</td>
    <td class="codeLine">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1236</td>
    <td class="codeLine">    return BinaryOp_match<LHS_t, RHS_t, 0, Commutable>::match(Opcode, V);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1236</td>
    <td class="codeLine">    return BinaryOp_match<LHS_t, RHS_t, 0, Commutable>::match(Opcode, V);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1237</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1237</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1238</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1238</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1239</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1239</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1240</td>
    <td class="codeLine">/// Matches a specific opcode.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1240</td>
    <td class="codeLine">/// Matches a specific opcode.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1241</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1241</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1242</td>
    <td class="codeLine">inline SpecificBinaryOp_match<LHS, RHS> m_BinOp(unsigned Opcode, const LHS &L,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1242</td>
    <td class="codeLine">inline SpecificBinaryOp_match<LHS, RHS> m_BinOp(unsigned Opcode, const LHS &L,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1243</td>
    <td class="codeLine">                                                const RHS &R) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1243</td>
    <td class="codeLine">                                                const RHS &R) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1244</td>
    <td class="codeLine">  return SpecificBinaryOp_match<LHS, RHS>(Opcode, L, R);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1244</td>
    <td class="codeLine">  return SpecificBinaryOp_match<LHS, RHS>(Opcode, L, R);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1245</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1245</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1246</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1246</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1247</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1247</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1248</td>
    <td class="codeLine">// Class that matches a group of binary opcodes.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1248</td>
    <td class="codeLine">// Class that matches a group of binary opcodes.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1249</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1249</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1250</td>
    <td class="codeLine">template <typename LHS_t, typename RHS_t, typename Predicate></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1250</td>
    <td class="codeLine">template <typename LHS_t, typename RHS_t, typename Predicate></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1251</td>
    <td class="codeLine">struct BinOpPred_match : Predicate {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1251</td>
    <td class="codeLine">struct BinOpPred_match : Predicate {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1252</td>
    <td class="codeLine">  LHS_t L;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1252</td>
    <td class="codeLine">  LHS_t L;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1253</td>
    <td class="codeLine">  RHS_t R;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1253</td>
    <td class="codeLine">  RHS_t R;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1254</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1254</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1255</td>
    <td class="codeLine">  BinOpPred_match(const LHS_t &LHS, const RHS_t &RHS) : L(LHS), R(RHS) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1255</td>
    <td class="codeLine">  BinOpPred_match(const LHS_t &LHS, const RHS_t &RHS) : L(LHS), R(RHS) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1256</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1256</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1257</td>
    <td class="codeLine">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1257</td>
    <td class="codeLine">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1258</td>
    <td class="codeLine">    if (auto *I = dyn_cast<Instruction>(V))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1258</td>
    <td class="codeLine">    if (auto *I = dyn_cast<Instruction>(V))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1259</td>
    <td class="codeLine">      return this->isOpType(I->getOpcode()) && L.match(I->getOperand(0)) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1259</td>
    <td class="codeLine">      return this->isOpType(I->getOpcode()) && L.match(I->getOperand(0)) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1260</td>
    <td class="codeLine">             R.match(I->getOperand(1));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1260</td>
    <td class="codeLine">             R.match(I->getOperand(1));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1261</td>
    <td class="codeLine">    if (auto *CE = dyn_cast<ConstantExpr>(V))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1261</td>
    <td class="codeLine">    if (auto *CE = dyn_cast<ConstantExpr>(V))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1262</td>
    <td class="codeLine">      return this->isOpType(CE->getOpcode()) && L.match(CE->getOperand(0)) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1262</td>
    <td class="codeLine">      return this->isOpType(CE->getOpcode()) && L.match(CE->getOperand(0)) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1263</td>
    <td class="codeLine">             R.match(CE->getOperand(1));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1263</td>
    <td class="codeLine">             R.match(CE->getOperand(1));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1264</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1264</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1265</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1265</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1266</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1266</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1267</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1267</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1268</td>
    <td class="codeLine">struct is_shift_op {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1268</td>
    <td class="codeLine">struct is_shift_op {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1269</td>
    <td class="codeLine">  bool isOpType(unsigned Opcode) { return Instruction::isShift(Opcode); }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1269</td>
    <td class="codeLine">  bool isOpType(unsigned Opcode) { return Instruction::isShift(Opcode); }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1270</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1270</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1271</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1271</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1272</td>
    <td class="codeLine">struct is_right_shift_op {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1272</td>
    <td class="codeLine">struct is_right_shift_op {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1273</td>
    <td class="codeLine">  bool isOpType(unsigned Opcode) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1273</td>
    <td class="codeLine">  bool isOpType(unsigned Opcode) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1274</td>
    <td class="codeLine">    return Opcode == Instruction::LShr || Opcode == Instruction::AShr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1274</td>
    <td class="codeLine">    return Opcode == Instruction::LShr || Opcode == Instruction::AShr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1275</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1275</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1276</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1276</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1277</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1277</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1278</td>
    <td class="codeLine">struct is_logical_shift_op {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1278</td>
    <td class="codeLine">struct is_logical_shift_op {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1279</td>
    <td class="codeLine">  bool isOpType(unsigned Opcode) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1279</td>
    <td class="codeLine">  bool isOpType(unsigned Opcode) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1280</td>
    <td class="codeLine">    return Opcode == Instruction::LShr || Opcode == Instruction::Shl;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1280</td>
    <td class="codeLine">    return Opcode == Instruction::LShr || Opcode == Instruction::Shl;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1281</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1281</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1282</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1282</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1283</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1283</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1284</td>
    <td class="codeLine">struct is_bitwiselogic_op {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1284</td>
    <td class="codeLine">struct is_bitwiselogic_op {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1285</td>
    <td class="codeLine">  bool isOpType(unsigned Opcode) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1285</td>
    <td class="codeLine">  bool isOpType(unsigned Opcode) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1286</td>
    <td class="codeLine">    return Instruction::isBitwiseLogicOp(Opcode);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1286</td>
    <td class="codeLine">    return Instruction::isBitwiseLogicOp(Opcode);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1287</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1287</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1288</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1288</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1289</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1289</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1290</td>
    <td class="codeLine">struct is_idiv_op {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1290</td>
    <td class="codeLine">struct is_idiv_op {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1291</td>
    <td class="codeLine">  bool isOpType(unsigned Opcode) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1291</td>
    <td class="codeLine">  bool isOpType(unsigned Opcode) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1292</td>
    <td class="codeLine">    return Opcode == Instruction::SDiv || Opcode == Instruction::UDiv;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1292</td>
    <td class="codeLine">    return Opcode == Instruction::SDiv || Opcode == Instruction::UDiv;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1293</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1293</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1294</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1294</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1295</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1295</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1296</td>
    <td class="codeLine">struct is_irem_op {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1296</td>
    <td class="codeLine">struct is_irem_op {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1297</td>
    <td class="codeLine">  bool isOpType(unsigned Opcode) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1297</td>
    <td class="codeLine">  bool isOpType(unsigned Opcode) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1298</td>
    <td class="codeLine">    return Opcode == Instruction::SRem || Opcode == Instruction::URem;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1298</td>
    <td class="codeLine">    return Opcode == Instruction::SRem || Opcode == Instruction::URem;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1299</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1299</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1300</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1300</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1301</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1301</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1302</td>
    <td class="codeLine">/// Matches shift operations.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1302</td>
    <td class="codeLine">/// Matches shift operations.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1303</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1303</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1304</td>
    <td class="codeLine">inline BinOpPred_match<LHS, RHS, is_shift_op> m_Shift(const LHS &L,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1304</td>
    <td class="codeLine">inline BinOpPred_match<LHS, RHS, is_shift_op> m_Shift(const LHS &L,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1305</td>
    <td class="codeLine">                                                      const RHS &R) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1305</td>
    <td class="codeLine">                                                      const RHS &R) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1306</td>
    <td class="codeLine">  return BinOpPred_match<LHS, RHS, is_shift_op>(L, R);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1306</td>
    <td class="codeLine">  return BinOpPred_match<LHS, RHS, is_shift_op>(L, R);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1307</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1307</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1308</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1308</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1309</td>
    <td class="codeLine">/// Matches logical shift operations.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1309</td>
    <td class="codeLine">/// Matches logical shift operations.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1310</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1310</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1311</td>
    <td class="codeLine">inline BinOpPred_match<LHS, RHS, is_right_shift_op> m_Shr(const LHS &L,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1311</td>
    <td class="codeLine">inline BinOpPred_match<LHS, RHS, is_right_shift_op> m_Shr(const LHS &L,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1312</td>
    <td class="codeLine">                                                          const RHS &R) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1312</td>
    <td class="codeLine">                                                          const RHS &R) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1313</td>
    <td class="codeLine">  return BinOpPred_match<LHS, RHS, is_right_shift_op>(L, R);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1313</td>
    <td class="codeLine">  return BinOpPred_match<LHS, RHS, is_right_shift_op>(L, R);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1314</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1314</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1315</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1315</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1316</td>
    <td class="codeLine">/// Matches logical shift operations.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1316</td>
    <td class="codeLine">/// Matches logical shift operations.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1317</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1317</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1318</td>
    <td class="codeLine">inline BinOpPred_match<LHS, RHS, is_logical_shift_op></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1318</td>
    <td class="codeLine">inline BinOpPred_match<LHS, RHS, is_logical_shift_op></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1319</td>
    <td class="codeLine">m_LogicalShift(const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1319</td>
    <td class="codeLine">m_LogicalShift(const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1320</td>
    <td class="codeLine">  return BinOpPred_match<LHS, RHS, is_logical_shift_op>(L, R);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1320</td>
    <td class="codeLine">  return BinOpPred_match<LHS, RHS, is_logical_shift_op>(L, R);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1321</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1321</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1322</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1322</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1323</td>
    <td class="codeLine">/// Matches bitwise logic operations.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1323</td>
    <td class="codeLine">/// Matches bitwise logic operations.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1324</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1324</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1325</td>
    <td class="codeLine">inline BinOpPred_match<LHS, RHS, is_bitwiselogic_op></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1325</td>
    <td class="codeLine">inline BinOpPred_match<LHS, RHS, is_bitwiselogic_op></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1326</td>
    <td class="codeLine">m_BitwiseLogic(const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1326</td>
    <td class="codeLine">m_BitwiseLogic(const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1327</td>
    <td class="codeLine">  return BinOpPred_match<LHS, RHS, is_bitwiselogic_op>(L, R);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1327</td>
    <td class="codeLine">  return BinOpPred_match<LHS, RHS, is_bitwiselogic_op>(L, R);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1328</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1328</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1329</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1329</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1330</td>
    <td class="codeLine">/// Matches integer division operations.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1330</td>
    <td class="codeLine">/// Matches integer division operations.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1331</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1331</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1332</td>
    <td class="codeLine">inline BinOpPred_match<LHS, RHS, is_idiv_op> m_IDiv(const LHS &L,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1332</td>
    <td class="codeLine">inline BinOpPred_match<LHS, RHS, is_idiv_op> m_IDiv(const LHS &L,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1333</td>
    <td class="codeLine">                                                    const RHS &R) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1333</td>
    <td class="codeLine">                                                    const RHS &R) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1334</td>
    <td class="codeLine">  return BinOpPred_match<LHS, RHS, is_idiv_op>(L, R);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1334</td>
    <td class="codeLine">  return BinOpPred_match<LHS, RHS, is_idiv_op>(L, R);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1335</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1335</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1336</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1336</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1337</td>
    <td class="codeLine">/// Matches integer remainder operations.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1337</td>
    <td class="codeLine">/// Matches integer remainder operations.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1338</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1338</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1339</td>
    <td class="codeLine">inline BinOpPred_match<LHS, RHS, is_irem_op> m_IRem(const LHS &L,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1339</td>
    <td class="codeLine">inline BinOpPred_match<LHS, RHS, is_irem_op> m_IRem(const LHS &L,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1340</td>
    <td class="codeLine">                                                    const RHS &R) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1340</td>
    <td class="codeLine">                                                    const RHS &R) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1341</td>
    <td class="codeLine">  return BinOpPred_match<LHS, RHS, is_irem_op>(L, R);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1341</td>
    <td class="codeLine">  return BinOpPred_match<LHS, RHS, is_irem_op>(L, R);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1342</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1342</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1343</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1343</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1344</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1344</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1345</td>
    <td class="codeLine">// Class that matches exact binary ops.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1345</td>
    <td class="codeLine">// Class that matches exact binary ops.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1346</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1346</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1347</td>
    <td class="codeLine">template <typename SubPattern_t> struct Exact_match {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1347</td>
    <td class="codeLine">template <typename SubPattern_t> struct Exact_match {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1348</td>
    <td class="codeLine">  SubPattern_t SubPattern;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1348</td>
    <td class="codeLine">  SubPattern_t SubPattern;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1349</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1349</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1350</td>
    <td class="codeLine">  Exact_match(const SubPattern_t &SP) : SubPattern(SP) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1350</td>
    <td class="codeLine">  Exact_match(const SubPattern_t &SP) : SubPattern(SP) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1351</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1351</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1352</td>
    <td class="codeLine">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1352</td>
    <td class="codeLine">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1353</td>
    <td class="codeLine">    if (auto *PEO = dyn_cast<PossiblyExactOperator>(V))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1353</td>
    <td class="codeLine">    if (auto *PEO = dyn_cast<PossiblyExactOperator>(V))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1354</td>
    <td class="codeLine">      return PEO->isExact() && SubPattern.match(V);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1354</td>
    <td class="codeLine">      return PEO->isExact() && SubPattern.match(V);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1355</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1355</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1356</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1356</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1357</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1357</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1358</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1358</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1359</td>
    <td class="codeLine">template <typename T> inline Exact_match<T> m_Exact(const T &SubPattern) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1359</td>
    <td class="codeLine">template <typename T> inline Exact_match<T> m_Exact(const T &SubPattern) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1360</td>
    <td class="codeLine">  return SubPattern;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1360</td>
    <td class="codeLine">  return SubPattern;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1361</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1361</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1362</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1362</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1363</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1363</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1364</td>
    <td class="codeLine">// Matchers for CmpInst classes</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1364</td>
    <td class="codeLine">// Matchers for CmpInst classes</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1365</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1365</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1366</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1366</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1367</td>
    <td class="codeLine">template <typename LHS_t, typename RHS_t, typename Class, typename PredicateTy,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1367</td>
    <td class="codeLine">template <typename LHS_t, typename RHS_t, typename Class, typename PredicateTy,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1368</td>
    <td class="codeLine">          bool Commutable = false></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1368</td>
    <td class="codeLine">          bool Commutable = false></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1369</td>
    <td class="codeLine">struct CmpClass_match {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1369</td>
    <td class="codeLine">struct CmpClass_match {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1370</td>
    <td class="codeLine">  PredicateTy &Predicate;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1370</td>
    <td class="codeLine">  PredicateTy &Predicate;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1371</td>
    <td class="codeLine">  LHS_t L;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1371</td>
    <td class="codeLine">  LHS_t L;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1372</td>
    <td class="codeLine">  RHS_t R;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1372</td>
    <td class="codeLine">  RHS_t R;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1373</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1373</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1374</td>
    <td class="codeLine">  // The evaluation order is always stable, regardless of Commutability.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1374</td>
    <td class="codeLine">  // The evaluation order is always stable, regardless of Commutability.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1375</td>
    <td class="codeLine">  // The LHS is always matched first.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1375</td>
    <td class="codeLine">  // The LHS is always matched first.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1376</td>
    <td class="codeLine">  CmpClass_match(PredicateTy &Pred, const LHS_t &LHS, const RHS_t &RHS)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1376</td>
    <td class="codeLine">  CmpClass_match(PredicateTy &Pred, const LHS_t &LHS, const RHS_t &RHS)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1377</td>
    <td class="codeLine">      : Predicate(Pred), L(LHS), R(RHS) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1377</td>
    <td class="codeLine">      : Predicate(Pred), L(LHS), R(RHS) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1378</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1378</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1379</td>
    <td class="codeLine">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1379</td>
    <td class="codeLine">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1380</td>
    <td class="codeLine">    if (auto *I = dyn_cast<Class>(V)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1380</td>
    <td class="codeLine">    if (auto *I = dyn_cast<Class>(V)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1381</td>
    <td class="codeLine">      if (L.match(I->getOperand(0)) && R.match(I->getOperand(1))) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1381</td>
    <td class="codeLine">      if (L.match(I->getOperand(0)) && R.match(I->getOperand(1))) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1382</td>
    <td class="codeLine">        Predicate = I->getPredicate();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1382</td>
    <td class="codeLine">        Predicate = I->getPredicate();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1383</td>
    <td class="codeLine">        return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1383</td>
    <td class="codeLine">        return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1384</td>
    <td class="codeLine">      } else if (Commutable && L.match(I->getOperand(1)) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1384</td>
    <td class="codeLine">      } else if (Commutable && L.match(I->getOperand(1)) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1385</td>
    <td class="codeLine">                 R.match(I->getOperand(0))) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1385</td>
    <td class="codeLine">                 R.match(I->getOperand(0))) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1386</td>
    <td class="codeLine">        Predicate = I->getSwappedPredicate();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1386</td>
    <td class="codeLine">        Predicate = I->getSwappedPredicate();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1387</td>
    <td class="codeLine">        return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1387</td>
    <td class="codeLine">        return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1388</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1388</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1389</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1389</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1390</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1390</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1391</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1391</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1392</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1392</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1393</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1393</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1394</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1394</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1395</td>
    <td class="codeLine">inline CmpClass_match<LHS, RHS, CmpInst, CmpInst::Predicate></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1395</td>
    <td class="codeLine">inline CmpClass_match<LHS, RHS, CmpInst, CmpInst::Predicate></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1396</td>
    <td class="codeLine">m_Cmp(CmpInst::Predicate &Pred, const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1396</td>
    <td class="codeLine">m_Cmp(CmpInst::Predicate &Pred, const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1397</td>
    <td class="codeLine">  return CmpClass_match<LHS, RHS, CmpInst, CmpInst::Predicate>(Pred, L, R);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1397</td>
    <td class="codeLine">  return CmpClass_match<LHS, RHS, CmpInst, CmpInst::Predicate>(Pred, L, R);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1398</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1398</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1399</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1399</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1400</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1400</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1401</td>
    <td class="codeLine">inline CmpClass_match<LHS, RHS, ICmpInst, ICmpInst::Predicate></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1401</td>
    <td class="codeLine">inline CmpClass_match<LHS, RHS, ICmpInst, ICmpInst::Predicate></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1402</td>
    <td class="codeLine">m_ICmp(ICmpInst::Predicate &Pred, const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1402</td>
    <td class="codeLine">m_ICmp(ICmpInst::Predicate &Pred, const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1403</td>
    <td class="codeLine">  return CmpClass_match<LHS, RHS, ICmpInst, ICmpInst::Predicate>(Pred, L, R);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1403</td>
    <td class="codeLine">  return CmpClass_match<LHS, RHS, ICmpInst, ICmpInst::Predicate>(Pred, L, R);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1404</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1404</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1405</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1405</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1406</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1406</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1407</td>
    <td class="codeLine">inline CmpClass_match<LHS, RHS, FCmpInst, FCmpInst::Predicate></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1407</td>
    <td class="codeLine">inline CmpClass_match<LHS, RHS, FCmpInst, FCmpInst::Predicate></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1408</td>
    <td class="codeLine">m_FCmp(FCmpInst::Predicate &Pred, const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1408</td>
    <td class="codeLine">m_FCmp(FCmpInst::Predicate &Pred, const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1409</td>
    <td class="codeLine">  return CmpClass_match<LHS, RHS, FCmpInst, FCmpInst::Predicate>(Pred, L, R);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1409</td>
    <td class="codeLine">  return CmpClass_match<LHS, RHS, FCmpInst, FCmpInst::Predicate>(Pred, L, R);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1410</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1410</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1411</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1411</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1412</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1412</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1413</td>
    <td class="codeLine">// Matchers for instructions with a given opcode and number of operands.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1413</td>
    <td class="codeLine">// Matchers for instructions with a given opcode and number of operands.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1414</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1414</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1415</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1415</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1416</td>
    <td class="codeLine">/// Matches instructions with Opcode and three operands.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1416</td>
    <td class="codeLine">/// Matches instructions with Opcode and three operands.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1417</td>
    <td class="codeLine">template <typename T0, unsigned Opcode> struct OneOps_match {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1417</td>
    <td class="codeLine">template <typename T0, unsigned Opcode> struct OneOps_match {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1418</td>
    <td class="codeLine">  T0 Op1;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1418</td>
    <td class="codeLine">  T0 Op1;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1419</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1419</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1420</td>
    <td class="codeLine">  OneOps_match(const T0 &Op1) : Op1(Op1) {}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1420</td>
    <td class="codeLine">  OneOps_match(const T0 &Op1) : Op1(Op1) {}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1421</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1421</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1422</td>
    <td class="codeLine">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1422</td>
    <td class="codeLine">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1423</td>
    <td class="codeLine">    if (V->getValueID() == Value::InstructionVal + Opcode) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1423</td>
    <td class="codeLine">    if (V->getValueID() == Value::InstructionVal + Opcode) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1424</td>
    <td class="codeLine">      auto *I = cast<Instruction>(V);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1424</td>
    <td class="codeLine">      auto *I = cast<Instruction>(V);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1425</td>
    <td class="codeLine">      return Op1.match(I->getOperand(0));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1425</td>
    <td class="codeLine">      return Op1.match(I->getOperand(0));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1426</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1426</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1427</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1427</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1428</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1428</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1429</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1429</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1430</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1430</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1431</td>
    <td class="codeLine">/// Matches instructions with Opcode and three operands.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1431</td>
    <td class="codeLine">/// Matches instructions with Opcode and three operands.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1432</td>
    <td class="codeLine">template <typename T0, typename T1, unsigned Opcode> struct TwoOps_match {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1432</td>
    <td class="codeLine">template <typename T0, typename T1, unsigned Opcode> struct TwoOps_match {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1433</td>
    <td class="codeLine">  T0 Op1;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1433</td>
    <td class="codeLine">  T0 Op1;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1434</td>
    <td class="codeLine">  T1 Op2;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1434</td>
    <td class="codeLine">  T1 Op2;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1435</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1435</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1436</td>
    <td class="codeLine">  TwoOps_match(const T0 &Op1, const T1 &Op2) : Op1(Op1), Op2(Op2) {}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1436</td>
    <td class="codeLine">  TwoOps_match(const T0 &Op1, const T1 &Op2) : Op1(Op1), Op2(Op2) {}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1437</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1437</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1438</td>
    <td class="codeLine">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1438</td>
    <td class="codeLine">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1439</td>
    <td class="codeLine">    if (V->getValueID() == Value::InstructionVal + Opcode) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1439</td>
    <td class="codeLine">    if (V->getValueID() == Value::InstructionVal + Opcode) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1440</td>
    <td class="codeLine">      auto *I = cast<Instruction>(V);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1440</td>
    <td class="codeLine">      auto *I = cast<Instruction>(V);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1441</td>
    <td class="codeLine">      return Op1.match(I->getOperand(0)) && Op2.match(I->getOperand(1));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1441</td>
    <td class="codeLine">      return Op1.match(I->getOperand(0)) && Op2.match(I->getOperand(1));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1442</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1442</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1443</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1443</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1444</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1444</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1445</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1445</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1446</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1446</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1447</td>
    <td class="codeLine">/// Matches instructions with Opcode and three operands.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1447</td>
    <td class="codeLine">/// Matches instructions with Opcode and three operands.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1448</td>
    <td class="codeLine">template <typename T0, typename T1, typename T2, unsigned Opcode></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1448</td>
    <td class="codeLine">template <typename T0, typename T1, typename T2, unsigned Opcode></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1449</td>
    <td class="codeLine">struct ThreeOps_match {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1449</td>
    <td class="codeLine">struct ThreeOps_match {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1450</td>
    <td class="codeLine">  T0 Op1;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1450</td>
    <td class="codeLine">  T0 Op1;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1451</td>
    <td class="codeLine">  T1 Op2;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1451</td>
    <td class="codeLine">  T1 Op2;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1452</td>
    <td class="codeLine">  T2 Op3;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1452</td>
    <td class="codeLine">  T2 Op3;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1453</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1453</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1454</td>
    <td class="codeLine">  ThreeOps_match(const T0 &Op1, const T1 &Op2, const T2 &Op3)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1454</td>
    <td class="codeLine">  ThreeOps_match(const T0 &Op1, const T1 &Op2, const T2 &Op3)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1455</td>
    <td class="codeLine">      : Op1(Op1), Op2(Op2), Op3(Op3) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1455</td>
    <td class="codeLine">      : Op1(Op1), Op2(Op2), Op3(Op3) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1456</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1456</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1457</td>
    <td class="codeLine">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1457</td>
    <td class="codeLine">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1458</td>
    <td class="codeLine">    if (V->getValueID() == Value::InstructionVal + Opcode) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1458</td>
    <td class="codeLine">    if (V->getValueID() == Value::InstructionVal + Opcode) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1459</td>
    <td class="codeLine">      auto *I = cast<Instruction>(V);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1459</td>
    <td class="codeLine">      auto *I = cast<Instruction>(V);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1460</td>
    <td class="codeLine">      return Op1.match(I->getOperand(0)) && Op2.match(I->getOperand(1)) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1460</td>
    <td class="codeLine">      return Op1.match(I->getOperand(0)) && Op2.match(I->getOperand(1)) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1461</td>
    <td class="codeLine">             Op3.match(I->getOperand(2));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1461</td>
    <td class="codeLine">             Op3.match(I->getOperand(2));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1462</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1462</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1463</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1463</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1464</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1464</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1465</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1465</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1466</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1466</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1467</td>
    <td class="codeLine">/// Matches SelectInst.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1467</td>
    <td class="codeLine">/// Matches SelectInst.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1468</td>
    <td class="codeLine">template <typename Cond, typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1468</td>
    <td class="codeLine">template <typename Cond, typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1469</td>
    <td class="codeLine">inline ThreeOps_match<Cond, LHS, RHS, Instruction::Select></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1469</td>
    <td class="codeLine">inline ThreeOps_match<Cond, LHS, RHS, Instruction::Select></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1470</td>
    <td class="codeLine">m_Select(const Cond &C, const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1470</td>
    <td class="codeLine">m_Select(const Cond &C, const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1471</td>
    <td class="codeLine">  return ThreeOps_match<Cond, LHS, RHS, Instruction::Select>(C, L, R);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1471</td>
    <td class="codeLine">  return ThreeOps_match<Cond, LHS, RHS, Instruction::Select>(C, L, R);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1472</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1472</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1473</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1473</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1474</td>
    <td class="codeLine">/// This matches a select of two constants, e.g.:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1474</td>
    <td class="codeLine">/// This matches a select of two constants, e.g.:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1475</td>
    <td class="codeLine">/// m_SelectCst<-1, 0>(m_Value(V))</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1475</td>
    <td class="codeLine">/// m_SelectCst<-1, 0>(m_Value(V))</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1476</td>
    <td class="codeLine">template <int64_t L, int64_t R, typename Cond></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1476</td>
    <td class="codeLine">template <int64_t L, int64_t R, typename Cond></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1477</td>
    <td class="codeLine">inline ThreeOps_match<Cond, constantint_match<L>, constantint_match<R>,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1477</td>
    <td class="codeLine">inline ThreeOps_match<Cond, constantint_match<L>, constantint_match<R>,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1478</td>
    <td class="codeLine">                      Instruction::Select></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1478</td>
    <td class="codeLine">                      Instruction::Select></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1479</td>
    <td class="codeLine">m_SelectCst(const Cond &C) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1479</td>
    <td class="codeLine">m_SelectCst(const Cond &C) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1480</td>
    <td class="codeLine">  return m_Select(C, m_ConstantInt<L>(), m_ConstantInt<R>());</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1480</td>
    <td class="codeLine">  return m_Select(C, m_ConstantInt<L>(), m_ConstantInt<R>());</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1481</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1481</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1482</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1482</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1483</td>
    <td class="codeLine">/// Matches FreezeInst.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1483</td>
    <td class="codeLine">/// Matches FreezeInst.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1484</td>
    <td class="codeLine">template <typename OpTy></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1484</td>
    <td class="codeLine">template <typename OpTy></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1485</td>
    <td class="codeLine">inline OneOps_match<OpTy, Instruction::Freeze> m_Freeze(const OpTy &Op) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1485</td>
    <td class="codeLine">inline OneOps_match<OpTy, Instruction::Freeze> m_Freeze(const OpTy &Op) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1486</td>
    <td class="codeLine">  return OneOps_match<OpTy, Instruction::Freeze>(Op);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1486</td>
    <td class="codeLine">  return OneOps_match<OpTy, Instruction::Freeze>(Op);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1487</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1487</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1488</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1488</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1489</td>
    <td class="codeLine">/// Matches InsertElementInst.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1489</td>
    <td class="codeLine">/// Matches InsertElementInst.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1490</td>
    <td class="codeLine">template <typename Val_t, typename Elt_t, typename Idx_t></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1490</td>
    <td class="codeLine">template <typename Val_t, typename Elt_t, typename Idx_t></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1491</td>
    <td class="codeLine">inline ThreeOps_match<Val_t, Elt_t, Idx_t, Instruction::InsertElement></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1491</td>
    <td class="codeLine">inline ThreeOps_match<Val_t, Elt_t, Idx_t, Instruction::InsertElement></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1492</td>
    <td class="codeLine">m_InsertElt(const Val_t &Val, const Elt_t &Elt, const Idx_t &Idx) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1492</td>
    <td class="codeLine">m_InsertElt(const Val_t &Val, const Elt_t &Elt, const Idx_t &Idx) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1493</td>
    <td class="codeLine">  return ThreeOps_match<Val_t, Elt_t, Idx_t, Instruction::InsertElement>(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1493</td>
    <td class="codeLine">  return ThreeOps_match<Val_t, Elt_t, Idx_t, Instruction::InsertElement>(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1494</td>
    <td class="codeLine">      Val, Elt, Idx);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1494</td>
    <td class="codeLine">      Val, Elt, Idx);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1495</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1495</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1496</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1496</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1497</td>
    <td class="codeLine">/// Matches ExtractElementInst.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1497</td>
    <td class="codeLine">/// Matches ExtractElementInst.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1498</td>
    <td class="codeLine">template <typename Val_t, typename Idx_t></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1498</td>
    <td class="codeLine">template <typename Val_t, typename Idx_t></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1499</td>
    <td class="codeLine">inline TwoOps_match<Val_t, Idx_t, Instruction::ExtractElement></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1499</td>
    <td class="codeLine">inline TwoOps_match<Val_t, Idx_t, Instruction::ExtractElement></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1500</td>
    <td class="codeLine">m_ExtractElt(const Val_t &Val, const Idx_t &Idx) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1500</td>
    <td class="codeLine">m_ExtractElt(const Val_t &Val, const Idx_t &Idx) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1501</td>
    <td class="codeLine">  return TwoOps_match<Val_t, Idx_t, Instruction::ExtractElement>(Val, Idx);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1501</td>
    <td class="codeLine">  return TwoOps_match<Val_t, Idx_t, Instruction::ExtractElement>(Val, Idx);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1502</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1502</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1503</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1503</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1504</td>
    <td class="codeLine">/// Matches shuffle.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1504</td>
    <td class="codeLine">/// Matches shuffle.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1505</td>
    <td class="codeLine">template <typename T0, typename T1, typename T2> struct Shuffle_match {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1505</td>
    <td class="codeLine">template <typename T0, typename T1, typename T2> struct Shuffle_match {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1506</td>
    <td class="codeLine">  T0 Op1;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1506</td>
    <td class="codeLine">  T0 Op1;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1507</td>
    <td class="codeLine">  T1 Op2;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1507</td>
    <td class="codeLine">  T1 Op2;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1508</td>
    <td class="codeLine">  T2 Mask;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1508</td>
    <td class="codeLine">  T2 Mask;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1509</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1509</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1510</td>
    <td class="codeLine">  Shuffle_match(const T0 &Op1, const T1 &Op2, const T2 &Mask)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1510</td>
    <td class="codeLine">  Shuffle_match(const T0 &Op1, const T1 &Op2, const T2 &Mask)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1511</td>
    <td class="codeLine">      : Op1(Op1), Op2(Op2), Mask(Mask) {}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1511</td>
    <td class="codeLine">      : Op1(Op1), Op2(Op2), Mask(Mask) {}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1512</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1512</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1513</td>
    <td class="codeLine">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1513</td>
    <td class="codeLine">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1514</td>
    <td class="codeLine">    if (auto *I = dyn_cast<ShuffleVectorInst>(V)) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1514</td>
    <td class="codeLine">    if (auto *I = dyn_cast<ShuffleVectorInst>(V)) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1515</td>
    <td class="codeLine">      return Op1.match(I->getOperand(0)) && Op2.match(I->getOperand(1)) &&</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1515</td>
    <td class="codeLine">      return Op1.match(I->getOperand(0)) && Op2.match(I->getOperand(1)) &&</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1516</td>
    <td class="codeLine">             Mask.match(I->getShuffleMask());</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1516</td>
    <td class="codeLine">             Mask.match(I->getShuffleMask());</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1517</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1517</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1518</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1518</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1519</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1519</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1520</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1520</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1521</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1521</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1522</td>
    <td class="codeLine">struct m_Mask {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1522</td>
    <td class="codeLine">struct m_Mask {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1523</td>
    <td class="codeLine">  ArrayRef<int> &MaskRef;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1523</td>
    <td class="codeLine">  ArrayRef<int> &MaskRef;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1524</td>
    <td class="codeLine">  m_Mask(ArrayRef<int> &MaskRef) : MaskRef(MaskRef) {}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1524</td>
    <td class="codeLine">  m_Mask(ArrayRef<int> &MaskRef) : MaskRef(MaskRef) {}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1525</td>
    <td class="codeLine">  bool match(ArrayRef<int> Mask) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1525</td>
    <td class="codeLine">  bool match(ArrayRef<int> Mask) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1526</td>
    <td class="codeLine">    MaskRef = Mask;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1526</td>
    <td class="codeLine">    MaskRef = Mask;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1527</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1527</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1528</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1528</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1529</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1529</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1530</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1530</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1531</td>
    <td class="codeLine">struct m_ZeroMask {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1531</td>
    <td class="codeLine">struct m_ZeroMask {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1532</td>
    <td class="codeLine">  bool match(ArrayRef<int> Mask) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1532</td>
    <td class="codeLine">  bool match(ArrayRef<int> Mask) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1533</td>
    <td class="codeLine">    return all_of(Mask, [](int Elem) { return Elem == 0 || Elem == -1; });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1533</td>
    <td class="codeLine">    return all_of(Mask, [](int Elem) { return Elem == 0 || Elem == -1; });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1534</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1534</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1535</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1535</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1536</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1536</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1537</td>
    <td class="codeLine">struct m_SpecificMask {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1537</td>
    <td class="codeLine">struct m_SpecificMask {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1538</td>
    <td class="codeLine">  ArrayRef<int> &MaskRef;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1538</td>
    <td class="codeLine">  ArrayRef<int> &MaskRef;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1539</td>
    <td class="codeLine">  m_SpecificMask(ArrayRef<int> &MaskRef) : MaskRef(MaskRef) {}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1539</td>
    <td class="codeLine">  m_SpecificMask(ArrayRef<int> &MaskRef) : MaskRef(MaskRef) {}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1540</td>
    <td class="codeLine">  bool match(ArrayRef<int> Mask) { return MaskRef == Mask; }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1540</td>
    <td class="codeLine">  bool match(ArrayRef<int> Mask) { return MaskRef == Mask; }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1541</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1541</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1542</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1542</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1543</td>
    <td class="codeLine">struct m_SplatOrUndefMask {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1543</td>
    <td class="codeLine">struct m_SplatOrUndefMask {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1544</td>
    <td class="codeLine">  int &SplatIndex;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1544</td>
    <td class="codeLine">  int &SplatIndex;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1545</td>
    <td class="codeLine">  m_SplatOrUndefMask(int &SplatIndex) : SplatIndex(SplatIndex) {}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1545</td>
    <td class="codeLine">  m_SplatOrUndefMask(int &SplatIndex) : SplatIndex(SplatIndex) {}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1546</td>
    <td class="codeLine">  bool match(ArrayRef<int> Mask) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1546</td>
    <td class="codeLine">  bool match(ArrayRef<int> Mask) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1547</td>
    <td class="codeLine">    const auto *First = find_if(Mask, [](int Elem) { return Elem != -1; });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1547</td>
    <td class="codeLine">    const auto *First = find_if(Mask, [](int Elem) { return Elem != -1; });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1548</td>
    <td class="codeLine">    if (First == Mask.end())</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1548</td>
    <td class="codeLine">    if (First == Mask.end())</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1549</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1549</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1550</td>
    <td class="codeLine">    SplatIndex = *First;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1550</td>
    <td class="codeLine">    SplatIndex = *First;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1551</td>
    <td class="codeLine">    return all_of(Mask,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1551</td>
    <td class="codeLine">    return all_of(Mask,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1552</td>
    <td class="codeLine">                  [First](int Elem) { return Elem == *First || Elem == -1; });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1552</td>
    <td class="codeLine">                  [First](int Elem) { return Elem == *First || Elem == -1; });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1553</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1553</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1554</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1554</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1555</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1555</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1556</td>
    <td class="codeLine">/// Matches ShuffleVectorInst independently of mask value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1556</td>
    <td class="codeLine">/// Matches ShuffleVectorInst independently of mask value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1557</td>
    <td class="codeLine">template <typename V1_t, typename V2_t></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1557</td>
    <td class="codeLine">template <typename V1_t, typename V2_t></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1558</td>
    <td class="codeLine">inline TwoOps_match<V1_t, V2_t, Instruction::ShuffleVector></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1558</td>
    <td class="codeLine">inline TwoOps_match<V1_t, V2_t, Instruction::ShuffleVector></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1559</td>
    <td class="codeLine">m_Shuffle(const V1_t &v1, const V2_t &v2) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1559</td>
    <td class="codeLine">m_Shuffle(const V1_t &v1, const V2_t &v2) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1560</td>
    <td class="codeLine">  return TwoOps_match<V1_t, V2_t, Instruction::ShuffleVector>(v1, v2);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1560</td>
    <td class="codeLine">  return TwoOps_match<V1_t, V2_t, Instruction::ShuffleVector>(v1, v2);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1561</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1561</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1562</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1562</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1563</td>
    <td class="codeLine">template <typename V1_t, typename V2_t, typename Mask_t></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1563</td>
    <td class="codeLine">template <typename V1_t, typename V2_t, typename Mask_t></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1564</td>
    <td class="codeLine">inline Shuffle_match<V1_t, V2_t, Mask_t></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1564</td>
    <td class="codeLine">inline Shuffle_match<V1_t, V2_t, Mask_t></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1565</td>
    <td class="codeLine">m_Shuffle(const V1_t &v1, const V2_t &v2, const Mask_t &mask) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1565</td>
    <td class="codeLine">m_Shuffle(const V1_t &v1, const V2_t &v2, const Mask_t &mask) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1566</td>
    <td class="codeLine">  return Shuffle_match<V1_t, V2_t, Mask_t>(v1, v2, mask);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1566</td>
    <td class="codeLine">  return Shuffle_match<V1_t, V2_t, Mask_t>(v1, v2, mask);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1567</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1567</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1568</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1568</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1569</td>
    <td class="codeLine">/// Matches LoadInst.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1569</td>
    <td class="codeLine">/// Matches LoadInst.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1570</td>
    <td class="codeLine">template <typename OpTy></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1570</td>
    <td class="codeLine">template <typename OpTy></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1571</td>
    <td class="codeLine">inline OneOps_match<OpTy, Instruction::Load> m_Load(const OpTy &Op) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1571</td>
    <td class="codeLine">inline OneOps_match<OpTy, Instruction::Load> m_Load(const OpTy &Op) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1572</td>
    <td class="codeLine">  return OneOps_match<OpTy, Instruction::Load>(Op);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1572</td>
    <td class="codeLine">  return OneOps_match<OpTy, Instruction::Load>(Op);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1573</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1573</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1574</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1574</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1575</td>
    <td class="codeLine">/// Matches StoreInst.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1575</td>
    <td class="codeLine">/// Matches StoreInst.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1576</td>
    <td class="codeLine">template <typename ValueOpTy, typename PointerOpTy></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1576</td>
    <td class="codeLine">template <typename ValueOpTy, typename PointerOpTy></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1577</td>
    <td class="codeLine">inline TwoOps_match<ValueOpTy, PointerOpTy, Instruction::Store></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1577</td>
    <td class="codeLine">inline TwoOps_match<ValueOpTy, PointerOpTy, Instruction::Store></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1578</td>
    <td class="codeLine">m_Store(const ValueOpTy &ValueOp, const PointerOpTy &PointerOp) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1578</td>
    <td class="codeLine">m_Store(const ValueOpTy &ValueOp, const PointerOpTy &PointerOp) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1579</td>
    <td class="codeLine">  return TwoOps_match<ValueOpTy, PointerOpTy, Instruction::Store>(ValueOp,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1579</td>
    <td class="codeLine">  return TwoOps_match<ValueOpTy, PointerOpTy, Instruction::Store>(ValueOp,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1580</td>
    <td class="codeLine">                                                                  PointerOp);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1580</td>
    <td class="codeLine">                                                                  PointerOp);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1581</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1581</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1582</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1582</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1583</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1583</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1584</td>
    <td class="codeLine">// Matchers for CastInst classes</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1584</td>
    <td class="codeLine">// Matchers for CastInst classes</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1585</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1585</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1586</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1586</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1587</td>
    <td class="codeLine">template <typename Op_t, unsigned Opcode> struct CastClass_match {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1587</td>
    <td class="codeLine">template <typename Op_t, unsigned Opcode> struct CastClass_match {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1588</td>
    <td class="codeLine">  Op_t Op;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1588</td>
    <td class="codeLine">  Op_t Op;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1589</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1589</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1590</td>
    <td class="codeLine">  CastClass_match(const Op_t &OpMatch) : Op(OpMatch) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1590</td>
    <td class="codeLine">  CastClass_match(const Op_t &OpMatch) : Op(OpMatch) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1591</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1591</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1592</td>
    <td class="codeLine">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1592</td>
    <td class="codeLine">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1593</td>
    <td class="codeLine">    if (auto *O = dyn_cast<Operator>(V))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1593</td>
    <td class="codeLine">    if (auto *O = dyn_cast<Operator>(V))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1594</td>
    <td class="codeLine">      return O->getOpcode() == Opcode && Op.match(O->getOperand(0));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1594</td>
    <td class="codeLine">      return O->getOpcode() == Opcode && Op.match(O->getOperand(0));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1595</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1595</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1596</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1596</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1597</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1597</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1598</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1598</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1599</td>
    <td class="codeLine">template <typename Op_t> struct PtrToIntSameSize_match {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1599</td>
    <td class="codeLine">template <typename Op_t> struct PtrToIntSameSize_match {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1600</td>
    <td class="codeLine">  const DataLayout &DL;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1600</td>
    <td class="codeLine">  const DataLayout &DL;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1601</td>
    <td class="codeLine">  Op_t Op;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1601</td>
    <td class="codeLine">  Op_t Op;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1602</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1602</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1603</td>
    <td class="codeLine">  PtrToIntSameSize_match(const DataLayout &DL, const Op_t &OpMatch)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1603</td>
    <td class="codeLine">  PtrToIntSameSize_match(const DataLayout &DL, const Op_t &OpMatch)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1604</td>
    <td class="codeLine">      : DL(DL), Op(OpMatch) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1604</td>
    <td class="codeLine">      : DL(DL), Op(OpMatch) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1605</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1605</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1606</td>
    <td class="codeLine">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1606</td>
    <td class="codeLine">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1607</td>
    <td class="codeLine">    if (auto *O = dyn_cast<Operator>(V))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1607</td>
    <td class="codeLine">    if (auto *O = dyn_cast<Operator>(V))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1608</td>
    <td class="codeLine">      return O->getOpcode() == Instruction::PtrToInt &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1608</td>
    <td class="codeLine">      return O->getOpcode() == Instruction::PtrToInt &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1609</td>
    <td class="codeLine">             DL.getTypeSizeInBits(O->getType()) ==</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1609</td>
    <td class="codeLine">             DL.getTypeSizeInBits(O->getType()) ==</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1610</td>
    <td class="codeLine">                 DL.getTypeSizeInBits(O->getOperand(0)->getType()) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1610</td>
    <td class="codeLine">                 DL.getTypeSizeInBits(O->getOperand(0)->getType()) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1611</td>
    <td class="codeLine">             Op.match(O->getOperand(0));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1611</td>
    <td class="codeLine">             Op.match(O->getOperand(0));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1612</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1612</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1613</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1613</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1614</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1614</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1615</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1615</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1616</td>
    <td class="codeLine">/// Matches BitCast.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1616</td>
    <td class="codeLine">/// Matches BitCast.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1617</td>
    <td class="codeLine">template <typename OpTy></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1617</td>
    <td class="codeLine">template <typename OpTy></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1618</td>
    <td class="codeLine">inline CastClass_match<OpTy, Instruction::BitCast> m_BitCast(const OpTy &Op) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1618</td>
    <td class="codeLine">inline CastClass_match<OpTy, Instruction::BitCast> m_BitCast(const OpTy &Op) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1619</td>
    <td class="codeLine">  return CastClass_match<OpTy, Instruction::BitCast>(Op);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1619</td>
    <td class="codeLine">  return CastClass_match<OpTy, Instruction::BitCast>(Op);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1620</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1620</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1621</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1621</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1622</td>
    <td class="codeLine">/// Matches PtrToInt.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1622</td>
    <td class="codeLine">/// Matches PtrToInt.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1623</td>
    <td class="codeLine">template <typename OpTy></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1623</td>
    <td class="codeLine">template <typename OpTy></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1624</td>
    <td class="codeLine">inline CastClass_match<OpTy, Instruction::PtrToInt> m_PtrToInt(const OpTy &Op) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1624</td>
    <td class="codeLine">inline CastClass_match<OpTy, Instruction::PtrToInt> m_PtrToInt(const OpTy &Op) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1625</td>
    <td class="codeLine">  return CastClass_match<OpTy, Instruction::PtrToInt>(Op);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1625</td>
    <td class="codeLine">  return CastClass_match<OpTy, Instruction::PtrToInt>(Op);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1626</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1626</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1627</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1627</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1628</td>
    <td class="codeLine">template <typename OpTy></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1628</td>
    <td class="codeLine">template <typename OpTy></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1629</td>
    <td class="codeLine">inline PtrToIntSameSize_match<OpTy> m_PtrToIntSameSize(const DataLayout &DL,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1629</td>
    <td class="codeLine">inline PtrToIntSameSize_match<OpTy> m_PtrToIntSameSize(const DataLayout &DL,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1630</td>
    <td class="codeLine">                                                       const OpTy &Op) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1630</td>
    <td class="codeLine">                                                       const OpTy &Op) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1631</td>
    <td class="codeLine">  return PtrToIntSameSize_match<OpTy>(DL, Op);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1631</td>
    <td class="codeLine">  return PtrToIntSameSize_match<OpTy>(DL, Op);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1632</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1632</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1633</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1633</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1634</td>
    <td class="codeLine">/// Matches IntToPtr.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1634</td>
    <td class="codeLine">/// Matches IntToPtr.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1635</td>
    <td class="codeLine">template <typename OpTy></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1635</td>
    <td class="codeLine">template <typename OpTy></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1636</td>
    <td class="codeLine">inline CastClass_match<OpTy, Instruction::IntToPtr> m_IntToPtr(const OpTy &Op) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1636</td>
    <td class="codeLine">inline CastClass_match<OpTy, Instruction::IntToPtr> m_IntToPtr(const OpTy &Op) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1637</td>
    <td class="codeLine">  return CastClass_match<OpTy, Instruction::IntToPtr>(Op);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1637</td>
    <td class="codeLine">  return CastClass_match<OpTy, Instruction::IntToPtr>(Op);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1638</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1638</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1639</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1639</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1640</td>
    <td class="codeLine">/// Matches Trunc.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1640</td>
    <td class="codeLine">/// Matches Trunc.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1641</td>
    <td class="codeLine">template <typename OpTy></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1641</td>
    <td class="codeLine">template <typename OpTy></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1642</td>
    <td class="codeLine">inline CastClass_match<OpTy, Instruction::Trunc> m_Trunc(const OpTy &Op) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1642</td>
    <td class="codeLine">inline CastClass_match<OpTy, Instruction::Trunc> m_Trunc(const OpTy &Op) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1643</td>
    <td class="codeLine">  return CastClass_match<OpTy, Instruction::Trunc>(Op);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1643</td>
    <td class="codeLine">  return CastClass_match<OpTy, Instruction::Trunc>(Op);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1644</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1644</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1645</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1645</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1646</td>
    <td class="codeLine">template <typename OpTy></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1646</td>
    <td class="codeLine">template <typename OpTy></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1647</td>
    <td class="codeLine">inline match_combine_or<CastClass_match<OpTy, Instruction::Trunc>, OpTy></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1647</td>
    <td class="codeLine">inline match_combine_or<CastClass_match<OpTy, Instruction::Trunc>, OpTy></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1648</td>
    <td class="codeLine">m_TruncOrSelf(const OpTy &Op) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1648</td>
    <td class="codeLine">m_TruncOrSelf(const OpTy &Op) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1649</td>
    <td class="codeLine">  return m_CombineOr(m_Trunc(Op), Op);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1649</td>
    <td class="codeLine">  return m_CombineOr(m_Trunc(Op), Op);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1650</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1650</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1651</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1651</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1652</td>
    <td class="codeLine">/// Matches SExt.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1652</td>
    <td class="codeLine">/// Matches SExt.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1653</td>
    <td class="codeLine">template <typename OpTy></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1653</td>
    <td class="codeLine">template <typename OpTy></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1654</td>
    <td class="codeLine">inline CastClass_match<OpTy, Instruction::SExt> m_SExt(const OpTy &Op) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1654</td>
    <td class="codeLine">inline CastClass_match<OpTy, Instruction::SExt> m_SExt(const OpTy &Op) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1655</td>
    <td class="codeLine">  return CastClass_match<OpTy, Instruction::SExt>(Op);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1655</td>
    <td class="codeLine">  return CastClass_match<OpTy, Instruction::SExt>(Op);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1656</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1656</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1657</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1657</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1658</td>
    <td class="codeLine">/// Matches ZExt.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1658</td>
    <td class="codeLine">/// Matches ZExt.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1659</td>
    <td class="codeLine">template <typename OpTy></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1659</td>
    <td class="codeLine">template <typename OpTy></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1660</td>
    <td class="codeLine">inline CastClass_match<OpTy, Instruction::ZExt> m_ZExt(const OpTy &Op) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1660</td>
    <td class="codeLine">inline CastClass_match<OpTy, Instruction::ZExt> m_ZExt(const OpTy &Op) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1661</td>
    <td class="codeLine">  return CastClass_match<OpTy, Instruction::ZExt>(Op);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1661</td>
    <td class="codeLine">  return CastClass_match<OpTy, Instruction::ZExt>(Op);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1662</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1662</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1663</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1663</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1664</td>
    <td class="codeLine">template <typename OpTy></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1664</td>
    <td class="codeLine">template <typename OpTy></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1665</td>
    <td class="codeLine">inline match_combine_or<CastClass_match<OpTy, Instruction::ZExt>, OpTy></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1665</td>
    <td class="codeLine">inline match_combine_or<CastClass_match<OpTy, Instruction::ZExt>, OpTy></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1666</td>
    <td class="codeLine">m_ZExtOrSelf(const OpTy &Op) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1666</td>
    <td class="codeLine">m_ZExtOrSelf(const OpTy &Op) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1667</td>
    <td class="codeLine">  return m_CombineOr(m_ZExt(Op), Op);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1667</td>
    <td class="codeLine">  return m_CombineOr(m_ZExt(Op), Op);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1668</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1668</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1669</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1669</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1670</td>
    <td class="codeLine">template <typename OpTy></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1670</td>
    <td class="codeLine">template <typename OpTy></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1671</td>
    <td class="codeLine">inline match_combine_or<CastClass_match<OpTy, Instruction::SExt>, OpTy></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1671</td>
    <td class="codeLine">inline match_combine_or<CastClass_match<OpTy, Instruction::SExt>, OpTy></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1672</td>
    <td class="codeLine">m_SExtOrSelf(const OpTy &Op) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1672</td>
    <td class="codeLine">m_SExtOrSelf(const OpTy &Op) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1673</td>
    <td class="codeLine">  return m_CombineOr(m_SExt(Op), Op);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1673</td>
    <td class="codeLine">  return m_CombineOr(m_SExt(Op), Op);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1674</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1674</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1675</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1675</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1676</td>
    <td class="codeLine">template <typename OpTy></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1676</td>
    <td class="codeLine">template <typename OpTy></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1677</td>
    <td class="codeLine">inline match_combine_or<CastClass_match<OpTy, Instruction::ZExt>,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1677</td>
    <td class="codeLine">inline match_combine_or<CastClass_match<OpTy, Instruction::ZExt>,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1678</td>
    <td class="codeLine">                        CastClass_match<OpTy, Instruction::SExt>></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1678</td>
    <td class="codeLine">                        CastClass_match<OpTy, Instruction::SExt>></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1679</td>
    <td class="codeLine">m_ZExtOrSExt(const OpTy &Op) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1679</td>
    <td class="codeLine">m_ZExtOrSExt(const OpTy &Op) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1680</td>
    <td class="codeLine">  return m_CombineOr(m_ZExt(Op), m_SExt(Op));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1680</td>
    <td class="codeLine">  return m_CombineOr(m_ZExt(Op), m_SExt(Op));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1681</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1681</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1682</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1682</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1683</td>
    <td class="codeLine">template <typename OpTy></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1683</td>
    <td class="codeLine">template <typename OpTy></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1684</td>
    <td class="codeLine">inline match_combine_or<</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1684</td>
    <td class="codeLine">inline match_combine_or<</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1685</td>
    <td class="codeLine">    match_combine_or<CastClass_match<OpTy, Instruction::ZExt>,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1685</td>
    <td class="codeLine">    match_combine_or<CastClass_match<OpTy, Instruction::ZExt>,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1686</td>
    <td class="codeLine">                     CastClass_match<OpTy, Instruction::SExt>>,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1686</td>
    <td class="codeLine">                     CastClass_match<OpTy, Instruction::SExt>>,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1687</td>
    <td class="codeLine">    OpTy></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1687</td>
    <td class="codeLine">    OpTy></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1688</td>
    <td class="codeLine">m_ZExtOrSExtOrSelf(const OpTy &Op) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1688</td>
    <td class="codeLine">m_ZExtOrSExtOrSelf(const OpTy &Op) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1689</td>
    <td class="codeLine">  return m_CombineOr(m_ZExtOrSExt(Op), Op);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1689</td>
    <td class="codeLine">  return m_CombineOr(m_ZExtOrSExt(Op), Op);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1690</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1690</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1691</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1691</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1692</td>
    <td class="codeLine">template <typename OpTy></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1692</td>
    <td class="codeLine">template <typename OpTy></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1693</td>
    <td class="codeLine">inline CastClass_match<OpTy, Instruction::UIToFP> m_UIToFP(const OpTy &Op) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1693</td>
    <td class="codeLine">inline CastClass_match<OpTy, Instruction::UIToFP> m_UIToFP(const OpTy &Op) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1694</td>
    <td class="codeLine">  return CastClass_match<OpTy, Instruction::UIToFP>(Op);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1694</td>
    <td class="codeLine">  return CastClass_match<OpTy, Instruction::UIToFP>(Op);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1695</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1695</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1696</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1696</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1697</td>
    <td class="codeLine">template <typename OpTy></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1697</td>
    <td class="codeLine">template <typename OpTy></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1698</td>
    <td class="codeLine">inline CastClass_match<OpTy, Instruction::SIToFP> m_SIToFP(const OpTy &Op) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1698</td>
    <td class="codeLine">inline CastClass_match<OpTy, Instruction::SIToFP> m_SIToFP(const OpTy &Op) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1699</td>
    <td class="codeLine">  return CastClass_match<OpTy, Instruction::SIToFP>(Op);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1699</td>
    <td class="codeLine">  return CastClass_match<OpTy, Instruction::SIToFP>(Op);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1700</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1700</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1701</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1701</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1702</td>
    <td class="codeLine">template <typename OpTy></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1702</td>
    <td class="codeLine">template <typename OpTy></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1703</td>
    <td class="codeLine">inline CastClass_match<OpTy, Instruction::FPToUI> m_FPToUI(const OpTy &Op) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1703</td>
    <td class="codeLine">inline CastClass_match<OpTy, Instruction::FPToUI> m_FPToUI(const OpTy &Op) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1704</td>
    <td class="codeLine">  return CastClass_match<OpTy, Instruction::FPToUI>(Op);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1704</td>
    <td class="codeLine">  return CastClass_match<OpTy, Instruction::FPToUI>(Op);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1705</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1705</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1706</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1706</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1707</td>
    <td class="codeLine">template <typename OpTy></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1707</td>
    <td class="codeLine">template <typename OpTy></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1708</td>
    <td class="codeLine">inline CastClass_match<OpTy, Instruction::FPToSI> m_FPToSI(const OpTy &Op) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1708</td>
    <td class="codeLine">inline CastClass_match<OpTy, Instruction::FPToSI> m_FPToSI(const OpTy &Op) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1709</td>
    <td class="codeLine">  return CastClass_match<OpTy, Instruction::FPToSI>(Op);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1709</td>
    <td class="codeLine">  return CastClass_match<OpTy, Instruction::FPToSI>(Op);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1710</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1710</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1711</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1711</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1712</td>
    <td class="codeLine">template <typename OpTy></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1712</td>
    <td class="codeLine">template <typename OpTy></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1713</td>
    <td class="codeLine">inline CastClass_match<OpTy, Instruction::FPTrunc> m_FPTrunc(const OpTy &Op) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1713</td>
    <td class="codeLine">inline CastClass_match<OpTy, Instruction::FPTrunc> m_FPTrunc(const OpTy &Op) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1714</td>
    <td class="codeLine">  return CastClass_match<OpTy, Instruction::FPTrunc>(Op);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1714</td>
    <td class="codeLine">  return CastClass_match<OpTy, Instruction::FPTrunc>(Op);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1715</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1715</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1716</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1716</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1717</td>
    <td class="codeLine">template <typename OpTy></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1717</td>
    <td class="codeLine">template <typename OpTy></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1718</td>
    <td class="codeLine">inline CastClass_match<OpTy, Instruction::FPExt> m_FPExt(const OpTy &Op) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1718</td>
    <td class="codeLine">inline CastClass_match<OpTy, Instruction::FPExt> m_FPExt(const OpTy &Op) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1719</td>
    <td class="codeLine">  return CastClass_match<OpTy, Instruction::FPExt>(Op);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1719</td>
    <td class="codeLine">  return CastClass_match<OpTy, Instruction::FPExt>(Op);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1720</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1720</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1721</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1721</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1722</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1722</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1723</td>
    <td class="codeLine">// Matchers for control flow.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1723</td>
    <td class="codeLine">// Matchers for control flow.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1724</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1724</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1725</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1725</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1726</td>
    <td class="codeLine">struct br_match {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1726</td>
    <td class="codeLine">struct br_match {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1727</td>
    <td class="codeLine">  BasicBlock *&Succ;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1727</td>
    <td class="codeLine">  BasicBlock *&Succ;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1728</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1728</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1729</td>
    <td class="codeLine">  br_match(BasicBlock *&Succ) : Succ(Succ) {}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1729</td>
    <td class="codeLine">  br_match(BasicBlock *&Succ) : Succ(Succ) {}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1730</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1730</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1731</td>
    <td class="codeLine">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1731</td>
    <td class="codeLine">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1732</td>
    <td class="codeLine">    if (auto *BI = dyn_cast<BranchInst>(V))</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1732</td>
    <td class="codeLine">    if (auto *BI = dyn_cast<BranchInst>(V))</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1733</td>
    <td class="codeLine">      if (BI->isUnconditional()) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1733</td>
    <td class="codeLine">      if (BI->isUnconditional()) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1734</td>
    <td class="codeLine">        Succ = BI->getSuccessor(0);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1734</td>
    <td class="codeLine">        Succ = BI->getSuccessor(0);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1735</td>
    <td class="codeLine">        return true;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1735</td>
    <td class="codeLine">        return true;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1736</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1736</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1737</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1737</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1738</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1738</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1739</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1739</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1740</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1740</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1741</td>
    <td class="codeLine">inline br_match m_UnconditionalBr(BasicBlock *&Succ) { return br_match(Succ); }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1741</td>
    <td class="codeLine">inline br_match m_UnconditionalBr(BasicBlock *&Succ) { return br_match(Succ); }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1742</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1742</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1743</td>
    <td class="codeLine">template <typename Cond_t, typename TrueBlock_t, typename FalseBlock_t></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1743</td>
    <td class="codeLine">template <typename Cond_t, typename TrueBlock_t, typename FalseBlock_t></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1744</td>
    <td class="codeLine">struct brc_match {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1744</td>
    <td class="codeLine">struct brc_match {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1745</td>
    <td class="codeLine">  Cond_t Cond;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1745</td>
    <td class="codeLine">  Cond_t Cond;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1746</td>
    <td class="codeLine">  TrueBlock_t T;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1746</td>
    <td class="codeLine">  TrueBlock_t T;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1747</td>
    <td class="codeLine">  FalseBlock_t F;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1747</td>
    <td class="codeLine">  FalseBlock_t F;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1748</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1748</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1749</td>
    <td class="codeLine">  brc_match(const Cond_t &C, const TrueBlock_t &t, const FalseBlock_t &f)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1749</td>
    <td class="codeLine">  brc_match(const Cond_t &C, const TrueBlock_t &t, const FalseBlock_t &f)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1750</td>
    <td class="codeLine">      : Cond(C), T(t), F(f) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1750</td>
    <td class="codeLine">      : Cond(C), T(t), F(f) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1751</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1751</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1752</td>
    <td class="codeLine">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1752</td>
    <td class="codeLine">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1753</td>
    <td class="codeLine">    if (auto *BI = dyn_cast<BranchInst>(V))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1753</td>
    <td class="codeLine">    if (auto *BI = dyn_cast<BranchInst>(V))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1754</td>
    <td class="codeLine">      if (BI->isConditional() && Cond.match(BI->getCondition()))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1754</td>
    <td class="codeLine">      if (BI->isConditional() && Cond.match(BI->getCondition()))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1755</td>
    <td class="codeLine">        return T.match(BI->getSuccessor(0)) && F.match(BI->getSuccessor(1));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1755</td>
    <td class="codeLine">        return T.match(BI->getSuccessor(0)) && F.match(BI->getSuccessor(1));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1756</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1756</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1757</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1757</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1758</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1758</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1759</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1759</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1760</td>
    <td class="codeLine">template <typename Cond_t></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1760</td>
    <td class="codeLine">template <typename Cond_t></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1761</td>
    <td class="codeLine">inline brc_match<Cond_t, bind_ty<BasicBlock>, bind_ty<BasicBlock>></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1761</td>
    <td class="codeLine">inline brc_match<Cond_t, bind_ty<BasicBlock>, bind_ty<BasicBlock>></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1762</td>
    <td class="codeLine">m_Br(const Cond_t &C, BasicBlock *&T, BasicBlock *&F) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1762</td>
    <td class="codeLine">m_Br(const Cond_t &C, BasicBlock *&T, BasicBlock *&F) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1763</td>
    <td class="codeLine">  return brc_match<Cond_t, bind_ty<BasicBlock>, bind_ty<BasicBlock>>(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1763</td>
    <td class="codeLine">  return brc_match<Cond_t, bind_ty<BasicBlock>, bind_ty<BasicBlock>>(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1764</td>
    <td class="codeLine">      C, m_BasicBlock(T), m_BasicBlock(F));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1764</td>
    <td class="codeLine">      C, m_BasicBlock(T), m_BasicBlock(F));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1765</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1765</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1766</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1766</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1767</td>
    <td class="codeLine">template <typename Cond_t, typename TrueBlock_t, typename FalseBlock_t></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1767</td>
    <td class="codeLine">template <typename Cond_t, typename TrueBlock_t, typename FalseBlock_t></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1768</td>
    <td class="codeLine">inline brc_match<Cond_t, TrueBlock_t, FalseBlock_t></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1768</td>
    <td class="codeLine">inline brc_match<Cond_t, TrueBlock_t, FalseBlock_t></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1769</td>
    <td class="codeLine">m_Br(const Cond_t &C, const TrueBlock_t &T, const FalseBlock_t &F) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1769</td>
    <td class="codeLine">m_Br(const Cond_t &C, const TrueBlock_t &T, const FalseBlock_t &F) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1770</td>
    <td class="codeLine">  return brc_match<Cond_t, TrueBlock_t, FalseBlock_t>(C, T, F);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1770</td>
    <td class="codeLine">  return brc_match<Cond_t, TrueBlock_t, FalseBlock_t>(C, T, F);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1771</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1771</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1772</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1772</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1773</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1773</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1774</td>
    <td class="codeLine">// Matchers for max/min idioms, eg: "select (sgt x, y), x, y" -> smax(x,y).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1774</td>
    <td class="codeLine">// Matchers for max/min idioms, eg: "select (sgt x, y), x, y" -> smax(x,y).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1775</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1775</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1776</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1776</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1777</td>
    <td class="codeLine">template <typename CmpInst_t, typename LHS_t, typename RHS_t, typename Pred_t,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1777</td>
    <td class="codeLine">template <typename CmpInst_t, typename LHS_t, typename RHS_t, typename Pred_t,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1778</td>
    <td class="codeLine">          bool Commutable = false></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1778</td>
    <td class="codeLine">          bool Commutable = false></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1779</td>
    <td class="codeLine">struct MaxMin_match {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1779</td>
    <td class="codeLine">struct MaxMin_match {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1780</td>
    <td class="codeLine">  using PredType = Pred_t;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1780</td>
    <td class="codeLine">  using PredType = Pred_t;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1781</td>
    <td class="codeLine">  LHS_t L;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1781</td>
    <td class="codeLine">  LHS_t L;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1782</td>
    <td class="codeLine">  RHS_t R;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1782</td>
    <td class="codeLine">  RHS_t R;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1783</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1783</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1784</td>
    <td class="codeLine">  // The evaluation order is always stable, regardless of Commutability.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1784</td>
    <td class="codeLine">  // The evaluation order is always stable, regardless of Commutability.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1785</td>
    <td class="codeLine">  // The LHS is always matched first.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1785</td>
    <td class="codeLine">  // The LHS is always matched first.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1786</td>
    <td class="codeLine">  MaxMin_match(const LHS_t &LHS, const RHS_t &RHS) : L(LHS), R(RHS) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1786</td>
    <td class="codeLine">  MaxMin_match(const LHS_t &LHS, const RHS_t &RHS) : L(LHS), R(RHS) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1787</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1787</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1788</td>
    <td class="codeLine">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1788</td>
    <td class="codeLine">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1789</td>
    <td class="codeLine">    if (auto *II = dyn_cast<IntrinsicInst>(V)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1789</td>
    <td class="codeLine">    if (auto *II = dyn_cast<IntrinsicInst>(V)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1790</td>
    <td class="codeLine">      Intrinsic::ID IID = II->getIntrinsicID();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1790</td>
    <td class="codeLine">      Intrinsic::ID IID = II->getIntrinsicID();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1791</td>
    <td class="codeLine">      if ((IID == Intrinsic::smax && Pred_t::match(ICmpInst::ICMP_SGT)) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1791</td>
    <td class="codeLine">      if ((IID == Intrinsic::smax && Pred_t::match(ICmpInst::ICMP_SGT)) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1792</td>
    <td class="codeLine">          (IID == Intrinsic::smin && Pred_t::match(ICmpInst::ICMP_SLT)) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1792</td>
    <td class="codeLine">          (IID == Intrinsic::smin && Pred_t::match(ICmpInst::ICMP_SLT)) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1793</td>
    <td class="codeLine">          (IID == Intrinsic::umax && Pred_t::match(ICmpInst::ICMP_UGT)) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1793</td>
    <td class="codeLine">          (IID == Intrinsic::umax && Pred_t::match(ICmpInst::ICMP_UGT)) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1794</td>
    <td class="codeLine">          (IID == Intrinsic::umin && Pred_t::match(ICmpInst::ICMP_ULT))) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1794</td>
    <td class="codeLine">          (IID == Intrinsic::umin && Pred_t::match(ICmpInst::ICMP_ULT))) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1795</td>
    <td class="codeLine">        Value *LHS = II->getOperand(0), *RHS = II->getOperand(1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1795</td>
    <td class="codeLine">        Value *LHS = II->getOperand(0), *RHS = II->getOperand(1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1796</td>
    <td class="codeLine">        return (L.match(LHS) && R.match(RHS)) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1796</td>
    <td class="codeLine">        return (L.match(LHS) && R.match(RHS)) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1797</td>
    <td class="codeLine">               (Commutable && L.match(RHS) && R.match(LHS));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1797</td>
    <td class="codeLine">               (Commutable && L.match(RHS) && R.match(LHS));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1798</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1798</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1799</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1799</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1800</td>
    <td class="codeLine">    // Look for "(x pred y) ? x : y" or "(x pred y) ? y : x".</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1800</td>
    <td class="codeLine">    // Look for "(x pred y) ? x : y" or "(x pred y) ? y : x".</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1801</td>
    <td class="codeLine">    auto *SI = dyn_cast<SelectInst>(V);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1801</td>
    <td class="codeLine">    auto *SI = dyn_cast<SelectInst>(V);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1802</td>
    <td class="codeLine">    if (!SI)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1802</td>
    <td class="codeLine">    if (!SI)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1803</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1803</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1804</td>
    <td class="codeLine">    auto *Cmp = dyn_cast<CmpInst_t>(SI->getCondition());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1804</td>
    <td class="codeLine">    auto *Cmp = dyn_cast<CmpInst_t>(SI->getCondition());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1805</td>
    <td class="codeLine">    if (!Cmp)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1805</td>
    <td class="codeLine">    if (!Cmp)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1806</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1806</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1807</td>
    <td class="codeLine">    // At this point we have a select conditioned on a comparison.  Check that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1807</td>
    <td class="codeLine">    // At this point we have a select conditioned on a comparison.  Check that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1808</td>
    <td class="codeLine">    // it is the values returned by the select that are being compared.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1808</td>
    <td class="codeLine">    // it is the values returned by the select that are being compared.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1809</td>
    <td class="codeLine">    auto *TrueVal = SI->getTrueValue();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1809</td>
    <td class="codeLine">    auto *TrueVal = SI->getTrueValue();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1810</td>
    <td class="codeLine">    auto *FalseVal = SI->getFalseValue();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1810</td>
    <td class="codeLine">    auto *FalseVal = SI->getFalseValue();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1811</td>
    <td class="codeLine">    auto *LHS = Cmp->getOperand(0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1811</td>
    <td class="codeLine">    auto *LHS = Cmp->getOperand(0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1812</td>
    <td class="codeLine">    auto *RHS = Cmp->getOperand(1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1812</td>
    <td class="codeLine">    auto *RHS = Cmp->getOperand(1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1813</td>
    <td class="codeLine">    if ((TrueVal != LHS || FalseVal != RHS) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1813</td>
    <td class="codeLine">    if ((TrueVal != LHS || FalseVal != RHS) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1814</td>
    <td class="codeLine">        (TrueVal != RHS || FalseVal != LHS))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1814</td>
    <td class="codeLine">        (TrueVal != RHS || FalseVal != LHS))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1815</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1815</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1816</td>
    <td class="codeLine">    typename CmpInst_t::Predicate Pred =</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1816</td>
    <td class="codeLine">    typename CmpInst_t::Predicate Pred =</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1817</td>
    <td class="codeLine">        LHS == TrueVal ? Cmp->getPredicate() : Cmp->getInversePredicate();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1817</td>
    <td class="codeLine">        LHS == TrueVal ? Cmp->getPredicate() : Cmp->getInversePredicate();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1818</td>
    <td class="codeLine">    // Does "(x pred y) ? x : y" represent the desired max/min operation?</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1818</td>
    <td class="codeLine">    // Does "(x pred y) ? x : y" represent the desired max/min operation?</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1819</td>
    <td class="codeLine">    if (!Pred_t::match(Pred))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1819</td>
    <td class="codeLine">    if (!Pred_t::match(Pred))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1820</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1820</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1821</td>
    <td class="codeLine">    // It does!  Bind the operands.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1821</td>
    <td class="codeLine">    // It does!  Bind the operands.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1822</td>
    <td class="codeLine">    return (L.match(LHS) && R.match(RHS)) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1822</td>
    <td class="codeLine">    return (L.match(LHS) && R.match(RHS)) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1823</td>
    <td class="codeLine">           (Commutable && L.match(RHS) && R.match(LHS));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1823</td>
    <td class="codeLine">           (Commutable && L.match(RHS) && R.match(LHS));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1824</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1824</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1825</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1825</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1826</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1826</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1827</td>
    <td class="codeLine">/// Helper class for identifying signed max predicates.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1827</td>
    <td class="codeLine">/// Helper class for identifying signed max predicates.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1828</td>
    <td class="codeLine">struct smax_pred_ty {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1828</td>
    <td class="codeLine">struct smax_pred_ty {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1829</td>
    <td class="codeLine">  static bool match(ICmpInst::Predicate Pred) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1829</td>
    <td class="codeLine">  static bool match(ICmpInst::Predicate Pred) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1830</td>
    <td class="codeLine">    return Pred == CmpInst::ICMP_SGT || Pred == CmpInst::ICMP_SGE;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1830</td>
    <td class="codeLine">    return Pred == CmpInst::ICMP_SGT || Pred == CmpInst::ICMP_SGE;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1831</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1831</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1832</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1832</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1833</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1833</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1834</td>
    <td class="codeLine">/// Helper class for identifying signed min predicates.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1834</td>
    <td class="codeLine">/// Helper class for identifying signed min predicates.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1835</td>
    <td class="codeLine">struct smin_pred_ty {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1835</td>
    <td class="codeLine">struct smin_pred_ty {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1836</td>
    <td class="codeLine">  static bool match(ICmpInst::Predicate Pred) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1836</td>
    <td class="codeLine">  static bool match(ICmpInst::Predicate Pred) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1837</td>
    <td class="codeLine">    return Pred == CmpInst::ICMP_SLT || Pred == CmpInst::ICMP_SLE;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1837</td>
    <td class="codeLine">    return Pred == CmpInst::ICMP_SLT || Pred == CmpInst::ICMP_SLE;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1838</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1838</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1839</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1839</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1840</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1840</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1841</td>
    <td class="codeLine">/// Helper class for identifying unsigned max predicates.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1841</td>
    <td class="codeLine">/// Helper class for identifying unsigned max predicates.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1842</td>
    <td class="codeLine">struct umax_pred_ty {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1842</td>
    <td class="codeLine">struct umax_pred_ty {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1843</td>
    <td class="codeLine">  static bool match(ICmpInst::Predicate Pred) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1843</td>
    <td class="codeLine">  static bool match(ICmpInst::Predicate Pred) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1844</td>
    <td class="codeLine">    return Pred == CmpInst::ICMP_UGT || Pred == CmpInst::ICMP_UGE;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1844</td>
    <td class="codeLine">    return Pred == CmpInst::ICMP_UGT || Pred == CmpInst::ICMP_UGE;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1845</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1845</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1846</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1846</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1847</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1847</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1848</td>
    <td class="codeLine">/// Helper class for identifying unsigned min predicates.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1848</td>
    <td class="codeLine">/// Helper class for identifying unsigned min predicates.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1849</td>
    <td class="codeLine">struct umin_pred_ty {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1849</td>
    <td class="codeLine">struct umin_pred_ty {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1850</td>
    <td class="codeLine">  static bool match(ICmpInst::Predicate Pred) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1850</td>
    <td class="codeLine">  static bool match(ICmpInst::Predicate Pred) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1851</td>
    <td class="codeLine">    return Pred == CmpInst::ICMP_ULT || Pred == CmpInst::ICMP_ULE;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1851</td>
    <td class="codeLine">    return Pred == CmpInst::ICMP_ULT || Pred == CmpInst::ICMP_ULE;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1852</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1852</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1853</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1853</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1854</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1854</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1855</td>
    <td class="codeLine">/// Helper class for identifying ordered max predicates.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1855</td>
    <td class="codeLine">/// Helper class for identifying ordered max predicates.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1856</td>
    <td class="codeLine">struct ofmax_pred_ty {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1856</td>
    <td class="codeLine">struct ofmax_pred_ty {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1857</td>
    <td class="codeLine">  static bool match(FCmpInst::Predicate Pred) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1857</td>
    <td class="codeLine">  static bool match(FCmpInst::Predicate Pred) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1858</td>
    <td class="codeLine">    return Pred == CmpInst::FCMP_OGT || Pred == CmpInst::FCMP_OGE;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1858</td>
    <td class="codeLine">    return Pred == CmpInst::FCMP_OGT || Pred == CmpInst::FCMP_OGE;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1859</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1859</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1860</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1860</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1861</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1861</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1862</td>
    <td class="codeLine">/// Helper class for identifying ordered min predicates.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1862</td>
    <td class="codeLine">/// Helper class for identifying ordered min predicates.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1863</td>
    <td class="codeLine">struct ofmin_pred_ty {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1863</td>
    <td class="codeLine">struct ofmin_pred_ty {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1864</td>
    <td class="codeLine">  static bool match(FCmpInst::Predicate Pred) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1864</td>
    <td class="codeLine">  static bool match(FCmpInst::Predicate Pred) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1865</td>
    <td class="codeLine">    return Pred == CmpInst::FCMP_OLT || Pred == CmpInst::FCMP_OLE;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1865</td>
    <td class="codeLine">    return Pred == CmpInst::FCMP_OLT || Pred == CmpInst::FCMP_OLE;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1866</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1866</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1867</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1867</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1868</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1868</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1869</td>
    <td class="codeLine">/// Helper class for identifying unordered max predicates.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1869</td>
    <td class="codeLine">/// Helper class for identifying unordered max predicates.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1870</td>
    <td class="codeLine">struct ufmax_pred_ty {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1870</td>
    <td class="codeLine">struct ufmax_pred_ty {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1871</td>
    <td class="codeLine">  static bool match(FCmpInst::Predicate Pred) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1871</td>
    <td class="codeLine">  static bool match(FCmpInst::Predicate Pred) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1872</td>
    <td class="codeLine">    return Pred == CmpInst::FCMP_UGT || Pred == CmpInst::FCMP_UGE;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1872</td>
    <td class="codeLine">    return Pred == CmpInst::FCMP_UGT || Pred == CmpInst::FCMP_UGE;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1873</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1873</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1874</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1874</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1875</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1875</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1876</td>
    <td class="codeLine">/// Helper class for identifying unordered min predicates.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1876</td>
    <td class="codeLine">/// Helper class for identifying unordered min predicates.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1877</td>
    <td class="codeLine">struct ufmin_pred_ty {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1877</td>
    <td class="codeLine">struct ufmin_pred_ty {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1878</td>
    <td class="codeLine">  static bool match(FCmpInst::Predicate Pred) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1878</td>
    <td class="codeLine">  static bool match(FCmpInst::Predicate Pred) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1879</td>
    <td class="codeLine">    return Pred == CmpInst::FCMP_ULT || Pred == CmpInst::FCMP_ULE;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1879</td>
    <td class="codeLine">    return Pred == CmpInst::FCMP_ULT || Pred == CmpInst::FCMP_ULE;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1880</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1880</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1881</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1881</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1882</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1882</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1883</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1883</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1884</td>
    <td class="codeLine">inline MaxMin_match<ICmpInst, LHS, RHS, smax_pred_ty> m_SMax(const LHS &L,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1884</td>
    <td class="codeLine">inline MaxMin_match<ICmpInst, LHS, RHS, smax_pred_ty> m_SMax(const LHS &L,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1885</td>
    <td class="codeLine">                                                             const RHS &R) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1885</td>
    <td class="codeLine">                                                             const RHS &R) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1886</td>
    <td class="codeLine">  return MaxMin_match<ICmpInst, LHS, RHS, smax_pred_ty>(L, R);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1886</td>
    <td class="codeLine">  return MaxMin_match<ICmpInst, LHS, RHS, smax_pred_ty>(L, R);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1887</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1887</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1888</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1888</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1889</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1889</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1890</td>
    <td class="codeLine">inline MaxMin_match<ICmpInst, LHS, RHS, smin_pred_ty> m_SMin(const LHS &L,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1890</td>
    <td class="codeLine">inline MaxMin_match<ICmpInst, LHS, RHS, smin_pred_ty> m_SMin(const LHS &L,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1891</td>
    <td class="codeLine">                                                             const RHS &R) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1891</td>
    <td class="codeLine">                                                             const RHS &R) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1892</td>
    <td class="codeLine">  return MaxMin_match<ICmpInst, LHS, RHS, smin_pred_ty>(L, R);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1892</td>
    <td class="codeLine">  return MaxMin_match<ICmpInst, LHS, RHS, smin_pred_ty>(L, R);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1893</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1893</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1894</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1894</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1895</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1895</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1896</td>
    <td class="codeLine">inline MaxMin_match<ICmpInst, LHS, RHS, umax_pred_ty> m_UMax(const LHS &L,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1896</td>
    <td class="codeLine">inline MaxMin_match<ICmpInst, LHS, RHS, umax_pred_ty> m_UMax(const LHS &L,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1897</td>
    <td class="codeLine">                                                             const RHS &R) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1897</td>
    <td class="codeLine">                                                             const RHS &R) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1898</td>
    <td class="codeLine">  return MaxMin_match<ICmpInst, LHS, RHS, umax_pred_ty>(L, R);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1898</td>
    <td class="codeLine">  return MaxMin_match<ICmpInst, LHS, RHS, umax_pred_ty>(L, R);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1899</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1899</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1900</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1900</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1901</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1901</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1902</td>
    <td class="codeLine">inline MaxMin_match<ICmpInst, LHS, RHS, umin_pred_ty> m_UMin(const LHS &L,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1902</td>
    <td class="codeLine">inline MaxMin_match<ICmpInst, LHS, RHS, umin_pred_ty> m_UMin(const LHS &L,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1903</td>
    <td class="codeLine">                                                             const RHS &R) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1903</td>
    <td class="codeLine">                                                             const RHS &R) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1904</td>
    <td class="codeLine">  return MaxMin_match<ICmpInst, LHS, RHS, umin_pred_ty>(L, R);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1904</td>
    <td class="codeLine">  return MaxMin_match<ICmpInst, LHS, RHS, umin_pred_ty>(L, R);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1905</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1905</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1906</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1906</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1907</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1907</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1908</td>
    <td class="codeLine">inline match_combine_or<</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1908</td>
    <td class="codeLine">inline match_combine_or<</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1909</td>
    <td class="codeLine">    match_combine_or<MaxMin_match<ICmpInst, LHS, RHS, smax_pred_ty>,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1909</td>
    <td class="codeLine">    match_combine_or<MaxMin_match<ICmpInst, LHS, RHS, smax_pred_ty>,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1910</td>
    <td class="codeLine">                     MaxMin_match<ICmpInst, LHS, RHS, smin_pred_ty>>,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1910</td>
    <td class="codeLine">                     MaxMin_match<ICmpInst, LHS, RHS, smin_pred_ty>>,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1911</td>
    <td class="codeLine">    match_combine_or<MaxMin_match<ICmpInst, LHS, RHS, umax_pred_ty>,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1911</td>
    <td class="codeLine">    match_combine_or<MaxMin_match<ICmpInst, LHS, RHS, umax_pred_ty>,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1912</td>
    <td class="codeLine">                     MaxMin_match<ICmpInst, LHS, RHS, umin_pred_ty>>></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1912</td>
    <td class="codeLine">                     MaxMin_match<ICmpInst, LHS, RHS, umin_pred_ty>>></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1913</td>
    <td class="codeLine">m_MaxOrMin(const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1913</td>
    <td class="codeLine">m_MaxOrMin(const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1914</td>
    <td class="codeLine">  return m_CombineOr(m_CombineOr(m_SMax(L, R), m_SMin(L, R)),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1914</td>
    <td class="codeLine">  return m_CombineOr(m_CombineOr(m_SMax(L, R), m_SMin(L, R)),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1915</td>
    <td class="codeLine">                     m_CombineOr(m_UMax(L, R), m_UMin(L, R)));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1915</td>
    <td class="codeLine">                     m_CombineOr(m_UMax(L, R), m_UMin(L, R)));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1916</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1916</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1917</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1917</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1918</td>
    <td class="codeLine">/// Match an 'ordered' floating point maximum function.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1918</td>
    <td class="codeLine">/// Match an 'ordered' floating point maximum function.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1919</td>
    <td class="codeLine">/// Floating point has one special value 'NaN'. Therefore, there is no total</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1919</td>
    <td class="codeLine">/// Floating point has one special value 'NaN'. Therefore, there is no total</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1920</td>
    <td class="codeLine">/// order. However, if we can ignore the 'NaN' value (for example, because of a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1920</td>
    <td class="codeLine">/// order. However, if we can ignore the 'NaN' value (for example, because of a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1921</td>
    <td class="codeLine">/// 'no-nans-float-math' flag) a combination of a fcmp and select has 'maximum'</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1921</td>
    <td class="codeLine">/// 'no-nans-float-math' flag) a combination of a fcmp and select has 'maximum'</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1922</td>
    <td class="codeLine">/// semantics. In the presence of 'NaN' we have to preserve the original</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1922</td>
    <td class="codeLine">/// semantics. In the presence of 'NaN' we have to preserve the original</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1923</td>
    <td class="codeLine">/// select(fcmp(ogt/ge, L, R), L, R) semantics matched by this predicate.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1923</td>
    <td class="codeLine">/// select(fcmp(ogt/ge, L, R), L, R) semantics matched by this predicate.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1924</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1924</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1925</td>
    <td class="codeLine">///                         max(L, R)  iff L and R are not NaN</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1925</td>
    <td class="codeLine">///                         max(L, R)  iff L and R are not NaN</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1926</td>
    <td class="codeLine">///  m_OrdFMax(L, R) =      R          iff L or R are NaN</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1926</td>
    <td class="codeLine">///  m_OrdFMax(L, R) =      R          iff L or R are NaN</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1927</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1927</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1928</td>
    <td class="codeLine">inline MaxMin_match<FCmpInst, LHS, RHS, ofmax_pred_ty> m_OrdFMax(const LHS &L,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1928</td>
    <td class="codeLine">inline MaxMin_match<FCmpInst, LHS, RHS, ofmax_pred_ty> m_OrdFMax(const LHS &L,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1929</td>
    <td class="codeLine">                                                                 const RHS &R) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1929</td>
    <td class="codeLine">                                                                 const RHS &R) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1930</td>
    <td class="codeLine">  return MaxMin_match<FCmpInst, LHS, RHS, ofmax_pred_ty>(L, R);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1930</td>
    <td class="codeLine">  return MaxMin_match<FCmpInst, LHS, RHS, ofmax_pred_ty>(L, R);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1931</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1931</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1932</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1932</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1933</td>
    <td class="codeLine">/// Match an 'ordered' floating point minimum function.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1933</td>
    <td class="codeLine">/// Match an 'ordered' floating point minimum function.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1934</td>
    <td class="codeLine">/// Floating point has one special value 'NaN'. Therefore, there is no total</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1934</td>
    <td class="codeLine">/// Floating point has one special value 'NaN'. Therefore, there is no total</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1935</td>
    <td class="codeLine">/// order. However, if we can ignore the 'NaN' value (for example, because of a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1935</td>
    <td class="codeLine">/// order. However, if we can ignore the 'NaN' value (for example, because of a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1936</td>
    <td class="codeLine">/// 'no-nans-float-math' flag) a combination of a fcmp and select has 'minimum'</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1936</td>
    <td class="codeLine">/// 'no-nans-float-math' flag) a combination of a fcmp and select has 'minimum'</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1937</td>
    <td class="codeLine">/// semantics. In the presence of 'NaN' we have to preserve the original</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1937</td>
    <td class="codeLine">/// semantics. In the presence of 'NaN' we have to preserve the original</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1938</td>
    <td class="codeLine">/// select(fcmp(olt/le, L, R), L, R) semantics matched by this predicate.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1938</td>
    <td class="codeLine">/// select(fcmp(olt/le, L, R), L, R) semantics matched by this predicate.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1939</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1939</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1940</td>
    <td class="codeLine">///                         min(L, R)  iff L and R are not NaN</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1940</td>
    <td class="codeLine">///                         min(L, R)  iff L and R are not NaN</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1941</td>
    <td class="codeLine">///  m_OrdFMin(L, R) =      R          iff L or R are NaN</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1941</td>
    <td class="codeLine">///  m_OrdFMin(L, R) =      R          iff L or R are NaN</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1942</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1942</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1943</td>
    <td class="codeLine">inline MaxMin_match<FCmpInst, LHS, RHS, ofmin_pred_ty> m_OrdFMin(const LHS &L,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1943</td>
    <td class="codeLine">inline MaxMin_match<FCmpInst, LHS, RHS, ofmin_pred_ty> m_OrdFMin(const LHS &L,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1944</td>
    <td class="codeLine">                                                                 const RHS &R) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1944</td>
    <td class="codeLine">                                                                 const RHS &R) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1945</td>
    <td class="codeLine">  return MaxMin_match<FCmpInst, LHS, RHS, ofmin_pred_ty>(L, R);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1945</td>
    <td class="codeLine">  return MaxMin_match<FCmpInst, LHS, RHS, ofmin_pred_ty>(L, R);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1946</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1946</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1947</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1947</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1948</td>
    <td class="codeLine">/// Match an 'unordered' floating point maximum function.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1948</td>
    <td class="codeLine">/// Match an 'unordered' floating point maximum function.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1949</td>
    <td class="codeLine">/// Floating point has one special value 'NaN'. Therefore, there is no total</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1949</td>
    <td class="codeLine">/// Floating point has one special value 'NaN'. Therefore, there is no total</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1950</td>
    <td class="codeLine">/// order. However, if we can ignore the 'NaN' value (for example, because of a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1950</td>
    <td class="codeLine">/// order. However, if we can ignore the 'NaN' value (for example, because of a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1951</td>
    <td class="codeLine">/// 'no-nans-float-math' flag) a combination of a fcmp and select has 'maximum'</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1951</td>
    <td class="codeLine">/// 'no-nans-float-math' flag) a combination of a fcmp and select has 'maximum'</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1952</td>
    <td class="codeLine">/// semantics. In the presence of 'NaN' we have to preserve the original</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1952</td>
    <td class="codeLine">/// semantics. In the presence of 'NaN' we have to preserve the original</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1953</td>
    <td class="codeLine">/// select(fcmp(ugt/ge, L, R), L, R) semantics matched by this predicate.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1953</td>
    <td class="codeLine">/// select(fcmp(ugt/ge, L, R), L, R) semantics matched by this predicate.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1954</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1954</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1955</td>
    <td class="codeLine">///                         max(L, R)  iff L and R are not NaN</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1955</td>
    <td class="codeLine">///                         max(L, R)  iff L and R are not NaN</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1956</td>
    <td class="codeLine">///  m_UnordFMax(L, R) =    L          iff L or R are NaN</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1956</td>
    <td class="codeLine">///  m_UnordFMax(L, R) =    L          iff L or R are NaN</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1957</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1957</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1958</td>
    <td class="codeLine">inline MaxMin_match<FCmpInst, LHS, RHS, ufmax_pred_ty></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1958</td>
    <td class="codeLine">inline MaxMin_match<FCmpInst, LHS, RHS, ufmax_pred_ty></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1959</td>
    <td class="codeLine">m_UnordFMax(const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1959</td>
    <td class="codeLine">m_UnordFMax(const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1960</td>
    <td class="codeLine">  return MaxMin_match<FCmpInst, LHS, RHS, ufmax_pred_ty>(L, R);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1960</td>
    <td class="codeLine">  return MaxMin_match<FCmpInst, LHS, RHS, ufmax_pred_ty>(L, R);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1961</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1961</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1962</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1962</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1963</td>
    <td class="codeLine">/// Match an 'unordered' floating point minimum function.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1963</td>
    <td class="codeLine">/// Match an 'unordered' floating point minimum function.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1964</td>
    <td class="codeLine">/// Floating point has one special value 'NaN'. Therefore, there is no total</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1964</td>
    <td class="codeLine">/// Floating point has one special value 'NaN'. Therefore, there is no total</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1965</td>
    <td class="codeLine">/// order. However, if we can ignore the 'NaN' value (for example, because of a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1965</td>
    <td class="codeLine">/// order. However, if we can ignore the 'NaN' value (for example, because of a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1966</td>
    <td class="codeLine">/// 'no-nans-float-math' flag) a combination of a fcmp and select has 'minimum'</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1966</td>
    <td class="codeLine">/// 'no-nans-float-math' flag) a combination of a fcmp and select has 'minimum'</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1967</td>
    <td class="codeLine">/// semantics. In the presence of 'NaN' we have to preserve the original</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1967</td>
    <td class="codeLine">/// semantics. In the presence of 'NaN' we have to preserve the original</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1968</td>
    <td class="codeLine">/// select(fcmp(ult/le, L, R), L, R) semantics matched by this predicate.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1968</td>
    <td class="codeLine">/// select(fcmp(ult/le, L, R), L, R) semantics matched by this predicate.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1969</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1969</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1970</td>
    <td class="codeLine">///                          min(L, R)  iff L and R are not NaN</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1970</td>
    <td class="codeLine">///                          min(L, R)  iff L and R are not NaN</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1971</td>
    <td class="codeLine">///  m_UnordFMin(L, R) =     L          iff L or R are NaN</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1971</td>
    <td class="codeLine">///  m_UnordFMin(L, R) =     L          iff L or R are NaN</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1972</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1972</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1973</td>
    <td class="codeLine">inline MaxMin_match<FCmpInst, LHS, RHS, ufmin_pred_ty></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1973</td>
    <td class="codeLine">inline MaxMin_match<FCmpInst, LHS, RHS, ufmin_pred_ty></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1974</td>
    <td class="codeLine">m_UnordFMin(const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1974</td>
    <td class="codeLine">m_UnordFMin(const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1975</td>
    <td class="codeLine">  return MaxMin_match<FCmpInst, LHS, RHS, ufmin_pred_ty>(L, R);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1975</td>
    <td class="codeLine">  return MaxMin_match<FCmpInst, LHS, RHS, ufmin_pred_ty>(L, R);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1976</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1976</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1977</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1977</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1978</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1978</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1979</td>
    <td class="codeLine">// Matchers for overflow check patterns: e.g. (a + b) u< a, (a ^ -1) <u b</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1979</td>
    <td class="codeLine">// Matchers for overflow check patterns: e.g. (a + b) u< a, (a ^ -1) <u b</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1980</td>
    <td class="codeLine">// Note that S might be matched to other instructions than AddInst.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1980</td>
    <td class="codeLine">// Note that S might be matched to other instructions than AddInst.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1981</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1981</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1982</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1982</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1983</td>
    <td class="codeLine">template <typename LHS_t, typename RHS_t, typename Sum_t></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1983</td>
    <td class="codeLine">template <typename LHS_t, typename RHS_t, typename Sum_t></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1984</td>
    <td class="codeLine">struct UAddWithOverflow_match {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1984</td>
    <td class="codeLine">struct UAddWithOverflow_match {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1985</td>
    <td class="codeLine">  LHS_t L;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1985</td>
    <td class="codeLine">  LHS_t L;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1986</td>
    <td class="codeLine">  RHS_t R;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1986</td>
    <td class="codeLine">  RHS_t R;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1987</td>
    <td class="codeLine">  Sum_t S;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1987</td>
    <td class="codeLine">  Sum_t S;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1988</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1988</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1989</td>
    <td class="codeLine">  UAddWithOverflow_match(const LHS_t &L, const RHS_t &R, const Sum_t &S)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1989</td>
    <td class="codeLine">  UAddWithOverflow_match(const LHS_t &L, const RHS_t &R, const Sum_t &S)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1990</td>
    <td class="codeLine">      : L(L), R(R), S(S) {}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1990</td>
    <td class="codeLine">      : L(L), R(R), S(S) {}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1991</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1991</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1992</td>
    <td class="codeLine">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1992</td>
    <td class="codeLine">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1993</td>
    <td class="codeLine">    Value *ICmpLHS, *ICmpRHS;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1993</td>
    <td class="codeLine">    Value *ICmpLHS, *ICmpRHS;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1994</td>
    <td class="codeLine">    ICmpInst::Predicate Pred;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1994</td>
    <td class="codeLine">    ICmpInst::Predicate Pred;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1995</td>
    <td class="codeLine">    if (!m_ICmp(Pred, m_Value(ICmpLHS), m_Value(ICmpRHS)).match(V))</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1995</td>
    <td class="codeLine">    if (!m_ICmp(Pred, m_Value(ICmpLHS), m_Value(ICmpRHS)).match(V))</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1996</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1996</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1997</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1997</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1998</td>
    <td class="codeLine">    Value *AddLHS, *AddRHS;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1998</td>
    <td class="codeLine">    Value *AddLHS, *AddRHS;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1999</td>
    <td class="codeLine">    auto AddExpr = m_Add(m_Value(AddLHS), m_Value(AddRHS));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1999</td>
    <td class="codeLine">    auto AddExpr = m_Add(m_Value(AddLHS), m_Value(AddRHS));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2000</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2000</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2001</td>
    <td class="codeLine">    // (a + b) u< a, (a + b) u< b</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2001</td>
    <td class="codeLine">    // (a + b) u< a, (a + b) u< b</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2002</td>
    <td class="codeLine">    if (Pred == ICmpInst::ICMP_ULT)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2002</td>
    <td class="codeLine">    if (Pred == ICmpInst::ICMP_ULT)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2003</td>
    <td class="codeLine">      if (AddExpr.match(ICmpLHS) && (ICmpRHS == AddLHS || ICmpRHS == AddRHS))</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2003</td>
    <td class="codeLine">      if (AddExpr.match(ICmpLHS) && (ICmpRHS == AddLHS || ICmpRHS == AddRHS))</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2004</td>
    <td class="codeLine">        return L.match(AddLHS) && R.match(AddRHS) && S.match(ICmpLHS);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2004</td>
    <td class="codeLine">        return L.match(AddLHS) && R.match(AddRHS) && S.match(ICmpLHS);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2005</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2005</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2006</td>
    <td class="codeLine">    // a >u (a + b), b >u (a + b)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2006</td>
    <td class="codeLine">    // a >u (a + b), b >u (a + b)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2007</td>
    <td class="codeLine">    if (Pred == ICmpInst::ICMP_UGT)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2007</td>
    <td class="codeLine">    if (Pred == ICmpInst::ICMP_UGT)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2008</td>
    <td class="codeLine">      if (AddExpr.match(ICmpRHS) && (ICmpLHS == AddLHS || ICmpLHS == AddRHS))</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2008</td>
    <td class="codeLine">      if (AddExpr.match(ICmpRHS) && (ICmpLHS == AddLHS || ICmpLHS == AddRHS))</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2009</td>
    <td class="codeLine">        return L.match(AddLHS) && R.match(AddRHS) && S.match(ICmpRHS);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2009</td>
    <td class="codeLine">        return L.match(AddLHS) && R.match(AddRHS) && S.match(ICmpRHS);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2010</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2010</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2011</td>
    <td class="codeLine">    Value *Op1;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2011</td>
    <td class="codeLine">    Value *Op1;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2012</td>
    <td class="codeLine">    auto XorExpr = m_OneUse(m_Xor(m_Value(Op1), m_AllOnes()));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2012</td>
    <td class="codeLine">    auto XorExpr = m_OneUse(m_Xor(m_Value(Op1), m_AllOnes()));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2013</td>
    <td class="codeLine">    // (a ^ -1) <u b</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2013</td>
    <td class="codeLine">    // (a ^ -1) <u b</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2014</td>
    <td class="codeLine">    if (Pred == ICmpInst::ICMP_ULT) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2014</td>
    <td class="codeLine">    if (Pred == ICmpInst::ICMP_ULT) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2015</td>
    <td class="codeLine">      if (XorExpr.match(ICmpLHS))</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2015</td>
    <td class="codeLine">      if (XorExpr.match(ICmpLHS))</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2016</td>
    <td class="codeLine">        return L.match(Op1) && R.match(ICmpRHS) && S.match(ICmpLHS);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2016</td>
    <td class="codeLine">        return L.match(Op1) && R.match(ICmpRHS) && S.match(ICmpLHS);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2017</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2017</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2018</td>
    <td class="codeLine">    //  b > u (a ^ -1)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2018</td>
    <td class="codeLine">    //  b > u (a ^ -1)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2019</td>
    <td class="codeLine">    if (Pred == ICmpInst::ICMP_UGT) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2019</td>
    <td class="codeLine">    if (Pred == ICmpInst::ICMP_UGT) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2020</td>
    <td class="codeLine">      if (XorExpr.match(ICmpRHS))</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2020</td>
    <td class="codeLine">      if (XorExpr.match(ICmpRHS))</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2021</td>
    <td class="codeLine">        return L.match(Op1) && R.match(ICmpLHS) && S.match(ICmpRHS);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2021</td>
    <td class="codeLine">        return L.match(Op1) && R.match(ICmpLHS) && S.match(ICmpRHS);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2022</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2022</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2023</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2023</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2024</td>
    <td class="codeLine">    // Match special-case for increment-by-1.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2024</td>
    <td class="codeLine">    // Match special-case for increment-by-1.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2025</td>
    <td class="codeLine">    if (Pred == ICmpInst::ICMP_EQ) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2025</td>
    <td class="codeLine">    if (Pred == ICmpInst::ICMP_EQ) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2026</td>
    <td class="codeLine">      // (a + 1) == 0</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2026</td>
    <td class="codeLine">      // (a + 1) == 0</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2027</td>
    <td class="codeLine">      // (1 + a) == 0</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2027</td>
    <td class="codeLine">      // (1 + a) == 0</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2028</td>
    <td class="codeLine">      if (AddExpr.match(ICmpLHS) && m_ZeroInt().match(ICmpRHS) &&</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2028</td>
    <td class="codeLine">      if (AddExpr.match(ICmpLHS) && m_ZeroInt().match(ICmpRHS) &&</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2029</td>
    <td class="codeLine">          (m_One().match(AddLHS) || m_One().match(AddRHS)))</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2029</td>
    <td class="codeLine">          (m_One().match(AddLHS) || m_One().match(AddRHS)))</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2030</td>
    <td class="codeLine">        return L.match(AddLHS) && R.match(AddRHS) && S.match(ICmpLHS);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2030</td>
    <td class="codeLine">        return L.match(AddLHS) && R.match(AddRHS) && S.match(ICmpLHS);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2031</td>
    <td class="codeLine">      // 0 == (a + 1)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2031</td>
    <td class="codeLine">      // 0 == (a + 1)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2032</td>
    <td class="codeLine">      // 0 == (1 + a)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2032</td>
    <td class="codeLine">      // 0 == (1 + a)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2033</td>
    <td class="codeLine">      if (m_ZeroInt().match(ICmpLHS) && AddExpr.match(ICmpRHS) &&</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2033</td>
    <td class="codeLine">      if (m_ZeroInt().match(ICmpLHS) && AddExpr.match(ICmpRHS) &&</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2034</td>
    <td class="codeLine">          (m_One().match(AddLHS) || m_One().match(AddRHS)))</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2034</td>
    <td class="codeLine">          (m_One().match(AddLHS) || m_One().match(AddRHS)))</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2035</td>
    <td class="codeLine">        return L.match(AddLHS) && R.match(AddRHS) && S.match(ICmpRHS);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2035</td>
    <td class="codeLine">        return L.match(AddLHS) && R.match(AddRHS) && S.match(ICmpRHS);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2036</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2036</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2037</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2037</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2038</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2038</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2039</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2039</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2040</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2040</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2041</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2041</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2042</td>
    <td class="codeLine">/// Match an icmp instruction checking for unsigned overflow on addition.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2042</td>
    <td class="codeLine">/// Match an icmp instruction checking for unsigned overflow on addition.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2043</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2043</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2044</td>
    <td class="codeLine">/// S is matched to the addition whose result is being checked for overflow, and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2044</td>
    <td class="codeLine">/// S is matched to the addition whose result is being checked for overflow, and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2045</td>
    <td class="codeLine">/// L and R are matched to the LHS and RHS of S.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2045</td>
    <td class="codeLine">/// L and R are matched to the LHS and RHS of S.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2046</td>
    <td class="codeLine">template <typename LHS_t, typename RHS_t, typename Sum_t></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2046</td>
    <td class="codeLine">template <typename LHS_t, typename RHS_t, typename Sum_t></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2047</td>
    <td class="codeLine">UAddWithOverflow_match<LHS_t, RHS_t, Sum_t></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2047</td>
    <td class="codeLine">UAddWithOverflow_match<LHS_t, RHS_t, Sum_t></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2048</td>
    <td class="codeLine">m_UAddWithOverflow(const LHS_t &L, const RHS_t &R, const Sum_t &S) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2048</td>
    <td class="codeLine">m_UAddWithOverflow(const LHS_t &L, const RHS_t &R, const Sum_t &S) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2049</td>
    <td class="codeLine">  return UAddWithOverflow_match<LHS_t, RHS_t, Sum_t>(L, R, S);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2049</td>
    <td class="codeLine">  return UAddWithOverflow_match<LHS_t, RHS_t, Sum_t>(L, R, S);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2050</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2050</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2051</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2051</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2052</td>
    <td class="codeLine">template <typename Opnd_t> struct Argument_match {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2052</td>
    <td class="codeLine">template <typename Opnd_t> struct Argument_match {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2053</td>
    <td class="codeLine">  unsigned OpI;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2053</td>
    <td class="codeLine">  unsigned OpI;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2054</td>
    <td class="codeLine">  Opnd_t Val;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2054</td>
    <td class="codeLine">  Opnd_t Val;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2055</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2055</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2056</td>
    <td class="codeLine">  Argument_match(unsigned OpIdx, const Opnd_t &V) : OpI(OpIdx), Val(V) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2056</td>
    <td class="codeLine">  Argument_match(unsigned OpIdx, const Opnd_t &V) : OpI(OpIdx), Val(V) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2057</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2057</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2058</td>
    <td class="codeLine">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2058</td>
    <td class="codeLine">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2059</td>
    <td class="codeLine">    // FIXME: Should likely be switched to use `CallBase`.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2059</td>
    <td class="codeLine">    // FIXME: Should likely be switched to use `CallBase`.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2060</td>
    <td class="codeLine">    if (const auto *CI = dyn_cast<CallInst>(V))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2060</td>
    <td class="codeLine">    if (const auto *CI = dyn_cast<CallInst>(V))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2061</td>
    <td class="codeLine">      return Val.match(CI->getArgOperand(OpI));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2061</td>
    <td class="codeLine">      return Val.match(CI->getArgOperand(OpI));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2062</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2062</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2063</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2063</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2064</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2064</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2065</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2065</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2066</td>
    <td class="codeLine">/// Match an argument.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2066</td>
    <td class="codeLine">/// Match an argument.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2067</td>
    <td class="codeLine">template <unsigned OpI, typename Opnd_t></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2067</td>
    <td class="codeLine">template <unsigned OpI, typename Opnd_t></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2068</td>
    <td class="codeLine">inline Argument_match<Opnd_t> m_Argument(const Opnd_t &Op) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2068</td>
    <td class="codeLine">inline Argument_match<Opnd_t> m_Argument(const Opnd_t &Op) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2069</td>
    <td class="codeLine">  return Argument_match<Opnd_t>(OpI, Op);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2069</td>
    <td class="codeLine">  return Argument_match<Opnd_t>(OpI, Op);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2070</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2070</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2071</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2071</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2072</td>
    <td class="codeLine">/// Intrinsic matchers.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2072</td>
    <td class="codeLine">/// Intrinsic matchers.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2073</td>
    <td class="codeLine">struct IntrinsicID_match {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2073</td>
    <td class="codeLine">struct IntrinsicID_match {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2074</td>
    <td class="codeLine">  unsigned ID;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2074</td>
    <td class="codeLine">  unsigned ID;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2075</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2075</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2076</td>
    <td class="codeLine">  IntrinsicID_match(Intrinsic::ID IntrID) : ID(IntrID) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2076</td>
    <td class="codeLine">  IntrinsicID_match(Intrinsic::ID IntrID) : ID(IntrID) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2077</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2077</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2078</td>
    <td class="codeLine">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2078</td>
    <td class="codeLine">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2079</td>
    <td class="codeLine">    if (const auto *CI = dyn_cast<CallInst>(V))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2079</td>
    <td class="codeLine">    if (const auto *CI = dyn_cast<CallInst>(V))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2080</td>
    <td class="codeLine">      if (const auto *F = CI->getCalledFunction())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2080</td>
    <td class="codeLine">      if (const auto *F = CI->getCalledFunction())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2081</td>
    <td class="codeLine">        return F->getIntrinsicID() == ID;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2081</td>
    <td class="codeLine">        return F->getIntrinsicID() == ID;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2082</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2082</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2083</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2083</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2084</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2084</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2085</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2085</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2086</td>
    <td class="codeLine">/// Intrinsic matches are combinations of ID matchers, and argument</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2086</td>
    <td class="codeLine">/// Intrinsic matches are combinations of ID matchers, and argument</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2087</td>
    <td class="codeLine">/// matchers. Higher arity matcher are defined recursively in terms of and-ing</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2087</td>
    <td class="codeLine">/// matchers. Higher arity matcher are defined recursively in terms of and-ing</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2088</td>
    <td class="codeLine">/// them with lower arity matchers. Here's some convenient typedefs for up to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2088</td>
    <td class="codeLine">/// them with lower arity matchers. Here's some convenient typedefs for up to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2089</td>
    <td class="codeLine">/// several arguments, and more can be added as needed</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2089</td>
    <td class="codeLine">/// several arguments, and more can be added as needed</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2090</td>
    <td class="codeLine">template <typename T0 = void, typename T1 = void, typename T2 = void,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2090</td>
    <td class="codeLine">template <typename T0 = void, typename T1 = void, typename T2 = void,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2091</td>
    <td class="codeLine">          typename T3 = void, typename T4 = void, typename T5 = void,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2091</td>
    <td class="codeLine">          typename T3 = void, typename T4 = void, typename T5 = void,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2092</td>
    <td class="codeLine">          typename T6 = void, typename T7 = void, typename T8 = void,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2092</td>
    <td class="codeLine">          typename T6 = void, typename T7 = void, typename T8 = void,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2093</td>
    <td class="codeLine">          typename T9 = void, typename T10 = void></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2093</td>
    <td class="codeLine">          typename T9 = void, typename T10 = void></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2094</td>
    <td class="codeLine">struct m_Intrinsic_Ty;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2094</td>
    <td class="codeLine">struct m_Intrinsic_Ty;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2095</td>
    <td class="codeLine">template <typename T0> struct m_Intrinsic_Ty<T0> {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2095</td>
    <td class="codeLine">template <typename T0> struct m_Intrinsic_Ty<T0> {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2096</td>
    <td class="codeLine">  using Ty = match_combine_and<IntrinsicID_match, Argument_match<T0>>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2096</td>
    <td class="codeLine">  using Ty = match_combine_and<IntrinsicID_match, Argument_match<T0>>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2097</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2097</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2098</td>
    <td class="codeLine">template <typename T0, typename T1> struct m_Intrinsic_Ty<T0, T1> {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2098</td>
    <td class="codeLine">template <typename T0, typename T1> struct m_Intrinsic_Ty<T0, T1> {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2099</td>
    <td class="codeLine">  using Ty =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2099</td>
    <td class="codeLine">  using Ty =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2100</td>
    <td class="codeLine">      match_combine_and<typename m_Intrinsic_Ty<T0>::Ty, Argument_match<T1>>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2100</td>
    <td class="codeLine">      match_combine_and<typename m_Intrinsic_Ty<T0>::Ty, Argument_match<T1>>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2101</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2101</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2102</td>
    <td class="codeLine">template <typename T0, typename T1, typename T2></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2102</td>
    <td class="codeLine">template <typename T0, typename T1, typename T2></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2103</td>
    <td class="codeLine">struct m_Intrinsic_Ty<T0, T1, T2> {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2103</td>
    <td class="codeLine">struct m_Intrinsic_Ty<T0, T1, T2> {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2104</td>
    <td class="codeLine">  using Ty = match_combine_and<typename m_Intrinsic_Ty<T0, T1>::Ty,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2104</td>
    <td class="codeLine">  using Ty = match_combine_and<typename m_Intrinsic_Ty<T0, T1>::Ty,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2105</td>
    <td class="codeLine">                               Argument_match<T2>>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2105</td>
    <td class="codeLine">                               Argument_match<T2>>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2106</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2106</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2107</td>
    <td class="codeLine">template <typename T0, typename T1, typename T2, typename T3></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2107</td>
    <td class="codeLine">template <typename T0, typename T1, typename T2, typename T3></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2108</td>
    <td class="codeLine">struct m_Intrinsic_Ty<T0, T1, T2, T3> {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2108</td>
    <td class="codeLine">struct m_Intrinsic_Ty<T0, T1, T2, T3> {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2109</td>
    <td class="codeLine">  using Ty = match_combine_and<typename m_Intrinsic_Ty<T0, T1, T2>::Ty,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2109</td>
    <td class="codeLine">  using Ty = match_combine_and<typename m_Intrinsic_Ty<T0, T1, T2>::Ty,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2110</td>
    <td class="codeLine">                               Argument_match<T3>>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2110</td>
    <td class="codeLine">                               Argument_match<T3>>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2111</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2111</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2112</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2112</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2113</td>
    <td class="codeLine">template <typename T0, typename T1, typename T2, typename T3, typename T4></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2113</td>
    <td class="codeLine">template <typename T0, typename T1, typename T2, typename T3, typename T4></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2114</td>
    <td class="codeLine">struct m_Intrinsic_Ty<T0, T1, T2, T3, T4> {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2114</td>
    <td class="codeLine">struct m_Intrinsic_Ty<T0, T1, T2, T3, T4> {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2115</td>
    <td class="codeLine">  using Ty = match_combine_and<typename m_Intrinsic_Ty<T0, T1, T2, T3>::Ty,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2115</td>
    <td class="codeLine">  using Ty = match_combine_and<typename m_Intrinsic_Ty<T0, T1, T2, T3>::Ty,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2116</td>
    <td class="codeLine">                               Argument_match<T4>>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2116</td>
    <td class="codeLine">                               Argument_match<T4>>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2117</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2117</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2118</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2118</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2119</td>
    <td class="codeLine">template <typename T0, typename T1, typename T2, typename T3, typename T4,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2119</td>
    <td class="codeLine">template <typename T0, typename T1, typename T2, typename T3, typename T4,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2120</td>
    <td class="codeLine">          typename T5></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2120</td>
    <td class="codeLine">          typename T5></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2121</td>
    <td class="codeLine">struct m_Intrinsic_Ty<T0, T1, T2, T3, T4, T5> {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2121</td>
    <td class="codeLine">struct m_Intrinsic_Ty<T0, T1, T2, T3, T4, T5> {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2122</td>
    <td class="codeLine">  using Ty = match_combine_and<typename m_Intrinsic_Ty<T0, T1, T2, T3, T4>::Ty,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2122</td>
    <td class="codeLine">  using Ty = match_combine_and<typename m_Intrinsic_Ty<T0, T1, T2, T3, T4>::Ty,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2123</td>
    <td class="codeLine">                               Argument_match<T5>>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2123</td>
    <td class="codeLine">                               Argument_match<T5>>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2124</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2124</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2125</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2125</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2126</td>
    <td class="codeLine">/// Match intrinsic calls like this:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2126</td>
    <td class="codeLine">/// Match intrinsic calls like this:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2127</td>
    <td class="codeLine">/// m_Intrinsic<Intrinsic::fabs>(m_Value(X))</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2127</td>
    <td class="codeLine">/// m_Intrinsic<Intrinsic::fabs>(m_Value(X))</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2128</td>
    <td class="codeLine">template <Intrinsic::ID IntrID> inline IntrinsicID_match m_Intrinsic() {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2128</td>
    <td class="codeLine">template <Intrinsic::ID IntrID> inline IntrinsicID_match m_Intrinsic() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2129</td>
    <td class="codeLine">  return IntrinsicID_match(IntrID);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2129</td>
    <td class="codeLine">  return IntrinsicID_match(IntrID);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2130</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2130</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2131</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2131</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2132</td>
    <td class="codeLine">/// Matches MaskedLoad Intrinsic.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2132</td>
    <td class="codeLine">/// Matches MaskedLoad Intrinsic.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2133</td>
    <td class="codeLine">template <typename Opnd0, typename Opnd1, typename Opnd2, typename Opnd3></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2133</td>
    <td class="codeLine">template <typename Opnd0, typename Opnd1, typename Opnd2, typename Opnd3></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2134</td>
    <td class="codeLine">inline typename m_Intrinsic_Ty<Opnd0, Opnd1, Opnd2, Opnd3>::Ty</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2134</td>
    <td class="codeLine">inline typename m_Intrinsic_Ty<Opnd0, Opnd1, Opnd2, Opnd3>::Ty</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2135</td>
    <td class="codeLine">m_MaskedLoad(const Opnd0 &Op0, const Opnd1 &Op1, const Opnd2 &Op2,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2135</td>
    <td class="codeLine">m_MaskedLoad(const Opnd0 &Op0, const Opnd1 &Op1, const Opnd2 &Op2,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2136</td>
    <td class="codeLine">             const Opnd3 &Op3) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2136</td>
    <td class="codeLine">             const Opnd3 &Op3) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2137</td>
    <td class="codeLine">  return m_Intrinsic<Intrinsic::masked_load>(Op0, Op1, Op2, Op3);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2137</td>
    <td class="codeLine">  return m_Intrinsic<Intrinsic::masked_load>(Op0, Op1, Op2, Op3);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2138</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2138</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2139</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2139</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2140</td>
    <td class="codeLine">/// Matches MaskedGather Intrinsic.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2140</td>
    <td class="codeLine">/// Matches MaskedGather Intrinsic.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2141</td>
    <td class="codeLine">template <typename Opnd0, typename Opnd1, typename Opnd2, typename Opnd3></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2141</td>
    <td class="codeLine">template <typename Opnd0, typename Opnd1, typename Opnd2, typename Opnd3></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2142</td>
    <td class="codeLine">inline typename m_Intrinsic_Ty<Opnd0, Opnd1, Opnd2, Opnd3>::Ty</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2142</td>
    <td class="codeLine">inline typename m_Intrinsic_Ty<Opnd0, Opnd1, Opnd2, Opnd3>::Ty</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2143</td>
    <td class="codeLine">m_MaskedGather(const Opnd0 &Op0, const Opnd1 &Op1, const Opnd2 &Op2,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2143</td>
    <td class="codeLine">m_MaskedGather(const Opnd0 &Op0, const Opnd1 &Op1, const Opnd2 &Op2,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2144</td>
    <td class="codeLine">               const Opnd3 &Op3) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2144</td>
    <td class="codeLine">               const Opnd3 &Op3) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2145</td>
    <td class="codeLine">  return m_Intrinsic<Intrinsic::masked_gather>(Op0, Op1, Op2, Op3);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2145</td>
    <td class="codeLine">  return m_Intrinsic<Intrinsic::masked_gather>(Op0, Op1, Op2, Op3);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2146</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2146</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2147</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2147</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2148</td>
    <td class="codeLine">template <Intrinsic::ID IntrID, typename T0></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2148</td>
    <td class="codeLine">template <Intrinsic::ID IntrID, typename T0></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2149</td>
    <td class="codeLine">inline typename m_Intrinsic_Ty<T0>::Ty m_Intrinsic(const T0 &Op0) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2149</td>
    <td class="codeLine">inline typename m_Intrinsic_Ty<T0>::Ty m_Intrinsic(const T0 &Op0) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2150</td>
    <td class="codeLine">  return m_CombineAnd(m_Intrinsic<IntrID>(), m_Argument<0>(Op0));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2150</td>
    <td class="codeLine">  return m_CombineAnd(m_Intrinsic<IntrID>(), m_Argument<0>(Op0));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2151</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2151</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2152</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2152</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2153</td>
    <td class="codeLine">template <Intrinsic::ID IntrID, typename T0, typename T1></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2153</td>
    <td class="codeLine">template <Intrinsic::ID IntrID, typename T0, typename T1></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2154</td>
    <td class="codeLine">inline typename m_Intrinsic_Ty<T0, T1>::Ty m_Intrinsic(const T0 &Op0,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2154</td>
    <td class="codeLine">inline typename m_Intrinsic_Ty<T0, T1>::Ty m_Intrinsic(const T0 &Op0,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2155</td>
    <td class="codeLine">                                                       const T1 &Op1) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2155</td>
    <td class="codeLine">                                                       const T1 &Op1) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2156</td>
    <td class="codeLine">  return m_CombineAnd(m_Intrinsic<IntrID>(Op0), m_Argument<1>(Op1));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2156</td>
    <td class="codeLine">  return m_CombineAnd(m_Intrinsic<IntrID>(Op0), m_Argument<1>(Op1));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2157</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2157</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2158</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2158</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2159</td>
    <td class="codeLine">template <Intrinsic::ID IntrID, typename T0, typename T1, typename T2></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2159</td>
    <td class="codeLine">template <Intrinsic::ID IntrID, typename T0, typename T1, typename T2></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2160</td>
    <td class="codeLine">inline typename m_Intrinsic_Ty<T0, T1, T2>::Ty</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2160</td>
    <td class="codeLine">inline typename m_Intrinsic_Ty<T0, T1, T2>::Ty</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2161</td>
    <td class="codeLine">m_Intrinsic(const T0 &Op0, const T1 &Op1, const T2 &Op2) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2161</td>
    <td class="codeLine">m_Intrinsic(const T0 &Op0, const T1 &Op1, const T2 &Op2) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2162</td>
    <td class="codeLine">  return m_CombineAnd(m_Intrinsic<IntrID>(Op0, Op1), m_Argument<2>(Op2));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2162</td>
    <td class="codeLine">  return m_CombineAnd(m_Intrinsic<IntrID>(Op0, Op1), m_Argument<2>(Op2));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2163</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2163</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2164</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2164</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2165</td>
    <td class="codeLine">template <Intrinsic::ID IntrID, typename T0, typename T1, typename T2,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2165</td>
    <td class="codeLine">template <Intrinsic::ID IntrID, typename T0, typename T1, typename T2,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2166</td>
    <td class="codeLine">          typename T3></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2166</td>
    <td class="codeLine">          typename T3></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2167</td>
    <td class="codeLine">inline typename m_Intrinsic_Ty<T0, T1, T2, T3>::Ty</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2167</td>
    <td class="codeLine">inline typename m_Intrinsic_Ty<T0, T1, T2, T3>::Ty</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2168</td>
    <td class="codeLine">m_Intrinsic(const T0 &Op0, const T1 &Op1, const T2 &Op2, const T3 &Op3) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2168</td>
    <td class="codeLine">m_Intrinsic(const T0 &Op0, const T1 &Op1, const T2 &Op2, const T3 &Op3) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2169</td>
    <td class="codeLine">  return m_CombineAnd(m_Intrinsic<IntrID>(Op0, Op1, Op2), m_Argument<3>(Op3));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2169</td>
    <td class="codeLine">  return m_CombineAnd(m_Intrinsic<IntrID>(Op0, Op1, Op2), m_Argument<3>(Op3));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2170</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2170</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2171</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2171</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2172</td>
    <td class="codeLine">template <Intrinsic::ID IntrID, typename T0, typename T1, typename T2,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2172</td>
    <td class="codeLine">template <Intrinsic::ID IntrID, typename T0, typename T1, typename T2,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2173</td>
    <td class="codeLine">          typename T3, typename T4></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2173</td>
    <td class="codeLine">          typename T3, typename T4></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2174</td>
    <td class="codeLine">inline typename m_Intrinsic_Ty<T0, T1, T2, T3, T4>::Ty</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2174</td>
    <td class="codeLine">inline typename m_Intrinsic_Ty<T0, T1, T2, T3, T4>::Ty</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2175</td>
    <td class="codeLine">m_Intrinsic(const T0 &Op0, const T1 &Op1, const T2 &Op2, const T3 &Op3,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2175</td>
    <td class="codeLine">m_Intrinsic(const T0 &Op0, const T1 &Op1, const T2 &Op2, const T3 &Op3,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2176</td>
    <td class="codeLine">            const T4 &Op4) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2176</td>
    <td class="codeLine">            const T4 &Op4) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2177</td>
    <td class="codeLine">  return m_CombineAnd(m_Intrinsic<IntrID>(Op0, Op1, Op2, Op3),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2177</td>
    <td class="codeLine">  return m_CombineAnd(m_Intrinsic<IntrID>(Op0, Op1, Op2, Op3),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2178</td>
    <td class="codeLine">                      m_Argument<4>(Op4));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2178</td>
    <td class="codeLine">                      m_Argument<4>(Op4));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2179</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2179</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2180</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2180</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2181</td>
    <td class="codeLine">template <Intrinsic::ID IntrID, typename T0, typename T1, typename T2,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2181</td>
    <td class="codeLine">template <Intrinsic::ID IntrID, typename T0, typename T1, typename T2,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2182</td>
    <td class="codeLine">          typename T3, typename T4, typename T5></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2182</td>
    <td class="codeLine">          typename T3, typename T4, typename T5></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2183</td>
    <td class="codeLine">inline typename m_Intrinsic_Ty<T0, T1, T2, T3, T4, T5>::Ty</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2183</td>
    <td class="codeLine">inline typename m_Intrinsic_Ty<T0, T1, T2, T3, T4, T5>::Ty</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2184</td>
    <td class="codeLine">m_Intrinsic(const T0 &Op0, const T1 &Op1, const T2 &Op2, const T3 &Op3,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2184</td>
    <td class="codeLine">m_Intrinsic(const T0 &Op0, const T1 &Op1, const T2 &Op2, const T3 &Op3,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2185</td>
    <td class="codeLine">            const T4 &Op4, const T5 &Op5) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2185</td>
    <td class="codeLine">            const T4 &Op4, const T5 &Op5) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2186</td>
    <td class="codeLine">  return m_CombineAnd(m_Intrinsic<IntrID>(Op0, Op1, Op2, Op3, Op4),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2186</td>
    <td class="codeLine">  return m_CombineAnd(m_Intrinsic<IntrID>(Op0, Op1, Op2, Op3, Op4),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2187</td>
    <td class="codeLine">                      m_Argument<5>(Op5));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2187</td>
    <td class="codeLine">                      m_Argument<5>(Op5));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2188</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2188</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2189</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2189</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2190</td>
    <td class="codeLine">// Helper intrinsic matching specializations.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2190</td>
    <td class="codeLine">// Helper intrinsic matching specializations.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2191</td>
    <td class="codeLine">template <typename Opnd0></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2191</td>
    <td class="codeLine">template <typename Opnd0></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2192</td>
    <td class="codeLine">inline typename m_Intrinsic_Ty<Opnd0>::Ty m_BitReverse(const Opnd0 &Op0) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2192</td>
    <td class="codeLine">inline typename m_Intrinsic_Ty<Opnd0>::Ty m_BitReverse(const Opnd0 &Op0) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2193</td>
    <td class="codeLine">  return m_Intrinsic<Intrinsic::bitreverse>(Op0);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2193</td>
    <td class="codeLine">  return m_Intrinsic<Intrinsic::bitreverse>(Op0);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2194</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2194</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2195</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2195</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2196</td>
    <td class="codeLine">template <typename Opnd0></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2196</td>
    <td class="codeLine">template <typename Opnd0></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2197</td>
    <td class="codeLine">inline typename m_Intrinsic_Ty<Opnd0>::Ty m_BSwap(const Opnd0 &Op0) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2197</td>
    <td class="codeLine">inline typename m_Intrinsic_Ty<Opnd0>::Ty m_BSwap(const Opnd0 &Op0) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2198</td>
    <td class="codeLine">  return m_Intrinsic<Intrinsic::bswap>(Op0);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2198</td>
    <td class="codeLine">  return m_Intrinsic<Intrinsic::bswap>(Op0);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2199</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2199</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2200</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2200</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2201</td>
    <td class="codeLine">template <typename Opnd0></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2201</td>
    <td class="codeLine">template <typename Opnd0></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2202</td>
    <td class="codeLine">inline typename m_Intrinsic_Ty<Opnd0>::Ty m_FAbs(const Opnd0 &Op0) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2202</td>
    <td class="codeLine">inline typename m_Intrinsic_Ty<Opnd0>::Ty m_FAbs(const Opnd0 &Op0) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2203</td>
    <td class="codeLine">  return m_Intrinsic<Intrinsic::fabs>(Op0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2203</td>
    <td class="codeLine">  return m_Intrinsic<Intrinsic::fabs>(Op0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2204</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2204</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2205</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2205</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2206</td>
    <td class="codeLine">template <typename Opnd0></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2206</td>
    <td class="codeLine">template <typename Opnd0></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2207</td>
    <td class="codeLine">inline typename m_Intrinsic_Ty<Opnd0>::Ty m_FCanonicalize(const Opnd0 &Op0) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2207</td>
    <td class="codeLine">inline typename m_Intrinsic_Ty<Opnd0>::Ty m_FCanonicalize(const Opnd0 &Op0) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2208</td>
    <td class="codeLine">  return m_Intrinsic<Intrinsic::canonicalize>(Op0);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2208</td>
    <td class="codeLine">  return m_Intrinsic<Intrinsic::canonicalize>(Op0);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2209</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2209</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2210</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2210</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2211</td>
    <td class="codeLine">template <typename Opnd0, typename Opnd1></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2211</td>
    <td class="codeLine">template <typename Opnd0, typename Opnd1></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2212</td>
    <td class="codeLine">inline typename m_Intrinsic_Ty<Opnd0, Opnd1>::Ty m_FMin(const Opnd0 &Op0,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2212</td>
    <td class="codeLine">inline typename m_Intrinsic_Ty<Opnd0, Opnd1>::Ty m_FMin(const Opnd0 &Op0,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2213</td>
    <td class="codeLine">                                                        const Opnd1 &Op1) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2213</td>
    <td class="codeLine">                                                        const Opnd1 &Op1) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2214</td>
    <td class="codeLine">  return m_Intrinsic<Intrinsic::minnum>(Op0, Op1);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2214</td>
    <td class="codeLine">  return m_Intrinsic<Intrinsic::minnum>(Op0, Op1);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2215</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2215</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2216</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2216</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2217</td>
    <td class="codeLine">template <typename Opnd0, typename Opnd1></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2217</td>
    <td class="codeLine">template <typename Opnd0, typename Opnd1></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2218</td>
    <td class="codeLine">inline typename m_Intrinsic_Ty<Opnd0, Opnd1>::Ty m_FMax(const Opnd0 &Op0,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2218</td>
    <td class="codeLine">inline typename m_Intrinsic_Ty<Opnd0, Opnd1>::Ty m_FMax(const Opnd0 &Op0,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2219</td>
    <td class="codeLine">                                                        const Opnd1 &Op1) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2219</td>
    <td class="codeLine">                                                        const Opnd1 &Op1) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2220</td>
    <td class="codeLine">  return m_Intrinsic<Intrinsic::maxnum>(Op0, Op1);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2220</td>
    <td class="codeLine">  return m_Intrinsic<Intrinsic::maxnum>(Op0, Op1);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2221</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2221</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2222</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2222</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2223</td>
    <td class="codeLine">template <typename Opnd0, typename Opnd1, typename Opnd2></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2223</td>
    <td class="codeLine">template <typename Opnd0, typename Opnd1, typename Opnd2></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2224</td>
    <td class="codeLine">inline typename m_Intrinsic_Ty<Opnd0, Opnd1, Opnd2>::Ty</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2224</td>
    <td class="codeLine">inline typename m_Intrinsic_Ty<Opnd0, Opnd1, Opnd2>::Ty</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2225</td>
    <td class="codeLine">m_FShl(const Opnd0 &Op0, const Opnd1 &Op1, const Opnd2 &Op2) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2225</td>
    <td class="codeLine">m_FShl(const Opnd0 &Op0, const Opnd1 &Op1, const Opnd2 &Op2) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2226</td>
    <td class="codeLine">  return m_Intrinsic<Intrinsic::fshl>(Op0, Op1, Op2);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2226</td>
    <td class="codeLine">  return m_Intrinsic<Intrinsic::fshl>(Op0, Op1, Op2);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2227</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2227</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2228</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2228</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2229</td>
    <td class="codeLine">template <typename Opnd0, typename Opnd1, typename Opnd2></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2229</td>
    <td class="codeLine">template <typename Opnd0, typename Opnd1, typename Opnd2></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2230</td>
    <td class="codeLine">inline typename m_Intrinsic_Ty<Opnd0, Opnd1, Opnd2>::Ty</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2230</td>
    <td class="codeLine">inline typename m_Intrinsic_Ty<Opnd0, Opnd1, Opnd2>::Ty</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2231</td>
    <td class="codeLine">m_FShr(const Opnd0 &Op0, const Opnd1 &Op1, const Opnd2 &Op2) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2231</td>
    <td class="codeLine">m_FShr(const Opnd0 &Op0, const Opnd1 &Op1, const Opnd2 &Op2) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2232</td>
    <td class="codeLine">  return m_Intrinsic<Intrinsic::fshr>(Op0, Op1, Op2);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2232</td>
    <td class="codeLine">  return m_Intrinsic<Intrinsic::fshr>(Op0, Op1, Op2);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2233</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2233</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2234</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2234</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2235</td>
    <td class="codeLine">template <typename Opnd0></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2235</td>
    <td class="codeLine">template <typename Opnd0></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2236</td>
    <td class="codeLine">inline typename m_Intrinsic_Ty<Opnd0>::Ty m_Sqrt(const Opnd0 &Op0) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2236</td>
    <td class="codeLine">inline typename m_Intrinsic_Ty<Opnd0>::Ty m_Sqrt(const Opnd0 &Op0) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2237</td>
    <td class="codeLine">  return m_Intrinsic<Intrinsic::sqrt>(Op0);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2237</td>
    <td class="codeLine">  return m_Intrinsic<Intrinsic::sqrt>(Op0);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2238</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2238</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2239</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2239</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2240</td>
    <td class="codeLine">template <typename Opnd0, typename Opnd1></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2240</td>
    <td class="codeLine">template <typename Opnd0, typename Opnd1></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2241</td>
    <td class="codeLine">inline typename m_Intrinsic_Ty<Opnd0, Opnd1>::Ty m_CopySign(const Opnd0 &Op0,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2241</td>
    <td class="codeLine">inline typename m_Intrinsic_Ty<Opnd0, Opnd1>::Ty m_CopySign(const Opnd0 &Op0,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2242</td>
    <td class="codeLine">                                                            const Opnd1 &Op1) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2242</td>
    <td class="codeLine">                                                            const Opnd1 &Op1) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2243</td>
    <td class="codeLine">  return m_Intrinsic<Intrinsic::copysign>(Op0, Op1);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2243</td>
    <td class="codeLine">  return m_Intrinsic<Intrinsic::copysign>(Op0, Op1);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2244</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2244</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2245</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2245</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2246</td>
    <td class="codeLine">template <typename Opnd0></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2246</td>
    <td class="codeLine">template <typename Opnd0></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2247</td>
    <td class="codeLine">inline typename m_Intrinsic_Ty<Opnd0>::Ty m_VecReverse(const Opnd0 &Op0) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2247</td>
    <td class="codeLine">inline typename m_Intrinsic_Ty<Opnd0>::Ty m_VecReverse(const Opnd0 &Op0) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2248</td>
    <td class="codeLine">  return m_Intrinsic<Intrinsic::experimental_vector_reverse>(Op0);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2248</td>
    <td class="codeLine">  return m_Intrinsic<Intrinsic::experimental_vector_reverse>(Op0);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2249</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2249</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2250</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2250</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2251</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2251</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2252</td>
    <td class="codeLine">// Matchers for two-operands operators with the operators in either order</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2252</td>
    <td class="codeLine">// Matchers for two-operands operators with the operators in either order</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2253</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2253</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2254</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2254</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2255</td>
    <td class="codeLine">/// Matches a BinaryOperator with LHS and RHS in either order.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2255</td>
    <td class="codeLine">/// Matches a BinaryOperator with LHS and RHS in either order.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2256</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2256</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2257</td>
    <td class="codeLine">inline AnyBinaryOp_match<LHS, RHS, true> m_c_BinOp(const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2257</td>
    <td class="codeLine">inline AnyBinaryOp_match<LHS, RHS, true> m_c_BinOp(const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2258</td>
    <td class="codeLine">  return AnyBinaryOp_match<LHS, RHS, true>(L, R);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2258</td>
    <td class="codeLine">  return AnyBinaryOp_match<LHS, RHS, true>(L, R);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2259</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2259</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2260</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2260</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2261</td>
    <td class="codeLine">/// Matches an ICmp with a predicate over LHS and RHS in either order.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2261</td>
    <td class="codeLine">/// Matches an ICmp with a predicate over LHS and RHS in either order.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2262</td>
    <td class="codeLine">/// Swaps the predicate if operands are commuted.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2262</td>
    <td class="codeLine">/// Swaps the predicate if operands are commuted.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2263</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2263</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2264</td>
    <td class="codeLine">inline CmpClass_match<LHS, RHS, ICmpInst, ICmpInst::Predicate, true></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2264</td>
    <td class="codeLine">inline CmpClass_match<LHS, RHS, ICmpInst, ICmpInst::Predicate, true></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2265</td>
    <td class="codeLine">m_c_ICmp(ICmpInst::Predicate &Pred, const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2265</td>
    <td class="codeLine">m_c_ICmp(ICmpInst::Predicate &Pred, const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2266</td>
    <td class="codeLine">  return CmpClass_match<LHS, RHS, ICmpInst, ICmpInst::Predicate, true>(Pred, L,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2266</td>
    <td class="codeLine">  return CmpClass_match<LHS, RHS, ICmpInst, ICmpInst::Predicate, true>(Pred, L,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2267</td>
    <td class="codeLine">                                                                       R);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2267</td>
    <td class="codeLine">                                                                       R);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2268</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2268</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2269</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2269</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2270</td>
    <td class="codeLine">/// Matches a specific opcode with LHS and RHS in either order.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2270</td>
    <td class="codeLine">/// Matches a specific opcode with LHS and RHS in either order.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2271</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2271</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2272</td>
    <td class="codeLine">inline SpecificBinaryOp_match<LHS, RHS, true></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2272</td>
    <td class="codeLine">inline SpecificBinaryOp_match<LHS, RHS, true></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2273</td>
    <td class="codeLine">m_c_BinOp(unsigned Opcode, const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2273</td>
    <td class="codeLine">m_c_BinOp(unsigned Opcode, const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2274</td>
    <td class="codeLine">  return SpecificBinaryOp_match<LHS, RHS, true>(Opcode, L, R);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2274</td>
    <td class="codeLine">  return SpecificBinaryOp_match<LHS, RHS, true>(Opcode, L, R);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2275</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2275</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2276</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2276</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2277</td>
    <td class="codeLine">/// Matches a Add with LHS and RHS in either order.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2277</td>
    <td class="codeLine">/// Matches a Add with LHS and RHS in either order.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2278</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2278</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2279</td>
    <td class="codeLine">inline BinaryOp_match<LHS, RHS, Instruction::Add, true> m_c_Add(const LHS &L,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2279</td>
    <td class="codeLine">inline BinaryOp_match<LHS, RHS, Instruction::Add, true> m_c_Add(const LHS &L,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2280</td>
    <td class="codeLine">                                                                const RHS &R) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2280</td>
    <td class="codeLine">                                                                const RHS &R) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2281</td>
    <td class="codeLine">  return BinaryOp_match<LHS, RHS, Instruction::Add, true>(L, R);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2281</td>
    <td class="codeLine">  return BinaryOp_match<LHS, RHS, Instruction::Add, true>(L, R);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2282</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2282</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2283</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2283</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2284</td>
    <td class="codeLine">/// Matches a Mul with LHS and RHS in either order.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2284</td>
    <td class="codeLine">/// Matches a Mul with LHS and RHS in either order.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2285</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2285</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2286</td>
    <td class="codeLine">inline BinaryOp_match<LHS, RHS, Instruction::Mul, true> m_c_Mul(const LHS &L,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2286</td>
    <td class="codeLine">inline BinaryOp_match<LHS, RHS, Instruction::Mul, true> m_c_Mul(const LHS &L,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2287</td>
    <td class="codeLine">                                                                const RHS &R) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2287</td>
    <td class="codeLine">                                                                const RHS &R) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2288</td>
    <td class="codeLine">  return BinaryOp_match<LHS, RHS, Instruction::Mul, true>(L, R);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2288</td>
    <td class="codeLine">  return BinaryOp_match<LHS, RHS, Instruction::Mul, true>(L, R);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2289</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2289</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2290</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2290</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2291</td>
    <td class="codeLine">/// Matches an And with LHS and RHS in either order.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2291</td>
    <td class="codeLine">/// Matches an And with LHS and RHS in either order.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2292</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2292</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2293</td>
    <td class="codeLine">inline BinaryOp_match<LHS, RHS, Instruction::And, true> m_c_And(const LHS &L,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2293</td>
    <td class="codeLine">inline BinaryOp_match<LHS, RHS, Instruction::And, true> m_c_And(const LHS &L,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2294</td>
    <td class="codeLine">                                                                const RHS &R) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2294</td>
    <td class="codeLine">                                                                const RHS &R) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2295</td>
    <td class="codeLine">  return BinaryOp_match<LHS, RHS, Instruction::And, true>(L, R);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2295</td>
    <td class="codeLine">  return BinaryOp_match<LHS, RHS, Instruction::And, true>(L, R);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2296</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2296</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2297</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2297</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2298</td>
    <td class="codeLine">/// Matches an Or with LHS and RHS in either order.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2298</td>
    <td class="codeLine">/// Matches an Or with LHS and RHS in either order.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2299</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2299</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2300</td>
    <td class="codeLine">inline BinaryOp_match<LHS, RHS, Instruction::Or, true> m_c_Or(const LHS &L,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2300</td>
    <td class="codeLine">inline BinaryOp_match<LHS, RHS, Instruction::Or, true> m_c_Or(const LHS &L,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2301</td>
    <td class="codeLine">                                                              const RHS &R) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2301</td>
    <td class="codeLine">                                                              const RHS &R) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2302</td>
    <td class="codeLine">  return BinaryOp_match<LHS, RHS, Instruction::Or, true>(L, R);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2302</td>
    <td class="codeLine">  return BinaryOp_match<LHS, RHS, Instruction::Or, true>(L, R);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2303</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2303</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2304</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2304</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2305</td>
    <td class="codeLine">/// Matches an Xor with LHS and RHS in either order.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2305</td>
    <td class="codeLine">/// Matches an Xor with LHS and RHS in either order.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2306</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2306</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2307</td>
    <td class="codeLine">inline BinaryOp_match<LHS, RHS, Instruction::Xor, true> m_c_Xor(const LHS &L,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2307</td>
    <td class="codeLine">inline BinaryOp_match<LHS, RHS, Instruction::Xor, true> m_c_Xor(const LHS &L,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2308</td>
    <td class="codeLine">                                                                const RHS &R) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2308</td>
    <td class="codeLine">                                                                const RHS &R) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2309</td>
    <td class="codeLine">  return BinaryOp_match<LHS, RHS, Instruction::Xor, true>(L, R);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2309</td>
    <td class="codeLine">  return BinaryOp_match<LHS, RHS, Instruction::Xor, true>(L, R);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2310</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2310</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2311</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2311</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2312</td>
    <td class="codeLine">/// Matches a 'Neg' as 'sub 0, V'.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2312</td>
    <td class="codeLine">/// Matches a 'Neg' as 'sub 0, V'.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2313</td>
    <td class="codeLine">template <typename ValTy></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2313</td>
    <td class="codeLine">template <typename ValTy></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2314</td>
    <td class="codeLine">inline BinaryOp_match<cst_pred_ty<is_zero_int>, ValTy, Instruction::Sub></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2314</td>
    <td class="codeLine">inline BinaryOp_match<cst_pred_ty<is_zero_int>, ValTy, Instruction::Sub></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2315</td>
    <td class="codeLine">m_Neg(const ValTy &V) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2315</td>
    <td class="codeLine">m_Neg(const ValTy &V) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2316</td>
    <td class="codeLine">  return m_Sub(m_ZeroInt(), V);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2316</td>
    <td class="codeLine">  return m_Sub(m_ZeroInt(), V);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2317</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2317</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2318</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2318</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2319</td>
    <td class="codeLine">/// Matches a 'Neg' as 'sub nsw 0, V'.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2319</td>
    <td class="codeLine">/// Matches a 'Neg' as 'sub nsw 0, V'.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2320</td>
    <td class="codeLine">template <typename ValTy></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2320</td>
    <td class="codeLine">template <typename ValTy></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2321</td>
    <td class="codeLine">inline OverflowingBinaryOp_match<cst_pred_ty<is_zero_int>, ValTy,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2321</td>
    <td class="codeLine">inline OverflowingBinaryOp_match<cst_pred_ty<is_zero_int>, ValTy,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2322</td>
    <td class="codeLine">                                 Instruction::Sub,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2322</td>
    <td class="codeLine">                                 Instruction::Sub,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2323</td>
    <td class="codeLine">                                 OverflowingBinaryOperator::NoSignedWrap></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2323</td>
    <td class="codeLine">                                 OverflowingBinaryOperator::NoSignedWrap></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2324</td>
    <td class="codeLine">m_NSWNeg(const ValTy &V) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2324</td>
    <td class="codeLine">m_NSWNeg(const ValTy &V) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2325</td>
    <td class="codeLine">  return m_NSWSub(m_ZeroInt(), V);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2325</td>
    <td class="codeLine">  return m_NSWSub(m_ZeroInt(), V);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2326</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2326</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2327</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2327</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2328</td>
    <td class="codeLine">/// Matches a 'Not' as 'xor V, -1' or 'xor -1, V'.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2328</td>
    <td class="codeLine">/// Matches a 'Not' as 'xor V, -1' or 'xor -1, V'.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2329</td>
    <td class="codeLine">/// NOTE: we first match the 'Not' (by matching '-1'),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2329</td>
    <td class="codeLine">/// NOTE: we first match the 'Not' (by matching '-1'),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2330</td>
    <td class="codeLine">/// and only then match the inner matcher!</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2330</td>
    <td class="codeLine">/// and only then match the inner matcher!</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2331</td>
    <td class="codeLine">template <typename ValTy></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2331</td>
    <td class="codeLine">template <typename ValTy></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2332</td>
    <td class="codeLine">inline BinaryOp_match<cst_pred_ty<is_all_ones>, ValTy, Instruction::Xor, true></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2332</td>
    <td class="codeLine">inline BinaryOp_match<cst_pred_ty<is_all_ones>, ValTy, Instruction::Xor, true></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2333</td>
    <td class="codeLine">m_Not(const ValTy &V) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2333</td>
    <td class="codeLine">m_Not(const ValTy &V) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2334</td>
    <td class="codeLine">  return m_c_Xor(m_AllOnes(), V);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2334</td>
    <td class="codeLine">  return m_c_Xor(m_AllOnes(), V);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2335</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2335</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2336</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2336</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2337</td>
    <td class="codeLine">template <typename ValTy> struct NotForbidUndef_match {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2337</td>
    <td class="codeLine">template <typename ValTy> struct NotForbidUndef_match {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2338</td>
    <td class="codeLine">  ValTy Val;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2338</td>
    <td class="codeLine">  ValTy Val;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2339</td>
    <td class="codeLine">  NotForbidUndef_match(const ValTy &V) : Val(V) {}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2339</td>
    <td class="codeLine">  NotForbidUndef_match(const ValTy &V) : Val(V) {}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2340</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2340</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2341</td>
    <td class="codeLine">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2341</td>
    <td class="codeLine">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2342</td>
    <td class="codeLine">    // We do not use m_c_Xor because that could match an arbitrary APInt that is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2342</td>
    <td class="codeLine">    // We do not use m_c_Xor because that could match an arbitrary APInt that is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2343</td>
    <td class="codeLine">    // not -1 as C and then fail to match the other operand if it is -1.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2343</td>
    <td class="codeLine">    // not -1 as C and then fail to match the other operand if it is -1.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2344</td>
    <td class="codeLine">    // This code should still work even when both operands are constants.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2344</td>
    <td class="codeLine">    // This code should still work even when both operands are constants.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2345</td>
    <td class="codeLine">    Value *X;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2345</td>
    <td class="codeLine">    Value *X;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2346</td>
    <td class="codeLine">    const APInt *C;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2346</td>
    <td class="codeLine">    const APInt *C;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2347</td>
    <td class="codeLine">    if (m_Xor(m_Value(X), m_APIntForbidUndef(C)).match(V) && C->isAllOnes())</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2347</td>
    <td class="codeLine">    if (m_Xor(m_Value(X), m_APIntForbidUndef(C)).match(V) && C->isAllOnes())</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2348</td>
    <td class="codeLine">      return Val.match(X);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2348</td>
    <td class="codeLine">      return Val.match(X);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2349</td>
    <td class="codeLine">    if (m_Xor(m_APIntForbidUndef(C), m_Value(X)).match(V) && C->isAllOnes())</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2349</td>
    <td class="codeLine">    if (m_Xor(m_APIntForbidUndef(C), m_Value(X)).match(V) && C->isAllOnes())</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2350</td>
    <td class="codeLine">      return Val.match(X);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2350</td>
    <td class="codeLine">      return Val.match(X);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2351</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2351</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2352</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2352</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2353</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2353</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2354</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2354</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2355</td>
    <td class="codeLine">/// Matches a bitwise 'not' as 'xor V, -1' or 'xor -1, V'. For vectors, the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2355</td>
    <td class="codeLine">/// Matches a bitwise 'not' as 'xor V, -1' or 'xor -1, V'. For vectors, the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2356</td>
    <td class="codeLine">/// constant value must be composed of only -1 scalar elements.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2356</td>
    <td class="codeLine">/// constant value must be composed of only -1 scalar elements.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2357</td>
    <td class="codeLine">template <typename ValTy></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2357</td>
    <td class="codeLine">template <typename ValTy></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2358</td>
    <td class="codeLine">inline NotForbidUndef_match<ValTy> m_NotForbidUndef(const ValTy &V) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2358</td>
    <td class="codeLine">inline NotForbidUndef_match<ValTy> m_NotForbidUndef(const ValTy &V) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2359</td>
    <td class="codeLine">  return NotForbidUndef_match<ValTy>(V);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2359</td>
    <td class="codeLine">  return NotForbidUndef_match<ValTy>(V);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2360</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2360</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2361</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2361</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2362</td>
    <td class="codeLine">/// Matches an SMin with LHS and RHS in either order.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2362</td>
    <td class="codeLine">/// Matches an SMin with LHS and RHS in either order.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2363</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2363</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2364</td>
    <td class="codeLine">inline MaxMin_match<ICmpInst, LHS, RHS, smin_pred_ty, true></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2364</td>
    <td class="codeLine">inline MaxMin_match<ICmpInst, LHS, RHS, smin_pred_ty, true></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2365</td>
    <td class="codeLine">m_c_SMin(const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2365</td>
    <td class="codeLine">m_c_SMin(const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2366</td>
    <td class="codeLine">  return MaxMin_match<ICmpInst, LHS, RHS, smin_pred_ty, true>(L, R);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2366</td>
    <td class="codeLine">  return MaxMin_match<ICmpInst, LHS, RHS, smin_pred_ty, true>(L, R);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2367</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2367</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2368</td>
    <td class="codeLine">/// Matches an SMax with LHS and RHS in either order.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2368</td>
    <td class="codeLine">/// Matches an SMax with LHS and RHS in either order.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2369</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2369</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2370</td>
    <td class="codeLine">inline MaxMin_match<ICmpInst, LHS, RHS, smax_pred_ty, true></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2370</td>
    <td class="codeLine">inline MaxMin_match<ICmpInst, LHS, RHS, smax_pred_ty, true></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2371</td>
    <td class="codeLine">m_c_SMax(const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2371</td>
    <td class="codeLine">m_c_SMax(const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2372</td>
    <td class="codeLine">  return MaxMin_match<ICmpInst, LHS, RHS, smax_pred_ty, true>(L, R);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2372</td>
    <td class="codeLine">  return MaxMin_match<ICmpInst, LHS, RHS, smax_pred_ty, true>(L, R);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2373</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2373</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2374</td>
    <td class="codeLine">/// Matches a UMin with LHS and RHS in either order.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2374</td>
    <td class="codeLine">/// Matches a UMin with LHS and RHS in either order.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2375</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2375</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2376</td>
    <td class="codeLine">inline MaxMin_match<ICmpInst, LHS, RHS, umin_pred_ty, true></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2376</td>
    <td class="codeLine">inline MaxMin_match<ICmpInst, LHS, RHS, umin_pred_ty, true></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2377</td>
    <td class="codeLine">m_c_UMin(const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2377</td>
    <td class="codeLine">m_c_UMin(const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2378</td>
    <td class="codeLine">  return MaxMin_match<ICmpInst, LHS, RHS, umin_pred_ty, true>(L, R);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2378</td>
    <td class="codeLine">  return MaxMin_match<ICmpInst, LHS, RHS, umin_pred_ty, true>(L, R);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2379</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2379</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2380</td>
    <td class="codeLine">/// Matches a UMax with LHS and RHS in either order.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2380</td>
    <td class="codeLine">/// Matches a UMax with LHS and RHS in either order.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2381</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2381</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2382</td>
    <td class="codeLine">inline MaxMin_match<ICmpInst, LHS, RHS, umax_pred_ty, true></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2382</td>
    <td class="codeLine">inline MaxMin_match<ICmpInst, LHS, RHS, umax_pred_ty, true></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2383</td>
    <td class="codeLine">m_c_UMax(const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2383</td>
    <td class="codeLine">m_c_UMax(const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2384</td>
    <td class="codeLine">  return MaxMin_match<ICmpInst, LHS, RHS, umax_pred_ty, true>(L, R);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2384</td>
    <td class="codeLine">  return MaxMin_match<ICmpInst, LHS, RHS, umax_pred_ty, true>(L, R);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2385</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2385</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2386</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2386</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2387</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2387</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2388</td>
    <td class="codeLine">inline match_combine_or<</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2388</td>
    <td class="codeLine">inline match_combine_or<</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2389</td>
    <td class="codeLine">    match_combine_or<MaxMin_match<ICmpInst, LHS, RHS, smax_pred_ty, true>,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2389</td>
    <td class="codeLine">    match_combine_or<MaxMin_match<ICmpInst, LHS, RHS, smax_pred_ty, true>,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2390</td>
    <td class="codeLine">                     MaxMin_match<ICmpInst, LHS, RHS, smin_pred_ty, true>>,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2390</td>
    <td class="codeLine">                     MaxMin_match<ICmpInst, LHS, RHS, smin_pred_ty, true>>,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2391</td>
    <td class="codeLine">    match_combine_or<MaxMin_match<ICmpInst, LHS, RHS, umax_pred_ty, true>,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2391</td>
    <td class="codeLine">    match_combine_or<MaxMin_match<ICmpInst, LHS, RHS, umax_pred_ty, true>,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2392</td>
    <td class="codeLine">                     MaxMin_match<ICmpInst, LHS, RHS, umin_pred_ty, true>>></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2392</td>
    <td class="codeLine">                     MaxMin_match<ICmpInst, LHS, RHS, umin_pred_ty, true>>></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2393</td>
    <td class="codeLine">m_c_MaxOrMin(const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2393</td>
    <td class="codeLine">m_c_MaxOrMin(const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2394</td>
    <td class="codeLine">  return m_CombineOr(m_CombineOr(m_c_SMax(L, R), m_c_SMin(L, R)),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2394</td>
    <td class="codeLine">  return m_CombineOr(m_CombineOr(m_c_SMax(L, R), m_c_SMin(L, R)),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2395</td>
    <td class="codeLine">                     m_CombineOr(m_c_UMax(L, R), m_c_UMin(L, R)));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2395</td>
    <td class="codeLine">                     m_CombineOr(m_c_UMax(L, R), m_c_UMin(L, R)));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2396</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2396</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2397</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2397</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2398</td>
    <td class="codeLine">template <Intrinsic::ID IntrID, typename T0, typename T1></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2398</td>
    <td class="codeLine">template <Intrinsic::ID IntrID, typename T0, typename T1></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2399</td>
    <td class="codeLine">inline match_combine_or<typename m_Intrinsic_Ty<T0, T1>::Ty,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2399</td>
    <td class="codeLine">inline match_combine_or<typename m_Intrinsic_Ty<T0, T1>::Ty,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2400</td>
    <td class="codeLine">                        typename m_Intrinsic_Ty<T1, T0>::Ty></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2400</td>
    <td class="codeLine">                        typename m_Intrinsic_Ty<T1, T0>::Ty></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2401</td>
    <td class="codeLine">m_c_Intrinsic(const T0 &Op0, const T1 &Op1) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2401</td>
    <td class="codeLine">m_c_Intrinsic(const T0 &Op0, const T1 &Op1) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2402</td>
    <td class="codeLine">  return m_CombineOr(m_Intrinsic<IntrID>(Op0, Op1),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2402</td>
    <td class="codeLine">  return m_CombineOr(m_Intrinsic<IntrID>(Op0, Op1),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2403</td>
    <td class="codeLine">                     m_Intrinsic<IntrID>(Op1, Op0));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2403</td>
    <td class="codeLine">                     m_Intrinsic<IntrID>(Op1, Op0));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2404</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2404</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2405</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2405</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2406</td>
    <td class="codeLine">/// Matches FAdd with LHS and RHS in either order.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2406</td>
    <td class="codeLine">/// Matches FAdd with LHS and RHS in either order.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2407</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2407</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2408</td>
    <td class="codeLine">inline BinaryOp_match<LHS, RHS, Instruction::FAdd, true></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2408</td>
    <td class="codeLine">inline BinaryOp_match<LHS, RHS, Instruction::FAdd, true></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2409</td>
    <td class="codeLine">m_c_FAdd(const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2409</td>
    <td class="codeLine">m_c_FAdd(const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2410</td>
    <td class="codeLine">  return BinaryOp_match<LHS, RHS, Instruction::FAdd, true>(L, R);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2410</td>
    <td class="codeLine">  return BinaryOp_match<LHS, RHS, Instruction::FAdd, true>(L, R);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2411</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2411</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2412</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2412</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2413</td>
    <td class="codeLine">/// Matches FMul with LHS and RHS in either order.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2413</td>
    <td class="codeLine">/// Matches FMul with LHS and RHS in either order.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2414</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2414</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2415</td>
    <td class="codeLine">inline BinaryOp_match<LHS, RHS, Instruction::FMul, true></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2415</td>
    <td class="codeLine">inline BinaryOp_match<LHS, RHS, Instruction::FMul, true></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2416</td>
    <td class="codeLine">m_c_FMul(const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2416</td>
    <td class="codeLine">m_c_FMul(const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2417</td>
    <td class="codeLine">  return BinaryOp_match<LHS, RHS, Instruction::FMul, true>(L, R);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2417</td>
    <td class="codeLine">  return BinaryOp_match<LHS, RHS, Instruction::FMul, true>(L, R);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2418</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2418</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2419</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2419</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2420</td>
    <td class="codeLine">template <typename Opnd_t> struct Signum_match {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2420</td>
    <td class="codeLine">template <typename Opnd_t> struct Signum_match {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2421</td>
    <td class="codeLine">  Opnd_t Val;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2421</td>
    <td class="codeLine">  Opnd_t Val;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2422</td>
    <td class="codeLine">  Signum_match(const Opnd_t &V) : Val(V) {}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2422</td>
    <td class="codeLine">  Signum_match(const Opnd_t &V) : Val(V) {}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2423</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2423</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2424</td>
    <td class="codeLine">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2424</td>
    <td class="codeLine">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2425</td>
    <td class="codeLine">    unsigned TypeSize = V->getType()->getScalarSizeInBits();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2425</td>
    <td class="codeLine">    unsigned TypeSize = V->getType()->getScalarSizeInBits();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2426</td>
    <td class="codeLine">    if (TypeSize == 0)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2426</td>
    <td class="codeLine">    if (TypeSize == 0)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2427</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2427</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2428</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2428</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2429</td>
    <td class="codeLine">    unsigned ShiftWidth = TypeSize - 1;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2429</td>
    <td class="codeLine">    unsigned ShiftWidth = TypeSize - 1;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2430</td>
    <td class="codeLine">    Value *OpL = nullptr, *OpR = nullptr;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2430</td>
    <td class="codeLine">    Value *OpL = nullptr, *OpR = nullptr;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2431</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2431</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2432</td>
    <td class="codeLine">    // This is the representation of signum we match:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2432</td>
    <td class="codeLine">    // This is the representation of signum we match:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2433</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2433</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2434</td>
    <td class="codeLine">    //  signum(x) == (x >> 63) | (-x >>u 63)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2434</td>
    <td class="codeLine">    //  signum(x) == (x >> 63) | (-x >>u 63)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2435</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2435</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2436</td>
    <td class="codeLine">    // An i1 value is its own signum, so it's correct to match</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2436</td>
    <td class="codeLine">    // An i1 value is its own signum, so it's correct to match</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2437</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2437</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2438</td>
    <td class="codeLine">    //  signum(x) == (x >> 0)  | (-x >>u 0)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2438</td>
    <td class="codeLine">    //  signum(x) == (x >> 0)  | (-x >>u 0)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2439</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2439</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2440</td>
    <td class="codeLine">    // for i1 values.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2440</td>
    <td class="codeLine">    // for i1 values.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2441</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2441</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2442</td>
    <td class="codeLine">    auto LHS = m_AShr(m_Value(OpL), m_SpecificInt(ShiftWidth));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2442</td>
    <td class="codeLine">    auto LHS = m_AShr(m_Value(OpL), m_SpecificInt(ShiftWidth));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2443</td>
    <td class="codeLine">    auto RHS = m_LShr(m_Neg(m_Value(OpR)), m_SpecificInt(ShiftWidth));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2443</td>
    <td class="codeLine">    auto RHS = m_LShr(m_Neg(m_Value(OpR)), m_SpecificInt(ShiftWidth));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2444</td>
    <td class="codeLine">    auto Signum = m_Or(LHS, RHS);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2444</td>
    <td class="codeLine">    auto Signum = m_Or(LHS, RHS);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2445</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2445</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2446</td>
    <td class="codeLine">    return Signum.match(V) && OpL == OpR && Val.match(OpL);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2446</td>
    <td class="codeLine">    return Signum.match(V) && OpL == OpR && Val.match(OpL);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2447</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2447</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2448</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2448</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2449</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2449</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2450</td>
    <td class="codeLine">/// Matches a signum pattern.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2450</td>
    <td class="codeLine">/// Matches a signum pattern.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2451</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2451</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2452</td>
    <td class="codeLine">/// signum(x) =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2452</td>
    <td class="codeLine">/// signum(x) =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2453</td>
    <td class="codeLine">///      x >  0  ->  1</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2453</td>
    <td class="codeLine">///      x >  0  ->  1</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2454</td>
    <td class="codeLine">///      x == 0  ->  0</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2454</td>
    <td class="codeLine">///      x == 0  ->  0</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2455</td>
    <td class="codeLine">///      x <  0  -> -1</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2455</td>
    <td class="codeLine">///      x <  0  -> -1</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2456</td>
    <td class="codeLine">template <typename Val_t> inline Signum_match<Val_t> m_Signum(const Val_t &V) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2456</td>
    <td class="codeLine">template <typename Val_t> inline Signum_match<Val_t> m_Signum(const Val_t &V) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2457</td>
    <td class="codeLine">  return Signum_match<Val_t>(V);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2457</td>
    <td class="codeLine">  return Signum_match<Val_t>(V);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2458</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2458</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2459</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2459</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2460</td>
    <td class="codeLine">template <int Ind, typename Opnd_t> struct ExtractValue_match {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2460</td>
    <td class="codeLine">template <int Ind, typename Opnd_t> struct ExtractValue_match {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2461</td>
    <td class="codeLine">  Opnd_t Val;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2461</td>
    <td class="codeLine">  Opnd_t Val;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2462</td>
    <td class="codeLine">  ExtractValue_match(const Opnd_t &V) : Val(V) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2462</td>
    <td class="codeLine">  ExtractValue_match(const Opnd_t &V) : Val(V) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2463</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2463</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2464</td>
    <td class="codeLine">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2464</td>
    <td class="codeLine">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2465</td>
    <td class="codeLine">    if (auto *I = dyn_cast<ExtractValueInst>(V)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2465</td>
    <td class="codeLine">    if (auto *I = dyn_cast<ExtractValueInst>(V)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2466</td>
    <td class="codeLine">      // If Ind is -1, don't inspect indices</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2466</td>
    <td class="codeLine">      // If Ind is -1, don't inspect indices</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2467</td>
    <td class="codeLine">      if (Ind != -1 &&</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2467</td>
    <td class="codeLine">      if (Ind != -1 &&</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2468</td>
    <td class="codeLine">          !(I->getNumIndices() == 1 && I->getIndices()[0] == (unsigned)Ind))</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2468</td>
    <td class="codeLine">          !(I->getNumIndices() == 1 && I->getIndices()[0] == (unsigned)Ind))</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2469</td>
    <td class="codeLine">        return false;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2469</td>
    <td class="codeLine">        return false;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2470</td>
    <td class="codeLine">      return Val.match(I->getAggregateOperand());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2470</td>
    <td class="codeLine">      return Val.match(I->getAggregateOperand());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2471</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2471</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2472</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2472</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2473</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2473</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2474</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2474</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2475</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2475</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2476</td>
    <td class="codeLine">/// Match a single index ExtractValue instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2476</td>
    <td class="codeLine">/// Match a single index ExtractValue instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2477</td>
    <td class="codeLine">/// For example m_ExtractValue<1>(...)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2477</td>
    <td class="codeLine">/// For example m_ExtractValue<1>(...)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2478</td>
    <td class="codeLine">template <int Ind, typename Val_t></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2478</td>
    <td class="codeLine">template <int Ind, typename Val_t></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2479</td>
    <td class="codeLine">inline ExtractValue_match<Ind, Val_t> m_ExtractValue(const Val_t &V) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2479</td>
    <td class="codeLine">inline ExtractValue_match<Ind, Val_t> m_ExtractValue(const Val_t &V) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2480</td>
    <td class="codeLine">  return ExtractValue_match<Ind, Val_t>(V);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2480</td>
    <td class="codeLine">  return ExtractValue_match<Ind, Val_t>(V);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2481</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2481</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2482</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2482</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2483</td>
    <td class="codeLine">/// Match an ExtractValue instruction with any index.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2483</td>
    <td class="codeLine">/// Match an ExtractValue instruction with any index.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2484</td>
    <td class="codeLine">/// For example m_ExtractValue(...)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2484</td>
    <td class="codeLine">/// For example m_ExtractValue(...)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2485</td>
    <td class="codeLine">template <typename Val_t></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2485</td>
    <td class="codeLine">template <typename Val_t></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2486</td>
    <td class="codeLine">inline ExtractValue_match<-1, Val_t> m_ExtractValue(const Val_t &V) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2486</td>
    <td class="codeLine">inline ExtractValue_match<-1, Val_t> m_ExtractValue(const Val_t &V) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2487</td>
    <td class="codeLine">  return ExtractValue_match<-1, Val_t>(V);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2487</td>
    <td class="codeLine">  return ExtractValue_match<-1, Val_t>(V);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2488</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2488</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2489</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2489</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2490</td>
    <td class="codeLine">/// Matcher for a single index InsertValue instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2490</td>
    <td class="codeLine">/// Matcher for a single index InsertValue instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2491</td>
    <td class="codeLine">template <int Ind, typename T0, typename T1> struct InsertValue_match {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2491</td>
    <td class="codeLine">template <int Ind, typename T0, typename T1> struct InsertValue_match {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2492</td>
    <td class="codeLine">  T0 Op0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2492</td>
    <td class="codeLine">  T0 Op0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2493</td>
    <td class="codeLine">  T1 Op1;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2493</td>
    <td class="codeLine">  T1 Op1;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2494</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2494</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2495</td>
    <td class="codeLine">  InsertValue_match(const T0 &Op0, const T1 &Op1) : Op0(Op0), Op1(Op1) {}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2495</td>
    <td class="codeLine">  InsertValue_match(const T0 &Op0, const T1 &Op1) : Op0(Op0), Op1(Op1) {}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2496</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2496</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2497</td>
    <td class="codeLine">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2497</td>
    <td class="codeLine">  template <typename OpTy> bool match(OpTy *V) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2498</td>
    <td class="codeLine">    if (auto *I = dyn_cast<InsertValueInst>(V)) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2498</td>
    <td class="codeLine">    if (auto *I = dyn_cast<InsertValueInst>(V)) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2499</td>
    <td class="codeLine">      return Op0.match(I->getOperand(0)) && Op1.match(I->getOperand(1)) &&</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2499</td>
    <td class="codeLine">      return Op0.match(I->getOperand(0)) && Op1.match(I->getOperand(1)) &&</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2500</td>
    <td class="codeLine">             I->getNumIndices() == 1 && Ind == I->getIndices()[0];</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2500</td>
    <td class="codeLine">             I->getNumIndices() == 1 && Ind == I->getIndices()[0];</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2501</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2501</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2502</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2502</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2503</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2503</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2504</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2504</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2505</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2505</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2506</td>
    <td class="codeLine">/// Matches a single index InsertValue instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2506</td>
    <td class="codeLine">/// Matches a single index InsertValue instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2507</td>
    <td class="codeLine">template <int Ind, typename Val_t, typename Elt_t></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2507</td>
    <td class="codeLine">template <int Ind, typename Val_t, typename Elt_t></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2508</td>
    <td class="codeLine">inline InsertValue_match<Ind, Val_t, Elt_t> m_InsertValue(const Val_t &Val,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2508</td>
    <td class="codeLine">inline InsertValue_match<Ind, Val_t, Elt_t> m_InsertValue(const Val_t &Val,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2509</td>
    <td class="codeLine">                                                          const Elt_t &Elt) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2509</td>
    <td class="codeLine">                                                          const Elt_t &Elt) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2510</td>
    <td class="codeLine">  return InsertValue_match<Ind, Val_t, Elt_t>(Val, Elt);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2510</td>
    <td class="codeLine">  return InsertValue_match<Ind, Val_t, Elt_t>(Val, Elt);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2511</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2511</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2512</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2512</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2513</td>
    <td class="codeLine">/// Matches patterns for `vscale`. This can either be a call to `llvm.vscale` or</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2513</td>
    <td class="codeLine">/// Matches patterns for `vscale`. This can either be a call to `llvm.vscale` or</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2514</td>
    <td class="codeLine">/// the constant expression</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2514</td>
    <td class="codeLine">/// the constant expression</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2515</td>
    <td class="codeLine">///  `ptrtoint(gep <vscale x 1 x i8>, <vscale x 1 x i8>* null, i32 1>`</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2515</td>
    <td class="codeLine">///  `ptrtoint(gep <vscale x 1 x i8>, <vscale x 1 x i8>* null, i32 1>`</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2516</td>
    <td class="codeLine">/// under the right conditions determined by DataLayout.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2516</td>
    <td class="codeLine">/// under the right conditions determined by DataLayout.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2517</td>
    <td class="codeLine">struct VScaleVal_match {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2517</td>
    <td class="codeLine">struct VScaleVal_match {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2518</td>
    <td class="codeLine">  template <typename ITy> bool match(ITy *V) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2518</td>
    <td class="codeLine">  template <typename ITy> bool match(ITy *V) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2519</td>
    <td class="codeLine">    if (m_Intrinsic<Intrinsic::vscale>().match(V))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2519</td>
    <td class="codeLine">    if (m_Intrinsic<Intrinsic::vscale>().match(V))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2520</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2520</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2521</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2521</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2522</td>
    <td class="codeLine">    Value *Ptr;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2522</td>
    <td class="codeLine">    Value *Ptr;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2523</td>
    <td class="codeLine">    if (m_PtrToInt(m_Value(Ptr)).match(V)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2523</td>
    <td class="codeLine">    if (m_PtrToInt(m_Value(Ptr)).match(V)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2524</td>
    <td class="codeLine">      if (auto *GEP = dyn_cast<GEPOperator>(Ptr)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2524</td>
    <td class="codeLine">      if (auto *GEP = dyn_cast<GEPOperator>(Ptr)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2525</td>
    <td class="codeLine">        auto *DerefTy =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2525</td>
    <td class="codeLine">        auto *DerefTy =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2526</td>
    <td class="codeLine">            dyn_cast<ScalableVectorType>(GEP->getSourceElementType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2526</td>
    <td class="codeLine">            dyn_cast<ScalableVectorType>(GEP->getSourceElementType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2527</td>
    <td class="codeLine">        if (GEP->getNumIndices() == 1 && DerefTy &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2527</td>
    <td class="codeLine">        if (GEP->getNumIndices() == 1 && DerefTy &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2528</td>
    <td class="codeLine">            DerefTy->getElementType()->isIntegerTy(8) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2528</td>
    <td class="codeLine">            DerefTy->getElementType()->isIntegerTy(8) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2529</td>
    <td class="codeLine">            m_Zero().match(GEP->getPointerOperand()) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2529</td>
    <td class="codeLine">            m_Zero().match(GEP->getPointerOperand()) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2530</td>
    <td class="codeLine">            m_SpecificInt(1).match(GEP->idx_begin()->get()))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2530</td>
    <td class="codeLine">            m_SpecificInt(1).match(GEP->idx_begin()->get()))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2531</td>
    <td class="codeLine">          return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2531</td>
    <td class="codeLine">          return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2532</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2532</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2533</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2533</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2534</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2534</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2535</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2535</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2536</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2536</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2537</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2537</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2538</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2538</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2539</td>
    <td class="codeLine">inline VScaleVal_match m_VScale() {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2539</td>
    <td class="codeLine">inline VScaleVal_match m_VScale() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2540</td>
    <td class="codeLine">  return VScaleVal_match();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2540</td>
    <td class="codeLine">  return VScaleVal_match();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2541</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2541</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2542</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2542</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2543</td>
    <td class="codeLine">template <typename LHS, typename RHS, unsigned Opcode, bool Commutable = false></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2543</td>
    <td class="codeLine">template <typename LHS, typename RHS, unsigned Opcode, bool Commutable = false></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2544</td>
    <td class="codeLine">struct LogicalOp_match {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2544</td>
    <td class="codeLine">struct LogicalOp_match {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2545</td>
    <td class="codeLine">  LHS L;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2545</td>
    <td class="codeLine">  LHS L;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2546</td>
    <td class="codeLine">  RHS R;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2546</td>
    <td class="codeLine">  RHS R;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2547</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2547</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2548</td>
    <td class="codeLine coveredLine">  LogicalOp_match(const LHS &L, const RHS &R) : L(L), R(R) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2548</td>
    <td class="codeLine coveredLine">  LogicalOp_match(const LHS &L, const RHS &R) : L(L), R(R) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2549</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2549</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2550</td>
    <td class="codeLine coveredLine">  template <typename T> bool match(T *V) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2550</td>
    <td class="codeLine coveredLine">  template <typename T> bool match(T *V) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2551</td>
    <td class="codeLine coveredLine">    auto *I = dyn_cast<Instruction>(V);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2551</td>
    <td class="codeLine coveredLine">    auto *I = dyn_cast<Instruction>(V);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2552</td>
    <td class="codeLine coveredLine">    if (!I || !I->getType()->isIntOrIntVectorTy(1))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2552</td>
    <td class="codeLine coveredLine">    if (!I || !I->getType()->isIntOrIntVectorTy(1))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2553</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2553</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2554</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2554</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2555</td>
    <td class="codeLine coveredLine">    if (I->getOpcode() == Opcode) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2555</td>
    <td class="codeLine coveredLine">    if (I->getOpcode() == Opcode) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2556</td>
    <td class="codeLine">      auto *Op0 = I->getOperand(0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2556</td>
    <td class="codeLine">      auto *Op0 = I->getOperand(0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2557</td>
    <td class="codeLine">      auto *Op1 = I->getOperand(1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2557</td>
    <td class="codeLine">      auto *Op1 = I->getOperand(1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2558</td>
    <td class="codeLine">      return (L.match(Op0) && R.match(Op1)) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2558</td>
    <td class="codeLine">      return (L.match(Op0) && R.match(Op1)) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2559</td>
    <td class="codeLine">             (Commutable && L.match(Op1) && R.match(Op0));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2559</td>
    <td class="codeLine">             (Commutable && L.match(Op1) && R.match(Op0));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2560</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2560</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2561</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2561</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2562</td>
    <td class="codeLine coveredLine">    if (auto *Select = dyn_cast<SelectInst>(I)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2562</td>
    <td class="codeLine coveredLine">    if (auto *Select = dyn_cast<SelectInst>(I)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2563</td>
    <td class="codeLine">      auto *Cond = Select->getCondition();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2563</td>
    <td class="codeLine">      auto *Cond = Select->getCondition();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2564</td>
    <td class="codeLine">      auto *TVal = Select->getTrueValue();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2564</td>
    <td class="codeLine">      auto *TVal = Select->getTrueValue();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2565</td>
    <td class="codeLine">      auto *FVal = Select->getFalseValue();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2565</td>
    <td class="codeLine">      auto *FVal = Select->getFalseValue();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2566</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2566</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2567</td>
    <td class="codeLine">      // Don't match a scalar select of bool vectors.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2567</td>
    <td class="codeLine">      // Don't match a scalar select of bool vectors.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2568</td>
    <td class="codeLine">      // Transforms expect a single type for operands if this matches.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2568</td>
    <td class="codeLine">      // Transforms expect a single type for operands if this matches.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2569</td>
    <td class="codeLine">      if (Cond->getType() != Select->getType())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2569</td>
    <td class="codeLine">      if (Cond->getType() != Select->getType())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2570</td>
    <td class="codeLine">        return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2570</td>
    <td class="codeLine">        return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2571</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2571</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2572</td>
    <td class="codeLine">      if (Opcode == Instruction::And) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2572</td>
    <td class="codeLine">      if (Opcode == Instruction::And) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2573</td>
    <td class="codeLine">        auto *C = dyn_cast<Constant>(FVal);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2573</td>
    <td class="codeLine">        auto *C = dyn_cast<Constant>(FVal);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2574</td>
    <td class="codeLine">        if (C && C->isNullValue())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2574</td>
    <td class="codeLine">        if (C && C->isNullValue())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2575</td>
    <td class="codeLine">          return (L.match(Cond) && R.match(TVal)) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2575</td>
    <td class="codeLine">          return (L.match(Cond) && R.match(TVal)) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2576</td>
    <td class="codeLine">                 (Commutable && L.match(TVal) && R.match(Cond));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2576</td>
    <td class="codeLine">                 (Commutable && L.match(TVal) && R.match(Cond));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2577</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2577</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2578</td>
    <td class="codeLine">        assert(Opcode == Instruction::Or);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2578</td>
    <td class="codeLine">        assert(Opcode == Instruction::Or);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2579</td>
    <td class="codeLine">        auto *C = dyn_cast<Constant>(TVal);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2579</td>
    <td class="codeLine">        auto *C = dyn_cast<Constant>(TVal);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2580</td>
    <td class="codeLine">        if (C && C->isOneValue())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2580</td>
    <td class="codeLine">        if (C && C->isOneValue())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2581</td>
    <td class="codeLine">          return (L.match(Cond) && R.match(FVal)) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2581</td>
    <td class="codeLine">          return (L.match(Cond) && R.match(FVal)) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2582</td>
    <td class="codeLine">                 (Commutable && L.match(FVal) && R.match(Cond));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2582</td>
    <td class="codeLine">                 (Commutable && L.match(FVal) && R.match(Cond));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2583</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2583</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2584</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2584</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2585</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2585</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2586</td>
    <td class="codeLine coveredLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2586</td>
    <td class="codeLine coveredLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2587</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2587</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2588</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2588</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2589</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2589</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2590</td>
    <td class="codeLine">/// Matches L && R either in the form of L & R or L ? R : false.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2590</td>
    <td class="codeLine">/// Matches L && R either in the form of L & R or L ? R : false.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2591</td>
    <td class="codeLine">/// Note that the latter form is poison-blocking.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2591</td>
    <td class="codeLine">/// Note that the latter form is poison-blocking.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2592</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2592</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2593</td>
    <td class="codeLine coveredLine">inline LogicalOp_match<LHS, RHS, Instruction::And> m_LogicalAnd(const LHS &L,</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">2593</td>
    <td class="codeLine coveredLine">inline LogicalOp_match<LHS, RHS, Instruction::And> m_LogicalAnd(const LHS &L,</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2594</td>
    <td class="codeLine">                                                                const RHS &R) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2594</td>
    <td class="codeLine">                                                                const RHS &R) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2595</td>
    <td class="codeLine coveredLine">  return LogicalOp_match<LHS, RHS, Instruction::And>(L, R);</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">2595</td>
    <td class="codeLine coveredLine">  return LogicalOp_match<LHS, RHS, Instruction::And>(L, R);</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2596</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2596</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2597</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2597</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2598</td>
    <td class="codeLine">/// Matches L && R where L and R are arbitrary values.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2598</td>
    <td class="codeLine">/// Matches L && R where L and R are arbitrary values.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2599</td>
    <td class="codeLine">inline auto m_LogicalAnd() { return m_LogicalAnd(m_Value(), m_Value()); }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2599</td>
    <td class="codeLine">inline auto m_LogicalAnd() { return m_LogicalAnd(m_Value(), m_Value()); }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2600</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2600</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2601</td>
    <td class="codeLine">/// Matches L && R with LHS and RHS in either order.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2601</td>
    <td class="codeLine">/// Matches L && R with LHS and RHS in either order.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2602</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2602</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2603</td>
    <td class="codeLine">inline LogicalOp_match<LHS, RHS, Instruction::And, true></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2603</td>
    <td class="codeLine">inline LogicalOp_match<LHS, RHS, Instruction::And, true></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2604</td>
    <td class="codeLine">m_c_LogicalAnd(const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2604</td>
    <td class="codeLine">m_c_LogicalAnd(const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2605</td>
    <td class="codeLine">  return LogicalOp_match<LHS, RHS, Instruction::And, true>(L, R);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2605</td>
    <td class="codeLine">  return LogicalOp_match<LHS, RHS, Instruction::And, true>(L, R);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2606</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2606</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2607</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2607</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2608</td>
    <td class="codeLine">/// Matches L || R either in the form of L | R or L ? true : R.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2608</td>
    <td class="codeLine">/// Matches L || R either in the form of L | R or L ? true : R.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2609</td>
    <td class="codeLine">/// Note that the latter form is poison-blocking.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2609</td>
    <td class="codeLine">/// Note that the latter form is poison-blocking.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2610</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2610</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2611</td>
    <td class="codeLine coveredLine">inline LogicalOp_match<LHS, RHS, Instruction::Or> m_LogicalOr(const LHS &L,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2611</td>
    <td class="codeLine coveredLine">inline LogicalOp_match<LHS, RHS, Instruction::Or> m_LogicalOr(const LHS &L,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2612</td>
    <td class="codeLine">                                                              const RHS &R) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2612</td>
    <td class="codeLine">                                                              const RHS &R) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2613</td>
    <td class="codeLine coveredLine">  return LogicalOp_match<LHS, RHS, Instruction::Or>(L, R);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2613</td>
    <td class="codeLine coveredLine">  return LogicalOp_match<LHS, RHS, Instruction::Or>(L, R);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2614</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2614</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2615</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2615</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2616</td>
    <td class="codeLine">/// Matches L || R where L and R are arbitrary values.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2616</td>
    <td class="codeLine">/// Matches L || R where L and R are arbitrary values.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2617</td>
    <td class="codeLine">inline auto m_LogicalOr() { return m_LogicalOr(m_Value(), m_Value()); }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2617</td>
    <td class="codeLine">inline auto m_LogicalOr() { return m_LogicalOr(m_Value(), m_Value()); }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2618</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2618</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2619</td>
    <td class="codeLine">/// Matches L || R with LHS and RHS in either order.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2619</td>
    <td class="codeLine">/// Matches L || R with LHS and RHS in either order.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2620</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2620</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2621</td>
    <td class="codeLine">inline LogicalOp_match<LHS, RHS, Instruction::Or, true></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2621</td>
    <td class="codeLine">inline LogicalOp_match<LHS, RHS, Instruction::Or, true></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2622</td>
    <td class="codeLine">m_c_LogicalOr(const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2622</td>
    <td class="codeLine">m_c_LogicalOr(const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2623</td>
    <td class="codeLine">  return LogicalOp_match<LHS, RHS, Instruction::Or, true>(L, R);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2623</td>
    <td class="codeLine">  return LogicalOp_match<LHS, RHS, Instruction::Or, true>(L, R);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2624</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2624</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2625</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2625</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2626</td>
    <td class="codeLine">/// Matches either L && R or L || R,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2626</td>
    <td class="codeLine">/// Matches either L && R or L || R,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2627</td>
    <td class="codeLine">/// either one being in the either binary or logical form.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2627</td>
    <td class="codeLine">/// either one being in the either binary or logical form.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2628</td>
    <td class="codeLine">/// Note that the latter form is poison-blocking.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2628</td>
    <td class="codeLine">/// Note that the latter form is poison-blocking.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2629</td>
    <td class="codeLine">template <typename LHS, typename RHS, bool Commutable = false></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2629</td>
    <td class="codeLine">template <typename LHS, typename RHS, bool Commutable = false></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2630</td>
    <td class="codeLine">inline auto m_LogicalOp(const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2630</td>
    <td class="codeLine">inline auto m_LogicalOp(const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2631</td>
    <td class="codeLine">  return m_CombineOr(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2631</td>
    <td class="codeLine">  return m_CombineOr(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2632</td>
    <td class="codeLine">      LogicalOp_match<LHS, RHS, Instruction::And, Commutable>(L, R),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2632</td>
    <td class="codeLine">      LogicalOp_match<LHS, RHS, Instruction::And, Commutable>(L, R),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2633</td>
    <td class="codeLine">      LogicalOp_match<LHS, RHS, Instruction::Or, Commutable>(L, R));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2633</td>
    <td class="codeLine">      LogicalOp_match<LHS, RHS, Instruction::Or, Commutable>(L, R));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2634</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2634</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2635</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2635</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2636</td>
    <td class="codeLine">/// Matches either L && R or L || R where L and R are arbitrary values.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2636</td>
    <td class="codeLine">/// Matches either L && R or L || R where L and R are arbitrary values.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2637</td>
    <td class="codeLine">inline auto m_LogicalOp() { return m_LogicalOp(m_Value(), m_Value()); }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2637</td>
    <td class="codeLine">inline auto m_LogicalOp() { return m_LogicalOp(m_Value(), m_Value()); }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2638</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2638</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2639</td>
    <td class="codeLine">/// Matches either L && R or L || R with LHS and RHS in either order.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2639</td>
    <td class="codeLine">/// Matches either L && R or L || R with LHS and RHS in either order.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2640</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2640</td>
    <td class="codeLine">template <typename LHS, typename RHS></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2641</td>
    <td class="codeLine">inline auto m_c_LogicalOp(const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2641</td>
    <td class="codeLine">inline auto m_c_LogicalOp(const LHS &L, const RHS &R) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2642</td>
    <td class="codeLine">  return m_LogicalOp<LHS, RHS, /*Commutable=*/true>(L, R);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2642</td>
    <td class="codeLine">  return m_LogicalOp<LHS, RHS, /*Commutable=*/true>(L, R);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2643</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2643</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2644</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2644</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2645</td>
    <td class="codeLine">} // end namespace PatternMatch</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2645</td>
    <td class="codeLine">} // end namespace PatternMatch</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2646</td>
    <td class="codeLine">} // end namespace llvm</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2646</td>
    <td class="codeLine">} // end namespace llvm</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2647</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2647</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2648</td>
    <td class="codeLine">#endif // LLVM_IR_PATTERNMATCH_H</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2648</td>
    <td class="codeLine">#endif // LLVM_IR_PATTERNMATCH_H</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2649</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2649</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
</table>
    </div>
    <button id="myBtn" onclick="topFunction()" title="Go to top" type="button">Top</button>
    <script src="../Javascript/drop_down.js"></script>
    <script src="../Javascript/top_button.js"></script>
  </body>
</html>