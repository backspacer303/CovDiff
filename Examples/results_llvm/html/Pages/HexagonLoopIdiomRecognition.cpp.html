<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>HexagonLoopIdiomRecognition.cpp</title>
    <link rel="stylesheet" href="../Style/style.css" />
  </head>
  <body>
    <div class="headerDiv">
      <h1>
        Code Coverage
      </h1>
      <p>
        Source file: /home/nikola/Desktop/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
      </p>
    </div>
    <button class="collapsible" type="button">Open Summary Report</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Summary Report</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line number</th>
    <th class="mainTh">Line</th>
    <th class="mainTh">Number of hits</th>
    <th class="mainTh">Tests that cover line</th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="">//===- HexagonLoopIdiomRecognition.cpp ------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="">#include "HexagonLoopIdiomRecognition.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="">#include "llvm/ADT/APInt.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="">#include "llvm/ADT/DenseMap.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="">#include "llvm/ADT/SetVector.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="">#include "llvm/ADT/SmallPtrSet.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="">#include "llvm/ADT/SmallSet.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="">#include "llvm/ADT/SmallVector.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="">#include "llvm/ADT/StringRef.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="">#include "llvm/Analysis/AliasAnalysis.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="">#include "llvm/Analysis/InstructionSimplify.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="">#include "llvm/Analysis/LoopAnalysisManager.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="">#include "llvm/Analysis/LoopInfo.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="">#include "llvm/Analysis/LoopPass.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="">#include "llvm/Analysis/MemoryLocation.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="">#include "llvm/Analysis/ScalarEvolution.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="">#include "llvm/Analysis/ScalarEvolutionExpressions.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="">#include "llvm/Analysis/TargetLibraryInfo.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="">#include "llvm/Analysis/ValueTracking.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="">#include "llvm/IR/Attributes.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="">#include "llvm/IR/BasicBlock.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="">#include "llvm/IR/Constant.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="">#include "llvm/IR/Constants.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="">#include "llvm/IR/DataLayout.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="">#include "llvm/IR/DebugLoc.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="">#include "llvm/IR/DerivedTypes.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="">#include "llvm/IR/Dominators.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="">#include "llvm/IR/Function.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="">#include "llvm/IR/IRBuilder.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="">#include "llvm/IR/InstrTypes.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="">#include "llvm/IR/Instruction.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="">#include "llvm/IR/Instructions.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="">#include "llvm/IR/IntrinsicInst.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="">#include "llvm/IR/Intrinsics.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="">#include "llvm/IR/IntrinsicsHexagon.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="">#include "llvm/IR/Module.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="">#include "llvm/IR/PassManager.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="">#include "llvm/IR/PatternMatch.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="">#include "llvm/IR/Type.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="">#include "llvm/IR/User.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="">#include "llvm/IR/Value.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="">#include "llvm/InitializePasses.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="">#include "llvm/Pass.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="">#include "llvm/Support/Casting.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="">#include "llvm/Support/CommandLine.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="">#include "llvm/Support/Compiler.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="">#include "llvm/Support/Debug.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="">#include "llvm/Support/ErrorHandling.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="">#include "llvm/Support/KnownBits.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="">#include "llvm/Support/raw_ostream.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="">#include "llvm/TargetParser/Triple.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="">#include "llvm/Transforms/Scalar.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="">#include "llvm/Transforms/Utils.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="">#include "llvm/Transforms/Utils/Local.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="">#include "llvm/Transforms/Utils/ScalarEvolutionExpander.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="">#include <algorithm></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="">#include <array></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="">#include <cassert></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="">#include <cstdint></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="">#include <cstdlib></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="">#include <deque></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="">#include <functional></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="">#include <iterator></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="">#include <map></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="">#include <set></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="">#include <utility></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="">#include <vector></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="">#define DEBUG_TYPE "hexagon-lir"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="">using namespace llvm;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="">static cl::opt<bool> DisableMemcpyIdiom("disable-memcpy-idiom",</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="">  cl::Hidden, cl::init(false),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="">  cl::desc("Disable generation of memcpy in loop idiom recognition"));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="">static cl::opt<bool> DisableMemmoveIdiom("disable-memmove-idiom",</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="">  cl::Hidden, cl::init(false),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="">  cl::desc("Disable generation of memmove in loop idiom recognition"));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="">static cl::opt<unsigned> RuntimeMemSizeThreshold("runtime-mem-idiom-threshold",</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="">  cl::Hidden, cl::init(0), cl::desc("Threshold (in bytes) for the runtime "</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="">  "check guarding the memmove."));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="">static cl::opt<unsigned> CompileTimeMemSizeThreshold(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="">  "compile-time-mem-idiom-threshold", cl::Hidden, cl::init(64),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="">  cl::desc("Threshold (in bytes) to perform the transformation, if the "</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="">    "runtime loop count (mem transfer size) is known at compile-time."));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="">static cl::opt<bool> OnlyNonNestedMemmove("only-nonnested-memmove-idiom",</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="">  cl::Hidden, cl::init(true),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="">  cl::desc("Only enable generating memmove in non-nested loops"));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="">static cl::opt<bool> HexagonVolatileMemcpy(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="">    "disable-hexagon-volatile-memcpy", cl::Hidden, cl::init(false),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="">    cl::desc("Enable Hexagon-specific memcpy for volatile destination."));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="">static cl::opt<unsigned> SimplifyLimit("hlir-simplify-limit", cl::init(10000),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="">  cl::Hidden, cl::desc("Maximum number of simplification steps in HLIR"));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="">static const char *HexagonVolatileMemcpyName</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="">  = "hexagon_memcpy_forward_vp4cp4n2";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="">namespace llvm {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="">void initializeHexagonLoopIdiomRecognizeLegacyPassPass(PassRegistry &);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="">Pass *createHexagonLoopIdiomPass();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="">} // end namespace llvm</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="">namespace {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="">class HexagonLoopIdiomRecognize {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="uncoveredLine">  explicit HexagonLoopIdiomRecognize(AliasAnalysis *AA, DominatorTree *DT,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="">                                     LoopInfo *LF, const TargetLibraryInfo *TLI,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="">                                     ScalarEvolution *SE)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="uncoveredLine">      : AA(AA), DT(DT), LF(LF), TLI(TLI), SE(SE) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="">  bool run(Loop *L);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="">private:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="">  int getSCEVStride(const SCEVAddRecExpr *StoreEv);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="">  bool isLegalStore(Loop *CurLoop, StoreInst *SI);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="">  void collectStores(Loop *CurLoop, BasicBlock *BB,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="">                     SmallVectorImpl<StoreInst *> &Stores);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="">  bool processCopyingStore(Loop *CurLoop, StoreInst *SI, const SCEV *BECount);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="">  bool coverLoop(Loop *L, SmallVectorImpl<Instruction *> &Insts) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="">  bool runOnLoopBlock(Loop *CurLoop, BasicBlock *BB, const SCEV *BECount,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="">                      SmallVectorImpl<BasicBlock *> &ExitBlocks);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="">  bool runOnCountableLoop(Loop *L);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="">  AliasAnalysis *AA;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="">  const DataLayout *DL;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="">  DominatorTree *DT;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="">  LoopInfo *LF;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="">  const TargetLibraryInfo *TLI;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="">  ScalarEvolution *SE;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="">  bool HasMemcpy, HasMemmove;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="">class HexagonLoopIdiomRecognizeLegacyPass : public LoopPass {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="">  static char ID;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="uncoveredLine">  explicit HexagonLoopIdiomRecognizeLegacyPass() : LoopPass(ID) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="uncoveredLine">    initializeHexagonLoopIdiomRecognizeLegacyPassPass(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="uncoveredLine">        *PassRegistry::getPassRegistry());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="uncoveredLine">  StringRef getPassName() const override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="uncoveredLine">    return "Recognize Hexagon-specific loop idioms";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="uncoveredLine">  void getAnalysisUsage(AnalysisUsage &AU) const override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="uncoveredLine">    AU.addRequired<LoopInfoWrapperPass>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="uncoveredLine">    AU.addRequiredID(LoopSimplifyID);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="uncoveredLine">    AU.addRequiredID(LCSSAID);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="uncoveredLine">    AU.addRequired<AAResultsWrapperPass>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="uncoveredLine">    AU.addRequired<ScalarEvolutionWrapperPass>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="uncoveredLine">    AU.addRequired<DominatorTreeWrapperPass>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="uncoveredLine">    AU.addRequired<TargetLibraryInfoWrapperPass>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="uncoveredLine">    AU.addPreserved<TargetLibraryInfoWrapperPass>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="">  bool runOnLoop(Loop *L, LPPassManager &LPM) override;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="">struct Simplifier {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="">  struct Rule {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="">    using FuncType = std::function<Value *(Instruction *, LLVMContext &)>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="uncoveredLine">    Rule(StringRef N, FuncType F) : Name(N), Fn(F) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="">    StringRef Name; // For debugging.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="">    FuncType Fn;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="uncoveredLine">  void addRule(StringRef N, const Rule::FuncType &F) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="uncoveredLine">    Rules.push_back(Rule(N, F));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="">private:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="">  struct WorkListType {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="uncoveredLine">    WorkListType() = default;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="uncoveredLine">    void push_back(Value *V) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="">      // Do not push back duplicates.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="uncoveredLine">      if (S.insert(V).second)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="uncoveredLine">        Q.push_back(V);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="uncoveredLine">    }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="uncoveredLine">    Value *pop_front_val() {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="uncoveredLine">      Value *V = Q.front();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="uncoveredLine">      Q.pop_front();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="uncoveredLine">      S.erase(V);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="uncoveredLine">      return V;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="uncoveredLine">    bool empty() const { return Q.empty(); }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="">  private:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="">    std::deque<Value *> Q;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="">    std::set<Value *> S;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="">  using ValueSetType = std::set<Value *>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="">  std::vector<Rule> Rules;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="">  struct Context {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="">    using ValueMapType = DenseMap<Value *, Value *>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="">    Value *Root;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="">    ValueSetType Used;   // The set of all cloned values used by Root.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="">    ValueSetType Clones; // The set of all cloned values.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="">    LLVMContext &Ctx;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="uncoveredLine">    Context(Instruction *Exp)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="uncoveredLine">        : Ctx(Exp->getParent()->getParent()->getContext()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="uncoveredLine">      initialize(Exp);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="uncoveredLine">    }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="uncoveredLine">    ~Context() { cleanup(); }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="">    void print(raw_ostream &OS, const Value *V) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="">    Value *materialize(BasicBlock *B, BasicBlock::iterator At);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="">  private:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="">    friend struct Simplifier;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="">    void initialize(Instruction *Exp);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="">    void cleanup();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="">    template <typename FuncT> void traverse(Value *V, FuncT F);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="">    void record(Value *V);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="">    void use(Value *V);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="">    void unuse(Value *V);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="">    bool equal(const Instruction *I, const Instruction *J) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="">    Value *find(Value *Tree, Value *Sub) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="">    Value *subst(Value *Tree, Value *OldV, Value *NewV);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="">    void replace(Value *OldV, Value *NewV);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="">    void link(Instruction *I, BasicBlock *B, BasicBlock::iterator At);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="">  Value *simplify(Context &C);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="">  struct PE {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="uncoveredLine">    PE(const Simplifier::Context &c, Value *v = nullptr) : C(c), V(v) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="">    const Simplifier::Context &C;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="">    const Value *V;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="">  LLVM_ATTRIBUTE_USED</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="uncoveredLine">  raw_ostream &operator<<(raw_ostream &OS, const PE &P) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="uncoveredLine">    P.C.print(OS, P.V ? P.V : P.C.Root);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="uncoveredLine">    return OS;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="">} // end anonymous namespace</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="">char HexagonLoopIdiomRecognizeLegacyPass::ID = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="coveredLine">INITIALIZE_PASS_BEGIN(HexagonLoopIdiomRecognizeLegacyPass, "hexagon-loop-idiom",</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="">                      "Recognize Hexagon-specific loop idioms", false, false)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="coveredLine">INITIALIZE_PASS_DEPENDENCY(LoopInfoWrapperPass)</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="coveredLine">INITIALIZE_PASS_DEPENDENCY(LoopSimplify)</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="coveredLine">INITIALIZE_PASS_DEPENDENCY(LCSSAWrapperPass)</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="coveredLine">INITIALIZE_PASS_DEPENDENCY(ScalarEvolutionWrapperPass)</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="coveredLine">INITIALIZE_PASS_DEPENDENCY(DominatorTreeWrapperPass)</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="coveredLine">INITIALIZE_PASS_DEPENDENCY(TargetLibraryInfoWrapperPass)</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="coveredLine">INITIALIZE_PASS_DEPENDENCY(AAResultsWrapperPass)</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="coveredLine">INITIALIZE_PASS_END(HexagonLoopIdiomRecognizeLegacyPass, "hexagon-loop-idiom",</td>
    <td>4</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="">                    "Recognize Hexagon-specific loop idioms", false, false)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="">template <typename FuncT></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="uncoveredLine">void Simplifier::Context::traverse(Value *V, FuncT F) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="uncoveredLine">  WorkListType Q;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="uncoveredLine">  Q.push_back(V);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="uncoveredLine">  while (!Q.empty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="uncoveredLine">    Instruction *U = dyn_cast<Instruction>(Q.pop_front_val());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="uncoveredLine">    if (!U || U->getParent())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="uncoveredLine">    if (!F(U))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="uncoveredLine">    for (Value *Op : U->operands())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="uncoveredLine">      Q.push_back(Op);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="uncoveredLine">void Simplifier::Context::print(raw_ostream &OS, const Value *V) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="uncoveredLine">  const auto *U = dyn_cast<const Instruction>(V);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="uncoveredLine">  if (!U) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="uncoveredLine">    OS << V << '(' << *V << ')';</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="uncoveredLine">  if (U->getParent()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="uncoveredLine">    OS << U << '(';</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="uncoveredLine">    U->printAsOperand(OS, true);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="uncoveredLine">    OS << ')';</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="uncoveredLine">  unsigned N = U->getNumOperands();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="uncoveredLine">  if (N != 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="uncoveredLine">    OS << U << '(';</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="uncoveredLine">  OS << U->getOpcodeName();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="uncoveredLine">  for (const Value *Op : U->operands()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="uncoveredLine">    OS << ' ';</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="uncoveredLine">    print(OS, Op);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="uncoveredLine">  if (N != 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="uncoveredLine">    OS << ')';</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="uncoveredLine">void Simplifier::Context::initialize(Instruction *Exp) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="">  // Perform a deep clone of the expression, set Root to the root</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="">  // of the clone, and build a map from the cloned values to the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="">  // original ones.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="uncoveredLine">  ValueMapType M;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="uncoveredLine">  BasicBlock *Block = Exp->getParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="uncoveredLine">  WorkListType Q;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="uncoveredLine">  Q.push_back(Exp);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="uncoveredLine">  while (!Q.empty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="uncoveredLine">    Value *V = Q.pop_front_val();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="uncoveredLine">    if (M.contains(V))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="uncoveredLine">    if (Instruction *U = dyn_cast<Instruction>(V)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="uncoveredLine">      if (isa<PHINode>(U) || U->getParent() != Block)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="uncoveredLine">      for (Value *Op : U->operands())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="uncoveredLine">        Q.push_back(Op);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="uncoveredLine">      M.insert({U, U->clone()});</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="uncoveredLine">  for (std::pair<Value*,Value*> P : M) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="uncoveredLine">    Instruction *U = cast<Instruction>(P.second);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="uncoveredLine">    for (unsigned i = 0, n = U->getNumOperands(); i != n; ++i) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="uncoveredLine">      auto F = M.find(U->getOperand(i));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="uncoveredLine">      if (F != M.end())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="uncoveredLine">        U->setOperand(i, F->second);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="uncoveredLine">  auto R = M.find(Exp);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="uncoveredLine">  assert(R != M.end());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="uncoveredLine">  Root = R->second;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="uncoveredLine">  record(Root);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="uncoveredLine">  use(Root);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="uncoveredLine">void Simplifier::Context::record(Value *V) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="uncoveredLine">  auto Record = [this](Instruction *U) -> bool {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="uncoveredLine">    Clones.insert(U);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="uncoveredLine">  };</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="uncoveredLine">  traverse(V, Record);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="uncoveredLine">void Simplifier::Context::use(Value *V) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="uncoveredLine">  auto Use = [this](Instruction *U) -> bool {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="uncoveredLine">    Used.insert(U);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="uncoveredLine">  };</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="uncoveredLine">  traverse(V, Use);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="uncoveredLine">void Simplifier::Context::unuse(Value *V) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="uncoveredLine">  if (!isa<Instruction>(V) || cast<Instruction>(V)->getParent() != nullptr)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="uncoveredLine">  auto Unuse = [this](Instruction *U) -> bool {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="uncoveredLine">    if (!U->use_empty())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="uncoveredLine">    Used.erase(U);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="uncoveredLine">  };</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="uncoveredLine">  traverse(V, Unuse);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="uncoveredLine">Value *Simplifier::Context::subst(Value *Tree, Value *OldV, Value *NewV) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="uncoveredLine">  if (Tree == OldV)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="uncoveredLine">    return NewV;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="uncoveredLine">  if (OldV == NewV)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="uncoveredLine">    return Tree;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="uncoveredLine">  WorkListType Q;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="uncoveredLine">  Q.push_back(Tree);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="uncoveredLine">  while (!Q.empty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="uncoveredLine">    Instruction *U = dyn_cast<Instruction>(Q.pop_front_val());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="">    // If U is not an instruction, or it's not a clone, skip it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="uncoveredLine">    if (!U || U->getParent())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="uncoveredLine">    for (unsigned i = 0, n = U->getNumOperands(); i != n; ++i) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="uncoveredLine">      Value *Op = U->getOperand(i);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="uncoveredLine">      if (Op == OldV) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="uncoveredLine">        U->setOperand(i, NewV);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="uncoveredLine">        unuse(OldV);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="">      } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="uncoveredLine">        Q.push_back(Op);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="uncoveredLine">  return Tree;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="uncoveredLine">void Simplifier::Context::replace(Value *OldV, Value *NewV) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="uncoveredLine">  if (Root == OldV) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="uncoveredLine">    Root = NewV;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="uncoveredLine">    use(Root);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="">  // NewV may be a complex tree that has just been created by one of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="">  // transformation rules. We need to make sure that it is commoned with</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="">  // the existing Root to the maximum extent possible.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="">  // Identify all subtrees of NewV (including NewV itself) that have</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="">  // equivalent counterparts in Root, and replace those subtrees with</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="">  // these counterparts.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="uncoveredLine">  WorkListType Q;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="uncoveredLine">  Q.push_back(NewV);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="uncoveredLine">  while (!Q.empty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="uncoveredLine">    Value *V = Q.pop_front_val();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="uncoveredLine">    Instruction *U = dyn_cast<Instruction>(V);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="uncoveredLine">    if (!U || U->getParent())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="uncoveredLine">    if (Value *DupV = find(Root, V)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="uncoveredLine">      if (DupV != V)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="uncoveredLine">        NewV = subst(NewV, V, DupV);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="">    } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="uncoveredLine">      for (Value *Op : U->operands())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="uncoveredLine">        Q.push_back(Op);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="">  // Now, simply replace OldV with NewV in Root.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="uncoveredLine">  Root = subst(Root, OldV, NewV);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="uncoveredLine">  use(Root);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="uncoveredLine">void Simplifier::Context::cleanup() {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="uncoveredLine">  for (Value *V : Clones) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="uncoveredLine">    Instruction *U = cast<Instruction>(V);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="uncoveredLine">    if (!U->getParent())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="uncoveredLine">      U->dropAllReferences();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="uncoveredLine">  for (Value *V : Clones) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="uncoveredLine">    Instruction *U = cast<Instruction>(V);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="uncoveredLine">    if (!U->getParent())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="uncoveredLine">      U->deleteValue();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="uncoveredLine">bool Simplifier::Context::equal(const Instruction *I,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="">                                const Instruction *J) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="uncoveredLine">  if (I == J)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="uncoveredLine">  if (!I->isSameOperationAs(J))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="uncoveredLine">  if (isa<PHINode>(I))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="uncoveredLine">    return I->isIdenticalTo(J);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="uncoveredLine">  for (unsigned i = 0, n = I->getNumOperands(); i != n; ++i) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="uncoveredLine">    Value *OpI = I->getOperand(i), *OpJ = J->getOperand(i);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="uncoveredLine">    if (OpI == OpJ)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="uncoveredLine">    auto *InI = dyn_cast<const Instruction>(OpI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="uncoveredLine">    auto *InJ = dyn_cast<const Instruction>(OpJ);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="uncoveredLine">    if (InI && InJ) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="uncoveredLine">      if (!equal(InI, InJ))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="uncoveredLine">        return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="uncoveredLine">    } else if (InI != InJ || !InI)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="uncoveredLine">  return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="uncoveredLine">Value *Simplifier::Context::find(Value *Tree, Value *Sub) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="uncoveredLine">  Instruction *SubI = dyn_cast<Instruction>(Sub);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="uncoveredLine">  WorkListType Q;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="uncoveredLine">  Q.push_back(Tree);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="uncoveredLine">  while (!Q.empty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="uncoveredLine">    Value *V = Q.pop_front_val();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="uncoveredLine">    if (V == Sub)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="uncoveredLine">      return V;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="uncoveredLine">    Instruction *U = dyn_cast<Instruction>(V);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class="uncoveredLine">    if (!U || U->getParent())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="uncoveredLine">    if (SubI && equal(SubI, U))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="uncoveredLine">      return U;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="uncoveredLine">    assert(!isa<PHINode>(U));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="uncoveredLine">    for (Value *Op : U->operands())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="uncoveredLine">      Q.push_back(Op);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="uncoveredLine">  return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="uncoveredLine">void Simplifier::Context::link(Instruction *I, BasicBlock *B,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="">      BasicBlock::iterator At) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class="uncoveredLine">  if (I->getParent())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class="uncoveredLine">  for (Value *Op : I->operands()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="uncoveredLine">    if (Instruction *OpI = dyn_cast<Instruction>(Op))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="uncoveredLine">      link(OpI, B, At);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="uncoveredLine">  I->insertInto(B, At);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="uncoveredLine">Value *Simplifier::Context::materialize(BasicBlock *B,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="">      BasicBlock::iterator At) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="uncoveredLine">  if (Instruction *RootI = dyn_cast<Instruction>(Root))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="uncoveredLine">    link(RootI, B, At);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="uncoveredLine">  return Root;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="uncoveredLine">Value *Simplifier::simplify(Context &C) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="uncoveredLine">  WorkListType Q;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="uncoveredLine">  Q.push_back(C.Root);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="uncoveredLine">  unsigned Count = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="uncoveredLine">  const unsigned Limit = SimplifyLimit;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="uncoveredLine">  while (!Q.empty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="uncoveredLine">    if (Count++ >= Limit)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="uncoveredLine">    Instruction *U = dyn_cast<Instruction>(Q.pop_front_val());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="uncoveredLine">    if (!U || U->getParent() || !C.Used.count(U))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="uncoveredLine">    bool Changed = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="uncoveredLine">    for (Rule &R : Rules) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="uncoveredLine">      Value *W = R.Fn(U, C.Ctx);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="uncoveredLine">      if (!W)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="uncoveredLine">      Changed = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="uncoveredLine">      C.record(W);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="uncoveredLine">      C.replace(U, W);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="uncoveredLine">      Q.push_back(C.Root);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="uncoveredLine">    if (!Changed) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="uncoveredLine">      for (Value *Op : U->operands())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="uncoveredLine">        Q.push_back(Op);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="uncoveredLine">  return Count < Limit ? C.Root : nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="">//          Implementation of PolynomialMultiplyRecognize</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="">namespace {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="">  class PolynomialMultiplyRecognize {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="">  public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="uncoveredLine">    explicit PolynomialMultiplyRecognize(Loop *loop, const DataLayout &dl,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="">        const DominatorTree &dt, const TargetLibraryInfo &tli,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="">        ScalarEvolution &se)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class="uncoveredLine">      : CurLoop(loop), DL(dl), DT(dt), TLI(tli), SE(se) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="">    bool recognize();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="">  private:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="">    using ValueSeq = SetVector<Value *>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="uncoveredLine">    IntegerType *getPmpyType() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class="uncoveredLine">      LLVMContext &Ctx = CurLoop->getHeader()->getParent()->getContext();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="uncoveredLine">      return IntegerType::get(Ctx, 32);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="">    bool isPromotableTo(Value *V, IntegerType *Ty);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="">    void promoteTo(Instruction *In, IntegerType *DestTy, BasicBlock *LoopB);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="">    bool promoteTypes(BasicBlock *LoopB, BasicBlock *ExitB);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="">    Value *getCountIV(BasicBlock *BB);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="">    bool findCycle(Value *Out, Value *In, ValueSeq &Cycle);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class="">    void classifyCycle(Instruction *DivI, ValueSeq &Cycle, ValueSeq &Early,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="">          ValueSeq &Late);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="">    bool classifyInst(Instruction *UseI, ValueSeq &Early, ValueSeq &Late);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="">    bool commutesWithShift(Instruction *I);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="">    bool highBitsAreZero(Value *V, unsigned IterCount);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="">    bool keepsHighBitsZero(Value *V, unsigned IterCount);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="">    bool isOperandShifted(Instruction *I, Value *Op);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="">    bool convertShiftsToLeft(BasicBlock *LoopB, BasicBlock *ExitB,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="">          unsigned IterCount);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="">    void cleanupLoopBody(BasicBlock *LoopB);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="">    struct ParsedValues {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="">      ParsedValues() = default;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="">      Value *M = nullptr;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="">      Value *P = nullptr;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class="">      Value *Q = nullptr;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class="">      Value *R = nullptr;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="">      Value *X = nullptr;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="">      Instruction *Res = nullptr;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="">      unsigned IterCount = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class="">      bool Left = false;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="">      bool Inv = false;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="">    };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="">    bool matchLeftShift(SelectInst *SelI, Value *CIV, ParsedValues &PV);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="">    bool matchRightShift(SelectInst *SelI, ParsedValues &PV);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="">    bool scanSelect(SelectInst *SI, BasicBlock *LoopB, BasicBlock *PrehB,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="">          Value *CIV, ParsedValues &PV, bool PreScan);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="">    unsigned getInverseMxN(unsigned QP);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="">    Value *generate(BasicBlock::iterator At, ParsedValues &PV);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="">    void setupPreSimplifier(Simplifier &S);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class="">    void setupPostSimplifier(Simplifier &S);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="">    Loop *CurLoop;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="">    const DataLayout &DL;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="">    const DominatorTree &DT;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="">    const TargetLibraryInfo &TLI;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="">    ScalarEvolution &SE;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="">} // end anonymous namespace</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="uncoveredLine">Value *PolynomialMultiplyRecognize::getCountIV(BasicBlock *BB) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="uncoveredLine">  pred_iterator PI = pred_begin(BB), PE = pred_end(BB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="uncoveredLine">  if (std::distance(PI, PE) != 2)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class="uncoveredLine">    return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="uncoveredLine">  BasicBlock *PB = (*PI == BB) ? *std::next(PI) : *PI;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="uncoveredLine">  for (auto I = BB->begin(), E = BB->end(); I != E && isa<PHINode>(I); ++I) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="uncoveredLine">    auto *PN = cast<PHINode>(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="uncoveredLine">    Value *InitV = PN->getIncomingValueForBlock(PB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="uncoveredLine">    if (!isa<ConstantInt>(InitV) || !cast<ConstantInt>(InitV)->isZero())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="uncoveredLine">    Value *IterV = PN->getIncomingValueForBlock(BB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="uncoveredLine">    auto *BO = dyn_cast<BinaryOperator>(IterV);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="uncoveredLine">    if (!BO)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="uncoveredLine">    if (BO->getOpcode() != Instruction::Add)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="uncoveredLine">    Value *IncV = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="uncoveredLine">    if (BO->getOperand(0) == PN)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="uncoveredLine">      IncV = BO->getOperand(1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="uncoveredLine">    else if (BO->getOperand(1) == PN)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="uncoveredLine">      IncV = BO->getOperand(0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="uncoveredLine">    if (IncV == nullptr)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="uncoveredLine">    if (auto *T = dyn_cast<ConstantInt>(IncV))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="uncoveredLine">      if (T->isOne())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="uncoveredLine">        return PN;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="uncoveredLine">  return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="uncoveredLine">static void replaceAllUsesOfWithIn(Value *I, Value *J, BasicBlock *BB) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="uncoveredLine">  for (auto UI = I->user_begin(), UE = I->user_end(); UI != UE;) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class="uncoveredLine">    Use &TheUse = UI.getUse();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class="uncoveredLine">    ++UI;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="uncoveredLine">    if (auto *II = dyn_cast<Instruction>(TheUse.getUser()))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="uncoveredLine">      if (BB == II->getParent())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="uncoveredLine">        II->replaceUsesOfWith(I, J);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class="uncoveredLine">bool PolynomialMultiplyRecognize::matchLeftShift(SelectInst *SelI,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="">      Value *CIV, ParsedValues &PV) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class="">  // Match the following:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="">  //   select (X & (1 << i)) != 0 ? R ^ (Q << i) : R</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="">  //   select (X & (1 << i)) == 0 ? R : R ^ (Q << i)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class="">  // The condition may also check for equality with the masked value, i.e</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class="">  //   select (X & (1 << i)) == (1 << i) ? R ^ (Q << i) : R</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class="">  //   select (X & (1 << i)) != (1 << i) ? R : R ^ (Q << i);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="uncoveredLine">  Value *CondV = SelI->getCondition();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class="uncoveredLine">  Value *TrueV = SelI->getTrueValue();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class="uncoveredLine">  Value *FalseV = SelI->getFalseValue();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="">  using namespace PatternMatch;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class="">  CmpInst::Predicate P;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class="uncoveredLine">  Value *A = nullptr, *B = nullptr, *C = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="uncoveredLine">  if (!match(CondV, m_ICmp(P, m_And(m_Value(A), m_Value(B)), m_Value(C))) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class="uncoveredLine">      !match(CondV, m_ICmp(P, m_Value(C), m_And(m_Value(A), m_Value(B)))))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class="uncoveredLine">  if (P != CmpInst::ICMP_EQ && P != CmpInst::ICMP_NE)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class="">  // Matched: select (A & B) == C ? ... : ...</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class="">  //          select (A & B) != C ? ... : ...</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class="uncoveredLine">  Value *X = nullptr, *Sh1 = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="">  // Check (A & B) for (X & (1 << i)):</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class="uncoveredLine">  if (match(A, m_Shl(m_One(), m_Specific(CIV)))) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class="uncoveredLine">    Sh1 = A;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="uncoveredLine">    X = B;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="uncoveredLine">  } else if (match(B, m_Shl(m_One(), m_Specific(CIV)))) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="uncoveredLine">    Sh1 = B;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="uncoveredLine">    X = A;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class="">  } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class="">    // TODO: Could also check for an induction variable containing single</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class="">    // bit shifted left by 1 in each iteration.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="">  bool TrueIfZero;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="">  // Check C against the possible values for comparison: 0 and (1 << i):</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class="uncoveredLine">  if (match(C, m_Zero()))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class="uncoveredLine">    TrueIfZero = (P == CmpInst::ICMP_EQ);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class="uncoveredLine">  else if (C == Sh1)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="uncoveredLine">    TrueIfZero = (P == CmpInst::ICMP_NE);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class="">  else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="">  // So far, matched:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="">  //   select (X & (1 << i)) ? ... : ...</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class="">  // including variations of the check against zero/non-zero value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class="uncoveredLine">  Value *ShouldSameV = nullptr, *ShouldXoredV = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class="uncoveredLine">  if (TrueIfZero) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class="uncoveredLine">    ShouldSameV = TrueV;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="uncoveredLine">    ShouldXoredV = FalseV;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class="">  } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class="uncoveredLine">    ShouldSameV = FalseV;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class="uncoveredLine">    ShouldXoredV = TrueV;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class="uncoveredLine">  Value *Q = nullptr, *R = nullptr, *Y = nullptr, *Z = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class="uncoveredLine">  Value *T = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="uncoveredLine">  if (match(ShouldXoredV, m_Xor(m_Value(Y), m_Value(Z)))) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="">    // Matched: select +++ ? ... : Y ^ Z</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="">    //          select +++ ? Y ^ Z : ...</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class="">    // where +++ denotes previously checked matches.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class="uncoveredLine">    if (ShouldSameV == Y)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class="uncoveredLine">      T = Z;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class="uncoveredLine">    else if (ShouldSameV == Z)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class="uncoveredLine">      T = Y;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="">    else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="uncoveredLine">    R = ShouldSameV;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="">    // Matched: select +++ ? R : R ^ T</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class="">    //          select +++ ? R ^ T : R</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class="">    // depending on TrueIfZero.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="uncoveredLine">  } else if (match(ShouldSameV, m_Zero())) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class="">    // Matched: select +++ ? 0 : ...</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class="">    //          select +++ ? ... : 0</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class="uncoveredLine">    if (!SelI->hasOneUse())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class="uncoveredLine">    T = ShouldXoredV;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="">    // Matched: select +++ ? 0 : T</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="">    //          select +++ ? T : 0</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="uncoveredLine">    Value *U = *SelI->user_begin();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class="uncoveredLine">    if (!match(U, m_Xor(m_Specific(SelI), m_Value(R))) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="uncoveredLine">        !match(U, m_Xor(m_Value(R), m_Specific(SelI))))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class="">    // Matched: xor (select +++ ? 0 : T), R</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="">    //          xor (select +++ ? T : 0), R</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class="">  } else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class="">  // The xor input value T is isolated into its own match so that it could</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="">  // be checked against an induction variable containing a shifted bit</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="">  // (todo).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class="">  // For now, check against (Q << i).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class="uncoveredLine">  if (!match(T, m_Shl(m_Value(Q), m_Specific(CIV))) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class="uncoveredLine">      !match(T, m_Shl(m_ZExt(m_Value(Q)), m_ZExt(m_Specific(CIV)))))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="">  // Matched: select +++ ? R : R ^ (Q << i)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class="">  //          select +++ ? R ^ (Q << i) : R</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class="uncoveredLine">  PV.X = X;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class="uncoveredLine">  PV.Q = Q;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="uncoveredLine">  PV.R = R;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class="uncoveredLine">  PV.Left = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="uncoveredLine">  return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class="uncoveredLine">bool PolynomialMultiplyRecognize::matchRightShift(SelectInst *SelI,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class="">      ParsedValues &PV) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class="">  // Match the following:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class="">  //   select (X & 1) != 0 ? (R >> 1) ^ Q : (R >> 1)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class="">  //   select (X & 1) == 0 ? (R >> 1) : (R >> 1) ^ Q</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class="">  // The condition may also check for equality with the masked value, i.e</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class="">  //   select (X & 1) == 1 ? (R >> 1) ^ Q : (R >> 1)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class="">  //   select (X & 1) != 1 ? (R >> 1) : (R >> 1) ^ Q</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class="uncoveredLine">  Value *CondV = SelI->getCondition();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class="uncoveredLine">  Value *TrueV = SelI->getTrueValue();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class="uncoveredLine">  Value *FalseV = SelI->getFalseValue();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class="">  using namespace PatternMatch;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class="uncoveredLine">  Value *C = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class="">  CmpInst::Predicate P;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class="">  bool TrueIfZero;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class="uncoveredLine">  if (match(CondV, m_ICmp(P, m_Value(C), m_Zero())) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class="uncoveredLine">      match(CondV, m_ICmp(P, m_Zero(), m_Value(C)))) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class="uncoveredLine">    if (P != CmpInst::ICMP_EQ && P != CmpInst::ICMP_NE)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class="">    // Matched: select C == 0 ? ... : ...</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class="">    //          select C != 0 ? ... : ...</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class="uncoveredLine">    TrueIfZero = (P == CmpInst::ICMP_EQ);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class="uncoveredLine">  } else if (match(CondV, m_ICmp(P, m_Value(C), m_One())) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class="uncoveredLine">             match(CondV, m_ICmp(P, m_One(), m_Value(C)))) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class="uncoveredLine">    if (P != CmpInst::ICMP_EQ && P != CmpInst::ICMP_NE)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class="">    // Matched: select C == 1 ? ... : ...</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class="">    //          select C != 1 ? ... : ...</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class="uncoveredLine">    TrueIfZero = (P == CmpInst::ICMP_NE);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class="">  } else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class="uncoveredLine">  Value *X = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class="uncoveredLine">  if (!match(C, m_And(m_Value(X), m_One())) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class="uncoveredLine">      !match(C, m_And(m_One(), m_Value(X))))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class="">  // Matched: select (X & 1) == +++ ? ... : ...</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class="">  //          select (X & 1) != +++ ? ... : ...</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class="uncoveredLine">  Value *R = nullptr, *Q = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class="uncoveredLine">  if (TrueIfZero) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class="">    // The select's condition is true if the tested bit is 0.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class="">    // TrueV must be the shift, FalseV must be the xor.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class="uncoveredLine">    if (!match(TrueV, m_LShr(m_Value(R), m_One())))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class="">    // Matched: select +++ ? (R >> 1) : ...</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class="uncoveredLine">    if (!match(FalseV, m_Xor(m_Specific(TrueV), m_Value(Q))) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class="uncoveredLine">        !match(FalseV, m_Xor(m_Value(Q), m_Specific(TrueV))))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class="">    // Matched: select +++ ? (R >> 1) : (R >> 1) ^ Q</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class="">    // with commuting ^.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class="">  } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class="">    // The select's condition is true if the tested bit is 1.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class="">    // TrueV must be the xor, FalseV must be the shift.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class="uncoveredLine">    if (!match(FalseV, m_LShr(m_Value(R), m_One())))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class="">    // Matched: select +++ ? ... : (R >> 1)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class="uncoveredLine">    if (!match(TrueV, m_Xor(m_Specific(FalseV), m_Value(Q))) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class="uncoveredLine">        !match(TrueV, m_Xor(m_Value(Q), m_Specific(FalseV))))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class="">    // Matched: select +++ ? (R >> 1) ^ Q : (R >> 1)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class="">    // with commuting ^.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class="uncoveredLine">  PV.X = X;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class="uncoveredLine">  PV.Q = Q;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class="uncoveredLine">  PV.R = R;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class="uncoveredLine">  PV.Left = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="uncoveredLine">  return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">872</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">873</td>
    <td class="uncoveredLine">bool PolynomialMultiplyRecognize::scanSelect(SelectInst *SelI,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">874</td>
    <td class="">      BasicBlock *LoopB, BasicBlock *PrehB, Value *CIV, ParsedValues &PV,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">875</td>
    <td class="">      bool PreScan) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">876</td>
    <td class="">  using namespace PatternMatch;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">877</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">878</td>
    <td class="">  // The basic pattern for R = P.Q is:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">879</td>
    <td class="">  // for i = 0..31</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">880</td>
    <td class="">  //   R = phi (0, R')</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">881</td>
    <td class="">  //   if (P & (1 << i))        ; test-bit(P, i)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">882</td>
    <td class="">  //     R' = R ^ (Q << i)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">883</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">884</td>
    <td class="">  // Similarly, the basic pattern for R = (P/Q).Q - P</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">885</td>
    <td class="">  // for i = 0..31</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">886</td>
    <td class="">  //   R = phi(P, R')</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">887</td>
    <td class="">  //   if (R & (1 << i))</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">888</td>
    <td class="">  //     R' = R ^ (Q << i)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">889</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">890</td>
    <td class="">  // There exist idioms, where instead of Q being shifted left, P is shifted</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">891</td>
    <td class="">  // right. This produces a result that is shifted right by 32 bits (the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">892</td>
    <td class="">  // non-shifted result is 64-bit).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">893</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">894</td>
    <td class="">  // For R = P.Q, this would be:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">895</td>
    <td class="">  // for i = 0..31</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">896</td>
    <td class="">  //   R = phi (0, R')</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">897</td>
    <td class="">  //   if ((P >> i) & 1)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">898</td>
    <td class="">  //     R' = (R >> 1) ^ Q      ; R is cycled through the loop, so it must</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">899</td>
    <td class="">  //   else                     ; be shifted by 1, not i.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">900</td>
    <td class="">  //     R' = R >> 1</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">901</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">902</td>
    <td class="">  // And for the inverse:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">903</td>
    <td class="">  // for i = 0..31</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">904</td>
    <td class="">  //   R = phi (P, R')</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">905</td>
    <td class="">  //   if (R & 1)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">906</td>
    <td class="">  //     R' = (R >> 1) ^ Q</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">907</td>
    <td class="">  //   else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">908</td>
    <td class="">  //     R' = R >> 1</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">909</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">910</td>
    <td class="">  // The left-shifting idioms share the same pattern:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">911</td>
    <td class="">  //   select (X & (1 << i)) ? R ^ (Q << i) : R</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">912</td>
    <td class="">  // Similarly for right-shifting idioms:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">913</td>
    <td class="">  //   select (X & 1) ? (R >> 1) ^ Q</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">914</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">915</td>
    <td class="uncoveredLine">  if (matchLeftShift(SelI, CIV, PV)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">916</td>
    <td class="">    // If this is a pre-scan, getting this far is sufficient.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">917</td>
    <td class="uncoveredLine">    if (PreScan)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">918</td>
    <td class="uncoveredLine">      return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">919</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">920</td>
    <td class="">    // Need to make sure that the SelI goes back into R.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">921</td>
    <td class="uncoveredLine">    auto *RPhi = dyn_cast<PHINode>(PV.R);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">922</td>
    <td class="uncoveredLine">    if (!RPhi)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">923</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">924</td>
    <td class="uncoveredLine">    if (SelI != RPhi->getIncomingValueForBlock(LoopB))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">925</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">926</td>
    <td class="uncoveredLine">    PV.Res = SelI;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">927</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">928</td>
    <td class="">    // If X is loop invariant, it must be the input polynomial, and the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">929</td>
    <td class="">    // idiom is the basic polynomial multiply.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">930</td>
    <td class="uncoveredLine">    if (CurLoop->isLoopInvariant(PV.X)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">931</td>
    <td class="uncoveredLine">      PV.P = PV.X;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">932</td>
    <td class="uncoveredLine">      PV.Inv = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">933</td>
    <td class="">    } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">934</td>
    <td class="">      // X is not loop invariant. If X == R, this is the inverse pmpy.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">935</td>
    <td class="">      // Otherwise, check for an xor with an invariant value. If the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">936</td>
    <td class="">      // variable argument to the xor is R, then this is still a valid</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">937</td>
    <td class="">      // inverse pmpy.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">938</td>
    <td class="uncoveredLine">      PV.Inv = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">939</td>
    <td class="uncoveredLine">      if (PV.X != PV.R) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">940</td>
    <td class="uncoveredLine">        Value *Var = nullptr, *Inv = nullptr, *X1 = nullptr, *X2 = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">941</td>
    <td class="uncoveredLine">        if (!match(PV.X, m_Xor(m_Value(X1), m_Value(X2))))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">942</td>
    <td class="uncoveredLine">          return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">943</td>
    <td class="uncoveredLine">        auto *I1 = dyn_cast<Instruction>(X1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">944</td>
    <td class="uncoveredLine">        auto *I2 = dyn_cast<Instruction>(X2);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">945</td>
    <td class="uncoveredLine">        if (!I1 || I1->getParent() != LoopB) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">946</td>
    <td class="uncoveredLine">          Var = X2;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">947</td>
    <td class="uncoveredLine">          Inv = X1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">948</td>
    <td class="uncoveredLine">        } else if (!I2 || I2->getParent() != LoopB) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">949</td>
    <td class="uncoveredLine">          Var = X1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">950</td>
    <td class="uncoveredLine">          Inv = X2;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">951</td>
    <td class="">        } else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">952</td>
    <td class="uncoveredLine">          return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">953</td>
    <td class="uncoveredLine">        if (Var != PV.R)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">954</td>
    <td class="uncoveredLine">          return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">955</td>
    <td class="uncoveredLine">        PV.M = Inv;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">956</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">957</td>
    <td class="">      // The input polynomial P still needs to be determined. It will be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">958</td>
    <td class="">      // the entry value of R.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">959</td>
    <td class="uncoveredLine">      Value *EntryP = RPhi->getIncomingValueForBlock(PrehB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">960</td>
    <td class="uncoveredLine">      PV.P = EntryP;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">961</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">962</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">963</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">964</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">965</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">966</td>
    <td class="uncoveredLine">  if (matchRightShift(SelI, PV)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">967</td>
    <td class="">    // If this is an inverse pattern, the Q polynomial must be known at</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">968</td>
    <td class="">    // compile time.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">969</td>
    <td class="uncoveredLine">    if (PV.Inv && !isa<ConstantInt>(PV.Q))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">970</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">971</td>
    <td class="uncoveredLine">    if (PreScan)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">972</td>
    <td class="uncoveredLine">      return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">973</td>
    <td class="">    // There is no exact matching of right-shift pmpy.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">974</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">975</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">976</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">977</td>
    <td class="uncoveredLine">  return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">978</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">979</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">980</td>
    <td class="uncoveredLine">bool PolynomialMultiplyRecognize::isPromotableTo(Value *Val,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">981</td>
    <td class="">      IntegerType *DestTy) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">982</td>
    <td class="uncoveredLine">  IntegerType *T = dyn_cast<IntegerType>(Val->getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">983</td>
    <td class="uncoveredLine">  if (!T || T->getBitWidth() > DestTy->getBitWidth())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">984</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">985</td>
    <td class="uncoveredLine">  if (T->getBitWidth() == DestTy->getBitWidth())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">986</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">987</td>
    <td class="">  // Non-instructions are promotable. The reason why an instruction may not</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">988</td>
    <td class="">  // be promotable is that it may produce a different result if its operands</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">989</td>
    <td class="">  // and the result are promoted, for example, it may produce more non-zero</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">990</td>
    <td class="">  // bits. While it would still be possible to represent the proper result</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">991</td>
    <td class="">  // in a wider type, it may require adding additional instructions (which</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">992</td>
    <td class="">  // we don't want to do).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">993</td>
    <td class="uncoveredLine">  Instruction *In = dyn_cast<Instruction>(Val);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">994</td>
    <td class="uncoveredLine">  if (!In)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">995</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">996</td>
    <td class="">  // The bitwidth of the source type is smaller than the destination.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">997</td>
    <td class="">  // Check if the individual operation can be promoted.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">998</td>
    <td class="uncoveredLine">  switch (In->getOpcode()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">999</td>
    <td class="uncoveredLine">    case Instruction::PHI:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1000</td>
    <td class="">    case Instruction::ZExt:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1001</td>
    <td class="">    case Instruction::And:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1002</td>
    <td class="">    case Instruction::Or:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1003</td>
    <td class="">    case Instruction::Xor:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1004</td>
    <td class="">    case Instruction::LShr: // Shift right is ok.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1005</td>
    <td class="">    case Instruction::Select:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1006</td>
    <td class="">    case Instruction::Trunc:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1007</td>
    <td class="uncoveredLine">      return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1008</td>
    <td class="uncoveredLine">    case Instruction::ICmp:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1009</td>
    <td class="uncoveredLine">      if (CmpInst *CI = cast<CmpInst>(In))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1010</td>
    <td class="uncoveredLine">        return CI->isEquality() || CI->isUnsigned();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1011</td>
    <td class="uncoveredLine">      llvm_unreachable("Cast failed unexpectedly");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1012</td>
    <td class="uncoveredLine">    case Instruction::Add:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1013</td>
    <td class="uncoveredLine">      return In->hasNoSignedWrap() && In->hasNoUnsignedWrap();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1014</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1015</td>
    <td class="uncoveredLine">  return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1016</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1017</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1018</td>
    <td class="uncoveredLine">void PolynomialMultiplyRecognize::promoteTo(Instruction *In,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1019</td>
    <td class="">      IntegerType *DestTy, BasicBlock *LoopB) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1020</td>
    <td class="uncoveredLine">  Type *OrigTy = In->getType();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1021</td>
    <td class="uncoveredLine">  assert(!OrigTy->isVoidTy() && "Invalid instruction to promote");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1022</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1023</td>
    <td class="">  // Leave boolean values alone.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1024</td>
    <td class="uncoveredLine">  if (!In->getType()->isIntegerTy(1))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1025</td>
    <td class="uncoveredLine">    In->mutateType(DestTy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1026</td>
    <td class="uncoveredLine">  unsigned DestBW = DestTy->getBitWidth();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1027</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1028</td>
    <td class="">  // Handle PHIs.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1029</td>
    <td class="uncoveredLine">  if (PHINode *P = dyn_cast<PHINode>(In)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1030</td>
    <td class="uncoveredLine">    unsigned N = P->getNumIncomingValues();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1031</td>
    <td class="uncoveredLine">    for (unsigned i = 0; i != N; ++i) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1032</td>
    <td class="uncoveredLine">      BasicBlock *InB = P->getIncomingBlock(i);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1033</td>
    <td class="uncoveredLine">      if (InB == LoopB)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1034</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1035</td>
    <td class="uncoveredLine">      Value *InV = P->getIncomingValue(i);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1036</td>
    <td class="uncoveredLine">      IntegerType *Ty = cast<IntegerType>(InV->getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1037</td>
    <td class="">      // Do not promote values in PHI nodes of type i1.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1038</td>
    <td class="uncoveredLine">      if (Ty != P->getType()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1039</td>
    <td class="">        // If the value type does not match the PHI type, the PHI type</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1040</td>
    <td class="">        // must have been promoted.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1041</td>
    <td class="uncoveredLine">        assert(Ty->getBitWidth() < DestBW);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1042</td>
    <td class="uncoveredLine">        InV = IRBuilder<>(InB->getTerminator()).CreateZExt(InV, DestTy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1043</td>
    <td class="uncoveredLine">        P->setIncomingValue(i, InV);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1044</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1045</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1046</td>
    <td class="uncoveredLine">  } else if (ZExtInst *Z = dyn_cast<ZExtInst>(In)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1047</td>
    <td class="uncoveredLine">    Value *Op = Z->getOperand(0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1048</td>
    <td class="uncoveredLine">    if (Op->getType() == Z->getType())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1049</td>
    <td class="uncoveredLine">      Z->replaceAllUsesWith(Op);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1050</td>
    <td class="uncoveredLine">    Z->eraseFromParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1051</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1052</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1053</td>
    <td class="uncoveredLine">  if (TruncInst *T = dyn_cast<TruncInst>(In)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1054</td>
    <td class="uncoveredLine">    IntegerType *TruncTy = cast<IntegerType>(OrigTy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1055</td>
    <td class="uncoveredLine">    Value *Mask = ConstantInt::get(DestTy, (1u << TruncTy->getBitWidth()) - 1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1056</td>
    <td class="uncoveredLine">    Value *And = IRBuilder<>(In).CreateAnd(T->getOperand(0), Mask);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1057</td>
    <td class="uncoveredLine">    T->replaceAllUsesWith(And);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1058</td>
    <td class="uncoveredLine">    T->eraseFromParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1059</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1060</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1061</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1062</td>
    <td class="">  // Promote immediates.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1063</td>
    <td class="uncoveredLine">  for (unsigned i = 0, n = In->getNumOperands(); i != n; ++i) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1064</td>
    <td class="uncoveredLine">    if (ConstantInt *CI = dyn_cast<ConstantInt>(In->getOperand(i)))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1065</td>
    <td class="uncoveredLine">      if (CI->getType()->getBitWidth() < DestBW)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1066</td>
    <td class="uncoveredLine">        In->setOperand(i, ConstantInt::get(DestTy, CI->getZExtValue()));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1067</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1068</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1069</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1070</td>
    <td class="uncoveredLine">bool PolynomialMultiplyRecognize::promoteTypes(BasicBlock *LoopB,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1071</td>
    <td class="">      BasicBlock *ExitB) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1072</td>
    <td class="uncoveredLine">  assert(LoopB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1073</td>
    <td class="">  // Skip loops where the exit block has more than one predecessor. The values</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1074</td>
    <td class="">  // coming from the loop block will be promoted to another type, and so the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1075</td>
    <td class="">  // values coming into the exit block from other predecessors would also have</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1076</td>
    <td class="">  // to be promoted.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1077</td>
    <td class="uncoveredLine">  if (!ExitB || (ExitB->getSinglePredecessor() != LoopB))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1078</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1079</td>
    <td class="uncoveredLine">  IntegerType *DestTy = getPmpyType();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1080</td>
    <td class="">  // Check if the exit values have types that are no wider than the type</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1081</td>
    <td class="">  // that we want to promote to.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1082</td>
    <td class="uncoveredLine">  unsigned DestBW = DestTy->getBitWidth();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1083</td>
    <td class="uncoveredLine">  for (PHINode &P : ExitB->phis()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1084</td>
    <td class="uncoveredLine">    if (P.getNumIncomingValues() != 1)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1085</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1086</td>
    <td class="uncoveredLine">    assert(P.getIncomingBlock(0) == LoopB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1087</td>
    <td class="uncoveredLine">    IntegerType *T = dyn_cast<IntegerType>(P.getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1088</td>
    <td class="uncoveredLine">    if (!T || T->getBitWidth() > DestBW)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1089</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1090</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1091</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1092</td>
    <td class="">  // Check all instructions in the loop.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1093</td>
    <td class="uncoveredLine">  for (Instruction &In : *LoopB)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1094</td>
    <td class="uncoveredLine">    if (!In.isTerminator() && !isPromotableTo(&In, DestTy))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1095</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1096</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1097</td>
    <td class="">  // Perform the promotion.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1098</td>
    <td class="uncoveredLine">  std::vector<Instruction*> LoopIns;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1099</td>
    <td class="uncoveredLine">  std::transform(LoopB->begin(), LoopB->end(), std::back_inserter(LoopIns),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1100</td>
    <td class="uncoveredLine">                 [](Instruction &In) { return &In; });</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1101</td>
    <td class="uncoveredLine">  for (Instruction *In : LoopIns)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1102</td>
    <td class="uncoveredLine">    if (!In->isTerminator())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1103</td>
    <td class="uncoveredLine">      promoteTo(In, DestTy, LoopB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1104</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1105</td>
    <td class="">  // Fix up the PHI nodes in the exit block.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1106</td>
    <td class="uncoveredLine">  Instruction *EndI = ExitB->getFirstNonPHI();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1107</td>
    <td class="uncoveredLine">  BasicBlock::iterator End = EndI ? EndI->getIterator() : ExitB->end();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1108</td>
    <td class="uncoveredLine">  for (auto I = ExitB->begin(); I != End; ++I) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1109</td>
    <td class="uncoveredLine">    PHINode *P = dyn_cast<PHINode>(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1110</td>
    <td class="uncoveredLine">    if (!P)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1111</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1112</td>
    <td class="uncoveredLine">    Type *Ty0 = P->getIncomingValue(0)->getType();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1113</td>
    <td class="uncoveredLine">    Type *PTy = P->getType();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1114</td>
    <td class="uncoveredLine">    if (PTy != Ty0) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1115</td>
    <td class="uncoveredLine">      assert(Ty0 == DestTy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1116</td>
    <td class="">      // In order to create the trunc, P must have the promoted type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1117</td>
    <td class="uncoveredLine">      P->mutateType(Ty0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1118</td>
    <td class="uncoveredLine">      Value *T = IRBuilder<>(ExitB, End).CreateTrunc(P, PTy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1119</td>
    <td class="">      // In order for the RAUW to work, the types of P and T must match.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1120</td>
    <td class="uncoveredLine">      P->mutateType(PTy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1121</td>
    <td class="uncoveredLine">      P->replaceAllUsesWith(T);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1122</td>
    <td class="">      // Final update of the P's type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1123</td>
    <td class="uncoveredLine">      P->mutateType(Ty0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1124</td>
    <td class="uncoveredLine">      cast<Instruction>(T)->setOperand(0, P);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1125</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1126</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1127</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1128</td>
    <td class="uncoveredLine">  return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1129</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1130</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1131</td>
    <td class="uncoveredLine">bool PolynomialMultiplyRecognize::findCycle(Value *Out, Value *In,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1132</td>
    <td class="">      ValueSeq &Cycle) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1133</td>
    <td class="">  // Out = ..., In, ...</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1134</td>
    <td class="uncoveredLine">  if (Out == In)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1135</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1136</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1137</td>
    <td class="uncoveredLine">  auto *BB = cast<Instruction>(Out)->getParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1138</td>
    <td class="uncoveredLine">  bool HadPhi = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1139</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1140</td>
    <td class="uncoveredLine">  for (auto *U : Out->users()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1141</td>
    <td class="uncoveredLine">    auto *I = dyn_cast<Instruction>(&*U);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1142</td>
    <td class="uncoveredLine">    if (I == nullptr || I->getParent() != BB)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1143</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1144</td>
    <td class="">    // Make sure that there are no multi-iteration cycles, e.g.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1145</td>
    <td class="">    //   p1 = phi(p2)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1146</td>
    <td class="">    //   p2 = phi(p1)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1147</td>
    <td class="">    // The cycle p1->p2->p1 would span two loop iterations.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1148</td>
    <td class="">    // Check that there is only one phi in the cycle.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1149</td>
    <td class="uncoveredLine">    bool IsPhi = isa<PHINode>(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1150</td>
    <td class="uncoveredLine">    if (IsPhi && HadPhi)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1151</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1152</td>
    <td class="uncoveredLine">    HadPhi |= IsPhi;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1153</td>
    <td class="uncoveredLine">    if (!Cycle.insert(I))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1154</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1155</td>
    <td class="uncoveredLine">    if (findCycle(I, In, Cycle))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1156</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1157</td>
    <td class="uncoveredLine">    Cycle.remove(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1158</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1159</td>
    <td class="uncoveredLine">  return !Cycle.empty();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1160</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1161</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1162</td>
    <td class="uncoveredLine">void PolynomialMultiplyRecognize::classifyCycle(Instruction *DivI,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1163</td>
    <td class="">      ValueSeq &Cycle, ValueSeq &Early, ValueSeq &Late) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1164</td>
    <td class="">  // All the values in the cycle that are between the phi node and the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1165</td>
    <td class="">  // divider instruction will be classified as "early", all other values</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1166</td>
    <td class="">  // will be "late".</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1167</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1168</td>
    <td class="uncoveredLine">  bool IsE = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1169</td>
    <td class="uncoveredLine">  unsigned I, N = Cycle.size();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1170</td>
    <td class="uncoveredLine">  for (I = 0; I < N; ++I) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1171</td>
    <td class="uncoveredLine">    Value *V = Cycle[I];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1172</td>
    <td class="uncoveredLine">    if (DivI == V)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1173</td>
    <td class="uncoveredLine">      IsE = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1174</td>
    <td class="uncoveredLine">    else if (!isa<PHINode>(V))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1175</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1176</td>
    <td class="">    // Stop if found either.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1177</td>
    <td class="uncoveredLine">    break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1178</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1179</td>
    <td class="">  // "I" is the index of either DivI or the phi node, whichever was first.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1180</td>
    <td class="">  // "E" is "false" or "true" respectively.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1181</td>
    <td class="uncoveredLine">  ValueSeq &First = !IsE ? Early : Late;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1182</td>
    <td class="uncoveredLine">  for (unsigned J = 0; J < I; ++J)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1183</td>
    <td class="uncoveredLine">    First.insert(Cycle[J]);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1184</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1185</td>
    <td class="uncoveredLine">  ValueSeq &Second = IsE ? Early : Late;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1186</td>
    <td class="uncoveredLine">  Second.insert(Cycle[I]);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1187</td>
    <td class="uncoveredLine">  for (++I; I < N; ++I) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1188</td>
    <td class="uncoveredLine">    Value *V = Cycle[I];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1189</td>
    <td class="uncoveredLine">    if (DivI == V || isa<PHINode>(V))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1190</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1191</td>
    <td class="uncoveredLine">    Second.insert(V);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1192</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1193</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1194</td>
    <td class="uncoveredLine">  for (; I < N; ++I)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1195</td>
    <td class="uncoveredLine">    First.insert(Cycle[I]);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1196</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1197</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1198</td>
    <td class="uncoveredLine">bool PolynomialMultiplyRecognize::classifyInst(Instruction *UseI,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1199</td>
    <td class="">      ValueSeq &Early, ValueSeq &Late) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1200</td>
    <td class="">  // Select is an exception, since the condition value does not have to be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1201</td>
    <td class="">  // classified in the same way as the true/false values. The true/false</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1202</td>
    <td class="">  // values do have to be both early or both late.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1203</td>
    <td class="uncoveredLine">  if (UseI->getOpcode() == Instruction::Select) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1204</td>
    <td class="uncoveredLine">    Value *TV = UseI->getOperand(1), *FV = UseI->getOperand(2);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1205</td>
    <td class="uncoveredLine">    if (Early.count(TV) || Early.count(FV)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1206</td>
    <td class="uncoveredLine">      if (Late.count(TV) || Late.count(FV))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1207</td>
    <td class="uncoveredLine">        return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1208</td>
    <td class="uncoveredLine">      Early.insert(UseI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1209</td>
    <td class="uncoveredLine">    } else if (Late.count(TV) || Late.count(FV)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1210</td>
    <td class="uncoveredLine">      if (Early.count(TV) || Early.count(FV))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1211</td>
    <td class="uncoveredLine">        return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1212</td>
    <td class="uncoveredLine">      Late.insert(UseI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1213</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1214</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1215</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1216</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1217</td>
    <td class="">  // Not sure what would be the example of this, but the code below relies</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1218</td>
    <td class="">  // on having at least one operand.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1219</td>
    <td class="uncoveredLine">  if (UseI->getNumOperands() == 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1220</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1221</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1222</td>
    <td class="uncoveredLine">  bool AE = true, AL = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1223</td>
    <td class="uncoveredLine">  for (auto &I : UseI->operands()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1224</td>
    <td class="uncoveredLine">    if (Early.count(&*I))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1225</td>
    <td class="uncoveredLine">      AL = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1226</td>
    <td class="uncoveredLine">    else if (Late.count(&*I))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1227</td>
    <td class="uncoveredLine">      AE = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1228</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1229</td>
    <td class="">  // If the operands appear "all early" and "all late" at the same time,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1230</td>
    <td class="">  // then it means that none of them are actually classified as either.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1231</td>
    <td class="">  // This is harmless.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1232</td>
    <td class="uncoveredLine">  if (AE && AL)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1233</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1234</td>
    <td class="">  // Conversely, if they are neither "all early" nor "all late", then</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1235</td>
    <td class="">  // we have a mixture of early and late operands that is not a known</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1236</td>
    <td class="">  // exception.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1237</td>
    <td class="uncoveredLine">  if (!AE && !AL)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1238</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1239</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1240</td>
    <td class="">  // Check that we have covered the two special cases.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1241</td>
    <td class="uncoveredLine">  assert(AE != AL);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1242</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1243</td>
    <td class="uncoveredLine">  if (AE)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1244</td>
    <td class="uncoveredLine">    Early.insert(UseI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1245</td>
    <td class="">  else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1246</td>
    <td class="uncoveredLine">    Late.insert(UseI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1247</td>
    <td class="uncoveredLine">  return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1248</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1249</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1250</td>
    <td class="uncoveredLine">bool PolynomialMultiplyRecognize::commutesWithShift(Instruction *I) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1251</td>
    <td class="uncoveredLine">  switch (I->getOpcode()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1252</td>
    <td class="uncoveredLine">    case Instruction::And:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1253</td>
    <td class="">    case Instruction::Or:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1254</td>
    <td class="">    case Instruction::Xor:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1255</td>
    <td class="">    case Instruction::LShr:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1256</td>
    <td class="">    case Instruction::Shl:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1257</td>
    <td class="">    case Instruction::Select:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1258</td>
    <td class="">    case Instruction::ICmp:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1259</td>
    <td class="">    case Instruction::PHI:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1260</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1261</td>
    <td class="uncoveredLine">    default:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1262</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1263</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1264</td>
    <td class="uncoveredLine">  return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1265</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1266</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1267</td>
    <td class="uncoveredLine">bool PolynomialMultiplyRecognize::highBitsAreZero(Value *V,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1268</td>
    <td class="">      unsigned IterCount) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1269</td>
    <td class="uncoveredLine">  auto *T = dyn_cast<IntegerType>(V->getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1270</td>
    <td class="uncoveredLine">  if (!T)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1271</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1272</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1273</td>
    <td class="uncoveredLine">  KnownBits Known(T->getBitWidth());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1274</td>
    <td class="uncoveredLine">  computeKnownBits(V, Known, DL);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1275</td>
    <td class="uncoveredLine">  return Known.countMinLeadingZeros() >= IterCount;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1276</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1277</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1278</td>
    <td class="uncoveredLine">bool PolynomialMultiplyRecognize::keepsHighBitsZero(Value *V,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1279</td>
    <td class="">      unsigned IterCount) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1280</td>
    <td class="">  // Assume that all inputs to the value have the high bits zero.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1281</td>
    <td class="">  // Check if the value itself preserves the zeros in the high bits.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1282</td>
    <td class="uncoveredLine">  if (auto *C = dyn_cast<ConstantInt>(V))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1283</td>
    <td class="uncoveredLine">    return C->getValue().countl_zero() >= IterCount;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1284</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1285</td>
    <td class="uncoveredLine">  if (auto *I = dyn_cast<Instruction>(V)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1286</td>
    <td class="uncoveredLine">    switch (I->getOpcode()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1287</td>
    <td class="uncoveredLine">      case Instruction::And:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1288</td>
    <td class="">      case Instruction::Or:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1289</td>
    <td class="">      case Instruction::Xor:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1290</td>
    <td class="">      case Instruction::LShr:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1291</td>
    <td class="">      case Instruction::Select:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1292</td>
    <td class="">      case Instruction::ICmp:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1293</td>
    <td class="">      case Instruction::PHI:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1294</td>
    <td class="">      case Instruction::ZExt:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1295</td>
    <td class="uncoveredLine">        return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1296</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1297</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1298</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1299</td>
    <td class="uncoveredLine">  return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1300</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1301</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1302</td>
    <td class="uncoveredLine">bool PolynomialMultiplyRecognize::isOperandShifted(Instruction *I, Value *Op) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1303</td>
    <td class="uncoveredLine">  unsigned Opc = I->getOpcode();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1304</td>
    <td class="uncoveredLine">  if (Opc == Instruction::Shl || Opc == Instruction::LShr)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1305</td>
    <td class="uncoveredLine">    return Op != I->getOperand(1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1306</td>
    <td class="uncoveredLine">  return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1307</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1308</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1309</td>
    <td class="uncoveredLine">bool PolynomialMultiplyRecognize::convertShiftsToLeft(BasicBlock *LoopB,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1310</td>
    <td class="">      BasicBlock *ExitB, unsigned IterCount) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1311</td>
    <td class="uncoveredLine">  Value *CIV = getCountIV(LoopB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1312</td>
    <td class="uncoveredLine">  if (CIV == nullptr)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1313</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1314</td>
    <td class="uncoveredLine">  auto *CIVTy = dyn_cast<IntegerType>(CIV->getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1315</td>
    <td class="uncoveredLine">  if (CIVTy == nullptr)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1316</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1317</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1318</td>
    <td class="uncoveredLine">  ValueSeq RShifts;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1319</td>
    <td class="uncoveredLine">  ValueSeq Early, Late, Cycled;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1320</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1321</td>
    <td class="">  // Find all value cycles that contain logical right shifts by 1.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1322</td>
    <td class="uncoveredLine">  for (Instruction &I : *LoopB) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1323</td>
    <td class="">    using namespace PatternMatch;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1324</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1325</td>
    <td class="uncoveredLine">    Value *V = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1326</td>
    <td class="uncoveredLine">    if (!match(&I, m_LShr(m_Value(V), m_One())))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1327</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1328</td>
    <td class="uncoveredLine">    ValueSeq C;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1329</td>
    <td class="uncoveredLine">    if (!findCycle(&I, V, C))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1330</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1331</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1332</td>
    <td class="">    // Found a cycle.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1333</td>
    <td class="uncoveredLine">    C.insert(&I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1334</td>
    <td class="uncoveredLine">    classifyCycle(&I, C, Early, Late);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1335</td>
    <td class="uncoveredLine">    Cycled.insert(C.begin(), C.end());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1336</td>
    <td class="uncoveredLine">    RShifts.insert(&I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1337</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1338</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1339</td>
    <td class="">  // Find the set of all values affected by the shift cycles, i.e. all</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1340</td>
    <td class="">  // cycled values, and (recursively) all their users.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1341</td>
    <td class="uncoveredLine">  ValueSeq Users(Cycled.begin(), Cycled.end());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1342</td>
    <td class="uncoveredLine">  for (unsigned i = 0; i < Users.size(); ++i) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1343</td>
    <td class="uncoveredLine">    Value *V = Users[i];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1344</td>
    <td class="uncoveredLine">    if (!isa<IntegerType>(V->getType()))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1345</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1346</td>
    <td class="uncoveredLine">    auto *R = cast<Instruction>(V);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1347</td>
    <td class="">    // If the instruction does not commute with shifts, the loop cannot</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1348</td>
    <td class="">    // be unshifted.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1349</td>
    <td class="uncoveredLine">    if (!commutesWithShift(R))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1350</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1351</td>
    <td class="uncoveredLine">    for (User *U : R->users()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1352</td>
    <td class="uncoveredLine">      auto *T = cast<Instruction>(U);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1353</td>
    <td class="">      // Skip users from outside of the loop. They will be handled later.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1354</td>
    <td class="">      // Also, skip the right-shifts and phi nodes, since they mix early</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1355</td>
    <td class="">      // and late values.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1356</td>
    <td class="uncoveredLine">      if (T->getParent() != LoopB || RShifts.count(T) || isa<PHINode>(T))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1357</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1358</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1359</td>
    <td class="uncoveredLine">      Users.insert(T);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1360</td>
    <td class="uncoveredLine">      if (!classifyInst(T, Early, Late))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1361</td>
    <td class="uncoveredLine">        return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1362</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1363</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1364</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1365</td>
    <td class="uncoveredLine">  if (Users.empty())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1366</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1367</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1368</td>
    <td class="">  // Verify that high bits remain zero.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1369</td>
    <td class="uncoveredLine">  ValueSeq Internal(Users.begin(), Users.end());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1370</td>
    <td class="uncoveredLine">  ValueSeq Inputs;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1371</td>
    <td class="uncoveredLine">  for (unsigned i = 0; i < Internal.size(); ++i) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1372</td>
    <td class="uncoveredLine">    auto *R = dyn_cast<Instruction>(Internal[i]);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1373</td>
    <td class="uncoveredLine">    if (!R)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1374</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1375</td>
    <td class="uncoveredLine">    for (Value *Op : R->operands()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1376</td>
    <td class="uncoveredLine">      auto *T = dyn_cast<Instruction>(Op);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1377</td>
    <td class="uncoveredLine">      if (T && T->getParent() != LoopB)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1378</td>
    <td class="uncoveredLine">        Inputs.insert(Op);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1379</td>
    <td class="">      else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1380</td>
    <td class="uncoveredLine">        Internal.insert(Op);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1381</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1382</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1383</td>
    <td class="uncoveredLine">  for (Value *V : Inputs)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1384</td>
    <td class="uncoveredLine">    if (!highBitsAreZero(V, IterCount))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1385</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1386</td>
    <td class="uncoveredLine">  for (Value *V : Internal)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1387</td>
    <td class="uncoveredLine">    if (!keepsHighBitsZero(V, IterCount))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1388</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1389</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1390</td>
    <td class="">  // Finally, the work can be done. Unshift each user.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1391</td>
    <td class="uncoveredLine">  IRBuilder<> IRB(LoopB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1392</td>
    <td class="uncoveredLine">  std::map<Value*,Value*> ShiftMap;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1393</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1394</td>
    <td class="">  using CastMapType = std::map<std::pair<Value *, Type *>, Value *>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1395</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1396</td>
    <td class="uncoveredLine">  CastMapType CastMap;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1397</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1398</td>
    <td class="uncoveredLine">  auto upcast = [] (CastMapType &CM, IRBuilder<> &IRB, Value *V,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1399</td>
    <td class="">        IntegerType *Ty) -> Value* {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1400</td>
    <td class="uncoveredLine">    auto H = CM.find(std::make_pair(V, Ty));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1401</td>
    <td class="uncoveredLine">    if (H != CM.end())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1402</td>
    <td class="uncoveredLine">      return H->second;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1403</td>
    <td class="uncoveredLine">    Value *CV = IRB.CreateIntCast(V, Ty, false);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1404</td>
    <td class="uncoveredLine">    CM.insert(std::make_pair(std::make_pair(V, Ty), CV));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1405</td>
    <td class="uncoveredLine">    return CV;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1406</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1407</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1408</td>
    <td class="uncoveredLine">  for (auto I = LoopB->begin(), E = LoopB->end(); I != E; ++I) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1409</td>
    <td class="">    using namespace PatternMatch;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1410</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1411</td>
    <td class="uncoveredLine">    if (isa<PHINode>(I) || !Users.count(&*I))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1412</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1413</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1414</td>
    <td class="">    // Match lshr x, 1.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1415</td>
    <td class="uncoveredLine">    Value *V = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1416</td>
    <td class="uncoveredLine">    if (match(&*I, m_LShr(m_Value(V), m_One()))) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1417</td>
    <td class="uncoveredLine">      replaceAllUsesOfWithIn(&*I, V, LoopB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1418</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1419</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1420</td>
    <td class="">    // For each non-cycled operand, replace it with the corresponding</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1421</td>
    <td class="">    // value shifted left.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1422</td>
    <td class="uncoveredLine">    for (auto &J : I->operands()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1423</td>
    <td class="uncoveredLine">      Value *Op = J.get();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1424</td>
    <td class="uncoveredLine">      if (!isOperandShifted(&*I, Op))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1425</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1426</td>
    <td class="uncoveredLine">      if (Users.count(Op))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1427</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1428</td>
    <td class="">      // Skip shifting zeros.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1429</td>
    <td class="uncoveredLine">      if (isa<ConstantInt>(Op) && cast<ConstantInt>(Op)->isZero())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1430</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1431</td>
    <td class="">      // Check if we have already generated a shift for this value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1432</td>
    <td class="uncoveredLine">      auto F = ShiftMap.find(Op);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1433</td>
    <td class="uncoveredLine">      Value *W = (F != ShiftMap.end()) ? F->second : nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1434</td>
    <td class="uncoveredLine">      if (W == nullptr) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1435</td>
    <td class="uncoveredLine">        IRB.SetInsertPoint(&*I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1436</td>
    <td class="">        // First, the shift amount will be CIV or CIV+1, depending on</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1437</td>
    <td class="">        // whether the value is early or late. Instead of creating CIV+1,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1438</td>
    <td class="">        // do a single shift of the value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1439</td>
    <td class="uncoveredLine">        Value *ShAmt = CIV, *ShVal = Op;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1440</td>
    <td class="uncoveredLine">        auto *VTy = cast<IntegerType>(ShVal->getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1441</td>
    <td class="uncoveredLine">        auto *ATy = cast<IntegerType>(ShAmt->getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1442</td>
    <td class="uncoveredLine">        if (Late.count(&*I))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1443</td>
    <td class="uncoveredLine">          ShVal = IRB.CreateShl(Op, ConstantInt::get(VTy, 1));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1444</td>
    <td class="">        // Second, the types of the shifted value and the shift amount</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1445</td>
    <td class="">        // must match.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1446</td>
    <td class="uncoveredLine">        if (VTy != ATy) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1447</td>
    <td class="uncoveredLine">          if (VTy->getBitWidth() < ATy->getBitWidth())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1448</td>
    <td class="uncoveredLine">            ShVal = upcast(CastMap, IRB, ShVal, ATy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1449</td>
    <td class="">          else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1450</td>
    <td class="uncoveredLine">            ShAmt = upcast(CastMap, IRB, ShAmt, VTy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1451</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1452</td>
    <td class="">        // Ready to generate the shift and memoize it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1453</td>
    <td class="uncoveredLine">        W = IRB.CreateShl(ShVal, ShAmt);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1454</td>
    <td class="uncoveredLine">        ShiftMap.insert(std::make_pair(Op, W));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1455</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1456</td>
    <td class="uncoveredLine">      I->replaceUsesOfWith(Op, W);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1457</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1458</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1459</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1460</td>
    <td class="">  // Update the users outside of the loop to account for having left</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1461</td>
    <td class="">  // shifts. They would normally be shifted right in the loop, so shift</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1462</td>
    <td class="">  // them right after the loop exit.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1463</td>
    <td class="">  // Take advantage of the loop-closed SSA form, which has all the post-</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1464</td>
    <td class="">  // loop values in phi nodes.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1465</td>
    <td class="uncoveredLine">  IRB.SetInsertPoint(ExitB, ExitB->getFirstInsertionPt());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1466</td>
    <td class="uncoveredLine">  for (auto P = ExitB->begin(), Q = ExitB->end(); P != Q; ++P) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1467</td>
    <td class="uncoveredLine">    if (!isa<PHINode>(P))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1468</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1469</td>
    <td class="uncoveredLine">    auto *PN = cast<PHINode>(P);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1470</td>
    <td class="uncoveredLine">    Value *U = PN->getIncomingValueForBlock(LoopB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1471</td>
    <td class="uncoveredLine">    if (!Users.count(U))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1472</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1473</td>
    <td class="uncoveredLine">    Value *S = IRB.CreateLShr(PN, ConstantInt::get(PN->getType(), IterCount));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1474</td>
    <td class="uncoveredLine">    PN->replaceAllUsesWith(S);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1475</td>
    <td class="">    // The above RAUW will create</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1476</td>
    <td class="">    //   S = lshr S, IterCount</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1477</td>
    <td class="">    // so we need to fix it back into</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1478</td>
    <td class="">    //   S = lshr PN, IterCount</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1479</td>
    <td class="uncoveredLine">    cast<User>(S)->replaceUsesOfWith(S, PN);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1480</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1481</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1482</td>
    <td class="uncoveredLine">  return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1483</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1484</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1485</td>
    <td class="uncoveredLine">void PolynomialMultiplyRecognize::cleanupLoopBody(BasicBlock *LoopB) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1486</td>
    <td class="uncoveredLine">  for (auto &I : *LoopB)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1487</td>
    <td class="uncoveredLine">    if (Value *SV = simplifyInstruction(&I, {DL, &TLI, &DT}))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1488</td>
    <td class="uncoveredLine">      I.replaceAllUsesWith(SV);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1489</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1490</td>
    <td class="uncoveredLine">  for (Instruction &I : llvm::make_early_inc_range(*LoopB))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1491</td>
    <td class="uncoveredLine">    RecursivelyDeleteTriviallyDeadInstructions(&I, &TLI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1492</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1493</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1494</td>
    <td class="uncoveredLine">unsigned PolynomialMultiplyRecognize::getInverseMxN(unsigned QP) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1495</td>
    <td class="">  // Arrays of coefficients of Q and the inverse, C.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1496</td>
    <td class="">  // Q[i] = coefficient at x^i.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1497</td>
    <td class="">  std::array<char,32> Q, C;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1498</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1499</td>
    <td class="uncoveredLine">  for (unsigned i = 0; i < 32; ++i) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1500</td>
    <td class="uncoveredLine">    Q[i] = QP & 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1501</td>
    <td class="uncoveredLine">    QP >>= 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1502</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1503</td>
    <td class="uncoveredLine">  assert(Q[0] == 1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1504</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1505</td>
    <td class="">  // Find C, such that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1506</td>
    <td class="">  // (Q[n]*x^n + ... + Q[1]*x + Q[0]) * (C[n]*x^n + ... + C[1]*x + C[0]) = 1</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1507</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1508</td>
    <td class="">  // For it to have a solution, Q[0] must be 1. Since this is Z2[x], the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1509</td>
    <td class="">  // operations * and + are & and ^ respectively.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1510</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1511</td>
    <td class="">  // Find C[i] recursively, by comparing i-th coefficient in the product</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1512</td>
    <td class="">  // with 0 (or 1 for i=0).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1513</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1514</td>
    <td class="">  // C[0] = 1, since C[0] = Q[0], and Q[0] = 1.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1515</td>
    <td class="uncoveredLine">  C[0] = 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1516</td>
    <td class="uncoveredLine">  for (unsigned i = 1; i < 32; ++i) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1517</td>
    <td class="">    // Solve for C[i] in:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1518</td>
    <td class="">    //   C[0]Q[i] ^ C[1]Q[i-1] ^ ... ^ C[i-1]Q[1] ^ C[i]Q[0] = 0</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1519</td>
    <td class="">    // This is equivalent to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1520</td>
    <td class="">    //   C[0]Q[i] ^ C[1]Q[i-1] ^ ... ^ C[i-1]Q[1] ^ C[i] = 0</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1521</td>
    <td class="">    // which is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1522</td>
    <td class="">    //   C[0]Q[i] ^ C[1]Q[i-1] ^ ... ^ C[i-1]Q[1] = C[i]</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1523</td>
    <td class="uncoveredLine">    unsigned T = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1524</td>
    <td class="uncoveredLine">    for (unsigned j = 0; j < i; ++j)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1525</td>
    <td class="uncoveredLine">      T = T ^ (C[j] & Q[i-j]);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1526</td>
    <td class="uncoveredLine">    C[i] = T;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1527</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1528</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1529</td>
    <td class="uncoveredLine">  unsigned QV = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1530</td>
    <td class="uncoveredLine">  for (unsigned i = 0; i < 32; ++i)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1531</td>
    <td class="uncoveredLine">    if (C[i])</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1532</td>
    <td class="uncoveredLine">      QV |= (1 << i);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1533</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1534</td>
    <td class="uncoveredLine">  return QV;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1535</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1536</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1537</td>
    <td class="uncoveredLine">Value *PolynomialMultiplyRecognize::generate(BasicBlock::iterator At,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1538</td>
    <td class="">      ParsedValues &PV) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1539</td>
    <td class="uncoveredLine">  IRBuilder<> B(&*At);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1540</td>
    <td class="uncoveredLine">  Module *M = At->getParent()->getParent()->getParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1541</td>
    <td class="uncoveredLine">  Function *PMF = Intrinsic::getDeclaration(M, Intrinsic::hexagon_M4_pmpyw);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1542</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1543</td>
    <td class="uncoveredLine">  Value *P = PV.P, *Q = PV.Q, *P0 = P;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1544</td>
    <td class="uncoveredLine">  unsigned IC = PV.IterCount;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1545</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1546</td>
    <td class="uncoveredLine">  if (PV.M != nullptr)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1547</td>
    <td class="uncoveredLine">    P0 = P = B.CreateXor(P, PV.M);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1548</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1549</td>
    <td class="">  // Create a bit mask to clear the high bits beyond IterCount.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1550</td>
    <td class="uncoveredLine">  auto *BMI = ConstantInt::get(P->getType(), APInt::getLowBitsSet(32, IC));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1551</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1552</td>
    <td class="uncoveredLine">  if (PV.IterCount != 32)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1553</td>
    <td class="uncoveredLine">    P = B.CreateAnd(P, BMI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1554</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1555</td>
    <td class="uncoveredLine">  if (PV.Inv) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1556</td>
    <td class="uncoveredLine">    auto *QI = dyn_cast<ConstantInt>(PV.Q);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1557</td>
    <td class="uncoveredLine">    assert(QI && QI->getBitWidth() <= 32);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1558</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1559</td>
    <td class="">    // Again, clearing bits beyond IterCount.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1560</td>
    <td class="uncoveredLine">    unsigned M = (1 << PV.IterCount) - 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1561</td>
    <td class="uncoveredLine">    unsigned Tmp = (QI->getZExtValue() | 1) & M;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1562</td>
    <td class="uncoveredLine">    unsigned QV = getInverseMxN(Tmp) & M;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1563</td>
    <td class="uncoveredLine">    auto *QVI = ConstantInt::get(QI->getType(), QV);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1564</td>
    <td class="uncoveredLine">    P = B.CreateCall(PMF, {P, QVI});</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1565</td>
    <td class="uncoveredLine">    P = B.CreateTrunc(P, QI->getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1566</td>
    <td class="uncoveredLine">    if (IC != 32)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1567</td>
    <td class="uncoveredLine">      P = B.CreateAnd(P, BMI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1568</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1569</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1570</td>
    <td class="uncoveredLine">  Value *R = B.CreateCall(PMF, {P, Q});</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1571</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1572</td>
    <td class="uncoveredLine">  if (PV.M != nullptr)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1573</td>
    <td class="uncoveredLine">    R = B.CreateXor(R, B.CreateIntCast(P0, R->getType(), false));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1574</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1575</td>
    <td class="uncoveredLine">  return R;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1576</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1577</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1578</td>
    <td class="uncoveredLine">static bool hasZeroSignBit(const Value *V) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1579</td>
    <td class="uncoveredLine">  if (const auto *CI = dyn_cast<const ConstantInt>(V))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1580</td>
    <td class="uncoveredLine">    return (CI->getType()->getSignBit() & CI->getSExtValue()) == 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1581</td>
    <td class="uncoveredLine">  const Instruction *I = dyn_cast<const Instruction>(V);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1582</td>
    <td class="uncoveredLine">  if (!I)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1583</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1584</td>
    <td class="uncoveredLine">  switch (I->getOpcode()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1585</td>
    <td class="uncoveredLine">    case Instruction::LShr:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1586</td>
    <td class="uncoveredLine">      if (const auto SI = dyn_cast<const ConstantInt>(I->getOperand(1)))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1587</td>
    <td class="uncoveredLine">        return SI->getZExtValue() > 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1588</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1589</td>
    <td class="uncoveredLine">    case Instruction::Or:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1590</td>
    <td class="">    case Instruction::Xor:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1591</td>
    <td class="uncoveredLine">      return hasZeroSignBit(I->getOperand(0)) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1592</td>
    <td class="uncoveredLine">             hasZeroSignBit(I->getOperand(1));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1593</td>
    <td class="uncoveredLine">    case Instruction::And:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1594</td>
    <td class="uncoveredLine">      return hasZeroSignBit(I->getOperand(0)) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1595</td>
    <td class="uncoveredLine">             hasZeroSignBit(I->getOperand(1));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1596</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1597</td>
    <td class="uncoveredLine">  return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1598</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1599</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1600</td>
    <td class="uncoveredLine">void PolynomialMultiplyRecognize::setupPreSimplifier(Simplifier &S) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1601</td>
    <td class="uncoveredLine">  S.addRule("sink-zext",</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1602</td>
    <td class="">    // Sink zext past bitwise operations.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1603</td>
    <td class="uncoveredLine">    [](Instruction *I, LLVMContext &Ctx) -> Value* {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1604</td>
    <td class="uncoveredLine">      if (I->getOpcode() != Instruction::ZExt)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1605</td>
    <td class="uncoveredLine">        return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1606</td>
    <td class="uncoveredLine">      Instruction *T = dyn_cast<Instruction>(I->getOperand(0));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1607</td>
    <td class="uncoveredLine">      if (!T)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1608</td>
    <td class="uncoveredLine">        return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1609</td>
    <td class="uncoveredLine">      switch (T->getOpcode()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1610</td>
    <td class="uncoveredLine">        case Instruction::And:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1611</td>
    <td class="">        case Instruction::Or:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1612</td>
    <td class="">        case Instruction::Xor:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1613</td>
    <td class="uncoveredLine">          break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1614</td>
    <td class="uncoveredLine">        default:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1615</td>
    <td class="uncoveredLine">          return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1616</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1617</td>
    <td class="uncoveredLine">      IRBuilder<> B(Ctx);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1618</td>
    <td class="uncoveredLine">      return B.CreateBinOp(cast<BinaryOperator>(T)->getOpcode(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1619</td>
    <td class="">                           B.CreateZExt(T->getOperand(0), I->getType()),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1620</td>
    <td class="uncoveredLine">                           B.CreateZExt(T->getOperand(1), I->getType()));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1621</td>
    <td class="">    });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1622</td>
    <td class="uncoveredLine">  S.addRule("xor/and -> and/xor",</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1623</td>
    <td class="">    // (xor (and x a) (and y a)) -> (and (xor x y) a)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1624</td>
    <td class="uncoveredLine">    [](Instruction *I, LLVMContext &Ctx) -> Value* {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1625</td>
    <td class="uncoveredLine">      if (I->getOpcode() != Instruction::Xor)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1626</td>
    <td class="uncoveredLine">        return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1627</td>
    <td class="uncoveredLine">      Instruction *And0 = dyn_cast<Instruction>(I->getOperand(0));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1628</td>
    <td class="uncoveredLine">      Instruction *And1 = dyn_cast<Instruction>(I->getOperand(1));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1629</td>
    <td class="uncoveredLine">      if (!And0 || !And1)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1630</td>
    <td class="uncoveredLine">        return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1631</td>
    <td class="uncoveredLine">      if (And0->getOpcode() != Instruction::And ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1632</td>
    <td class="uncoveredLine">          And1->getOpcode() != Instruction::And)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1633</td>
    <td class="uncoveredLine">        return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1634</td>
    <td class="uncoveredLine">      if (And0->getOperand(1) != And1->getOperand(1))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1635</td>
    <td class="uncoveredLine">        return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1636</td>
    <td class="uncoveredLine">      IRBuilder<> B(Ctx);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1637</td>
    <td class="uncoveredLine">      return B.CreateAnd(B.CreateXor(And0->getOperand(0), And1->getOperand(0)),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1638</td>
    <td class="uncoveredLine">                         And0->getOperand(1));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1639</td>
    <td class="uncoveredLine">    });</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1640</td>
    <td class="uncoveredLine">  S.addRule("sink binop into select",</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1641</td>
    <td class="">    // (Op (select c x y) z) -> (select c (Op x z) (Op y z))</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1642</td>
    <td class="">    // (Op x (select c y z)) -> (select c (Op x y) (Op x z))</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1643</td>
    <td class="uncoveredLine">    [](Instruction *I, LLVMContext &Ctx) -> Value* {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1644</td>
    <td class="uncoveredLine">      BinaryOperator *BO = dyn_cast<BinaryOperator>(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1645</td>
    <td class="uncoveredLine">      if (!BO)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1646</td>
    <td class="uncoveredLine">        return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1647</td>
    <td class="uncoveredLine">      Instruction::BinaryOps Op = BO->getOpcode();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1648</td>
    <td class="uncoveredLine">      if (SelectInst *Sel = dyn_cast<SelectInst>(BO->getOperand(0))) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1649</td>
    <td class="uncoveredLine">        IRBuilder<> B(Ctx);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1650</td>
    <td class="uncoveredLine">        Value *X = Sel->getTrueValue(), *Y = Sel->getFalseValue();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1651</td>
    <td class="uncoveredLine">        Value *Z = BO->getOperand(1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1652</td>
    <td class="uncoveredLine">        return B.CreateSelect(Sel->getCondition(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1653</td>
    <td class="">                              B.CreateBinOp(Op, X, Z),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1654</td>
    <td class="uncoveredLine">                              B.CreateBinOp(Op, Y, Z));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1655</td>
    <td class="uncoveredLine">      }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1656</td>
    <td class="uncoveredLine">      if (SelectInst *Sel = dyn_cast<SelectInst>(BO->getOperand(1))) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1657</td>
    <td class="uncoveredLine">        IRBuilder<> B(Ctx);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1658</td>
    <td class="uncoveredLine">        Value *X = BO->getOperand(0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1659</td>
    <td class="uncoveredLine">        Value *Y = Sel->getTrueValue(), *Z = Sel->getFalseValue();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1660</td>
    <td class="uncoveredLine">        return B.CreateSelect(Sel->getCondition(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1661</td>
    <td class="">                              B.CreateBinOp(Op, X, Y),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1662</td>
    <td class="uncoveredLine">                              B.CreateBinOp(Op, X, Z));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1663</td>
    <td class="uncoveredLine">      }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1664</td>
    <td class="uncoveredLine">      return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1665</td>
    <td class="">    });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1666</td>
    <td class="uncoveredLine">  S.addRule("fold select-select",</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1667</td>
    <td class="">    // (select c (select c x y) z) -> (select c x z)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1668</td>
    <td class="">    // (select c x (select c y z)) -> (select c x z)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1669</td>
    <td class="uncoveredLine">    [](Instruction *I, LLVMContext &Ctx) -> Value* {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1670</td>
    <td class="uncoveredLine">      SelectInst *Sel = dyn_cast<SelectInst>(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1671</td>
    <td class="uncoveredLine">      if (!Sel)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1672</td>
    <td class="uncoveredLine">        return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1673</td>
    <td class="uncoveredLine">      IRBuilder<> B(Ctx);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1674</td>
    <td class="uncoveredLine">      Value *C = Sel->getCondition();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1675</td>
    <td class="uncoveredLine">      if (SelectInst *Sel0 = dyn_cast<SelectInst>(Sel->getTrueValue())) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1676</td>
    <td class="uncoveredLine">        if (Sel0->getCondition() == C)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1677</td>
    <td class="uncoveredLine">          return B.CreateSelect(C, Sel0->getTrueValue(), Sel->getFalseValue());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1678</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1679</td>
    <td class="uncoveredLine">      if (SelectInst *Sel1 = dyn_cast<SelectInst>(Sel->getFalseValue())) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1680</td>
    <td class="uncoveredLine">        if (Sel1->getCondition() == C)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1681</td>
    <td class="uncoveredLine">          return B.CreateSelect(C, Sel->getTrueValue(), Sel1->getFalseValue());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1682</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1683</td>
    <td class="uncoveredLine">      return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1684</td>
    <td class="uncoveredLine">    });</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1685</td>
    <td class="uncoveredLine">  S.addRule("or-signbit -> xor-signbit",</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1686</td>
    <td class="">    // (or (lshr x 1) 0x800.0) -> (xor (lshr x 1) 0x800.0)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1687</td>
    <td class="uncoveredLine">    [](Instruction *I, LLVMContext &Ctx) -> Value* {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1688</td>
    <td class="uncoveredLine">      if (I->getOpcode() != Instruction::Or)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1689</td>
    <td class="uncoveredLine">        return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1690</td>
    <td class="uncoveredLine">      ConstantInt *Msb = dyn_cast<ConstantInt>(I->getOperand(1));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1691</td>
    <td class="uncoveredLine">      if (!Msb || Msb->getZExtValue() != Msb->getType()->getSignBit())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1692</td>
    <td class="uncoveredLine">        return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1693</td>
    <td class="uncoveredLine">      if (!hasZeroSignBit(I->getOperand(0)))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1694</td>
    <td class="uncoveredLine">        return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1695</td>
    <td class="uncoveredLine">      return IRBuilder<>(Ctx).CreateXor(I->getOperand(0), Msb);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1696</td>
    <td class="">    });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1697</td>
    <td class="uncoveredLine">  S.addRule("sink lshr into binop",</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1698</td>
    <td class="">    // (lshr (BitOp x y) c) -> (BitOp (lshr x c) (lshr y c))</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1699</td>
    <td class="uncoveredLine">    [](Instruction *I, LLVMContext &Ctx) -> Value* {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1700</td>
    <td class="uncoveredLine">      if (I->getOpcode() != Instruction::LShr)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1701</td>
    <td class="uncoveredLine">        return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1702</td>
    <td class="uncoveredLine">      BinaryOperator *BitOp = dyn_cast<BinaryOperator>(I->getOperand(0));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1703</td>
    <td class="uncoveredLine">      if (!BitOp)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1704</td>
    <td class="uncoveredLine">        return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1705</td>
    <td class="uncoveredLine">      switch (BitOp->getOpcode()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1706</td>
    <td class="uncoveredLine">        case Instruction::And:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1707</td>
    <td class="">        case Instruction::Or:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1708</td>
    <td class="">        case Instruction::Xor:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1709</td>
    <td class="uncoveredLine">          break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1710</td>
    <td class="uncoveredLine">        default:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1711</td>
    <td class="uncoveredLine">          return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1712</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1713</td>
    <td class="uncoveredLine">      IRBuilder<> B(Ctx);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1714</td>
    <td class="uncoveredLine">      Value *S = I->getOperand(1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1715</td>
    <td class="uncoveredLine">      return B.CreateBinOp(BitOp->getOpcode(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1716</td>
    <td class="">                B.CreateLShr(BitOp->getOperand(0), S),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1717</td>
    <td class="uncoveredLine">                B.CreateLShr(BitOp->getOperand(1), S));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1718</td>
    <td class="">    });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1719</td>
    <td class="uncoveredLine">  S.addRule("expose bitop-const",</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1720</td>
    <td class="">    // (BitOp1 (BitOp2 x a) b) -> (BitOp2 x (BitOp1 a b))</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1721</td>
    <td class="uncoveredLine">    [](Instruction *I, LLVMContext &Ctx) -> Value* {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1722</td>
    <td class="uncoveredLine">      auto IsBitOp = [](unsigned Op) -> bool {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1723</td>
    <td class="uncoveredLine">        switch (Op) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1724</td>
    <td class="uncoveredLine">          case Instruction::And:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1725</td>
    <td class="">          case Instruction::Or:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1726</td>
    <td class="">          case Instruction::Xor:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1727</td>
    <td class="uncoveredLine">            return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1728</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1729</td>
    <td class="uncoveredLine">        return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1730</td>
    <td class="">      };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1731</td>
    <td class="uncoveredLine">      BinaryOperator *BitOp1 = dyn_cast<BinaryOperator>(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1732</td>
    <td class="uncoveredLine">      if (!BitOp1 || !IsBitOp(BitOp1->getOpcode()))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1733</td>
    <td class="uncoveredLine">        return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1734</td>
    <td class="uncoveredLine">      BinaryOperator *BitOp2 = dyn_cast<BinaryOperator>(BitOp1->getOperand(0));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1735</td>
    <td class="uncoveredLine">      if (!BitOp2 || !IsBitOp(BitOp2->getOpcode()))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1736</td>
    <td class="uncoveredLine">        return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1737</td>
    <td class="uncoveredLine">      ConstantInt *CA = dyn_cast<ConstantInt>(BitOp2->getOperand(1));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1738</td>
    <td class="uncoveredLine">      ConstantInt *CB = dyn_cast<ConstantInt>(BitOp1->getOperand(1));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1739</td>
    <td class="uncoveredLine">      if (!CA || !CB)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1740</td>
    <td class="uncoveredLine">        return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1741</td>
    <td class="uncoveredLine">      IRBuilder<> B(Ctx);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1742</td>
    <td class="uncoveredLine">      Value *X = BitOp2->getOperand(0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1743</td>
    <td class="uncoveredLine">      return B.CreateBinOp(BitOp2->getOpcode(), X,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1744</td>
    <td class="uncoveredLine">                B.CreateBinOp(BitOp1->getOpcode(), CA, CB));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1745</td>
    <td class="uncoveredLine">    });</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1746</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1747</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1748</td>
    <td class="uncoveredLine">void PolynomialMultiplyRecognize::setupPostSimplifier(Simplifier &S) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1749</td>
    <td class="uncoveredLine">  S.addRule("(and (xor (and x a) y) b) -> (and (xor x y) b), if b == b&a",</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1750</td>
    <td class="uncoveredLine">    [](Instruction *I, LLVMContext &Ctx) -> Value* {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1751</td>
    <td class="uncoveredLine">      if (I->getOpcode() != Instruction::And)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1752</td>
    <td class="uncoveredLine">        return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1753</td>
    <td class="uncoveredLine">      Instruction *Xor = dyn_cast<Instruction>(I->getOperand(0));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1754</td>
    <td class="uncoveredLine">      ConstantInt *C0 = dyn_cast<ConstantInt>(I->getOperand(1));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1755</td>
    <td class="uncoveredLine">      if (!Xor || !C0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1756</td>
    <td class="uncoveredLine">        return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1757</td>
    <td class="uncoveredLine">      if (Xor->getOpcode() != Instruction::Xor)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1758</td>
    <td class="uncoveredLine">        return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1759</td>
    <td class="uncoveredLine">      Instruction *And0 = dyn_cast<Instruction>(Xor->getOperand(0));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1760</td>
    <td class="uncoveredLine">      Instruction *And1 = dyn_cast<Instruction>(Xor->getOperand(1));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1761</td>
    <td class="">      // Pick the first non-null and.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1762</td>
    <td class="uncoveredLine">      if (!And0 || And0->getOpcode() != Instruction::And)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1763</td>
    <td class="uncoveredLine">        std::swap(And0, And1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1764</td>
    <td class="uncoveredLine">      ConstantInt *C1 = dyn_cast<ConstantInt>(And0->getOperand(1));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1765</td>
    <td class="uncoveredLine">      if (!C1)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1766</td>
    <td class="uncoveredLine">        return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1767</td>
    <td class="uncoveredLine">      uint32_t V0 = C0->getZExtValue();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1768</td>
    <td class="uncoveredLine">      uint32_t V1 = C1->getZExtValue();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1769</td>
    <td class="uncoveredLine">      if (V0 != (V0 & V1))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1770</td>
    <td class="uncoveredLine">        return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1771</td>
    <td class="uncoveredLine">      IRBuilder<> B(Ctx);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1772</td>
    <td class="uncoveredLine">      return B.CreateAnd(B.CreateXor(And0->getOperand(0), And1), C0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1773</td>
    <td class="uncoveredLine">    });</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1774</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1775</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1776</td>
    <td class="uncoveredLine">bool PolynomialMultiplyRecognize::recognize() {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1777</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << "Starting PolynomialMultiplyRecognize on loop\n"</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1778</td>
    <td class="">                    << *CurLoop << '\n');</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1779</td>
    <td class="">  // Restrictions:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1780</td>
    <td class="">  // - The loop must consist of a single block.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1781</td>
    <td class="">  // - The iteration count must be known at compile-time.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1782</td>
    <td class="">  // - The loop must have an induction variable starting from 0, and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1783</td>
    <td class="">  //   incremented in each iteration of the loop.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1784</td>
    <td class="uncoveredLine">  BasicBlock *LoopB = CurLoop->getHeader();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1785</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << "Loop header:\n" << *LoopB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1786</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1787</td>
    <td class="uncoveredLine">  if (LoopB != CurLoop->getLoopLatch())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1788</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1789</td>
    <td class="uncoveredLine">  BasicBlock *ExitB = CurLoop->getExitBlock();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1790</td>
    <td class="uncoveredLine">  if (ExitB == nullptr)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1791</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1792</td>
    <td class="uncoveredLine">  BasicBlock *EntryB = CurLoop->getLoopPreheader();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1793</td>
    <td class="uncoveredLine">  if (EntryB == nullptr)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1794</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1795</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1796</td>
    <td class="uncoveredLine">  unsigned IterCount = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1797</td>
    <td class="uncoveredLine">  const SCEV *CT = SE.getBackedgeTakenCount(CurLoop);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1798</td>
    <td class="uncoveredLine">  if (isa<SCEVCouldNotCompute>(CT))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1799</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1800</td>
    <td class="uncoveredLine">  if (auto *CV = dyn_cast<SCEVConstant>(CT))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1801</td>
    <td class="uncoveredLine">    IterCount = CV->getValue()->getZExtValue() + 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1802</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1803</td>
    <td class="uncoveredLine">  Value *CIV = getCountIV(LoopB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1804</td>
    <td class="uncoveredLine">  ParsedValues PV;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1805</td>
    <td class="uncoveredLine">  Simplifier PreSimp;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1806</td>
    <td class="uncoveredLine">  PV.IterCount = IterCount;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1807</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << "Loop IV: " << *CIV << "\nIterCount: " << IterCount</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1808</td>
    <td class="">                    << '\n');</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1809</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1810</td>
    <td class="uncoveredLine">  setupPreSimplifier(PreSimp);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1811</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1812</td>
    <td class="">  // Perform a preliminary scan of select instructions to see if any of them</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1813</td>
    <td class="">  // looks like a generator of the polynomial multiply steps. Assume that a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1814</td>
    <td class="">  // loop can only contain a single transformable operation, so stop the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1815</td>
    <td class="">  // traversal after the first reasonable candidate was found.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1816</td>
    <td class="">  // XXX: Currently this approach can modify the loop before being 100% sure</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1817</td>
    <td class="">  // that the transformation can be carried out.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1818</td>
    <td class="uncoveredLine">  bool FoundPreScan = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1819</td>
    <td class="uncoveredLine">  auto FeedsPHI = [LoopB](const Value *V) -> bool {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1820</td>
    <td class="uncoveredLine">    for (const Value *U : V->users()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1821</td>
    <td class="uncoveredLine">      if (const auto *P = dyn_cast<const PHINode>(U))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1822</td>
    <td class="uncoveredLine">        if (P->getParent() == LoopB)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1823</td>
    <td class="uncoveredLine">          return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1824</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1825</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1826</td>
    <td class="uncoveredLine">  };</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1827</td>
    <td class="uncoveredLine">  for (Instruction &In : *LoopB) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1828</td>
    <td class="uncoveredLine">    SelectInst *SI = dyn_cast<SelectInst>(&In);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1829</td>
    <td class="uncoveredLine">    if (!SI || !FeedsPHI(SI))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1830</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1831</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1832</td>
    <td class="uncoveredLine">    Simplifier::Context C(SI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1833</td>
    <td class="uncoveredLine">    Value *T = PreSimp.simplify(C);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1834</td>
    <td class="uncoveredLine">    SelectInst *SelI = (T && isa<SelectInst>(T)) ? cast<SelectInst>(T) : SI;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1835</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "scanSelect(pre-scan): " << PE(C, SelI) << '\n');</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1836</td>
    <td class="uncoveredLine">    if (scanSelect(SelI, LoopB, EntryB, CIV, PV, true)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1837</td>
    <td class="uncoveredLine">      FoundPreScan = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1838</td>
    <td class="uncoveredLine">      if (SelI != SI) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1839</td>
    <td class="uncoveredLine">        Value *NewSel = C.materialize(LoopB, SI->getIterator());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1840</td>
    <td class="uncoveredLine">        SI->replaceAllUsesWith(NewSel);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1841</td>
    <td class="uncoveredLine">        RecursivelyDeleteTriviallyDeadInstructions(SI, &TLI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1842</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1843</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1844</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1845</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1846</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1847</td>
    <td class="uncoveredLine">  if (!FoundPreScan) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1848</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "Have not found candidates for pmpy\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1849</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1850</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1851</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1852</td>
    <td class="uncoveredLine">  if (!PV.Left) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1853</td>
    <td class="">    // The right shift version actually only returns the higher bits of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1854</td>
    <td class="">    // the result (each iteration discards the LSB). If we want to convert it</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1855</td>
    <td class="">    // to a left-shifting loop, the working data type must be at least as</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1856</td>
    <td class="">    // wide as the target's pmpy instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1857</td>
    <td class="uncoveredLine">    if (!promoteTypes(LoopB, ExitB))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1858</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1859</td>
    <td class="">    // Run post-promotion simplifications.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1860</td>
    <td class="uncoveredLine">    Simplifier PostSimp;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1861</td>
    <td class="uncoveredLine">    setupPostSimplifier(PostSimp);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1862</td>
    <td class="uncoveredLine">    for (Instruction &In : *LoopB) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1863</td>
    <td class="uncoveredLine">      SelectInst *SI = dyn_cast<SelectInst>(&In);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1864</td>
    <td class="uncoveredLine">      if (!SI || !FeedsPHI(SI))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1865</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1866</td>
    <td class="uncoveredLine">      Simplifier::Context C(SI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1867</td>
    <td class="uncoveredLine">      Value *T = PostSimp.simplify(C);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1868</td>
    <td class="uncoveredLine">      SelectInst *SelI = dyn_cast_or_null<SelectInst>(T);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1869</td>
    <td class="uncoveredLine">      if (SelI != SI) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1870</td>
    <td class="uncoveredLine">        Value *NewSel = C.materialize(LoopB, SI->getIterator());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1871</td>
    <td class="uncoveredLine">        SI->replaceAllUsesWith(NewSel);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1872</td>
    <td class="uncoveredLine">        RecursivelyDeleteTriviallyDeadInstructions(SI, &TLI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1873</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1874</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1875</td>
    <td class="uncoveredLine">    }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1876</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1877</td>
    <td class="uncoveredLine">    if (!convertShiftsToLeft(LoopB, ExitB, IterCount))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1878</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1879</td>
    <td class="uncoveredLine">    cleanupLoopBody(LoopB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1880</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1881</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1882</td>
    <td class="">  // Scan the loop again, find the generating select instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1883</td>
    <td class="uncoveredLine">  bool FoundScan = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1884</td>
    <td class="uncoveredLine">  for (Instruction &In : *LoopB) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1885</td>
    <td class="uncoveredLine">    SelectInst *SelI = dyn_cast<SelectInst>(&In);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1886</td>
    <td class="uncoveredLine">    if (!SelI)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1887</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1888</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "scanSelect: " << *SelI << '\n');</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1889</td>
    <td class="uncoveredLine">    FoundScan = scanSelect(SelI, LoopB, EntryB, CIV, PV, false);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1890</td>
    <td class="uncoveredLine">    if (FoundScan)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1891</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1892</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1893</td>
    <td class="uncoveredLine">  assert(FoundScan);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1894</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1895</td>
    <td class="uncoveredLine">  LLVM_DEBUG({</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1896</td>
    <td class="">    StringRef PP = (PV.M ? "(P+M)" : "P");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1897</td>
    <td class="">    if (!PV.Inv)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1898</td>
    <td class="">      dbgs() << "Found pmpy idiom: R = " << PP << ".Q\n";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1899</td>
    <td class="">    else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1900</td>
    <td class="">      dbgs() << "Found inverse pmpy idiom: R = (" << PP << "/Q).Q) + "</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1901</td>
    <td class="">             << PP << "\n";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1902</td>
    <td class="">    dbgs() << "  Res:" << *PV.Res << "\n  P:" << *PV.P << "\n";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1903</td>
    <td class="">    if (PV.M)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1904</td>
    <td class="">      dbgs() << "  M:" << *PV.M << "\n";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1905</td>
    <td class="">    dbgs() << "  Q:" << *PV.Q << "\n";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1906</td>
    <td class="">    dbgs() << "  Iteration count:" << PV.IterCount << "\n";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1907</td>
    <td class="">  });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1908</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1909</td>
    <td class="uncoveredLine">  BasicBlock::iterator At(EntryB->getTerminator());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1910</td>
    <td class="uncoveredLine">  Value *PM = generate(At, PV);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1911</td>
    <td class="uncoveredLine">  if (PM == nullptr)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1912</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1913</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1914</td>
    <td class="uncoveredLine">  if (PM->getType() != PV.Res->getType())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1915</td>
    <td class="uncoveredLine">    PM = IRBuilder<>(&*At).CreateIntCast(PM, PV.Res->getType(), false);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1916</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1917</td>
    <td class="uncoveredLine">  PV.Res->replaceAllUsesWith(PM);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1918</td>
    <td class="uncoveredLine">  PV.Res->eraseFromParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1919</td>
    <td class="uncoveredLine">  return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1920</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1921</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1922</td>
    <td class="uncoveredLine">int HexagonLoopIdiomRecognize::getSCEVStride(const SCEVAddRecExpr *S) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1923</td>
    <td class="uncoveredLine">  if (const SCEVConstant *SC = dyn_cast<SCEVConstant>(S->getOperand(1)))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1924</td>
    <td class="uncoveredLine">    return SC->getAPInt().getSExtValue();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1925</td>
    <td class="uncoveredLine">  return 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1926</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1927</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1928</td>
    <td class="uncoveredLine">bool HexagonLoopIdiomRecognize::isLegalStore(Loop *CurLoop, StoreInst *SI) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1929</td>
    <td class="">  // Allow volatile stores if HexagonVolatileMemcpy is enabled.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1930</td>
    <td class="uncoveredLine">  if (!(SI->isVolatile() && HexagonVolatileMemcpy) && !SI->isSimple())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1931</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1932</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1933</td>
    <td class="uncoveredLine">  Value *StoredVal = SI->getValueOperand();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1934</td>
    <td class="uncoveredLine">  Value *StorePtr = SI->getPointerOperand();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1935</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1936</td>
    <td class="">  // Reject stores that are so large that they overflow an unsigned.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1937</td>
    <td class="uncoveredLine">  uint64_t SizeInBits = DL->getTypeSizeInBits(StoredVal->getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1938</td>
    <td class="uncoveredLine">  if ((SizeInBits & 7) || (SizeInBits >> 32) != 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1939</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1940</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1941</td>
    <td class="">  // See if the pointer expression is an AddRec like {base,+,1} on the current</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1942</td>
    <td class="">  // loop, which indicates a strided store.  If we have something else, it's a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1943</td>
    <td class="">  // random store we can't handle.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1944</td>
    <td class="uncoveredLine">  auto *StoreEv = dyn_cast<SCEVAddRecExpr>(SE->getSCEV(StorePtr));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1945</td>
    <td class="uncoveredLine">  if (!StoreEv || StoreEv->getLoop() != CurLoop || !StoreEv->isAffine())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1946</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1947</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1948</td>
    <td class="">  // Check to see if the stride matches the size of the store.  If so, then we</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1949</td>
    <td class="">  // know that every byte is touched in the loop.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1950</td>
    <td class="uncoveredLine">  int Stride = getSCEVStride(StoreEv);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1951</td>
    <td class="uncoveredLine">  if (Stride == 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1952</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1953</td>
    <td class="uncoveredLine">  unsigned StoreSize = DL->getTypeStoreSize(SI->getValueOperand()->getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1954</td>
    <td class="uncoveredLine">  if (StoreSize != unsigned(std::abs(Stride)))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1955</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1956</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1957</td>
    <td class="">  // The store must be feeding a non-volatile load.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1958</td>
    <td class="uncoveredLine">  LoadInst *LI = dyn_cast<LoadInst>(SI->getValueOperand());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1959</td>
    <td class="uncoveredLine">  if (!LI || !LI->isSimple())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1960</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1961</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1962</td>
    <td class="">  // See if the pointer expression is an AddRec like {base,+,1} on the current</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1963</td>
    <td class="">  // loop, which indicates a strided load.  If we have something else, it's a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1964</td>
    <td class="">  // random load we can't handle.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1965</td>
    <td class="uncoveredLine">  Value *LoadPtr = LI->getPointerOperand();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1966</td>
    <td class="uncoveredLine">  auto *LoadEv = dyn_cast<SCEVAddRecExpr>(SE->getSCEV(LoadPtr));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1967</td>
    <td class="uncoveredLine">  if (!LoadEv || LoadEv->getLoop() != CurLoop || !LoadEv->isAffine())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1968</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1969</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1970</td>
    <td class="">  // The store and load must share the same stride.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1971</td>
    <td class="uncoveredLine">  if (StoreEv->getOperand(1) != LoadEv->getOperand(1))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1972</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1973</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1974</td>
    <td class="">  // Success.  This store can be converted into a memcpy.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1975</td>
    <td class="uncoveredLine">  return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1976</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1977</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1978</td>
    <td class="">/// mayLoopAccessLocation - Return true if the specified loop might access the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1979</td>
    <td class="">/// specified pointer location, which is a loop-strided access.  The 'Access'</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1980</td>
    <td class="">/// argument specifies what the verboten forms of access are (read or write).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1981</td>
    <td class="">static bool</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1982</td>
    <td class="uncoveredLine">mayLoopAccessLocation(Value *Ptr, ModRefInfo Access, Loop *L,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1983</td>
    <td class="">                      const SCEV *BECount, unsigned StoreSize,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1984</td>
    <td class="">                      AliasAnalysis &AA,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1985</td>
    <td class="">                      SmallPtrSetImpl<Instruction *> &Ignored) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1986</td>
    <td class="">  // Get the location that may be stored across the loop.  Since the access</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1987</td>
    <td class="">  // is strided positively through memory, we say that the modified location</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1988</td>
    <td class="">  // starts at the pointer and has infinite size.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1989</td>
    <td class="uncoveredLine">  LocationSize AccessSize = LocationSize::afterPointer();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1990</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1991</td>
    <td class="">  // If the loop iterates a fixed number of times, we can refine the access</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1992</td>
    <td class="">  // size to be exactly the size of the memset, which is (BECount+1)*StoreSize</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1993</td>
    <td class="uncoveredLine">  if (const SCEVConstant *BECst = dyn_cast<SCEVConstant>(BECount))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1994</td>
    <td class="uncoveredLine">    AccessSize = LocationSize::precise((BECst->getValue()->getZExtValue() + 1) *</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1995</td>
    <td class="uncoveredLine">                                       StoreSize);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1996</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1997</td>
    <td class="">  // TODO: For this to be really effective, we have to dive into the pointer</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1998</td>
    <td class="">  // operand in the store.  Store to &A[i] of 100 will always return may alias</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1999</td>
    <td class="">  // with store of &A[100], we need to StoreLoc to be "A" with size of 100,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2000</td>
    <td class="">  // which will then no-alias a store to &A[100].</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2001</td>
    <td class="uncoveredLine">  MemoryLocation StoreLoc(Ptr, AccessSize);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2002</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2003</td>
    <td class="uncoveredLine">  for (auto *B : L->blocks())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2004</td>
    <td class="uncoveredLine">    for (auto &I : *B)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2005</td>
    <td class="uncoveredLine">      if (Ignored.count(&I) == 0 &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2006</td>
    <td class="uncoveredLine">          isModOrRefSet(AA.getModRefInfo(&I, StoreLoc) & Access))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2007</td>
    <td class="uncoveredLine">        return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2008</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2009</td>
    <td class="uncoveredLine">  return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2010</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2011</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2012</td>
    <td class="uncoveredLine">void HexagonLoopIdiomRecognize::collectStores(Loop *CurLoop, BasicBlock *BB,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2013</td>
    <td class="">      SmallVectorImpl<StoreInst*> &Stores) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2014</td>
    <td class="uncoveredLine">  Stores.clear();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2015</td>
    <td class="uncoveredLine">  for (Instruction &I : *BB)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2016</td>
    <td class="uncoveredLine">    if (StoreInst *SI = dyn_cast<StoreInst>(&I))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2017</td>
    <td class="uncoveredLine">      if (isLegalStore(CurLoop, SI))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2018</td>
    <td class="uncoveredLine">        Stores.push_back(SI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2019</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2020</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2021</td>
    <td class="uncoveredLine">bool HexagonLoopIdiomRecognize::processCopyingStore(Loop *CurLoop,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2022</td>
    <td class="">      StoreInst *SI, const SCEV *BECount) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2023</td>
    <td class="uncoveredLine">  assert((SI->isSimple() || (SI->isVolatile() && HexagonVolatileMemcpy)) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2024</td>
    <td class="">         "Expected only non-volatile stores, or Hexagon-specific memcpy"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2025</td>
    <td class="">         "to volatile destination.");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2026</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2027</td>
    <td class="uncoveredLine">  Value *StorePtr = SI->getPointerOperand();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2028</td>
    <td class="uncoveredLine">  auto *StoreEv = cast<SCEVAddRecExpr>(SE->getSCEV(StorePtr));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2029</td>
    <td class="uncoveredLine">  unsigned Stride = getSCEVStride(StoreEv);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2030</td>
    <td class="uncoveredLine">  unsigned StoreSize = DL->getTypeStoreSize(SI->getValueOperand()->getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2031</td>
    <td class="uncoveredLine">  if (Stride != StoreSize)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2032</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2033</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2034</td>
    <td class="">  // See if the pointer expression is an AddRec like {base,+,1} on the current</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2035</td>
    <td class="">  // loop, which indicates a strided load.  If we have something else, it's a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2036</td>
    <td class="">  // random load we can't handle.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2037</td>
    <td class="uncoveredLine">  auto *LI = cast<LoadInst>(SI->getValueOperand());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2038</td>
    <td class="uncoveredLine">  auto *LoadEv = cast<SCEVAddRecExpr>(SE->getSCEV(LI->getPointerOperand()));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2039</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2040</td>
    <td class="">  // The trip count of the loop and the base pointer of the addrec SCEV is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2041</td>
    <td class="">  // guaranteed to be loop invariant, which means that it should dominate the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2042</td>
    <td class="">  // header.  This allows us to insert code for it in the preheader.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2043</td>
    <td class="uncoveredLine">  BasicBlock *Preheader = CurLoop->getLoopPreheader();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2044</td>
    <td class="uncoveredLine">  Instruction *ExpPt = Preheader->getTerminator();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2045</td>
    <td class="uncoveredLine">  IRBuilder<> Builder(ExpPt);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2046</td>
    <td class="uncoveredLine">  SCEVExpander Expander(*SE, *DL, "hexagon-loop-idiom");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2047</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2048</td>
    <td class="uncoveredLine">  Type *IntPtrTy = Builder.getIntPtrTy(*DL, SI->getPointerAddressSpace());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2049</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2050</td>
    <td class="">  // Okay, we have a strided store "p[i]" of a loaded value.  We can turn</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2051</td>
    <td class="">  // this into a memcpy/memmove in the loop preheader now if we want.  However,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2052</td>
    <td class="">  // this would be unsafe to do if there is anything else in the loop that may</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2053</td>
    <td class="">  // read or write the memory region we're storing to.  For memcpy, this</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2054</td>
    <td class="">  // includes the load that feeds the stores.  Check for an alias by generating</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2055</td>
    <td class="">  // the base address and checking everything.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2056</td>
    <td class="uncoveredLine">  Value *StoreBasePtr = Expander.expandCodeFor(StoreEv->getStart(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2057</td>
    <td class="uncoveredLine">      Builder.getInt8PtrTy(SI->getPointerAddressSpace()), ExpPt);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2058</td>
    <td class="uncoveredLine">  Value *LoadBasePtr = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2059</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2060</td>
    <td class="uncoveredLine">  bool Overlap = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2061</td>
    <td class="uncoveredLine">  bool DestVolatile = SI->isVolatile();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2062</td>
    <td class="uncoveredLine">  Type *BECountTy = BECount->getType();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2063</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2064</td>
    <td class="uncoveredLine">  if (DestVolatile) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2065</td>
    <td class="">    // The trip count must fit in i32, since it is the type of the "num_words"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2066</td>
    <td class="">    // argument to hexagon_memcpy_forward_vp4cp4n2.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2067</td>
    <td class="uncoveredLine">    if (StoreSize != 4 || DL->getTypeSizeInBits(BECountTy) > 32) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2068</td>
    <td class="uncoveredLine">CleanupAndExit:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2069</td>
    <td class="">      // If we generated new code for the base pointer, clean up.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2070</td>
    <td class="uncoveredLine">      Expander.clear();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2071</td>
    <td class="uncoveredLine">      if (StoreBasePtr && (LoadBasePtr != StoreBasePtr)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2072</td>
    <td class="uncoveredLine">        RecursivelyDeleteTriviallyDeadInstructions(StoreBasePtr, TLI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2073</td>
    <td class="uncoveredLine">        StoreBasePtr = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2074</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2075</td>
    <td class="uncoveredLine">      if (LoadBasePtr) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2076</td>
    <td class="uncoveredLine">        RecursivelyDeleteTriviallyDeadInstructions(LoadBasePtr, TLI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2077</td>
    <td class="uncoveredLine">        LoadBasePtr = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2078</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2079</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2080</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2081</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2082</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2083</td>
    <td class="uncoveredLine">  SmallPtrSet<Instruction*, 2> Ignore1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2084</td>
    <td class="uncoveredLine">  Ignore1.insert(SI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2085</td>
    <td class="uncoveredLine">  if (mayLoopAccessLocation(StoreBasePtr, ModRefInfo::ModRef, CurLoop, BECount,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2086</td>
    <td class="uncoveredLine">                            StoreSize, *AA, Ignore1)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2087</td>
    <td class="">    // Check if the load is the offending instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2088</td>
    <td class="uncoveredLine">    Ignore1.insert(LI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2089</td>
    <td class="uncoveredLine">    if (mayLoopAccessLocation(StoreBasePtr, ModRefInfo::ModRef, CurLoop,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2090</td>
    <td class="uncoveredLine">                              BECount, StoreSize, *AA, Ignore1)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2091</td>
    <td class="">      // Still bad. Nothing we can do.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2092</td>
    <td class="uncoveredLine">      goto CleanupAndExit;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2093</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2094</td>
    <td class="">    // It worked with the load ignored.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2095</td>
    <td class="uncoveredLine">    Overlap = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2096</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2097</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2098</td>
    <td class="uncoveredLine">  if (!Overlap) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2099</td>
    <td class="uncoveredLine">    if (DisableMemcpyIdiom || !HasMemcpy)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2100</td>
    <td class="uncoveredLine">      goto CleanupAndExit;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2101</td>
    <td class="">  } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2102</td>
    <td class="">    // Don't generate memmove if this function will be inlined. This is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2103</td>
    <td class="">    // because the caller will undergo this transformation after inlining.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2104</td>
    <td class="uncoveredLine">    Function *Func = CurLoop->getHeader()->getParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2105</td>
    <td class="uncoveredLine">    if (Func->hasFnAttribute(Attribute::AlwaysInline))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2106</td>
    <td class="uncoveredLine">      goto CleanupAndExit;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2107</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2108</td>
    <td class="">    // In case of a memmove, the call to memmove will be executed instead</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2109</td>
    <td class="">    // of the loop, so we need to make sure that there is nothing else in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2110</td>
    <td class="">    // the loop than the load, store and instructions that these two depend</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2111</td>
    <td class="">    // on.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2112</td>
    <td class="uncoveredLine">    SmallVector<Instruction*,2> Insts;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2113</td>
    <td class="uncoveredLine">    Insts.push_back(SI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2114</td>
    <td class="uncoveredLine">    Insts.push_back(LI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2115</td>
    <td class="uncoveredLine">    if (!coverLoop(CurLoop, Insts))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2116</td>
    <td class="uncoveredLine">      goto CleanupAndExit;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2117</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2118</td>
    <td class="uncoveredLine">    if (DisableMemmoveIdiom || !HasMemmove)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2119</td>
    <td class="uncoveredLine">      goto CleanupAndExit;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2120</td>
    <td class="uncoveredLine">    bool IsNested = CurLoop->getParentLoop() != nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2121</td>
    <td class="uncoveredLine">    if (IsNested && OnlyNonNestedMemmove)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2122</td>
    <td class="uncoveredLine">      goto CleanupAndExit;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2123</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2124</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2125</td>
    <td class="">  // For a memcpy, we have to make sure that the input array is not being</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2126</td>
    <td class="">  // mutated by the loop.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2127</td>
    <td class="uncoveredLine">  LoadBasePtr = Expander.expandCodeFor(LoadEv->getStart(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2128</td>
    <td class="uncoveredLine">      Builder.getInt8PtrTy(LI->getPointerAddressSpace()), ExpPt);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2129</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2130</td>
    <td class="uncoveredLine">  SmallPtrSet<Instruction*, 2> Ignore2;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2131</td>
    <td class="uncoveredLine">  Ignore2.insert(SI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2132</td>
    <td class="uncoveredLine">  if (mayLoopAccessLocation(LoadBasePtr, ModRefInfo::Mod, CurLoop, BECount,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2133</td>
    <td class="uncoveredLine">                            StoreSize, *AA, Ignore2))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2134</td>
    <td class="uncoveredLine">    goto CleanupAndExit;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2135</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2136</td>
    <td class="">  // Check the stride.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2137</td>
    <td class="uncoveredLine">  bool StridePos = getSCEVStride(LoadEv) >= 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2138</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2139</td>
    <td class="">  // Currently, the volatile memcpy only emulates traversing memory forward.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2140</td>
    <td class="uncoveredLine">  if (!StridePos && DestVolatile)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2141</td>
    <td class="uncoveredLine">    goto CleanupAndExit;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2142</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2143</td>
    <td class="uncoveredLine">  bool RuntimeCheck = (Overlap || DestVolatile);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2144</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2145</td>
    <td class="">  BasicBlock *ExitB;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2146</td>
    <td class="uncoveredLine">  if (RuntimeCheck) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2147</td>
    <td class="">    // The runtime check needs a single exit block.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2148</td>
    <td class="uncoveredLine">    SmallVector<BasicBlock*, 8> ExitBlocks;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2149</td>
    <td class="uncoveredLine">    CurLoop->getUniqueExitBlocks(ExitBlocks);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2150</td>
    <td class="uncoveredLine">    if (ExitBlocks.size() != 1)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2151</td>
    <td class="uncoveredLine">      goto CleanupAndExit;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2152</td>
    <td class="uncoveredLine">    ExitB = ExitBlocks[0];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2153</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2154</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2155</td>
    <td class="">  // The # stored bytes is (BECount+1)*Size.  Expand the trip count out to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2156</td>
    <td class="">  // pointer size if it isn't already.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2157</td>
    <td class="uncoveredLine">  LLVMContext &Ctx = SI->getContext();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2158</td>
    <td class="uncoveredLine">  BECount = SE->getTruncateOrZeroExtend(BECount, IntPtrTy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2159</td>
    <td class="uncoveredLine">  DebugLoc DLoc = SI->getDebugLoc();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2160</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2161</td>
    <td class="">  const SCEV *NumBytesS =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2162</td>
    <td class="uncoveredLine">      SE->getAddExpr(BECount, SE->getOne(IntPtrTy), SCEV::FlagNUW);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2163</td>
    <td class="uncoveredLine">  if (StoreSize != 1)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2164</td>
    <td class="uncoveredLine">    NumBytesS = SE->getMulExpr(NumBytesS, SE->getConstant(IntPtrTy, StoreSize),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2165</td>
    <td class="">                               SCEV::FlagNUW);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2166</td>
    <td class="uncoveredLine">  Value *NumBytes = Expander.expandCodeFor(NumBytesS, IntPtrTy, ExpPt);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2167</td>
    <td class="uncoveredLine">  if (Instruction *In = dyn_cast<Instruction>(NumBytes))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2168</td>
    <td class="uncoveredLine">    if (Value *Simp = simplifyInstruction(In, {*DL, TLI, DT}))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2169</td>
    <td class="uncoveredLine">      NumBytes = Simp;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2170</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2171</td>
    <td class="">  CallInst *NewCall;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2172</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2173</td>
    <td class="uncoveredLine">  if (RuntimeCheck) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2174</td>
    <td class="uncoveredLine">    unsigned Threshold = RuntimeMemSizeThreshold;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2175</td>
    <td class="uncoveredLine">    if (ConstantInt *CI = dyn_cast<ConstantInt>(NumBytes)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2176</td>
    <td class="uncoveredLine">      uint64_t C = CI->getZExtValue();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2177</td>
    <td class="uncoveredLine">      if (Threshold != 0 && C < Threshold)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2178</td>
    <td class="uncoveredLine">        goto CleanupAndExit;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2179</td>
    <td class="uncoveredLine">      if (C < CompileTimeMemSizeThreshold)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2180</td>
    <td class="uncoveredLine">        goto CleanupAndExit;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2181</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2182</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2183</td>
    <td class="uncoveredLine">    BasicBlock *Header = CurLoop->getHeader();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2184</td>
    <td class="uncoveredLine">    Function *Func = Header->getParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2185</td>
    <td class="uncoveredLine">    Loop *ParentL = LF->getLoopFor(Preheader);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2186</td>
    <td class="uncoveredLine">    StringRef HeaderName = Header->getName();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2187</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2188</td>
    <td class="">    // Create a new (empty) preheader, and update the PHI nodes in the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2189</td>
    <td class="">    // header to use the new preheader.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2190</td>
    <td class="uncoveredLine">    BasicBlock *NewPreheader = BasicBlock::Create(Ctx, HeaderName+".rtli.ph",</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2191</td>
    <td class="">                                                  Func, Header);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2192</td>
    <td class="uncoveredLine">    if (ParentL)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2193</td>
    <td class="uncoveredLine">      ParentL->addBasicBlockToLoop(NewPreheader, *LF);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2194</td>
    <td class="uncoveredLine">    IRBuilder<>(NewPreheader).CreateBr(Header);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2195</td>
    <td class="uncoveredLine">    for (auto &In : *Header) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2196</td>
    <td class="uncoveredLine">      PHINode *PN = dyn_cast<PHINode>(&In);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2197</td>
    <td class="uncoveredLine">      if (!PN)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2198</td>
    <td class="uncoveredLine">        break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2199</td>
    <td class="uncoveredLine">      int bx = PN->getBasicBlockIndex(Preheader);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2200</td>
    <td class="uncoveredLine">      if (bx >= 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2201</td>
    <td class="uncoveredLine">        PN->setIncomingBlock(bx, NewPreheader);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2202</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2203</td>
    <td class="uncoveredLine">    DT->addNewBlock(NewPreheader, Preheader);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2204</td>
    <td class="uncoveredLine">    DT->changeImmediateDominator(Header, NewPreheader);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2205</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2206</td>
    <td class="">    // Check for safe conditions to execute memmove.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2207</td>
    <td class="">    // If stride is positive, copying things from higher to lower addresses</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2208</td>
    <td class="">    // is equivalent to memmove.  For negative stride, it's the other way</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2209</td>
    <td class="">    // around.  Copying forward in memory with positive stride may not be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2210</td>
    <td class="">    // same as memmove since we may be copying values that we just stored</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2211</td>
    <td class="">    // in some previous iteration.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2212</td>
    <td class="uncoveredLine">    Value *LA = Builder.CreatePtrToInt(LoadBasePtr, IntPtrTy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2213</td>
    <td class="uncoveredLine">    Value *SA = Builder.CreatePtrToInt(StoreBasePtr, IntPtrTy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2214</td>
    <td class="uncoveredLine">    Value *LowA = StridePos ? SA : LA;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2215</td>
    <td class="uncoveredLine">    Value *HighA = StridePos ? LA : SA;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2216</td>
    <td class="uncoveredLine">    Value *CmpA = Builder.CreateICmpULT(LowA, HighA);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2217</td>
    <td class="uncoveredLine">    Value *Cond = CmpA;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2218</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2219</td>
    <td class="">    // Check for distance between pointers. Since the case LowA < HighA</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2220</td>
    <td class="">    // is checked for above, assume LowA >= HighA.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2221</td>
    <td class="uncoveredLine">    Value *Dist = Builder.CreateSub(LowA, HighA);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2222</td>
    <td class="uncoveredLine">    Value *CmpD = Builder.CreateICmpSLE(NumBytes, Dist);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2223</td>
    <td class="uncoveredLine">    Value *CmpEither = Builder.CreateOr(Cond, CmpD);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2224</td>
    <td class="uncoveredLine">    Cond = CmpEither;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2225</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2226</td>
    <td class="uncoveredLine">    if (Threshold != 0) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2227</td>
    <td class="uncoveredLine">      Type *Ty = NumBytes->getType();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2228</td>
    <td class="uncoveredLine">      Value *Thr = ConstantInt::get(Ty, Threshold);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2229</td>
    <td class="uncoveredLine">      Value *CmpB = Builder.CreateICmpULT(Thr, NumBytes);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2230</td>
    <td class="uncoveredLine">      Value *CmpBoth = Builder.CreateAnd(Cond, CmpB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2231</td>
    <td class="uncoveredLine">      Cond = CmpBoth;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2232</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2233</td>
    <td class="uncoveredLine">    BasicBlock *MemmoveB = BasicBlock::Create(Ctx, Header->getName()+".rtli",</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2234</td>
    <td class="">                                              Func, NewPreheader);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2235</td>
    <td class="uncoveredLine">    if (ParentL)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2236</td>
    <td class="uncoveredLine">      ParentL->addBasicBlockToLoop(MemmoveB, *LF);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2237</td>
    <td class="uncoveredLine">    Instruction *OldT = Preheader->getTerminator();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2238</td>
    <td class="uncoveredLine">    Builder.CreateCondBr(Cond, MemmoveB, NewPreheader);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2239</td>
    <td class="uncoveredLine">    OldT->eraseFromParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2240</td>
    <td class="uncoveredLine">    Preheader->setName(Preheader->getName()+".old");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2241</td>
    <td class="uncoveredLine">    DT->addNewBlock(MemmoveB, Preheader);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2242</td>
    <td class="">    // Find the new immediate dominator of the exit block.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2243</td>
    <td class="uncoveredLine">    BasicBlock *ExitD = Preheader;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2244</td>
    <td class="uncoveredLine">    for (BasicBlock *PB : predecessors(ExitB)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2245</td>
    <td class="uncoveredLine">      ExitD = DT->findNearestCommonDominator(ExitD, PB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2246</td>
    <td class="uncoveredLine">      if (!ExitD)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2247</td>
    <td class="uncoveredLine">        break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2248</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2249</td>
    <td class="">    // If the prior immediate dominator of ExitB was dominated by the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2250</td>
    <td class="">    // old preheader, then the old preheader becomes the new immediate</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2251</td>
    <td class="">    // dominator.  Otherwise don't change anything (because the newly</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2252</td>
    <td class="">    // added blocks are dominated by the old preheader).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2253</td>
    <td class="uncoveredLine">    if (ExitD && DT->dominates(Preheader, ExitD)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2254</td>
    <td class="uncoveredLine">      DomTreeNode *BN = DT->getNode(ExitB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2255</td>
    <td class="uncoveredLine">      DomTreeNode *DN = DT->getNode(ExitD);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2256</td>
    <td class="uncoveredLine">      BN->setIDom(DN);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2257</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2258</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2259</td>
    <td class="">    // Add a call to memmove to the conditional block.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2260</td>
    <td class="uncoveredLine">    IRBuilder<> CondBuilder(MemmoveB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2261</td>
    <td class="uncoveredLine">    CondBuilder.CreateBr(ExitB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2262</td>
    <td class="uncoveredLine">    CondBuilder.SetInsertPoint(MemmoveB->getTerminator());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2263</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2264</td>
    <td class="uncoveredLine">    if (DestVolatile) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2265</td>
    <td class="uncoveredLine">      Type *Int32Ty = Type::getInt32Ty(Ctx);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2266</td>
    <td class="uncoveredLine">      Type *Int32PtrTy = Type::getInt32PtrTy(Ctx);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2267</td>
    <td class="uncoveredLine">      Type *VoidTy = Type::getVoidTy(Ctx);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2268</td>
    <td class="uncoveredLine">      Module *M = Func->getParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2269</td>
    <td class="uncoveredLine">      FunctionCallee Fn = M->getOrInsertFunction(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2270</td>
    <td class="">          HexagonVolatileMemcpyName, VoidTy, Int32PtrTy, Int32PtrTy, Int32Ty);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2271</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2272</td>
    <td class="uncoveredLine">      const SCEV *OneS = SE->getConstant(Int32Ty, 1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2273</td>
    <td class="uncoveredLine">      const SCEV *BECount32 = SE->getTruncateOrZeroExtend(BECount, Int32Ty);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2274</td>
    <td class="uncoveredLine">      const SCEV *NumWordsS = SE->getAddExpr(BECount32, OneS, SCEV::FlagNUW);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2275</td>
    <td class="uncoveredLine">      Value *NumWords = Expander.expandCodeFor(NumWordsS, Int32Ty,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2276</td>
    <td class="">                                               MemmoveB->getTerminator());</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2277</td>
    <td class="uncoveredLine">      if (Instruction *In = dyn_cast<Instruction>(NumWords))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2278</td>
    <td class="uncoveredLine">        if (Value *Simp = simplifyInstruction(In, {*DL, TLI, DT}))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2279</td>
    <td class="uncoveredLine">          NumWords = Simp;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2280</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2281</td>
    <td class="uncoveredLine">      Value *Op0 = (StoreBasePtr->getType() == Int32PtrTy)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2282</td>
    <td class="uncoveredLine">                      ? StoreBasePtr</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2283</td>
    <td class="uncoveredLine">                      : CondBuilder.CreateBitCast(StoreBasePtr, Int32PtrTy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2284</td>
    <td class="uncoveredLine">      Value *Op1 = (LoadBasePtr->getType() == Int32PtrTy)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2285</td>
    <td class="uncoveredLine">                      ? LoadBasePtr</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2286</td>
    <td class="uncoveredLine">                      : CondBuilder.CreateBitCast(LoadBasePtr, Int32PtrTy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2287</td>
    <td class="uncoveredLine">      NewCall = CondBuilder.CreateCall(Fn, {Op0, Op1, NumWords});</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2288</td>
    <td class="">    } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2289</td>
    <td class="uncoveredLine">      NewCall = CondBuilder.CreateMemMove(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2290</td>
    <td class="">          StoreBasePtr, SI->getAlign(), LoadBasePtr, LI->getAlign(), NumBytes);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2291</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2292</td>
    <td class="uncoveredLine">  } else {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2293</td>
    <td class="uncoveredLine">    NewCall = Builder.CreateMemCpy(StoreBasePtr, SI->getAlign(), LoadBasePtr,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2294</td>
    <td class="">                                   LI->getAlign(), NumBytes);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2295</td>
    <td class="">    // Okay, the memcpy has been formed.  Zap the original store and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2296</td>
    <td class="">    // anything that feeds into it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2297</td>
    <td class="uncoveredLine">    RecursivelyDeleteTriviallyDeadInstructions(SI, TLI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2298</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2299</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2300</td>
    <td class="uncoveredLine">  NewCall->setDebugLoc(DLoc);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2301</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2302</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << "  Formed " << (Overlap ? "memmove: " : "memcpy: ")</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2303</td>
    <td class="">                    << *NewCall << "\n"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2304</td>
    <td class="">                    << "    from load ptr=" << *LoadEv << " at: " << *LI << "\n"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2305</td>
    <td class="">                    << "    from store ptr=" << *StoreEv << " at: " << *SI</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2306</td>
    <td class="">                    << "\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2307</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2308</td>
    <td class="uncoveredLine">  return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2309</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2310</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2311</td>
    <td class="">// Check if the instructions in Insts, together with their dependencies</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2312</td>
    <td class="">// cover the loop in the sense that the loop could be safely eliminated once</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2313</td>
    <td class="">// the instructions in Insts are removed.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2314</td>
    <td class="uncoveredLine">bool HexagonLoopIdiomRecognize::coverLoop(Loop *L,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2315</td>
    <td class="">      SmallVectorImpl<Instruction*> &Insts) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2316</td>
    <td class="uncoveredLine">  SmallSet<BasicBlock*,8> LoopBlocks;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2317</td>
    <td class="uncoveredLine">  for (auto *B : L->blocks())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2318</td>
    <td class="uncoveredLine">    LoopBlocks.insert(B);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2319</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2320</td>
    <td class="uncoveredLine">  SetVector<Instruction*> Worklist(Insts.begin(), Insts.end());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2321</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2322</td>
    <td class="">  // Collect all instructions from the loop that the instructions in Insts</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2323</td>
    <td class="">  // depend on (plus their dependencies, etc.).  These instructions will</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2324</td>
    <td class="">  // constitute the expression trees that feed those in Insts, but the trees</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2325</td>
    <td class="">  // will be limited only to instructions contained in the loop.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2326</td>
    <td class="uncoveredLine">  for (unsigned i = 0; i < Worklist.size(); ++i) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2327</td>
    <td class="uncoveredLine">    Instruction *In = Worklist[i];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2328</td>
    <td class="uncoveredLine">    for (auto I = In->op_begin(), E = In->op_end(); I != E; ++I) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2329</td>
    <td class="uncoveredLine">      Instruction *OpI = dyn_cast<Instruction>(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2330</td>
    <td class="uncoveredLine">      if (!OpI)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2331</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2332</td>
    <td class="uncoveredLine">      BasicBlock *PB = OpI->getParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2333</td>
    <td class="uncoveredLine">      if (!LoopBlocks.count(PB))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2334</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2335</td>
    <td class="uncoveredLine">      Worklist.insert(OpI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2336</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2337</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2338</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2339</td>
    <td class="">  // Scan all instructions in the loop, if any of them have a user outside</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2340</td>
    <td class="">  // of the loop, or outside of the expressions collected above, then either</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2341</td>
    <td class="">  // the loop has a side-effect visible outside of it, or there are</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2342</td>
    <td class="">  // instructions in it that are not involved in the original set Insts.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2343</td>
    <td class="uncoveredLine">  for (auto *B : L->blocks()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2344</td>
    <td class="uncoveredLine">    for (auto &In : *B) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2345</td>
    <td class="uncoveredLine">      if (isa<BranchInst>(In) || isa<DbgInfoIntrinsic>(In))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2346</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2347</td>
    <td class="uncoveredLine">      if (!Worklist.count(&In) && In.mayHaveSideEffects())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2348</td>
    <td class="uncoveredLine">        return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2349</td>
    <td class="uncoveredLine">      for (auto *K : In.users()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2350</td>
    <td class="uncoveredLine">        Instruction *UseI = dyn_cast<Instruction>(K);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2351</td>
    <td class="uncoveredLine">        if (!UseI)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2352</td>
    <td class="uncoveredLine">          continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2353</td>
    <td class="uncoveredLine">        BasicBlock *UseB = UseI->getParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2354</td>
    <td class="uncoveredLine">        if (LF->getLoopFor(UseB) != L)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2355</td>
    <td class="uncoveredLine">          return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2356</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2357</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2358</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2359</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2360</td>
    <td class="uncoveredLine">  return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2361</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2362</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2363</td>
    <td class="">/// runOnLoopBlock - Process the specified block, which lives in a counted loop</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2364</td>
    <td class="">/// with the specified backedge count.  This block is known to be in the current</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2365</td>
    <td class="">/// loop and not in any subloops.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2366</td>
    <td class="uncoveredLine">bool HexagonLoopIdiomRecognize::runOnLoopBlock(Loop *CurLoop, BasicBlock *BB,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2367</td>
    <td class="">      const SCEV *BECount, SmallVectorImpl<BasicBlock*> &ExitBlocks) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2368</td>
    <td class="">  // We can only promote stores in this block if they are unconditionally</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2369</td>
    <td class="">  // executed in the loop.  For a block to be unconditionally executed, it has</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2370</td>
    <td class="">  // to dominate all the exit blocks of the loop.  Verify this now.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2371</td>
    <td class="uncoveredLine">  auto DominatedByBB = [this,BB] (BasicBlock *EB) -> bool {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2372</td>
    <td class="uncoveredLine">    return DT->dominates(BB, EB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2373</td>
    <td class="uncoveredLine">  };</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2374</td>
    <td class="uncoveredLine">  if (!all_of(ExitBlocks, DominatedByBB))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2375</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2376</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2377</td>
    <td class="uncoveredLine">  bool MadeChange = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2378</td>
    <td class="">  // Look for store instructions, which may be optimized to memset/memcpy.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2379</td>
    <td class="uncoveredLine">  SmallVector<StoreInst*,8> Stores;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2380</td>
    <td class="uncoveredLine">  collectStores(CurLoop, BB, Stores);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2381</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2382</td>
    <td class="">  // Optimize the store into a memcpy, if it feeds an similarly strided load.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2383</td>
    <td class="uncoveredLine">  for (auto &SI : Stores)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2384</td>
    <td class="uncoveredLine">    MadeChange |= processCopyingStore(CurLoop, SI, BECount);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2385</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2386</td>
    <td class="uncoveredLine">  return MadeChange;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2387</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2388</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2389</td>
    <td class="uncoveredLine">bool HexagonLoopIdiomRecognize::runOnCountableLoop(Loop *L) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2390</td>
    <td class="uncoveredLine">  PolynomialMultiplyRecognize PMR(L, *DL, *DT, *TLI, *SE);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2391</td>
    <td class="uncoveredLine">  if (PMR.recognize())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2392</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2393</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2394</td>
    <td class="uncoveredLine">  if (!HasMemcpy && !HasMemmove)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2395</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2396</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2397</td>
    <td class="uncoveredLine">  const SCEV *BECount = SE->getBackedgeTakenCount(L);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2398</td>
    <td class="uncoveredLine">  assert(!isa<SCEVCouldNotCompute>(BECount) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2399</td>
    <td class="">         "runOnCountableLoop() called on a loop without a predictable"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2400</td>
    <td class="">         "backedge-taken count");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2401</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2402</td>
    <td class="uncoveredLine">  SmallVector<BasicBlock *, 8> ExitBlocks;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2403</td>
    <td class="uncoveredLine">  L->getUniqueExitBlocks(ExitBlocks);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2404</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2405</td>
    <td class="uncoveredLine">  bool Changed = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2406</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2407</td>
    <td class="">  // Scan all the blocks in the loop that are not in subloops.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2408</td>
    <td class="uncoveredLine">  for (auto *BB : L->getBlocks()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2409</td>
    <td class="">    // Ignore blocks in subloops.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2410</td>
    <td class="uncoveredLine">    if (LF->getLoopFor(BB) != L)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2411</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2412</td>
    <td class="uncoveredLine">    Changed |= runOnLoopBlock(L, BB, BECount, ExitBlocks);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2413</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2414</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2415</td>
    <td class="uncoveredLine">  return Changed;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2416</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2417</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2418</td>
    <td class="uncoveredLine">bool HexagonLoopIdiomRecognize::run(Loop *L) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2419</td>
    <td class="uncoveredLine">  const Module &M = *L->getHeader()->getParent()->getParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2420</td>
    <td class="uncoveredLine">  if (Triple(M.getTargetTriple()).getArch() != Triple::hexagon)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2421</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2422</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2423</td>
    <td class="">  // If the loop could not be converted to canonical form, it must have an</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2424</td>
    <td class="">  // indirectbr in it, just give up.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2425</td>
    <td class="uncoveredLine">  if (!L->getLoopPreheader())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2426</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2427</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2428</td>
    <td class="">  // Disable loop idiom recognition if the function's name is a common idiom.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2429</td>
    <td class="uncoveredLine">  StringRef Name = L->getHeader()->getParent()->getName();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2430</td>
    <td class="uncoveredLine">  if (Name == "memset" || Name == "memcpy" || Name == "memmove")</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2431</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2432</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2433</td>
    <td class="uncoveredLine">  DL = &L->getHeader()->getModule()->getDataLayout();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2434</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2435</td>
    <td class="uncoveredLine">  HasMemcpy = TLI->has(LibFunc_memcpy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2436</td>
    <td class="uncoveredLine">  HasMemmove = TLI->has(LibFunc_memmove);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2437</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2438</td>
    <td class="uncoveredLine">  if (SE->hasLoopInvariantBackedgeTakenCount(L))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2439</td>
    <td class="uncoveredLine">    return runOnCountableLoop(L);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2440</td>
    <td class="uncoveredLine">  return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2441</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2442</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2443</td>
    <td class="uncoveredLine">bool HexagonLoopIdiomRecognizeLegacyPass::runOnLoop(Loop *L,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2444</td>
    <td class="">                                                    LPPassManager &LPM) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2445</td>
    <td class="uncoveredLine">  if (skipLoop(L))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2446</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2447</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2448</td>
    <td class="uncoveredLine">  auto *AA = &getAnalysis<AAResultsWrapperPass>().getAAResults();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2449</td>
    <td class="uncoveredLine">  auto *DT = &getAnalysis<DominatorTreeWrapperPass>().getDomTree();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2450</td>
    <td class="uncoveredLine">  auto *LF = &getAnalysis<LoopInfoWrapperPass>().getLoopInfo();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2451</td>
    <td class="uncoveredLine">  auto *TLI = &getAnalysis<TargetLibraryInfoWrapperPass>().getTLI(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2452</td>
    <td class="uncoveredLine">      *L->getHeader()->getParent());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2453</td>
    <td class="uncoveredLine">  auto *SE = &getAnalysis<ScalarEvolutionWrapperPass>().getSE();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2454</td>
    <td class="uncoveredLine">  return HexagonLoopIdiomRecognize(AA, DT, LF, TLI, SE).run(L);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2455</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2456</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2457</td>
    <td class="uncoveredLine">Pass *llvm::createHexagonLoopIdiomPass() {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2458</td>
    <td class="uncoveredLine">  return new HexagonLoopIdiomRecognizeLegacyPass();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2459</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2460</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2461</td>
    <td class="">PreservedAnalyses</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2462</td>
    <td class="uncoveredLine">HexagonLoopIdiomRecognitionPass::run(Loop &L, LoopAnalysisManager &AM,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2463</td>
    <td class="">                                     LoopStandardAnalysisResults &AR,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2464</td>
    <td class="">                                     LPMUpdater &U) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2465</td>
    <td class="uncoveredLine">  return HexagonLoopIdiomRecognize(&AR.AA, &AR.DT, &AR.LI, &AR.TLI, &AR.SE)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2466</td>
    <td class="uncoveredLine">                 .run(&L)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2467</td>
    <td class="">             ? getLoopPassPreservedAnalyses()</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2468</td>
    <td class="uncoveredLine">             : PreservedAnalyses::all();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2469</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2470</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Functions Report</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Functions Report</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Function name</th>
    <th class="mainTh">Number of hits</th>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_125HexagonLoopIdiomRecognizeC2EPN4llvm9AAResultsEPNS1_13DominatorTreeEPNS1_8LoopInfoEPKNS1_17TargetLibraryInfoEPNS1_15ScalarEvolutionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_135HexagonLoopIdiomRecognizeLegacyPassC2Ev</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_135HexagonLoopIdiomRecognizeLegacyPass11getPassNameEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_135HexagonLoopIdiomRecognizeLegacyPass16getAnalysisUsageERN4llvm13AnalysisUsageE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_110Simplifier4RuleC2EN4llvm9StringRefESt8functionIFPNS2_5ValueEPNS2_11InstructionERNS2_11LLVMContextEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_110Simplifier7addRuleEN4llvm9StringRefERKSt8functionIFPNS1_5ValueEPNS1_11InstructionERNS1_11LLVMContextEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_110Simplifier12WorkListTypeC2Ev</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_110Simplifier12WorkListType9push_backEPN4llvm5ValueE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_110Simplifier12WorkListType13pop_front_valEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_110Simplifier12WorkListType5emptyEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_110Simplifier7ContextC2EPN4llvm11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_110Simplifier7ContextD2Ev</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_12PEC2ERKNS_10Simplifier7ContextEPN4llvm5ValueE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_1lsERN4llvm11raw_ostreamERKNS_2PEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL53initializeHexagonLoopIdiomRecognizeLegacyPassPassOnceRN4llvm12PassRegistryE</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm49initializeHexagonLoopIdiomRecognizeLegacyPassPassERNS_12PassRegistryE</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_110Simplifier7Context8traverseIZNS1_3useEPN4llvm5ValueEEUlPNS3_11InstructionEE_EEvS5_T_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_110Simplifier7Context8traverseIZNS1_5unuseEPN4llvm5ValueEEUlPNS3_11InstructionEE_EEvS5_T_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_110Simplifier7Context8traverseIZNS1_6recordEPN4llvm5ValueEEUlPNS3_11InstructionEE_EEvS5_T_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_110Simplifier7Context5printERN4llvm11raw_ostreamEPKNS2_5ValueE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_110Simplifier7Context10initializeEPN4llvm11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_110Simplifier7Context6recordEPN4llvm5ValueE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN12_GLOBAL__N_110Simplifier7Context6recordEPN4llvm5ValueEENKUlPNS2_11InstructionEE_clES6_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_110Simplifier7Context3useEPN4llvm5ValueE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN12_GLOBAL__N_110Simplifier7Context3useEPN4llvm5ValueEENKUlPNS2_11InstructionEE_clES6_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_110Simplifier7Context5unuseEPN4llvm5ValueE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN12_GLOBAL__N_110Simplifier7Context5unuseEPN4llvm5ValueEENKUlPNS2_11InstructionEE_clES6_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_110Simplifier7Context5substEPN4llvm5ValueES4_S4_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_110Simplifier7Context7replaceEPN4llvm5ValueES4_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_110Simplifier7Context7cleanupEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_110Simplifier7Context5equalEPKN4llvm11InstructionES5_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_110Simplifier7Context4findEPN4llvm5ValueES4_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_110Simplifier7Context4linkEPN4llvm11InstructionEPNS2_10BasicBlockENS2_14ilist_iteratorINS2_12ilist_detail12node_optionsIS3_Lb1ELb0EvEELb0ELb0EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_110Simplifier7Context11materializeEPN4llvm10BasicBlockENS2_14ilist_iteratorINS2_12ilist_detail12node_optionsINS2_11InstructionELb1ELb0EvEELb0ELb0EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_110Simplifier8simplifyERNS0_7ContextE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_127PolynomialMultiplyRecognizeC2EPN4llvm4LoopERKNS1_10DataLayoutERKNS1_13DominatorTreeERKNS1_17TargetLibraryInfoERNS1_15ScalarEvolutionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_127PolynomialMultiplyRecognize11getPmpyTypeEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_127PolynomialMultiplyRecognize10getCountIVEPN4llvm10BasicBlockE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL22replaceAllUsesOfWithInPN4llvm5ValueES1_PNS_10BasicBlockE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_127PolynomialMultiplyRecognize14matchLeftShiftEPN4llvm10SelectInstEPNS1_5ValueERNS0_12ParsedValuesE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_127PolynomialMultiplyRecognize15matchRightShiftEPN4llvm10SelectInstERNS0_12ParsedValuesE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_127PolynomialMultiplyRecognize10scanSelectEPN4llvm10SelectInstEPNS1_10BasicBlockES5_PNS1_5ValueERNS0_12ParsedValuesEb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_127PolynomialMultiplyRecognize14isPromotableToEPN4llvm5ValueEPNS1_11IntegerTypeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_127PolynomialMultiplyRecognize9promoteToEPN4llvm11InstructionEPNS1_11IntegerTypeEPNS1_10BasicBlockE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_127PolynomialMultiplyRecognize12promoteTypesEPN4llvm10BasicBlockES3_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN12_GLOBAL__N_127PolynomialMultiplyRecognize12promoteTypesEPN4llvm10BasicBlockES3_ENKUlRNS1_11InstructionEE_clES5_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_127PolynomialMultiplyRecognize9findCycleEPN4llvm5ValueES3_RNS1_9SetVectorIS3_NS1_11SmallVectorIS3_Lj0EEENS1_8DenseSetIS3_NS1_12DenseMapInfoIS3_vEEEELj0EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_127PolynomialMultiplyRecognize13classifyCycleEPN4llvm11InstructionERNS1_9SetVectorIPNS1_5ValueENS1_11SmallVectorIS6_Lj0EEENS1_8DenseSetIS6_NS1_12DenseMapInfoIS6_vEEEELj0EEESE_SE_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_127PolynomialMultiplyRecognize12classifyInstEPN4llvm11InstructionERNS1_9SetVectorIPNS1_5ValueENS1_11SmallVectorIS6_Lj0EEENS1_8DenseSetIS6_NS1_12DenseMapInfoIS6_vEEEELj0EEESE_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_127PolynomialMultiplyRecognize17commutesWithShiftEPN4llvm11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_127PolynomialMultiplyRecognize15highBitsAreZeroEPN4llvm5ValueEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_127PolynomialMultiplyRecognize17keepsHighBitsZeroEPN4llvm5ValueEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_127PolynomialMultiplyRecognize16isOperandShiftedEPN4llvm11InstructionEPNS1_5ValueE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_127PolynomialMultiplyRecognize19convertShiftsToLeftEPN4llvm10BasicBlockES3_j</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN12_GLOBAL__N_127PolynomialMultiplyRecognize19convertShiftsToLeftEPN4llvm10BasicBlockES3_jENKUlRSt3mapISt4pairIPNS1_5ValueEPNS1_4TypeEES7_St4lessISA_ESaIS5_IKSA_S7_EEERNS1_9IRBuilderINS1_14ConstantFolderENS1_24IRBuilderDefaultInserterEEES7_PNS1_11IntegerTypeEE_clESH_SM_S7_SO_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_127PolynomialMultiplyRecognize15cleanupLoopBodyEPN4llvm10BasicBlockE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_127PolynomialMultiplyRecognize13getInverseMxNEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_127PolynomialMultiplyRecognize8generateEN4llvm14ilist_iteratorINS1_12ilist_detail12node_optionsINS1_11InstructionELb1ELb0EvEELb0ELb0EEERNS0_12ParsedValuesE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL14hasZeroSignBitPKN4llvm5ValueE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_127PolynomialMultiplyRecognize18setupPreSimplifierERNS_10SimplifierE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN12_GLOBAL__N_127PolynomialMultiplyRecognize18setupPreSimplifierERNS_10SimplifierEENKUlPN4llvm11InstructionERNS3_11LLVMContextEE_clES5_S7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN12_GLOBAL__N_127PolynomialMultiplyRecognize18setupPreSimplifierERNS_10SimplifierEENKUlPN4llvm11InstructionERNS3_11LLVMContextEE0_clES5_S7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN12_GLOBAL__N_127PolynomialMultiplyRecognize18setupPreSimplifierERNS_10SimplifierEENKUlPN4llvm11InstructionERNS3_11LLVMContextEE1_clES5_S7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN12_GLOBAL__N_127PolynomialMultiplyRecognize18setupPreSimplifierERNS_10SimplifierEENKUlPN4llvm11InstructionERNS3_11LLVMContextEE2_clES5_S7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN12_GLOBAL__N_127PolynomialMultiplyRecognize18setupPreSimplifierERNS_10SimplifierEENKUlPN4llvm11InstructionERNS3_11LLVMContextEE3_clES5_S7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN12_GLOBAL__N_127PolynomialMultiplyRecognize18setupPreSimplifierERNS_10SimplifierEENKUlPN4llvm11InstructionERNS3_11LLVMContextEE4_clES5_S7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN12_GLOBAL__N_127PolynomialMultiplyRecognize18setupPreSimplifierERNS_10SimplifierEENKUlPN4llvm11InstructionERNS3_11LLVMContextEE5_clES5_S7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZZN12_GLOBAL__N_127PolynomialMultiplyRecognize18setupPreSimplifierERNS_10SimplifierEENKUlPN4llvm11InstructionERNS3_11LLVMContextEE5_clES5_S7_ENKUljE_clEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_127PolynomialMultiplyRecognize19setupPostSimplifierERNS_10SimplifierE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN12_GLOBAL__N_127PolynomialMultiplyRecognize19setupPostSimplifierERNS_10SimplifierEENKUlPN4llvm11InstructionERNS3_11LLVMContextEE_clES5_S7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_127PolynomialMultiplyRecognize9recognizeEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN12_GLOBAL__N_127PolynomialMultiplyRecognize9recognizeEvENKUlPKN4llvm5ValueEE_clES4_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_125HexagonLoopIdiomRecognize13getSCEVStrideEPKN4llvm14SCEVAddRecExprE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_125HexagonLoopIdiomRecognize12isLegalStoreEPN4llvm4LoopEPNS1_9StoreInstE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL21mayLoopAccessLocationPN4llvm5ValueENS_10ModRefInfoEPNS_4LoopEPKNS_4SCEVEjRNS_9AAResultsERNS_15SmallPtrSetImplIPNS_11InstructionEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_125HexagonLoopIdiomRecognize13collectStoresEPN4llvm4LoopEPNS1_10BasicBlockERNS1_15SmallVectorImplIPNS1_9StoreInstEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_125HexagonLoopIdiomRecognize19processCopyingStoreEPN4llvm4LoopEPNS1_9StoreInstEPKNS1_4SCEVE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_125HexagonLoopIdiomRecognize9coverLoopEPN4llvm4LoopERNS1_15SmallVectorImplIPNS1_11InstructionEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_125HexagonLoopIdiomRecognize14runOnLoopBlockEPN4llvm4LoopEPNS1_10BasicBlockEPKNS1_4SCEVERNS1_15SmallVectorImplIS5_EE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN12_GLOBAL__N_125HexagonLoopIdiomRecognize14runOnLoopBlockEPN4llvm4LoopEPNS1_10BasicBlockEPKNS1_4SCEVERNS1_15SmallVectorImplIS5_EEENKUlS5_E_clES5_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_125HexagonLoopIdiomRecognize18runOnCountableLoopEPN4llvm4LoopE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_125HexagonLoopIdiomRecognize3runEPN4llvm4LoopE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_135HexagonLoopIdiomRecognizeLegacyPass9runOnLoopEPN4llvm4LoopERNS1_13LPPassManagerE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm26createHexagonLoopIdiomPassEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm31HexagonLoopIdiomRecognitionPass3runERNS_4LoopERNS_15AnalysisManagerIS1_JRNS_27LoopStandardAnalysisResultsEEEES5_RNS_10LPMUpdaterE</td>
    <td class="numberOfCalls">0</td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Coverage Diff</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Coverage Diff</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span> BUT NOT </span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </th>
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
      <span> BUT NOT </span>
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="codeline">//===- HexagonLoopIdiomRecognition.cpp ------------------------------------===//</td>
    <td class="lineNumber">1</td>
    <td class="codeline">//===- HexagonLoopIdiomRecognition.cpp ------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="codeline">//</td>
    <td class="lineNumber">2</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="codeline">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">3</td>
    <td class="codeline">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="codeline">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">4</td>
    <td class="codeline">// See https://llvm.org/LICENSE.txt for license information.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="codeline">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">5</td>
    <td class="codeline">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="codeline">//</td>
    <td class="lineNumber">6</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">7</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="codeline"></td>
    <td class="lineNumber">8</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="codeline">#include "HexagonLoopIdiomRecognition.h"</td>
    <td class="lineNumber">9</td>
    <td class="codeline">#include "HexagonLoopIdiomRecognition.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="codeline">#include "llvm/ADT/APInt.h"</td>
    <td class="lineNumber">10</td>
    <td class="codeline">#include "llvm/ADT/APInt.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="codeline">#include "llvm/ADT/DenseMap.h"</td>
    <td class="lineNumber">11</td>
    <td class="codeline">#include "llvm/ADT/DenseMap.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="codeline">#include "llvm/ADT/SetVector.h"</td>
    <td class="lineNumber">12</td>
    <td class="codeline">#include "llvm/ADT/SetVector.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="codeline">#include "llvm/ADT/SmallPtrSet.h"</td>
    <td class="lineNumber">13</td>
    <td class="codeline">#include "llvm/ADT/SmallPtrSet.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="codeline">#include "llvm/ADT/SmallSet.h"</td>
    <td class="lineNumber">14</td>
    <td class="codeline">#include "llvm/ADT/SmallSet.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="codeline">#include "llvm/ADT/SmallVector.h"</td>
    <td class="lineNumber">15</td>
    <td class="codeline">#include "llvm/ADT/SmallVector.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="codeline">#include "llvm/ADT/StringRef.h"</td>
    <td class="lineNumber">16</td>
    <td class="codeline">#include "llvm/ADT/StringRef.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="codeline">#include "llvm/Analysis/AliasAnalysis.h"</td>
    <td class="lineNumber">17</td>
    <td class="codeline">#include "llvm/Analysis/AliasAnalysis.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="codeline">#include "llvm/Analysis/InstructionSimplify.h"</td>
    <td class="lineNumber">18</td>
    <td class="codeline">#include "llvm/Analysis/InstructionSimplify.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="codeline">#include "llvm/Analysis/LoopAnalysisManager.h"</td>
    <td class="lineNumber">19</td>
    <td class="codeline">#include "llvm/Analysis/LoopAnalysisManager.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="codeline">#include "llvm/Analysis/LoopInfo.h"</td>
    <td class="lineNumber">20</td>
    <td class="codeline">#include "llvm/Analysis/LoopInfo.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="codeline">#include "llvm/Analysis/LoopPass.h"</td>
    <td class="lineNumber">21</td>
    <td class="codeline">#include "llvm/Analysis/LoopPass.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="codeline">#include "llvm/Analysis/MemoryLocation.h"</td>
    <td class="lineNumber">22</td>
    <td class="codeline">#include "llvm/Analysis/MemoryLocation.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="codeline">#include "llvm/Analysis/ScalarEvolution.h"</td>
    <td class="lineNumber">23</td>
    <td class="codeline">#include "llvm/Analysis/ScalarEvolution.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="codeline">#include "llvm/Analysis/ScalarEvolutionExpressions.h"</td>
    <td class="lineNumber">24</td>
    <td class="codeline">#include "llvm/Analysis/ScalarEvolutionExpressions.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="codeline">#include "llvm/Analysis/TargetLibraryInfo.h"</td>
    <td class="lineNumber">25</td>
    <td class="codeline">#include "llvm/Analysis/TargetLibraryInfo.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="codeline">#include "llvm/Analysis/ValueTracking.h"</td>
    <td class="lineNumber">26</td>
    <td class="codeline">#include "llvm/Analysis/ValueTracking.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="codeline">#include "llvm/IR/Attributes.h"</td>
    <td class="lineNumber">27</td>
    <td class="codeline">#include "llvm/IR/Attributes.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="codeline">#include "llvm/IR/BasicBlock.h"</td>
    <td class="lineNumber">28</td>
    <td class="codeline">#include "llvm/IR/BasicBlock.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="codeline">#include "llvm/IR/Constant.h"</td>
    <td class="lineNumber">29</td>
    <td class="codeline">#include "llvm/IR/Constant.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="codeline">#include "llvm/IR/Constants.h"</td>
    <td class="lineNumber">30</td>
    <td class="codeline">#include "llvm/IR/Constants.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="codeline">#include "llvm/IR/DataLayout.h"</td>
    <td class="lineNumber">31</td>
    <td class="codeline">#include "llvm/IR/DataLayout.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="codeline">#include "llvm/IR/DebugLoc.h"</td>
    <td class="lineNumber">32</td>
    <td class="codeline">#include "llvm/IR/DebugLoc.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="codeline">#include "llvm/IR/DerivedTypes.h"</td>
    <td class="lineNumber">33</td>
    <td class="codeline">#include "llvm/IR/DerivedTypes.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="codeline">#include "llvm/IR/Dominators.h"</td>
    <td class="lineNumber">34</td>
    <td class="codeline">#include "llvm/IR/Dominators.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="codeline">#include "llvm/IR/Function.h"</td>
    <td class="lineNumber">35</td>
    <td class="codeline">#include "llvm/IR/Function.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="codeline">#include "llvm/IR/IRBuilder.h"</td>
    <td class="lineNumber">36</td>
    <td class="codeline">#include "llvm/IR/IRBuilder.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="codeline">#include "llvm/IR/InstrTypes.h"</td>
    <td class="lineNumber">37</td>
    <td class="codeline">#include "llvm/IR/InstrTypes.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="codeline">#include "llvm/IR/Instruction.h"</td>
    <td class="lineNumber">38</td>
    <td class="codeline">#include "llvm/IR/Instruction.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="codeline">#include "llvm/IR/Instructions.h"</td>
    <td class="lineNumber">39</td>
    <td class="codeline">#include "llvm/IR/Instructions.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="codeline">#include "llvm/IR/IntrinsicInst.h"</td>
    <td class="lineNumber">40</td>
    <td class="codeline">#include "llvm/IR/IntrinsicInst.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="codeline">#include "llvm/IR/Intrinsics.h"</td>
    <td class="lineNumber">41</td>
    <td class="codeline">#include "llvm/IR/Intrinsics.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="codeline">#include "llvm/IR/IntrinsicsHexagon.h"</td>
    <td class="lineNumber">42</td>
    <td class="codeline">#include "llvm/IR/IntrinsicsHexagon.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="codeline">#include "llvm/IR/Module.h"</td>
    <td class="lineNumber">43</td>
    <td class="codeline">#include "llvm/IR/Module.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="codeline">#include "llvm/IR/PassManager.h"</td>
    <td class="lineNumber">44</td>
    <td class="codeline">#include "llvm/IR/PassManager.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="codeline">#include "llvm/IR/PatternMatch.h"</td>
    <td class="lineNumber">45</td>
    <td class="codeline">#include "llvm/IR/PatternMatch.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="codeline">#include "llvm/IR/Type.h"</td>
    <td class="lineNumber">46</td>
    <td class="codeline">#include "llvm/IR/Type.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="codeline">#include "llvm/IR/User.h"</td>
    <td class="lineNumber">47</td>
    <td class="codeline">#include "llvm/IR/User.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="codeline">#include "llvm/IR/Value.h"</td>
    <td class="lineNumber">48</td>
    <td class="codeline">#include "llvm/IR/Value.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="codeline">#include "llvm/InitializePasses.h"</td>
    <td class="lineNumber">49</td>
    <td class="codeline">#include "llvm/InitializePasses.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="codeline">#include "llvm/Pass.h"</td>
    <td class="lineNumber">50</td>
    <td class="codeline">#include "llvm/Pass.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="codeline">#include "llvm/Support/Casting.h"</td>
    <td class="lineNumber">51</td>
    <td class="codeline">#include "llvm/Support/Casting.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="codeline">#include "llvm/Support/CommandLine.h"</td>
    <td class="lineNumber">52</td>
    <td class="codeline">#include "llvm/Support/CommandLine.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="codeline">#include "llvm/Support/Compiler.h"</td>
    <td class="lineNumber">53</td>
    <td class="codeline">#include "llvm/Support/Compiler.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="codeline">#include "llvm/Support/Debug.h"</td>
    <td class="lineNumber">54</td>
    <td class="codeline">#include "llvm/Support/Debug.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="codeline">#include "llvm/Support/ErrorHandling.h"</td>
    <td class="lineNumber">55</td>
    <td class="codeline">#include "llvm/Support/ErrorHandling.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="codeline">#include "llvm/Support/KnownBits.h"</td>
    <td class="lineNumber">56</td>
    <td class="codeline">#include "llvm/Support/KnownBits.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="codeline">#include "llvm/Support/raw_ostream.h"</td>
    <td class="lineNumber">57</td>
    <td class="codeline">#include "llvm/Support/raw_ostream.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="codeline">#include "llvm/TargetParser/Triple.h"</td>
    <td class="lineNumber">58</td>
    <td class="codeline">#include "llvm/TargetParser/Triple.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="codeline">#include "llvm/Transforms/Scalar.h"</td>
    <td class="lineNumber">59</td>
    <td class="codeline">#include "llvm/Transforms/Scalar.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="codeline">#include "llvm/Transforms/Utils.h"</td>
    <td class="lineNumber">60</td>
    <td class="codeline">#include "llvm/Transforms/Utils.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="codeline">#include "llvm/Transforms/Utils/Local.h"</td>
    <td class="lineNumber">61</td>
    <td class="codeline">#include "llvm/Transforms/Utils/Local.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="codeline">#include "llvm/Transforms/Utils/ScalarEvolutionExpander.h"</td>
    <td class="lineNumber">62</td>
    <td class="codeline">#include "llvm/Transforms/Utils/ScalarEvolutionExpander.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="codeline">#include <algorithm></td>
    <td class="lineNumber">63</td>
    <td class="codeline">#include <algorithm></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="codeline">#include <array></td>
    <td class="lineNumber">64</td>
    <td class="codeline">#include <array></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="codeline">#include <cassert></td>
    <td class="lineNumber">65</td>
    <td class="codeline">#include <cassert></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="codeline">#include <cstdint></td>
    <td class="lineNumber">66</td>
    <td class="codeline">#include <cstdint></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="codeline">#include <cstdlib></td>
    <td class="lineNumber">67</td>
    <td class="codeline">#include <cstdlib></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="codeline">#include <deque></td>
    <td class="lineNumber">68</td>
    <td class="codeline">#include <deque></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="codeline">#include <functional></td>
    <td class="lineNumber">69</td>
    <td class="codeline">#include <functional></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="codeline">#include <iterator></td>
    <td class="lineNumber">70</td>
    <td class="codeline">#include <iterator></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="codeline">#include <map></td>
    <td class="lineNumber">71</td>
    <td class="codeline">#include <map></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="codeline">#include <set></td>
    <td class="lineNumber">72</td>
    <td class="codeline">#include <set></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="codeline">#include <utility></td>
    <td class="lineNumber">73</td>
    <td class="codeline">#include <utility></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="codeline">#include <vector></td>
    <td class="lineNumber">74</td>
    <td class="codeline">#include <vector></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="codeline"></td>
    <td class="lineNumber">75</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="codeline">#define DEBUG_TYPE "hexagon-lir"</td>
    <td class="lineNumber">76</td>
    <td class="codeline">#define DEBUG_TYPE "hexagon-lir"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="codeline"></td>
    <td class="lineNumber">77</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="codeline">using namespace llvm;</td>
    <td class="lineNumber">78</td>
    <td class="codeline">using namespace llvm;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="codeline"></td>
    <td class="lineNumber">79</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="codeline">static cl::opt<bool> DisableMemcpyIdiom("disable-memcpy-idiom",</td>
    <td class="lineNumber">80</td>
    <td class="codeline">static cl::opt<bool> DisableMemcpyIdiom("disable-memcpy-idiom",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="codeline">  cl::Hidden, cl::init(false),</td>
    <td class="lineNumber">81</td>
    <td class="codeline">  cl::Hidden, cl::init(false),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="codeline">  cl::desc("Disable generation of memcpy in loop idiom recognition"));</td>
    <td class="lineNumber">82</td>
    <td class="codeline">  cl::desc("Disable generation of memcpy in loop idiom recognition"));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="codeline"></td>
    <td class="lineNumber">83</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="codeline">static cl::opt<bool> DisableMemmoveIdiom("disable-memmove-idiom",</td>
    <td class="lineNumber">84</td>
    <td class="codeline">static cl::opt<bool> DisableMemmoveIdiom("disable-memmove-idiom",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="codeline">  cl::Hidden, cl::init(false),</td>
    <td class="lineNumber">85</td>
    <td class="codeline">  cl::Hidden, cl::init(false),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="codeline">  cl::desc("Disable generation of memmove in loop idiom recognition"));</td>
    <td class="lineNumber">86</td>
    <td class="codeline">  cl::desc("Disable generation of memmove in loop idiom recognition"));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="codeline"></td>
    <td class="lineNumber">87</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="codeline">static cl::opt<unsigned> RuntimeMemSizeThreshold("runtime-mem-idiom-threshold",</td>
    <td class="lineNumber">88</td>
    <td class="codeline">static cl::opt<unsigned> RuntimeMemSizeThreshold("runtime-mem-idiom-threshold",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="codeline">  cl::Hidden, cl::init(0), cl::desc("Threshold (in bytes) for the runtime "</td>
    <td class="lineNumber">89</td>
    <td class="codeline">  cl::Hidden, cl::init(0), cl::desc("Threshold (in bytes) for the runtime "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="codeline">  "check guarding the memmove."));</td>
    <td class="lineNumber">90</td>
    <td class="codeline">  "check guarding the memmove."));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="codeline"></td>
    <td class="lineNumber">91</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="codeline">static cl::opt<unsigned> CompileTimeMemSizeThreshold(</td>
    <td class="lineNumber">92</td>
    <td class="codeline">static cl::opt<unsigned> CompileTimeMemSizeThreshold(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="codeline">  "compile-time-mem-idiom-threshold", cl::Hidden, cl::init(64),</td>
    <td class="lineNumber">93</td>
    <td class="codeline">  "compile-time-mem-idiom-threshold", cl::Hidden, cl::init(64),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="codeline">  cl::desc("Threshold (in bytes) to perform the transformation, if the "</td>
    <td class="lineNumber">94</td>
    <td class="codeline">  cl::desc("Threshold (in bytes) to perform the transformation, if the "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="codeline">    "runtime loop count (mem transfer size) is known at compile-time."));</td>
    <td class="lineNumber">95</td>
    <td class="codeline">    "runtime loop count (mem transfer size) is known at compile-time."));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="codeline"></td>
    <td class="lineNumber">96</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="codeline">static cl::opt<bool> OnlyNonNestedMemmove("only-nonnested-memmove-idiom",</td>
    <td class="lineNumber">97</td>
    <td class="codeline">static cl::opt<bool> OnlyNonNestedMemmove("only-nonnested-memmove-idiom",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="codeline">  cl::Hidden, cl::init(true),</td>
    <td class="lineNumber">98</td>
    <td class="codeline">  cl::Hidden, cl::init(true),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="codeline">  cl::desc("Only enable generating memmove in non-nested loops"));</td>
    <td class="lineNumber">99</td>
    <td class="codeline">  cl::desc("Only enable generating memmove in non-nested loops"));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="codeline"></td>
    <td class="lineNumber">100</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="codeline">static cl::opt<bool> HexagonVolatileMemcpy(</td>
    <td class="lineNumber">101</td>
    <td class="codeline">static cl::opt<bool> HexagonVolatileMemcpy(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="codeline">    "disable-hexagon-volatile-memcpy", cl::Hidden, cl::init(false),</td>
    <td class="lineNumber">102</td>
    <td class="codeline">    "disable-hexagon-volatile-memcpy", cl::Hidden, cl::init(false),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="codeline">    cl::desc("Enable Hexagon-specific memcpy for volatile destination."));</td>
    <td class="lineNumber">103</td>
    <td class="codeline">    cl::desc("Enable Hexagon-specific memcpy for volatile destination."));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="codeline"></td>
    <td class="lineNumber">104</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="codeline">static cl::opt<unsigned> SimplifyLimit("hlir-simplify-limit", cl::init(10000),</td>
    <td class="lineNumber">105</td>
    <td class="codeline">static cl::opt<unsigned> SimplifyLimit("hlir-simplify-limit", cl::init(10000),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="codeline">  cl::Hidden, cl::desc("Maximum number of simplification steps in HLIR"));</td>
    <td class="lineNumber">106</td>
    <td class="codeline">  cl::Hidden, cl::desc("Maximum number of simplification steps in HLIR"));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="codeline"></td>
    <td class="lineNumber">107</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="codeline">static const char *HexagonVolatileMemcpyName</td>
    <td class="lineNumber">108</td>
    <td class="codeline">static const char *HexagonVolatileMemcpyName</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="codeline">  = "hexagon_memcpy_forward_vp4cp4n2";</td>
    <td class="lineNumber">109</td>
    <td class="codeline">  = "hexagon_memcpy_forward_vp4cp4n2";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="codeline"></td>
    <td class="lineNumber">110</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="codeline"></td>
    <td class="lineNumber">111</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="codeline">namespace llvm {</td>
    <td class="lineNumber">112</td>
    <td class="codeline">namespace llvm {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="codeline"></td>
    <td class="lineNumber">113</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="codeline">void initializeHexagonLoopIdiomRecognizeLegacyPassPass(PassRegistry &);</td>
    <td class="lineNumber">114</td>
    <td class="codeline">void initializeHexagonLoopIdiomRecognizeLegacyPassPass(PassRegistry &);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="codeline">Pass *createHexagonLoopIdiomPass();</td>
    <td class="lineNumber">115</td>
    <td class="codeline">Pass *createHexagonLoopIdiomPass();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="codeline"></td>
    <td class="lineNumber">116</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="codeline">} // end namespace llvm</td>
    <td class="lineNumber">117</td>
    <td class="codeline">} // end namespace llvm</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="codeline"></td>
    <td class="lineNumber">118</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="codeline">namespace {</td>
    <td class="lineNumber">119</td>
    <td class="codeline">namespace {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="codeline"></td>
    <td class="lineNumber">120</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="codeline">class HexagonLoopIdiomRecognize {</td>
    <td class="lineNumber">121</td>
    <td class="codeline">class HexagonLoopIdiomRecognize {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">122</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="codeline">  explicit HexagonLoopIdiomRecognize(AliasAnalysis *AA, DominatorTree *DT,</td>
    <td class="lineNumber">123</td>
    <td class="codeline">  explicit HexagonLoopIdiomRecognize(AliasAnalysis *AA, DominatorTree *DT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="codeline">                                     LoopInfo *LF, const TargetLibraryInfo *TLI,</td>
    <td class="lineNumber">124</td>
    <td class="codeline">                                     LoopInfo *LF, const TargetLibraryInfo *TLI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="codeline">                                     ScalarEvolution *SE)</td>
    <td class="lineNumber">125</td>
    <td class="codeline">                                     ScalarEvolution *SE)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="codeline">      : AA(AA), DT(DT), LF(LF), TLI(TLI), SE(SE) {}</td>
    <td class="lineNumber">126</td>
    <td class="codeline">      : AA(AA), DT(DT), LF(LF), TLI(TLI), SE(SE) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="codeline"></td>
    <td class="lineNumber">127</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="codeline">  bool run(Loop *L);</td>
    <td class="lineNumber">128</td>
    <td class="codeline">  bool run(Loop *L);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="codeline"></td>
    <td class="lineNumber">129</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="codeline">private:</td>
    <td class="lineNumber">130</td>
    <td class="codeline">private:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="codeline">  int getSCEVStride(const SCEVAddRecExpr *StoreEv);</td>
    <td class="lineNumber">131</td>
    <td class="codeline">  int getSCEVStride(const SCEVAddRecExpr *StoreEv);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="codeline">  bool isLegalStore(Loop *CurLoop, StoreInst *SI);</td>
    <td class="lineNumber">132</td>
    <td class="codeline">  bool isLegalStore(Loop *CurLoop, StoreInst *SI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="codeline">  void collectStores(Loop *CurLoop, BasicBlock *BB,</td>
    <td class="lineNumber">133</td>
    <td class="codeline">  void collectStores(Loop *CurLoop, BasicBlock *BB,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="codeline">                     SmallVectorImpl<StoreInst *> &Stores);</td>
    <td class="lineNumber">134</td>
    <td class="codeline">                     SmallVectorImpl<StoreInst *> &Stores);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="codeline">  bool processCopyingStore(Loop *CurLoop, StoreInst *SI, const SCEV *BECount);</td>
    <td class="lineNumber">135</td>
    <td class="codeline">  bool processCopyingStore(Loop *CurLoop, StoreInst *SI, const SCEV *BECount);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="codeline">  bool coverLoop(Loop *L, SmallVectorImpl<Instruction *> &Insts) const;</td>
    <td class="lineNumber">136</td>
    <td class="codeline">  bool coverLoop(Loop *L, SmallVectorImpl<Instruction *> &Insts) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="codeline">  bool runOnLoopBlock(Loop *CurLoop, BasicBlock *BB, const SCEV *BECount,</td>
    <td class="lineNumber">137</td>
    <td class="codeline">  bool runOnLoopBlock(Loop *CurLoop, BasicBlock *BB, const SCEV *BECount,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="codeline">                      SmallVectorImpl<BasicBlock *> &ExitBlocks);</td>
    <td class="lineNumber">138</td>
    <td class="codeline">                      SmallVectorImpl<BasicBlock *> &ExitBlocks);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="codeline">  bool runOnCountableLoop(Loop *L);</td>
    <td class="lineNumber">139</td>
    <td class="codeline">  bool runOnCountableLoop(Loop *L);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="codeline"></td>
    <td class="lineNumber">140</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="codeline">  AliasAnalysis *AA;</td>
    <td class="lineNumber">141</td>
    <td class="codeline">  AliasAnalysis *AA;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="codeline">  const DataLayout *DL;</td>
    <td class="lineNumber">142</td>
    <td class="codeline">  const DataLayout *DL;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="codeline">  DominatorTree *DT;</td>
    <td class="lineNumber">143</td>
    <td class="codeline">  DominatorTree *DT;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="codeline">  LoopInfo *LF;</td>
    <td class="lineNumber">144</td>
    <td class="codeline">  LoopInfo *LF;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="codeline">  const TargetLibraryInfo *TLI;</td>
    <td class="lineNumber">145</td>
    <td class="codeline">  const TargetLibraryInfo *TLI;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="codeline">  ScalarEvolution *SE;</td>
    <td class="lineNumber">146</td>
    <td class="codeline">  ScalarEvolution *SE;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="codeline">  bool HasMemcpy, HasMemmove;</td>
    <td class="lineNumber">147</td>
    <td class="codeline">  bool HasMemcpy, HasMemmove;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="codeline">};</td>
    <td class="lineNumber">148</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="codeline"></td>
    <td class="lineNumber">149</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="codeline">class HexagonLoopIdiomRecognizeLegacyPass : public LoopPass {</td>
    <td class="lineNumber">150</td>
    <td class="codeline">class HexagonLoopIdiomRecognizeLegacyPass : public LoopPass {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">151</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="codeline">  static char ID;</td>
    <td class="lineNumber">152</td>
    <td class="codeline">  static char ID;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="codeline"></td>
    <td class="lineNumber">153</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="codeline">  explicit HexagonLoopIdiomRecognizeLegacyPass() : LoopPass(ID) {</td>
    <td class="lineNumber">154</td>
    <td class="codeline">  explicit HexagonLoopIdiomRecognizeLegacyPass() : LoopPass(ID) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="codeline">    initializeHexagonLoopIdiomRecognizeLegacyPassPass(</td>
    <td class="lineNumber">155</td>
    <td class="codeline">    initializeHexagonLoopIdiomRecognizeLegacyPassPass(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="codeline">        *PassRegistry::getPassRegistry());</td>
    <td class="lineNumber">156</td>
    <td class="codeline">        *PassRegistry::getPassRegistry());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">157</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="codeline"></td>
    <td class="lineNumber">158</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="codeline">  StringRef getPassName() const override {</td>
    <td class="lineNumber">159</td>
    <td class="codeline">  StringRef getPassName() const override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="codeline">    return "Recognize Hexagon-specific loop idioms";</td>
    <td class="lineNumber">160</td>
    <td class="codeline">    return "Recognize Hexagon-specific loop idioms";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">161</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="codeline"></td>
    <td class="lineNumber">162</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="codeline">  void getAnalysisUsage(AnalysisUsage &AU) const override {</td>
    <td class="lineNumber">163</td>
    <td class="codeline">  void getAnalysisUsage(AnalysisUsage &AU) const override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="codeline">    AU.addRequired<LoopInfoWrapperPass>();</td>
    <td class="lineNumber">164</td>
    <td class="codeline">    AU.addRequired<LoopInfoWrapperPass>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="codeline">    AU.addRequiredID(LoopSimplifyID);</td>
    <td class="lineNumber">165</td>
    <td class="codeline">    AU.addRequiredID(LoopSimplifyID);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="codeline">    AU.addRequiredID(LCSSAID);</td>
    <td class="lineNumber">166</td>
    <td class="codeline">    AU.addRequiredID(LCSSAID);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="codeline">    AU.addRequired<AAResultsWrapperPass>();</td>
    <td class="lineNumber">167</td>
    <td class="codeline">    AU.addRequired<AAResultsWrapperPass>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="codeline">    AU.addRequired<ScalarEvolutionWrapperPass>();</td>
    <td class="lineNumber">168</td>
    <td class="codeline">    AU.addRequired<ScalarEvolutionWrapperPass>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="codeline">    AU.addRequired<DominatorTreeWrapperPass>();</td>
    <td class="lineNumber">169</td>
    <td class="codeline">    AU.addRequired<DominatorTreeWrapperPass>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="codeline">    AU.addRequired<TargetLibraryInfoWrapperPass>();</td>
    <td class="lineNumber">170</td>
    <td class="codeline">    AU.addRequired<TargetLibraryInfoWrapperPass>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="codeline">    AU.addPreserved<TargetLibraryInfoWrapperPass>();</td>
    <td class="lineNumber">171</td>
    <td class="codeline">    AU.addPreserved<TargetLibraryInfoWrapperPass>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">172</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="codeline"></td>
    <td class="lineNumber">173</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="codeline">  bool runOnLoop(Loop *L, LPPassManager &LPM) override;</td>
    <td class="lineNumber">174</td>
    <td class="codeline">  bool runOnLoop(Loop *L, LPPassManager &LPM) override;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="codeline">};</td>
    <td class="lineNumber">175</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="codeline"></td>
    <td class="lineNumber">176</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="codeline">struct Simplifier {</td>
    <td class="lineNumber">177</td>
    <td class="codeline">struct Simplifier {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="codeline">  struct Rule {</td>
    <td class="lineNumber">178</td>
    <td class="codeline">  struct Rule {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="codeline">    using FuncType = std::function<Value *(Instruction *, LLVMContext &)>;</td>
    <td class="lineNumber">179</td>
    <td class="codeline">    using FuncType = std::function<Value *(Instruction *, LLVMContext &)>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="codeline">    Rule(StringRef N, FuncType F) : Name(N), Fn(F) {}</td>
    <td class="lineNumber">180</td>
    <td class="codeline">    Rule(StringRef N, FuncType F) : Name(N), Fn(F) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="codeline">    StringRef Name; // For debugging.</td>
    <td class="lineNumber">181</td>
    <td class="codeline">    StringRef Name; // For debugging.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="codeline">    FuncType Fn;</td>
    <td class="lineNumber">182</td>
    <td class="codeline">    FuncType Fn;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">183</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="codeline"></td>
    <td class="lineNumber">184</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="codeline">  void addRule(StringRef N, const Rule::FuncType &F) {</td>
    <td class="lineNumber">185</td>
    <td class="codeline">  void addRule(StringRef N, const Rule::FuncType &F) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="codeline">    Rules.push_back(Rule(N, F));</td>
    <td class="lineNumber">186</td>
    <td class="codeline">    Rules.push_back(Rule(N, F));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">187</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="codeline"></td>
    <td class="lineNumber">188</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="codeline">private:</td>
    <td class="lineNumber">189</td>
    <td class="codeline">private:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="codeline">  struct WorkListType {</td>
    <td class="lineNumber">190</td>
    <td class="codeline">  struct WorkListType {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="codeline">    WorkListType() = default;</td>
    <td class="lineNumber">191</td>
    <td class="codeline">    WorkListType() = default;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="codeline"></td>
    <td class="lineNumber">192</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="codeline">    void push_back(Value *V) {</td>
    <td class="lineNumber">193</td>
    <td class="codeline">    void push_back(Value *V) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="codeline">      // Do not push back duplicates.</td>
    <td class="lineNumber">194</td>
    <td class="codeline">      // Do not push back duplicates.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="codeline">      if (S.insert(V).second)</td>
    <td class="lineNumber">195</td>
    <td class="codeline">      if (S.insert(V).second)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="codeline">        Q.push_back(V);</td>
    <td class="lineNumber">196</td>
    <td class="codeline">        Q.push_back(V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">197</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="codeline"></td>
    <td class="lineNumber">198</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="codeline">    Value *pop_front_val() {</td>
    <td class="lineNumber">199</td>
    <td class="codeline">    Value *pop_front_val() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="codeline">      Value *V = Q.front();</td>
    <td class="lineNumber">200</td>
    <td class="codeline">      Value *V = Q.front();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="codeline">      Q.pop_front();</td>
    <td class="lineNumber">201</td>
    <td class="codeline">      Q.pop_front();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="codeline">      S.erase(V);</td>
    <td class="lineNumber">202</td>
    <td class="codeline">      S.erase(V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="codeline">      return V;</td>
    <td class="lineNumber">203</td>
    <td class="codeline">      return V;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">204</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="codeline"></td>
    <td class="lineNumber">205</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="codeline">    bool empty() const { return Q.empty(); }</td>
    <td class="lineNumber">206</td>
    <td class="codeline">    bool empty() const { return Q.empty(); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="codeline"></td>
    <td class="lineNumber">207</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="codeline">  private:</td>
    <td class="lineNumber">208</td>
    <td class="codeline">  private:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="codeline">    std::deque<Value *> Q;</td>
    <td class="lineNumber">209</td>
    <td class="codeline">    std::deque<Value *> Q;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="codeline">    std::set<Value *> S;</td>
    <td class="lineNumber">210</td>
    <td class="codeline">    std::set<Value *> S;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">211</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="codeline"></td>
    <td class="lineNumber">212</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="codeline">  using ValueSetType = std::set<Value *>;</td>
    <td class="lineNumber">213</td>
    <td class="codeline">  using ValueSetType = std::set<Value *>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="codeline"></td>
    <td class="lineNumber">214</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="codeline">  std::vector<Rule> Rules;</td>
    <td class="lineNumber">215</td>
    <td class="codeline">  std::vector<Rule> Rules;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="codeline"></td>
    <td class="lineNumber">216</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">217</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="codeline">  struct Context {</td>
    <td class="lineNumber">218</td>
    <td class="codeline">  struct Context {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="codeline">    using ValueMapType = DenseMap<Value *, Value *>;</td>
    <td class="lineNumber">219</td>
    <td class="codeline">    using ValueMapType = DenseMap<Value *, Value *>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="codeline"></td>
    <td class="lineNumber">220</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="codeline">    Value *Root;</td>
    <td class="lineNumber">221</td>
    <td class="codeline">    Value *Root;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="codeline">    ValueSetType Used;   // The set of all cloned values used by Root.</td>
    <td class="lineNumber">222</td>
    <td class="codeline">    ValueSetType Used;   // The set of all cloned values used by Root.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="codeline">    ValueSetType Clones; // The set of all cloned values.</td>
    <td class="lineNumber">223</td>
    <td class="codeline">    ValueSetType Clones; // The set of all cloned values.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="codeline">    LLVMContext &Ctx;</td>
    <td class="lineNumber">224</td>
    <td class="codeline">    LLVMContext &Ctx;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="codeline"></td>
    <td class="lineNumber">225</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="codeline">    Context(Instruction *Exp)</td>
    <td class="lineNumber">226</td>
    <td class="codeline">    Context(Instruction *Exp)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="codeline">        : Ctx(Exp->getParent()->getParent()->getContext()) {</td>
    <td class="lineNumber">227</td>
    <td class="codeline">        : Ctx(Exp->getParent()->getParent()->getContext()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="codeline">      initialize(Exp);</td>
    <td class="lineNumber">228</td>
    <td class="codeline">      initialize(Exp);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">229</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="codeline"></td>
    <td class="lineNumber">230</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="codeline">    ~Context() { cleanup(); }</td>
    <td class="lineNumber">231</td>
    <td class="codeline">    ~Context() { cleanup(); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="codeline"></td>
    <td class="lineNumber">232</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="codeline">    void print(raw_ostream &OS, const Value *V) const;</td>
    <td class="lineNumber">233</td>
    <td class="codeline">    void print(raw_ostream &OS, const Value *V) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="codeline">    Value *materialize(BasicBlock *B, BasicBlock::iterator At);</td>
    <td class="lineNumber">234</td>
    <td class="codeline">    Value *materialize(BasicBlock *B, BasicBlock::iterator At);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="codeline"></td>
    <td class="lineNumber">235</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="codeline">  private:</td>
    <td class="lineNumber">236</td>
    <td class="codeline">  private:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="codeline">    friend struct Simplifier;</td>
    <td class="lineNumber">237</td>
    <td class="codeline">    friend struct Simplifier;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="codeline"></td>
    <td class="lineNumber">238</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="codeline">    void initialize(Instruction *Exp);</td>
    <td class="lineNumber">239</td>
    <td class="codeline">    void initialize(Instruction *Exp);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="codeline">    void cleanup();</td>
    <td class="lineNumber">240</td>
    <td class="codeline">    void cleanup();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="codeline"></td>
    <td class="lineNumber">241</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="codeline">    template <typename FuncT> void traverse(Value *V, FuncT F);</td>
    <td class="lineNumber">242</td>
    <td class="codeline">    template <typename FuncT> void traverse(Value *V, FuncT F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="codeline">    void record(Value *V);</td>
    <td class="lineNumber">243</td>
    <td class="codeline">    void record(Value *V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="codeline">    void use(Value *V);</td>
    <td class="lineNumber">244</td>
    <td class="codeline">    void use(Value *V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="codeline">    void unuse(Value *V);</td>
    <td class="lineNumber">245</td>
    <td class="codeline">    void unuse(Value *V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="codeline"></td>
    <td class="lineNumber">246</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="codeline">    bool equal(const Instruction *I, const Instruction *J) const;</td>
    <td class="lineNumber">247</td>
    <td class="codeline">    bool equal(const Instruction *I, const Instruction *J) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="codeline">    Value *find(Value *Tree, Value *Sub) const;</td>
    <td class="lineNumber">248</td>
    <td class="codeline">    Value *find(Value *Tree, Value *Sub) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="codeline">    Value *subst(Value *Tree, Value *OldV, Value *NewV);</td>
    <td class="lineNumber">249</td>
    <td class="codeline">    Value *subst(Value *Tree, Value *OldV, Value *NewV);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="codeline">    void replace(Value *OldV, Value *NewV);</td>
    <td class="lineNumber">250</td>
    <td class="codeline">    void replace(Value *OldV, Value *NewV);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="codeline">    void link(Instruction *I, BasicBlock *B, BasicBlock::iterator At);</td>
    <td class="lineNumber">251</td>
    <td class="codeline">    void link(Instruction *I, BasicBlock *B, BasicBlock::iterator At);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">252</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="codeline"></td>
    <td class="lineNumber">253</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="codeline">  Value *simplify(Context &C);</td>
    <td class="lineNumber">254</td>
    <td class="codeline">  Value *simplify(Context &C);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="codeline">};</td>
    <td class="lineNumber">255</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="codeline"></td>
    <td class="lineNumber">256</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="codeline">  struct PE {</td>
    <td class="lineNumber">257</td>
    <td class="codeline">  struct PE {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="codeline">    PE(const Simplifier::Context &c, Value *v = nullptr) : C(c), V(v) {}</td>
    <td class="lineNumber">258</td>
    <td class="codeline">    PE(const Simplifier::Context &c, Value *v = nullptr) : C(c), V(v) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="codeline"></td>
    <td class="lineNumber">259</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="codeline">    const Simplifier::Context &C;</td>
    <td class="lineNumber">260</td>
    <td class="codeline">    const Simplifier::Context &C;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="codeline">    const Value *V;</td>
    <td class="lineNumber">261</td>
    <td class="codeline">    const Value *V;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">262</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="codeline"></td>
    <td class="lineNumber">263</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="codeline">  LLVM_ATTRIBUTE_USED</td>
    <td class="lineNumber">264</td>
    <td class="codeline">  LLVM_ATTRIBUTE_USED</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="codeline">  raw_ostream &operator<<(raw_ostream &OS, const PE &P) {</td>
    <td class="lineNumber">265</td>
    <td class="codeline">  raw_ostream &operator<<(raw_ostream &OS, const PE &P) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="codeline">    P.C.print(OS, P.V ? P.V : P.C.Root);</td>
    <td class="lineNumber">266</td>
    <td class="codeline">    P.C.print(OS, P.V ? P.V : P.C.Root);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="codeline">    return OS;</td>
    <td class="lineNumber">267</td>
    <td class="codeline">    return OS;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">268</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="codeline"></td>
    <td class="lineNumber">269</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="codeline">} // end anonymous namespace</td>
    <td class="lineNumber">270</td>
    <td class="codeline">} // end anonymous namespace</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="codeline"></td>
    <td class="lineNumber">271</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="codeline">char HexagonLoopIdiomRecognizeLegacyPass::ID = 0;</td>
    <td class="lineNumber">272</td>
    <td class="codeline">char HexagonLoopIdiomRecognizeLegacyPass::ID = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="codeline"></td>
    <td class="lineNumber">273</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="codeline">INITIALIZE_PASS_BEGIN(HexagonLoopIdiomRecognizeLegacyPass, "hexagon-loop-idiom",</td>
    <td class="lineNumber">274</td>
    <td class="codeline">INITIALIZE_PASS_BEGIN(HexagonLoopIdiomRecognizeLegacyPass, "hexagon-loop-idiom",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="codeline">                      "Recognize Hexagon-specific loop idioms", false, false)</td>
    <td class="lineNumber">275</td>
    <td class="codeline">                      "Recognize Hexagon-specific loop idioms", false, false)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(LoopInfoWrapperPass)</td>
    <td class="lineNumber">276</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(LoopInfoWrapperPass)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(LoopSimplify)</td>
    <td class="lineNumber">277</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(LoopSimplify)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(LCSSAWrapperPass)</td>
    <td class="lineNumber">278</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(LCSSAWrapperPass)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(ScalarEvolutionWrapperPass)</td>
    <td class="lineNumber">279</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(ScalarEvolutionWrapperPass)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(DominatorTreeWrapperPass)</td>
    <td class="lineNumber">280</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(DominatorTreeWrapperPass)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(TargetLibraryInfoWrapperPass)</td>
    <td class="lineNumber">281</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(TargetLibraryInfoWrapperPass)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(AAResultsWrapperPass)</td>
    <td class="lineNumber">282</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(AAResultsWrapperPass)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="codeline">INITIALIZE_PASS_END(HexagonLoopIdiomRecognizeLegacyPass, "hexagon-loop-idiom",</td>
    <td class="lineNumber">283</td>
    <td class="codeline">INITIALIZE_PASS_END(HexagonLoopIdiomRecognizeLegacyPass, "hexagon-loop-idiom",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="codeline">                    "Recognize Hexagon-specific loop idioms", false, false)</td>
    <td class="lineNumber">284</td>
    <td class="codeline">                    "Recognize Hexagon-specific loop idioms", false, false)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="codeline"></td>
    <td class="lineNumber">285</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="codeline">template <typename FuncT></td>
    <td class="lineNumber">286</td>
    <td class="codeline">template <typename FuncT></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="codeline">void Simplifier::Context::traverse(Value *V, FuncT F) {</td>
    <td class="lineNumber">287</td>
    <td class="codeline">void Simplifier::Context::traverse(Value *V, FuncT F) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="codeline">  WorkListType Q;</td>
    <td class="lineNumber">288</td>
    <td class="codeline">  WorkListType Q;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="codeline">  Q.push_back(V);</td>
    <td class="lineNumber">289</td>
    <td class="codeline">  Q.push_back(V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="codeline"></td>
    <td class="lineNumber">290</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="codeline">  while (!Q.empty()) {</td>
    <td class="lineNumber">291</td>
    <td class="codeline">  while (!Q.empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="codeline">    Instruction *U = dyn_cast<Instruction>(Q.pop_front_val());</td>
    <td class="lineNumber">292</td>
    <td class="codeline">    Instruction *U = dyn_cast<Instruction>(Q.pop_front_val());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="codeline">    if (!U || U->getParent())</td>
    <td class="lineNumber">293</td>
    <td class="codeline">    if (!U || U->getParent())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">294</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="codeline">    if (!F(U))</td>
    <td class="lineNumber">295</td>
    <td class="codeline">    if (!F(U))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">296</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="codeline">    for (Value *Op : U->operands())</td>
    <td class="lineNumber">297</td>
    <td class="codeline">    for (Value *Op : U->operands())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="codeline">      Q.push_back(Op);</td>
    <td class="lineNumber">298</td>
    <td class="codeline">      Q.push_back(Op);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">299</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="codeline">}</td>
    <td class="lineNumber">300</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="codeline"></td>
    <td class="lineNumber">301</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="codeline">void Simplifier::Context::print(raw_ostream &OS, const Value *V) const {</td>
    <td class="lineNumber">302</td>
    <td class="codeline">void Simplifier::Context::print(raw_ostream &OS, const Value *V) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="codeline">  const auto *U = dyn_cast<const Instruction>(V);</td>
    <td class="lineNumber">303</td>
    <td class="codeline">  const auto *U = dyn_cast<const Instruction>(V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="codeline">  if (!U) {</td>
    <td class="lineNumber">304</td>
    <td class="codeline">  if (!U) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="codeline">    OS << V << '(' << *V << ')';</td>
    <td class="lineNumber">305</td>
    <td class="codeline">    OS << V << '(' << *V << ')';</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">306</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">307</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="codeline"></td>
    <td class="lineNumber">308</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="codeline">  if (U->getParent()) {</td>
    <td class="lineNumber">309</td>
    <td class="codeline">  if (U->getParent()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="codeline">    OS << U << '(';</td>
    <td class="lineNumber">310</td>
    <td class="codeline">    OS << U << '(';</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="codeline">    U->printAsOperand(OS, true);</td>
    <td class="lineNumber">311</td>
    <td class="codeline">    U->printAsOperand(OS, true);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="codeline">    OS << ')';</td>
    <td class="lineNumber">312</td>
    <td class="codeline">    OS << ')';</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">313</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">314</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="codeline"></td>
    <td class="lineNumber">315</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="codeline">  unsigned N = U->getNumOperands();</td>
    <td class="lineNumber">316</td>
    <td class="codeline">  unsigned N = U->getNumOperands();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="codeline">  if (N != 0)</td>
    <td class="lineNumber">317</td>
    <td class="codeline">  if (N != 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="codeline">    OS << U << '(';</td>
    <td class="lineNumber">318</td>
    <td class="codeline">    OS << U << '(';</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="codeline">  OS << U->getOpcodeName();</td>
    <td class="lineNumber">319</td>
    <td class="codeline">  OS << U->getOpcodeName();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="codeline">  for (const Value *Op : U->operands()) {</td>
    <td class="lineNumber">320</td>
    <td class="codeline">  for (const Value *Op : U->operands()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="codeline">    OS << ' ';</td>
    <td class="lineNumber">321</td>
    <td class="codeline">    OS << ' ';</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="codeline">    print(OS, Op);</td>
    <td class="lineNumber">322</td>
    <td class="codeline">    print(OS, Op);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">323</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="codeline">  if (N != 0)</td>
    <td class="lineNumber">324</td>
    <td class="codeline">  if (N != 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="codeline">    OS << ')';</td>
    <td class="lineNumber">325</td>
    <td class="codeline">    OS << ')';</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="codeline">}</td>
    <td class="lineNumber">326</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="codeline"></td>
    <td class="lineNumber">327</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="codeline">void Simplifier::Context::initialize(Instruction *Exp) {</td>
    <td class="lineNumber">328</td>
    <td class="codeline">void Simplifier::Context::initialize(Instruction *Exp) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="codeline">  // Perform a deep clone of the expression, set Root to the root</td>
    <td class="lineNumber">329</td>
    <td class="codeline">  // Perform a deep clone of the expression, set Root to the root</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="codeline">  // of the clone, and build a map from the cloned values to the</td>
    <td class="lineNumber">330</td>
    <td class="codeline">  // of the clone, and build a map from the cloned values to the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="codeline">  // original ones.</td>
    <td class="lineNumber">331</td>
    <td class="codeline">  // original ones.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="codeline">  ValueMapType M;</td>
    <td class="lineNumber">332</td>
    <td class="codeline">  ValueMapType M;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="codeline">  BasicBlock *Block = Exp->getParent();</td>
    <td class="lineNumber">333</td>
    <td class="codeline">  BasicBlock *Block = Exp->getParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="codeline">  WorkListType Q;</td>
    <td class="lineNumber">334</td>
    <td class="codeline">  WorkListType Q;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="codeline">  Q.push_back(Exp);</td>
    <td class="lineNumber">335</td>
    <td class="codeline">  Q.push_back(Exp);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="codeline"></td>
    <td class="lineNumber">336</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="codeline">  while (!Q.empty()) {</td>
    <td class="lineNumber">337</td>
    <td class="codeline">  while (!Q.empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="codeline">    Value *V = Q.pop_front_val();</td>
    <td class="lineNumber">338</td>
    <td class="codeline">    Value *V = Q.pop_front_val();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="codeline">    if (M.contains(V))</td>
    <td class="lineNumber">339</td>
    <td class="codeline">    if (M.contains(V))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">340</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="codeline">    if (Instruction *U = dyn_cast<Instruction>(V)) {</td>
    <td class="lineNumber">341</td>
    <td class="codeline">    if (Instruction *U = dyn_cast<Instruction>(V)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="codeline">      if (isa<PHINode>(U) || U->getParent() != Block)</td>
    <td class="lineNumber">342</td>
    <td class="codeline">      if (isa<PHINode>(U) || U->getParent() != Block)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">343</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="codeline">      for (Value *Op : U->operands())</td>
    <td class="lineNumber">344</td>
    <td class="codeline">      for (Value *Op : U->operands())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="codeline">        Q.push_back(Op);</td>
    <td class="lineNumber">345</td>
    <td class="codeline">        Q.push_back(Op);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="codeline">      M.insert({U, U->clone()});</td>
    <td class="lineNumber">346</td>
    <td class="codeline">      M.insert({U, U->clone()});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">347</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">348</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="codeline"></td>
    <td class="lineNumber">349</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="codeline">  for (std::pair<Value*,Value*> P : M) {</td>
    <td class="lineNumber">350</td>
    <td class="codeline">  for (std::pair<Value*,Value*> P : M) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="codeline">    Instruction *U = cast<Instruction>(P.second);</td>
    <td class="lineNumber">351</td>
    <td class="codeline">    Instruction *U = cast<Instruction>(P.second);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="codeline">    for (unsigned i = 0, n = U->getNumOperands(); i != n; ++i) {</td>
    <td class="lineNumber">352</td>
    <td class="codeline">    for (unsigned i = 0, n = U->getNumOperands(); i != n; ++i) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="codeline">      auto F = M.find(U->getOperand(i));</td>
    <td class="lineNumber">353</td>
    <td class="codeline">      auto F = M.find(U->getOperand(i));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="codeline">      if (F != M.end())</td>
    <td class="lineNumber">354</td>
    <td class="codeline">      if (F != M.end())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="codeline">        U->setOperand(i, F->second);</td>
    <td class="lineNumber">355</td>
    <td class="codeline">        U->setOperand(i, F->second);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">356</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">357</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="codeline"></td>
    <td class="lineNumber">358</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="codeline">  auto R = M.find(Exp);</td>
    <td class="lineNumber">359</td>
    <td class="codeline">  auto R = M.find(Exp);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="codeline">  assert(R != M.end());</td>
    <td class="lineNumber">360</td>
    <td class="codeline">  assert(R != M.end());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="codeline">  Root = R->second;</td>
    <td class="lineNumber">361</td>
    <td class="codeline">  Root = R->second;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="codeline"></td>
    <td class="lineNumber">362</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="codeline">  record(Root);</td>
    <td class="lineNumber">363</td>
    <td class="codeline">  record(Root);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="codeline">  use(Root);</td>
    <td class="lineNumber">364</td>
    <td class="codeline">  use(Root);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="codeline">}</td>
    <td class="lineNumber">365</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="codeline"></td>
    <td class="lineNumber">366</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="codeline">void Simplifier::Context::record(Value *V) {</td>
    <td class="lineNumber">367</td>
    <td class="codeline">void Simplifier::Context::record(Value *V) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="codeline">  auto Record = [this](Instruction *U) -> bool {</td>
    <td class="lineNumber">368</td>
    <td class="codeline">  auto Record = [this](Instruction *U) -> bool {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="codeline">    Clones.insert(U);</td>
    <td class="lineNumber">369</td>
    <td class="codeline">    Clones.insert(U);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">370</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">371</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="codeline">  traverse(V, Record);</td>
    <td class="lineNumber">372</td>
    <td class="codeline">  traverse(V, Record);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="codeline">}</td>
    <td class="lineNumber">373</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="codeline"></td>
    <td class="lineNumber">374</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="codeline">void Simplifier::Context::use(Value *V) {</td>
    <td class="lineNumber">375</td>
    <td class="codeline">void Simplifier::Context::use(Value *V) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="codeline">  auto Use = [this](Instruction *U) -> bool {</td>
    <td class="lineNumber">376</td>
    <td class="codeline">  auto Use = [this](Instruction *U) -> bool {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="codeline">    Used.insert(U);</td>
    <td class="lineNumber">377</td>
    <td class="codeline">    Used.insert(U);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">378</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">379</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="codeline">  traverse(V, Use);</td>
    <td class="lineNumber">380</td>
    <td class="codeline">  traverse(V, Use);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="codeline">}</td>
    <td class="lineNumber">381</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="codeline"></td>
    <td class="lineNumber">382</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="codeline">void Simplifier::Context::unuse(Value *V) {</td>
    <td class="lineNumber">383</td>
    <td class="codeline">void Simplifier::Context::unuse(Value *V) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="codeline">  if (!isa<Instruction>(V) || cast<Instruction>(V)->getParent() != nullptr)</td>
    <td class="lineNumber">384</td>
    <td class="codeline">  if (!isa<Instruction>(V) || cast<Instruction>(V)->getParent() != nullptr)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">385</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="codeline"></td>
    <td class="lineNumber">386</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="codeline">  auto Unuse = [this](Instruction *U) -> bool {</td>
    <td class="lineNumber">387</td>
    <td class="codeline">  auto Unuse = [this](Instruction *U) -> bool {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="codeline">    if (!U->use_empty())</td>
    <td class="lineNumber">388</td>
    <td class="codeline">    if (!U->use_empty())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">389</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="codeline">    Used.erase(U);</td>
    <td class="lineNumber">390</td>
    <td class="codeline">    Used.erase(U);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">391</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">392</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="codeline">  traverse(V, Unuse);</td>
    <td class="lineNumber">393</td>
    <td class="codeline">  traverse(V, Unuse);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="codeline">}</td>
    <td class="lineNumber">394</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="codeline"></td>
    <td class="lineNumber">395</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="codeline">Value *Simplifier::Context::subst(Value *Tree, Value *OldV, Value *NewV) {</td>
    <td class="lineNumber">396</td>
    <td class="codeline">Value *Simplifier::Context::subst(Value *Tree, Value *OldV, Value *NewV) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="codeline">  if (Tree == OldV)</td>
    <td class="lineNumber">397</td>
    <td class="codeline">  if (Tree == OldV)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="codeline">    return NewV;</td>
    <td class="lineNumber">398</td>
    <td class="codeline">    return NewV;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="codeline">  if (OldV == NewV)</td>
    <td class="lineNumber">399</td>
    <td class="codeline">  if (OldV == NewV)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="codeline">    return Tree;</td>
    <td class="lineNumber">400</td>
    <td class="codeline">    return Tree;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="codeline"></td>
    <td class="lineNumber">401</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="codeline">  WorkListType Q;</td>
    <td class="lineNumber">402</td>
    <td class="codeline">  WorkListType Q;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="codeline">  Q.push_back(Tree);</td>
    <td class="lineNumber">403</td>
    <td class="codeline">  Q.push_back(Tree);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="codeline">  while (!Q.empty()) {</td>
    <td class="lineNumber">404</td>
    <td class="codeline">  while (!Q.empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="codeline">    Instruction *U = dyn_cast<Instruction>(Q.pop_front_val());</td>
    <td class="lineNumber">405</td>
    <td class="codeline">    Instruction *U = dyn_cast<Instruction>(Q.pop_front_val());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="codeline">    // If U is not an instruction, or it's not a clone, skip it.</td>
    <td class="lineNumber">406</td>
    <td class="codeline">    // If U is not an instruction, or it's not a clone, skip it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="codeline">    if (!U || U->getParent())</td>
    <td class="lineNumber">407</td>
    <td class="codeline">    if (!U || U->getParent())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">408</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="codeline">    for (unsigned i = 0, n = U->getNumOperands(); i != n; ++i) {</td>
    <td class="lineNumber">409</td>
    <td class="codeline">    for (unsigned i = 0, n = U->getNumOperands(); i != n; ++i) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="codeline">      Value *Op = U->getOperand(i);</td>
    <td class="lineNumber">410</td>
    <td class="codeline">      Value *Op = U->getOperand(i);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="codeline">      if (Op == OldV) {</td>
    <td class="lineNumber">411</td>
    <td class="codeline">      if (Op == OldV) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="codeline">        U->setOperand(i, NewV);</td>
    <td class="lineNumber">412</td>
    <td class="codeline">        U->setOperand(i, NewV);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="codeline">        unuse(OldV);</td>
    <td class="lineNumber">413</td>
    <td class="codeline">        unuse(OldV);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="codeline">      } else {</td>
    <td class="lineNumber">414</td>
    <td class="codeline">      } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="codeline">        Q.push_back(Op);</td>
    <td class="lineNumber">415</td>
    <td class="codeline">        Q.push_back(Op);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">416</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">417</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">418</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="codeline">  return Tree;</td>
    <td class="lineNumber">419</td>
    <td class="codeline">  return Tree;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="codeline">}</td>
    <td class="lineNumber">420</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="codeline"></td>
    <td class="lineNumber">421</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="codeline">void Simplifier::Context::replace(Value *OldV, Value *NewV) {</td>
    <td class="lineNumber">422</td>
    <td class="codeline">void Simplifier::Context::replace(Value *OldV, Value *NewV) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="codeline">  if (Root == OldV) {</td>
    <td class="lineNumber">423</td>
    <td class="codeline">  if (Root == OldV) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="codeline">    Root = NewV;</td>
    <td class="lineNumber">424</td>
    <td class="codeline">    Root = NewV;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="codeline">    use(Root);</td>
    <td class="lineNumber">425</td>
    <td class="codeline">    use(Root);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">426</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">427</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="codeline"></td>
    <td class="lineNumber">428</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="codeline">  // NewV may be a complex tree that has just been created by one of the</td>
    <td class="lineNumber">429</td>
    <td class="codeline">  // NewV may be a complex tree that has just been created by one of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="codeline">  // transformation rules. We need to make sure that it is commoned with</td>
    <td class="lineNumber">430</td>
    <td class="codeline">  // transformation rules. We need to make sure that it is commoned with</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="codeline">  // the existing Root to the maximum extent possible.</td>
    <td class="lineNumber">431</td>
    <td class="codeline">  // the existing Root to the maximum extent possible.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="codeline">  // Identify all subtrees of NewV (including NewV itself) that have</td>
    <td class="lineNumber">432</td>
    <td class="codeline">  // Identify all subtrees of NewV (including NewV itself) that have</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="codeline">  // equivalent counterparts in Root, and replace those subtrees with</td>
    <td class="lineNumber">433</td>
    <td class="codeline">  // equivalent counterparts in Root, and replace those subtrees with</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="codeline">  // these counterparts.</td>
    <td class="lineNumber">434</td>
    <td class="codeline">  // these counterparts.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="codeline">  WorkListType Q;</td>
    <td class="lineNumber">435</td>
    <td class="codeline">  WorkListType Q;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="codeline">  Q.push_back(NewV);</td>
    <td class="lineNumber">436</td>
    <td class="codeline">  Q.push_back(NewV);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="codeline">  while (!Q.empty()) {</td>
    <td class="lineNumber">437</td>
    <td class="codeline">  while (!Q.empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="codeline">    Value *V = Q.pop_front_val();</td>
    <td class="lineNumber">438</td>
    <td class="codeline">    Value *V = Q.pop_front_val();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="codeline">    Instruction *U = dyn_cast<Instruction>(V);</td>
    <td class="lineNumber">439</td>
    <td class="codeline">    Instruction *U = dyn_cast<Instruction>(V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="codeline">    if (!U || U->getParent())</td>
    <td class="lineNumber">440</td>
    <td class="codeline">    if (!U || U->getParent())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">441</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="codeline">    if (Value *DupV = find(Root, V)) {</td>
    <td class="lineNumber">442</td>
    <td class="codeline">    if (Value *DupV = find(Root, V)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="codeline">      if (DupV != V)</td>
    <td class="lineNumber">443</td>
    <td class="codeline">      if (DupV != V)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="codeline">        NewV = subst(NewV, V, DupV);</td>
    <td class="lineNumber">444</td>
    <td class="codeline">        NewV = subst(NewV, V, DupV);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="codeline">    } else {</td>
    <td class="lineNumber">445</td>
    <td class="codeline">    } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="codeline">      for (Value *Op : U->operands())</td>
    <td class="lineNumber">446</td>
    <td class="codeline">      for (Value *Op : U->operands())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="codeline">        Q.push_back(Op);</td>
    <td class="lineNumber">447</td>
    <td class="codeline">        Q.push_back(Op);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">448</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">449</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="codeline"></td>
    <td class="lineNumber">450</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="codeline">  // Now, simply replace OldV with NewV in Root.</td>
    <td class="lineNumber">451</td>
    <td class="codeline">  // Now, simply replace OldV with NewV in Root.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="codeline">  Root = subst(Root, OldV, NewV);</td>
    <td class="lineNumber">452</td>
    <td class="codeline">  Root = subst(Root, OldV, NewV);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="codeline">  use(Root);</td>
    <td class="lineNumber">453</td>
    <td class="codeline">  use(Root);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="codeline">}</td>
    <td class="lineNumber">454</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="codeline"></td>
    <td class="lineNumber">455</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="codeline">void Simplifier::Context::cleanup() {</td>
    <td class="lineNumber">456</td>
    <td class="codeline">void Simplifier::Context::cleanup() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="codeline">  for (Value *V : Clones) {</td>
    <td class="lineNumber">457</td>
    <td class="codeline">  for (Value *V : Clones) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="codeline">    Instruction *U = cast<Instruction>(V);</td>
    <td class="lineNumber">458</td>
    <td class="codeline">    Instruction *U = cast<Instruction>(V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="codeline">    if (!U->getParent())</td>
    <td class="lineNumber">459</td>
    <td class="codeline">    if (!U->getParent())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="codeline">      U->dropAllReferences();</td>
    <td class="lineNumber">460</td>
    <td class="codeline">      U->dropAllReferences();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">461</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="codeline"></td>
    <td class="lineNumber">462</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="codeline">  for (Value *V : Clones) {</td>
    <td class="lineNumber">463</td>
    <td class="codeline">  for (Value *V : Clones) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="codeline">    Instruction *U = cast<Instruction>(V);</td>
    <td class="lineNumber">464</td>
    <td class="codeline">    Instruction *U = cast<Instruction>(V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="codeline">    if (!U->getParent())</td>
    <td class="lineNumber">465</td>
    <td class="codeline">    if (!U->getParent())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="codeline">      U->deleteValue();</td>
    <td class="lineNumber">466</td>
    <td class="codeline">      U->deleteValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">467</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="codeline">}</td>
    <td class="lineNumber">468</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="codeline"></td>
    <td class="lineNumber">469</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="codeline">bool Simplifier::Context::equal(const Instruction *I,</td>
    <td class="lineNumber">470</td>
    <td class="codeline">bool Simplifier::Context::equal(const Instruction *I,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="codeline">                                const Instruction *J) const {</td>
    <td class="lineNumber">471</td>
    <td class="codeline">                                const Instruction *J) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="codeline">  if (I == J)</td>
    <td class="lineNumber">472</td>
    <td class="codeline">  if (I == J)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">473</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="codeline">  if (!I->isSameOperationAs(J))</td>
    <td class="lineNumber">474</td>
    <td class="codeline">  if (!I->isSameOperationAs(J))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">475</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="codeline">  if (isa<PHINode>(I))</td>
    <td class="lineNumber">476</td>
    <td class="codeline">  if (isa<PHINode>(I))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="codeline">    return I->isIdenticalTo(J);</td>
    <td class="lineNumber">477</td>
    <td class="codeline">    return I->isIdenticalTo(J);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="codeline"></td>
    <td class="lineNumber">478</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="codeline">  for (unsigned i = 0, n = I->getNumOperands(); i != n; ++i) {</td>
    <td class="lineNumber">479</td>
    <td class="codeline">  for (unsigned i = 0, n = I->getNumOperands(); i != n; ++i) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="codeline">    Value *OpI = I->getOperand(i), *OpJ = J->getOperand(i);</td>
    <td class="lineNumber">480</td>
    <td class="codeline">    Value *OpI = I->getOperand(i), *OpJ = J->getOperand(i);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="codeline">    if (OpI == OpJ)</td>
    <td class="lineNumber">481</td>
    <td class="codeline">    if (OpI == OpJ)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">482</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="codeline">    auto *InI = dyn_cast<const Instruction>(OpI);</td>
    <td class="lineNumber">483</td>
    <td class="codeline">    auto *InI = dyn_cast<const Instruction>(OpI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="codeline">    auto *InJ = dyn_cast<const Instruction>(OpJ);</td>
    <td class="lineNumber">484</td>
    <td class="codeline">    auto *InJ = dyn_cast<const Instruction>(OpJ);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="codeline">    if (InI && InJ) {</td>
    <td class="lineNumber">485</td>
    <td class="codeline">    if (InI && InJ) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="codeline">      if (!equal(InI, InJ))</td>
    <td class="lineNumber">486</td>
    <td class="codeline">      if (!equal(InI, InJ))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="codeline">        return false;</td>
    <td class="lineNumber">487</td>
    <td class="codeline">        return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="codeline">    } else if (InI != InJ || !InI)</td>
    <td class="lineNumber">488</td>
    <td class="codeline">    } else if (InI != InJ || !InI)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">489</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">490</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="codeline">  return true;</td>
    <td class="lineNumber">491</td>
    <td class="codeline">  return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="codeline">}</td>
    <td class="lineNumber">492</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="codeline"></td>
    <td class="lineNumber">493</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="codeline">Value *Simplifier::Context::find(Value *Tree, Value *Sub) const {</td>
    <td class="lineNumber">494</td>
    <td class="codeline">Value *Simplifier::Context::find(Value *Tree, Value *Sub) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="codeline">  Instruction *SubI = dyn_cast<Instruction>(Sub);</td>
    <td class="lineNumber">495</td>
    <td class="codeline">  Instruction *SubI = dyn_cast<Instruction>(Sub);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="codeline">  WorkListType Q;</td>
    <td class="lineNumber">496</td>
    <td class="codeline">  WorkListType Q;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="codeline">  Q.push_back(Tree);</td>
    <td class="lineNumber">497</td>
    <td class="codeline">  Q.push_back(Tree);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="codeline"></td>
    <td class="lineNumber">498</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="codeline">  while (!Q.empty()) {</td>
    <td class="lineNumber">499</td>
    <td class="codeline">  while (!Q.empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="codeline">    Value *V = Q.pop_front_val();</td>
    <td class="lineNumber">500</td>
    <td class="codeline">    Value *V = Q.pop_front_val();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="codeline">    if (V == Sub)</td>
    <td class="lineNumber">501</td>
    <td class="codeline">    if (V == Sub)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="codeline">      return V;</td>
    <td class="lineNumber">502</td>
    <td class="codeline">      return V;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="codeline">    Instruction *U = dyn_cast<Instruction>(V);</td>
    <td class="lineNumber">503</td>
    <td class="codeline">    Instruction *U = dyn_cast<Instruction>(V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class="codeline">    if (!U || U->getParent())</td>
    <td class="lineNumber">504</td>
    <td class="codeline">    if (!U || U->getParent())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">505</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="codeline">    if (SubI && equal(SubI, U))</td>
    <td class="lineNumber">506</td>
    <td class="codeline">    if (SubI && equal(SubI, U))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="codeline">      return U;</td>
    <td class="lineNumber">507</td>
    <td class="codeline">      return U;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="codeline">    assert(!isa<PHINode>(U));</td>
    <td class="lineNumber">508</td>
    <td class="codeline">    assert(!isa<PHINode>(U));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="codeline">    for (Value *Op : U->operands())</td>
    <td class="lineNumber">509</td>
    <td class="codeline">    for (Value *Op : U->operands())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="codeline">      Q.push_back(Op);</td>
    <td class="lineNumber">510</td>
    <td class="codeline">      Q.push_back(Op);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">511</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="codeline">  return nullptr;</td>
    <td class="lineNumber">512</td>
    <td class="codeline">  return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class="codeline">}</td>
    <td class="lineNumber">513</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="codeline"></td>
    <td class="lineNumber">514</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="codeline">void Simplifier::Context::link(Instruction *I, BasicBlock *B,</td>
    <td class="lineNumber">515</td>
    <td class="codeline">void Simplifier::Context::link(Instruction *I, BasicBlock *B,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="codeline">      BasicBlock::iterator At) {</td>
    <td class="lineNumber">516</td>
    <td class="codeline">      BasicBlock::iterator At) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class="codeline">  if (I->getParent())</td>
    <td class="lineNumber">517</td>
    <td class="codeline">  if (I->getParent())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">518</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="codeline"></td>
    <td class="lineNumber">519</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class="codeline">  for (Value *Op : I->operands()) {</td>
    <td class="lineNumber">520</td>
    <td class="codeline">  for (Value *Op : I->operands()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="codeline">    if (Instruction *OpI = dyn_cast<Instruction>(Op))</td>
    <td class="lineNumber">521</td>
    <td class="codeline">    if (Instruction *OpI = dyn_cast<Instruction>(Op))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="codeline">      link(OpI, B, At);</td>
    <td class="lineNumber">522</td>
    <td class="codeline">      link(OpI, B, At);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">523</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="codeline"></td>
    <td class="lineNumber">524</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="codeline">  I->insertInto(B, At);</td>
    <td class="lineNumber">525</td>
    <td class="codeline">  I->insertInto(B, At);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class="codeline">}</td>
    <td class="lineNumber">526</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="codeline"></td>
    <td class="lineNumber">527</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="codeline">Value *Simplifier::Context::materialize(BasicBlock *B,</td>
    <td class="lineNumber">528</td>
    <td class="codeline">Value *Simplifier::Context::materialize(BasicBlock *B,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="codeline">      BasicBlock::iterator At) {</td>
    <td class="lineNumber">529</td>
    <td class="codeline">      BasicBlock::iterator At) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="codeline">  if (Instruction *RootI = dyn_cast<Instruction>(Root))</td>
    <td class="lineNumber">530</td>
    <td class="codeline">  if (Instruction *RootI = dyn_cast<Instruction>(Root))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="codeline">    link(RootI, B, At);</td>
    <td class="lineNumber">531</td>
    <td class="codeline">    link(RootI, B, At);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="codeline">  return Root;</td>
    <td class="lineNumber">532</td>
    <td class="codeline">  return Root;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class="codeline">}</td>
    <td class="lineNumber">533</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="codeline"></td>
    <td class="lineNumber">534</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="codeline">Value *Simplifier::simplify(Context &C) {</td>
    <td class="lineNumber">535</td>
    <td class="codeline">Value *Simplifier::simplify(Context &C) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="codeline">  WorkListType Q;</td>
    <td class="lineNumber">536</td>
    <td class="codeline">  WorkListType Q;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="codeline">  Q.push_back(C.Root);</td>
    <td class="lineNumber">537</td>
    <td class="codeline">  Q.push_back(C.Root);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="codeline">  unsigned Count = 0;</td>
    <td class="lineNumber">538</td>
    <td class="codeline">  unsigned Count = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="codeline">  const unsigned Limit = SimplifyLimit;</td>
    <td class="lineNumber">539</td>
    <td class="codeline">  const unsigned Limit = SimplifyLimit;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class="codeline"></td>
    <td class="lineNumber">540</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="codeline">  while (!Q.empty()) {</td>
    <td class="lineNumber">541</td>
    <td class="codeline">  while (!Q.empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="codeline">    if (Count++ >= Limit)</td>
    <td class="lineNumber">542</td>
    <td class="codeline">    if (Count++ >= Limit)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">543</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="codeline">    Instruction *U = dyn_cast<Instruction>(Q.pop_front_val());</td>
    <td class="lineNumber">544</td>
    <td class="codeline">    Instruction *U = dyn_cast<Instruction>(Q.pop_front_val());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="codeline">    if (!U || U->getParent() || !C.Used.count(U))</td>
    <td class="lineNumber">545</td>
    <td class="codeline">    if (!U || U->getParent() || !C.Used.count(U))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">546</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="codeline">    bool Changed = false;</td>
    <td class="lineNumber">547</td>
    <td class="codeline">    bool Changed = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="codeline">    for (Rule &R : Rules) {</td>
    <td class="lineNumber">548</td>
    <td class="codeline">    for (Rule &R : Rules) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="codeline">      Value *W = R.Fn(U, C.Ctx);</td>
    <td class="lineNumber">549</td>
    <td class="codeline">      Value *W = R.Fn(U, C.Ctx);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="codeline">      if (!W)</td>
    <td class="lineNumber">550</td>
    <td class="codeline">      if (!W)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">551</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="codeline">      Changed = true;</td>
    <td class="lineNumber">552</td>
    <td class="codeline">      Changed = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="codeline">      C.record(W);</td>
    <td class="lineNumber">553</td>
    <td class="codeline">      C.record(W);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="codeline">      C.replace(U, W);</td>
    <td class="lineNumber">554</td>
    <td class="codeline">      C.replace(U, W);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="codeline">      Q.push_back(C.Root);</td>
    <td class="lineNumber">555</td>
    <td class="codeline">      Q.push_back(C.Root);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">556</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">557</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="codeline">    if (!Changed) {</td>
    <td class="lineNumber">558</td>
    <td class="codeline">    if (!Changed) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="codeline">      for (Value *Op : U->operands())</td>
    <td class="lineNumber">559</td>
    <td class="codeline">      for (Value *Op : U->operands())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="codeline">        Q.push_back(Op);</td>
    <td class="lineNumber">560</td>
    <td class="codeline">        Q.push_back(Op);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">561</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">562</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="codeline">  return Count < Limit ? C.Root : nullptr;</td>
    <td class="lineNumber">563</td>
    <td class="codeline">  return Count < Limit ? C.Root : nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="codeline">}</td>
    <td class="lineNumber">564</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class="codeline"></td>
    <td class="lineNumber">565</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">566</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="codeline">//</td>
    <td class="lineNumber">567</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="codeline">//          Implementation of PolynomialMultiplyRecognize</td>
    <td class="lineNumber">568</td>
    <td class="codeline">//          Implementation of PolynomialMultiplyRecognize</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="codeline">//</td>
    <td class="lineNumber">569</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">570</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="codeline"></td>
    <td class="lineNumber">571</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="codeline">namespace {</td>
    <td class="lineNumber">572</td>
    <td class="codeline">namespace {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="codeline"></td>
    <td class="lineNumber">573</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="codeline">  class PolynomialMultiplyRecognize {</td>
    <td class="lineNumber">574</td>
    <td class="codeline">  class PolynomialMultiplyRecognize {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="codeline">  public:</td>
    <td class="lineNumber">575</td>
    <td class="codeline">  public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="codeline">    explicit PolynomialMultiplyRecognize(Loop *loop, const DataLayout &dl,</td>
    <td class="lineNumber">576</td>
    <td class="codeline">    explicit PolynomialMultiplyRecognize(Loop *loop, const DataLayout &dl,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="codeline">        const DominatorTree &dt, const TargetLibraryInfo &tli,</td>
    <td class="lineNumber">577</td>
    <td class="codeline">        const DominatorTree &dt, const TargetLibraryInfo &tli,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="codeline">        ScalarEvolution &se)</td>
    <td class="lineNumber">578</td>
    <td class="codeline">        ScalarEvolution &se)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class="codeline">      : CurLoop(loop), DL(dl), DT(dt), TLI(tli), SE(se) {}</td>
    <td class="lineNumber">579</td>
    <td class="codeline">      : CurLoop(loop), DL(dl), DT(dt), TLI(tli), SE(se) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="codeline"></td>
    <td class="lineNumber">580</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="codeline">    bool recognize();</td>
    <td class="lineNumber">581</td>
    <td class="codeline">    bool recognize();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class="codeline"></td>
    <td class="lineNumber">582</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="codeline">  private:</td>
    <td class="lineNumber">583</td>
    <td class="codeline">  private:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="codeline">    using ValueSeq = SetVector<Value *>;</td>
    <td class="lineNumber">584</td>
    <td class="codeline">    using ValueSeq = SetVector<Value *>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="codeline"></td>
    <td class="lineNumber">585</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="codeline">    IntegerType *getPmpyType() const {</td>
    <td class="lineNumber">586</td>
    <td class="codeline">    IntegerType *getPmpyType() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class="codeline">      LLVMContext &Ctx = CurLoop->getHeader()->getParent()->getContext();</td>
    <td class="lineNumber">587</td>
    <td class="codeline">      LLVMContext &Ctx = CurLoop->getHeader()->getParent()->getContext();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="codeline">      return IntegerType::get(Ctx, 32);</td>
    <td class="lineNumber">588</td>
    <td class="codeline">      return IntegerType::get(Ctx, 32);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">589</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class="codeline"></td>
    <td class="lineNumber">590</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="codeline">    bool isPromotableTo(Value *V, IntegerType *Ty);</td>
    <td class="lineNumber">591</td>
    <td class="codeline">    bool isPromotableTo(Value *V, IntegerType *Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="codeline">    void promoteTo(Instruction *In, IntegerType *DestTy, BasicBlock *LoopB);</td>
    <td class="lineNumber">592</td>
    <td class="codeline">    void promoteTo(Instruction *In, IntegerType *DestTy, BasicBlock *LoopB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="codeline">    bool promoteTypes(BasicBlock *LoopB, BasicBlock *ExitB);</td>
    <td class="lineNumber">593</td>
    <td class="codeline">    bool promoteTypes(BasicBlock *LoopB, BasicBlock *ExitB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="codeline"></td>
    <td class="lineNumber">594</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="codeline">    Value *getCountIV(BasicBlock *BB);</td>
    <td class="lineNumber">595</td>
    <td class="codeline">    Value *getCountIV(BasicBlock *BB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="codeline">    bool findCycle(Value *Out, Value *In, ValueSeq &Cycle);</td>
    <td class="lineNumber">596</td>
    <td class="codeline">    bool findCycle(Value *Out, Value *In, ValueSeq &Cycle);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class="codeline">    void classifyCycle(Instruction *DivI, ValueSeq &Cycle, ValueSeq &Early,</td>
    <td class="lineNumber">597</td>
    <td class="codeline">    void classifyCycle(Instruction *DivI, ValueSeq &Cycle, ValueSeq &Early,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="codeline">          ValueSeq &Late);</td>
    <td class="lineNumber">598</td>
    <td class="codeline">          ValueSeq &Late);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="codeline">    bool classifyInst(Instruction *UseI, ValueSeq &Early, ValueSeq &Late);</td>
    <td class="lineNumber">599</td>
    <td class="codeline">    bool classifyInst(Instruction *UseI, ValueSeq &Early, ValueSeq &Late);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="codeline">    bool commutesWithShift(Instruction *I);</td>
    <td class="lineNumber">600</td>
    <td class="codeline">    bool commutesWithShift(Instruction *I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="codeline">    bool highBitsAreZero(Value *V, unsigned IterCount);</td>
    <td class="lineNumber">601</td>
    <td class="codeline">    bool highBitsAreZero(Value *V, unsigned IterCount);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="codeline">    bool keepsHighBitsZero(Value *V, unsigned IterCount);</td>
    <td class="lineNumber">602</td>
    <td class="codeline">    bool keepsHighBitsZero(Value *V, unsigned IterCount);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="codeline">    bool isOperandShifted(Instruction *I, Value *Op);</td>
    <td class="lineNumber">603</td>
    <td class="codeline">    bool isOperandShifted(Instruction *I, Value *Op);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="codeline">    bool convertShiftsToLeft(BasicBlock *LoopB, BasicBlock *ExitB,</td>
    <td class="lineNumber">604</td>
    <td class="codeline">    bool convertShiftsToLeft(BasicBlock *LoopB, BasicBlock *ExitB,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="codeline">          unsigned IterCount);</td>
    <td class="lineNumber">605</td>
    <td class="codeline">          unsigned IterCount);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="codeline">    void cleanupLoopBody(BasicBlock *LoopB);</td>
    <td class="lineNumber">606</td>
    <td class="codeline">    void cleanupLoopBody(BasicBlock *LoopB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="codeline"></td>
    <td class="lineNumber">607</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="codeline">    struct ParsedValues {</td>
    <td class="lineNumber">608</td>
    <td class="codeline">    struct ParsedValues {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="codeline">      ParsedValues() = default;</td>
    <td class="lineNumber">609</td>
    <td class="codeline">      ParsedValues() = default;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="codeline"></td>
    <td class="lineNumber">610</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="codeline">      Value *M = nullptr;</td>
    <td class="lineNumber">611</td>
    <td class="codeline">      Value *M = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="codeline">      Value *P = nullptr;</td>
    <td class="lineNumber">612</td>
    <td class="codeline">      Value *P = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class="codeline">      Value *Q = nullptr;</td>
    <td class="lineNumber">613</td>
    <td class="codeline">      Value *Q = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class="codeline">      Value *R = nullptr;</td>
    <td class="lineNumber">614</td>
    <td class="codeline">      Value *R = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="codeline">      Value *X = nullptr;</td>
    <td class="lineNumber">615</td>
    <td class="codeline">      Value *X = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="codeline">      Instruction *Res = nullptr;</td>
    <td class="lineNumber">616</td>
    <td class="codeline">      Instruction *Res = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="codeline">      unsigned IterCount = 0;</td>
    <td class="lineNumber">617</td>
    <td class="codeline">      unsigned IterCount = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class="codeline">      bool Left = false;</td>
    <td class="lineNumber">618</td>
    <td class="codeline">      bool Left = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="codeline">      bool Inv = false;</td>
    <td class="lineNumber">619</td>
    <td class="codeline">      bool Inv = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="codeline">    };</td>
    <td class="lineNumber">620</td>
    <td class="codeline">    };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class="codeline"></td>
    <td class="lineNumber">621</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="codeline">    bool matchLeftShift(SelectInst *SelI, Value *CIV, ParsedValues &PV);</td>
    <td class="lineNumber">622</td>
    <td class="codeline">    bool matchLeftShift(SelectInst *SelI, Value *CIV, ParsedValues &PV);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="codeline">    bool matchRightShift(SelectInst *SelI, ParsedValues &PV);</td>
    <td class="lineNumber">623</td>
    <td class="codeline">    bool matchRightShift(SelectInst *SelI, ParsedValues &PV);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="codeline">    bool scanSelect(SelectInst *SI, BasicBlock *LoopB, BasicBlock *PrehB,</td>
    <td class="lineNumber">624</td>
    <td class="codeline">    bool scanSelect(SelectInst *SI, BasicBlock *LoopB, BasicBlock *PrehB,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="codeline">          Value *CIV, ParsedValues &PV, bool PreScan);</td>
    <td class="lineNumber">625</td>
    <td class="codeline">          Value *CIV, ParsedValues &PV, bool PreScan);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="codeline">    unsigned getInverseMxN(unsigned QP);</td>
    <td class="lineNumber">626</td>
    <td class="codeline">    unsigned getInverseMxN(unsigned QP);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="codeline">    Value *generate(BasicBlock::iterator At, ParsedValues &PV);</td>
    <td class="lineNumber">627</td>
    <td class="codeline">    Value *generate(BasicBlock::iterator At, ParsedValues &PV);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class="codeline"></td>
    <td class="lineNumber">628</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="codeline">    void setupPreSimplifier(Simplifier &S);</td>
    <td class="lineNumber">629</td>
    <td class="codeline">    void setupPreSimplifier(Simplifier &S);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class="codeline">    void setupPostSimplifier(Simplifier &S);</td>
    <td class="lineNumber">630</td>
    <td class="codeline">    void setupPostSimplifier(Simplifier &S);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="codeline"></td>
    <td class="lineNumber">631</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="codeline">    Loop *CurLoop;</td>
    <td class="lineNumber">632</td>
    <td class="codeline">    Loop *CurLoop;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="codeline">    const DataLayout &DL;</td>
    <td class="lineNumber">633</td>
    <td class="codeline">    const DataLayout &DL;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="codeline">    const DominatorTree &DT;</td>
    <td class="lineNumber">634</td>
    <td class="codeline">    const DominatorTree &DT;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="codeline">    const TargetLibraryInfo &TLI;</td>
    <td class="lineNumber">635</td>
    <td class="codeline">    const TargetLibraryInfo &TLI;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="codeline">    ScalarEvolution &SE;</td>
    <td class="lineNumber">636</td>
    <td class="codeline">    ScalarEvolution &SE;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">637</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="codeline"></td>
    <td class="lineNumber">638</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="codeline">} // end anonymous namespace</td>
    <td class="lineNumber">639</td>
    <td class="codeline">} // end anonymous namespace</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="codeline"></td>
    <td class="lineNumber">640</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="codeline">Value *PolynomialMultiplyRecognize::getCountIV(BasicBlock *BB) {</td>
    <td class="lineNumber">641</td>
    <td class="codeline">Value *PolynomialMultiplyRecognize::getCountIV(BasicBlock *BB) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="codeline">  pred_iterator PI = pred_begin(BB), PE = pred_end(BB);</td>
    <td class="lineNumber">642</td>
    <td class="codeline">  pred_iterator PI = pred_begin(BB), PE = pred_end(BB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="codeline">  if (std::distance(PI, PE) != 2)</td>
    <td class="lineNumber">643</td>
    <td class="codeline">  if (std::distance(PI, PE) != 2)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class="codeline">    return nullptr;</td>
    <td class="lineNumber">644</td>
    <td class="codeline">    return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="codeline">  BasicBlock *PB = (*PI == BB) ? *std::next(PI) : *PI;</td>
    <td class="lineNumber">645</td>
    <td class="codeline">  BasicBlock *PB = (*PI == BB) ? *std::next(PI) : *PI;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="codeline"></td>
    <td class="lineNumber">646</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="codeline">  for (auto I = BB->begin(), E = BB->end(); I != E && isa<PHINode>(I); ++I) {</td>
    <td class="lineNumber">647</td>
    <td class="codeline">  for (auto I = BB->begin(), E = BB->end(); I != E && isa<PHINode>(I); ++I) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="codeline">    auto *PN = cast<PHINode>(I);</td>
    <td class="lineNumber">648</td>
    <td class="codeline">    auto *PN = cast<PHINode>(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="codeline">    Value *InitV = PN->getIncomingValueForBlock(PB);</td>
    <td class="lineNumber">649</td>
    <td class="codeline">    Value *InitV = PN->getIncomingValueForBlock(PB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="codeline">    if (!isa<ConstantInt>(InitV) || !cast<ConstantInt>(InitV)->isZero())</td>
    <td class="lineNumber">650</td>
    <td class="codeline">    if (!isa<ConstantInt>(InitV) || !cast<ConstantInt>(InitV)->isZero())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">651</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="codeline">    Value *IterV = PN->getIncomingValueForBlock(BB);</td>
    <td class="lineNumber">652</td>
    <td class="codeline">    Value *IterV = PN->getIncomingValueForBlock(BB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="codeline">    auto *BO = dyn_cast<BinaryOperator>(IterV);</td>
    <td class="lineNumber">653</td>
    <td class="codeline">    auto *BO = dyn_cast<BinaryOperator>(IterV);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="codeline">    if (!BO)</td>
    <td class="lineNumber">654</td>
    <td class="codeline">    if (!BO)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">655</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="codeline">    if (BO->getOpcode() != Instruction::Add)</td>
    <td class="lineNumber">656</td>
    <td class="codeline">    if (BO->getOpcode() != Instruction::Add)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">657</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="codeline">    Value *IncV = nullptr;</td>
    <td class="lineNumber">658</td>
    <td class="codeline">    Value *IncV = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="codeline">    if (BO->getOperand(0) == PN)</td>
    <td class="lineNumber">659</td>
    <td class="codeline">    if (BO->getOperand(0) == PN)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="codeline">      IncV = BO->getOperand(1);</td>
    <td class="lineNumber">660</td>
    <td class="codeline">      IncV = BO->getOperand(1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="codeline">    else if (BO->getOperand(1) == PN)</td>
    <td class="lineNumber">661</td>
    <td class="codeline">    else if (BO->getOperand(1) == PN)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="codeline">      IncV = BO->getOperand(0);</td>
    <td class="lineNumber">662</td>
    <td class="codeline">      IncV = BO->getOperand(0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="codeline">    if (IncV == nullptr)</td>
    <td class="lineNumber">663</td>
    <td class="codeline">    if (IncV == nullptr)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">664</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="codeline"></td>
    <td class="lineNumber">665</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="codeline">    if (auto *T = dyn_cast<ConstantInt>(IncV))</td>
    <td class="lineNumber">666</td>
    <td class="codeline">    if (auto *T = dyn_cast<ConstantInt>(IncV))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="codeline">      if (T->isOne())</td>
    <td class="lineNumber">667</td>
    <td class="codeline">      if (T->isOne())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="codeline">        return PN;</td>
    <td class="lineNumber">668</td>
    <td class="codeline">        return PN;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">669</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="codeline">  return nullptr;</td>
    <td class="lineNumber">670</td>
    <td class="codeline">  return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="codeline">}</td>
    <td class="lineNumber">671</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class="codeline"></td>
    <td class="lineNumber">672</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="codeline">static void replaceAllUsesOfWithIn(Value *I, Value *J, BasicBlock *BB) {</td>
    <td class="lineNumber">673</td>
    <td class="codeline">static void replaceAllUsesOfWithIn(Value *I, Value *J, BasicBlock *BB) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="codeline">  for (auto UI = I->user_begin(), UE = I->user_end(); UI != UE;) {</td>
    <td class="lineNumber">674</td>
    <td class="codeline">  for (auto UI = I->user_begin(), UE = I->user_end(); UI != UE;) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class="codeline">    Use &TheUse = UI.getUse();</td>
    <td class="lineNumber">675</td>
    <td class="codeline">    Use &TheUse = UI.getUse();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class="codeline">    ++UI;</td>
    <td class="lineNumber">676</td>
    <td class="codeline">    ++UI;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="codeline">    if (auto *II = dyn_cast<Instruction>(TheUse.getUser()))</td>
    <td class="lineNumber">677</td>
    <td class="codeline">    if (auto *II = dyn_cast<Instruction>(TheUse.getUser()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="codeline">      if (BB == II->getParent())</td>
    <td class="lineNumber">678</td>
    <td class="codeline">      if (BB == II->getParent())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="codeline">        II->replaceUsesOfWith(I, J);</td>
    <td class="lineNumber">679</td>
    <td class="codeline">        II->replaceUsesOfWith(I, J);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">680</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="codeline">}</td>
    <td class="lineNumber">681</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="codeline"></td>
    <td class="lineNumber">682</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class="codeline">bool PolynomialMultiplyRecognize::matchLeftShift(SelectInst *SelI,</td>
    <td class="lineNumber">683</td>
    <td class="codeline">bool PolynomialMultiplyRecognize::matchLeftShift(SelectInst *SelI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="codeline">      Value *CIV, ParsedValues &PV) {</td>
    <td class="lineNumber">684</td>
    <td class="codeline">      Value *CIV, ParsedValues &PV) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class="codeline">  // Match the following:</td>
    <td class="lineNumber">685</td>
    <td class="codeline">  // Match the following:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="codeline">  //   select (X & (1 << i)) != 0 ? R ^ (Q << i) : R</td>
    <td class="lineNumber">686</td>
    <td class="codeline">  //   select (X & (1 << i)) != 0 ? R ^ (Q << i) : R</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="codeline">  //   select (X & (1 << i)) == 0 ? R : R ^ (Q << i)</td>
    <td class="lineNumber">687</td>
    <td class="codeline">  //   select (X & (1 << i)) == 0 ? R : R ^ (Q << i)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class="codeline">  // The condition may also check for equality with the masked value, i.e</td>
    <td class="lineNumber">688</td>
    <td class="codeline">  // The condition may also check for equality with the masked value, i.e</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class="codeline">  //   select (X & (1 << i)) == (1 << i) ? R ^ (Q << i) : R</td>
    <td class="lineNumber">689</td>
    <td class="codeline">  //   select (X & (1 << i)) == (1 << i) ? R ^ (Q << i) : R</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class="codeline">  //   select (X & (1 << i)) != (1 << i) ? R : R ^ (Q << i);</td>
    <td class="lineNumber">690</td>
    <td class="codeline">  //   select (X & (1 << i)) != (1 << i) ? R : R ^ (Q << i);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class="codeline"></td>
    <td class="lineNumber">691</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="codeline">  Value *CondV = SelI->getCondition();</td>
    <td class="lineNumber">692</td>
    <td class="codeline">  Value *CondV = SelI->getCondition();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class="codeline">  Value *TrueV = SelI->getTrueValue();</td>
    <td class="lineNumber">693</td>
    <td class="codeline">  Value *TrueV = SelI->getTrueValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class="codeline">  Value *FalseV = SelI->getFalseValue();</td>
    <td class="lineNumber">694</td>
    <td class="codeline">  Value *FalseV = SelI->getFalseValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="codeline"></td>
    <td class="lineNumber">695</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="codeline">  using namespace PatternMatch;</td>
    <td class="lineNumber">696</td>
    <td class="codeline">  using namespace PatternMatch;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class="codeline"></td>
    <td class="lineNumber">697</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class="codeline">  CmpInst::Predicate P;</td>
    <td class="lineNumber">698</td>
    <td class="codeline">  CmpInst::Predicate P;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class="codeline">  Value *A = nullptr, *B = nullptr, *C = nullptr;</td>
    <td class="lineNumber">699</td>
    <td class="codeline">  Value *A = nullptr, *B = nullptr, *C = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="codeline"></td>
    <td class="lineNumber">700</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="codeline">  if (!match(CondV, m_ICmp(P, m_And(m_Value(A), m_Value(B)), m_Value(C))) &&</td>
    <td class="lineNumber">701</td>
    <td class="codeline">  if (!match(CondV, m_ICmp(P, m_And(m_Value(A), m_Value(B)), m_Value(C))) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class="codeline">      !match(CondV, m_ICmp(P, m_Value(C), m_And(m_Value(A), m_Value(B)))))</td>
    <td class="lineNumber">702</td>
    <td class="codeline">      !match(CondV, m_ICmp(P, m_Value(C), m_And(m_Value(A), m_Value(B)))))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">703</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class="codeline">  if (P != CmpInst::ICMP_EQ && P != CmpInst::ICMP_NE)</td>
    <td class="lineNumber">704</td>
    <td class="codeline">  if (P != CmpInst::ICMP_EQ && P != CmpInst::ICMP_NE)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">705</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class="codeline">  // Matched: select (A & B) == C ? ... : ...</td>
    <td class="lineNumber">706</td>
    <td class="codeline">  // Matched: select (A & B) == C ? ... : ...</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class="codeline">  //          select (A & B) != C ? ... : ...</td>
    <td class="lineNumber">707</td>
    <td class="codeline">  //          select (A & B) != C ? ... : ...</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class="codeline"></td>
    <td class="lineNumber">708</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class="codeline">  Value *X = nullptr, *Sh1 = nullptr;</td>
    <td class="lineNumber">709</td>
    <td class="codeline">  Value *X = nullptr, *Sh1 = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="codeline">  // Check (A & B) for (X & (1 << i)):</td>
    <td class="lineNumber">710</td>
    <td class="codeline">  // Check (A & B) for (X & (1 << i)):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class="codeline">  if (match(A, m_Shl(m_One(), m_Specific(CIV)))) {</td>
    <td class="lineNumber">711</td>
    <td class="codeline">  if (match(A, m_Shl(m_One(), m_Specific(CIV)))) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class="codeline">    Sh1 = A;</td>
    <td class="lineNumber">712</td>
    <td class="codeline">    Sh1 = A;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="codeline">    X = B;</td>
    <td class="lineNumber">713</td>
    <td class="codeline">    X = B;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="codeline">  } else if (match(B, m_Shl(m_One(), m_Specific(CIV)))) {</td>
    <td class="lineNumber">714</td>
    <td class="codeline">  } else if (match(B, m_Shl(m_One(), m_Specific(CIV)))) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="codeline">    Sh1 = B;</td>
    <td class="lineNumber">715</td>
    <td class="codeline">    Sh1 = B;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="codeline">    X = A;</td>
    <td class="lineNumber">716</td>
    <td class="codeline">    X = A;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">717</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class="codeline">    // TODO: Could also check for an induction variable containing single</td>
    <td class="lineNumber">718</td>
    <td class="codeline">    // TODO: Could also check for an induction variable containing single</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class="codeline">    // bit shifted left by 1 in each iteration.</td>
    <td class="lineNumber">719</td>
    <td class="codeline">    // bit shifted left by 1 in each iteration.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">720</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">721</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class="codeline"></td>
    <td class="lineNumber">722</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="codeline">  bool TrueIfZero;</td>
    <td class="lineNumber">723</td>
    <td class="codeline">  bool TrueIfZero;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class="codeline"></td>
    <td class="lineNumber">724</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="codeline">  // Check C against the possible values for comparison: 0 and (1 << i):</td>
    <td class="lineNumber">725</td>
    <td class="codeline">  // Check C against the possible values for comparison: 0 and (1 << i):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class="codeline">  if (match(C, m_Zero()))</td>
    <td class="lineNumber">726</td>
    <td class="codeline">  if (match(C, m_Zero()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class="codeline">    TrueIfZero = (P == CmpInst::ICMP_EQ);</td>
    <td class="lineNumber">727</td>
    <td class="codeline">    TrueIfZero = (P == CmpInst::ICMP_EQ);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class="codeline">  else if (C == Sh1)</td>
    <td class="lineNumber">728</td>
    <td class="codeline">  else if (C == Sh1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="codeline">    TrueIfZero = (P == CmpInst::ICMP_NE);</td>
    <td class="lineNumber">729</td>
    <td class="codeline">    TrueIfZero = (P == CmpInst::ICMP_NE);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class="codeline">  else</td>
    <td class="lineNumber">730</td>
    <td class="codeline">  else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">731</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class="codeline"></td>
    <td class="lineNumber">732</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="codeline">  // So far, matched:</td>
    <td class="lineNumber">733</td>
    <td class="codeline">  // So far, matched:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="codeline">  //   select (X & (1 << i)) ? ... : ...</td>
    <td class="lineNumber">734</td>
    <td class="codeline">  //   select (X & (1 << i)) ? ... : ...</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class="codeline">  // including variations of the check against zero/non-zero value.</td>
    <td class="lineNumber">735</td>
    <td class="codeline">  // including variations of the check against zero/non-zero value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class="codeline"></td>
    <td class="lineNumber">736</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class="codeline">  Value *ShouldSameV = nullptr, *ShouldXoredV = nullptr;</td>
    <td class="lineNumber">737</td>
    <td class="codeline">  Value *ShouldSameV = nullptr, *ShouldXoredV = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class="codeline">  if (TrueIfZero) {</td>
    <td class="lineNumber">738</td>
    <td class="codeline">  if (TrueIfZero) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class="codeline">    ShouldSameV = TrueV;</td>
    <td class="lineNumber">739</td>
    <td class="codeline">    ShouldSameV = TrueV;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="codeline">    ShouldXoredV = FalseV;</td>
    <td class="lineNumber">740</td>
    <td class="codeline">    ShouldXoredV = FalseV;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">741</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class="codeline">    ShouldSameV = FalseV;</td>
    <td class="lineNumber">742</td>
    <td class="codeline">    ShouldSameV = FalseV;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class="codeline">    ShouldXoredV = TrueV;</td>
    <td class="lineNumber">743</td>
    <td class="codeline">    ShouldXoredV = TrueV;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">744</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="codeline"></td>
    <td class="lineNumber">745</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class="codeline">  Value *Q = nullptr, *R = nullptr, *Y = nullptr, *Z = nullptr;</td>
    <td class="lineNumber">746</td>
    <td class="codeline">  Value *Q = nullptr, *R = nullptr, *Y = nullptr, *Z = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class="codeline">  Value *T = nullptr;</td>
    <td class="lineNumber">747</td>
    <td class="codeline">  Value *T = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="codeline">  if (match(ShouldXoredV, m_Xor(m_Value(Y), m_Value(Z)))) {</td>
    <td class="lineNumber">748</td>
    <td class="codeline">  if (match(ShouldXoredV, m_Xor(m_Value(Y), m_Value(Z)))) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="codeline">    // Matched: select +++ ? ... : Y ^ Z</td>
    <td class="lineNumber">749</td>
    <td class="codeline">    // Matched: select +++ ? ... : Y ^ Z</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="codeline">    //          select +++ ? Y ^ Z : ...</td>
    <td class="lineNumber">750</td>
    <td class="codeline">    //          select +++ ? Y ^ Z : ...</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class="codeline">    // where +++ denotes previously checked matches.</td>
    <td class="lineNumber">751</td>
    <td class="codeline">    // where +++ denotes previously checked matches.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class="codeline">    if (ShouldSameV == Y)</td>
    <td class="lineNumber">752</td>
    <td class="codeline">    if (ShouldSameV == Y)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class="codeline">      T = Z;</td>
    <td class="lineNumber">753</td>
    <td class="codeline">      T = Z;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class="codeline">    else if (ShouldSameV == Z)</td>
    <td class="lineNumber">754</td>
    <td class="codeline">    else if (ShouldSameV == Z)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class="codeline">      T = Y;</td>
    <td class="lineNumber">755</td>
    <td class="codeline">      T = Y;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="codeline">    else</td>
    <td class="lineNumber">756</td>
    <td class="codeline">    else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">757</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="codeline">    R = ShouldSameV;</td>
    <td class="lineNumber">758</td>
    <td class="codeline">    R = ShouldSameV;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="codeline">    // Matched: select +++ ? R : R ^ T</td>
    <td class="lineNumber">759</td>
    <td class="codeline">    // Matched: select +++ ? R : R ^ T</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class="codeline">    //          select +++ ? R ^ T : R</td>
    <td class="lineNumber">760</td>
    <td class="codeline">    //          select +++ ? R ^ T : R</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class="codeline">    // depending on TrueIfZero.</td>
    <td class="lineNumber">761</td>
    <td class="codeline">    // depending on TrueIfZero.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class="codeline"></td>
    <td class="lineNumber">762</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="codeline">  } else if (match(ShouldSameV, m_Zero())) {</td>
    <td class="lineNumber">763</td>
    <td class="codeline">  } else if (match(ShouldSameV, m_Zero())) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class="codeline">    // Matched: select +++ ? 0 : ...</td>
    <td class="lineNumber">764</td>
    <td class="codeline">    // Matched: select +++ ? 0 : ...</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class="codeline">    //          select +++ ? ... : 0</td>
    <td class="lineNumber">765</td>
    <td class="codeline">    //          select +++ ? ... : 0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class="codeline">    if (!SelI->hasOneUse())</td>
    <td class="lineNumber">766</td>
    <td class="codeline">    if (!SelI->hasOneUse())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">767</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class="codeline">    T = ShouldXoredV;</td>
    <td class="lineNumber">768</td>
    <td class="codeline">    T = ShouldXoredV;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="codeline">    // Matched: select +++ ? 0 : T</td>
    <td class="lineNumber">769</td>
    <td class="codeline">    // Matched: select +++ ? 0 : T</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="codeline">    //          select +++ ? T : 0</td>
    <td class="lineNumber">770</td>
    <td class="codeline">    //          select +++ ? T : 0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class="codeline"></td>
    <td class="lineNumber">771</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="codeline">    Value *U = *SelI->user_begin();</td>
    <td class="lineNumber">772</td>
    <td class="codeline">    Value *U = *SelI->user_begin();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class="codeline">    if (!match(U, m_Xor(m_Specific(SelI), m_Value(R))) &&</td>
    <td class="lineNumber">773</td>
    <td class="codeline">    if (!match(U, m_Xor(m_Specific(SelI), m_Value(R))) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="codeline">        !match(U, m_Xor(m_Value(R), m_Specific(SelI))))</td>
    <td class="lineNumber">774</td>
    <td class="codeline">        !match(U, m_Xor(m_Value(R), m_Specific(SelI))))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">775</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class="codeline">    // Matched: xor (select +++ ? 0 : T), R</td>
    <td class="lineNumber">776</td>
    <td class="codeline">    // Matched: xor (select +++ ? 0 : T), R</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="codeline">    //          xor (select +++ ? T : 0), R</td>
    <td class="lineNumber">777</td>
    <td class="codeline">    //          xor (select +++ ? T : 0), R</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class="codeline">  } else</td>
    <td class="lineNumber">778</td>
    <td class="codeline">  } else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">779</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class="codeline"></td>
    <td class="lineNumber">780</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class="codeline">  // The xor input value T is isolated into its own match so that it could</td>
    <td class="lineNumber">781</td>
    <td class="codeline">  // The xor input value T is isolated into its own match so that it could</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="codeline">  // be checked against an induction variable containing a shifted bit</td>
    <td class="lineNumber">782</td>
    <td class="codeline">  // be checked against an induction variable containing a shifted bit</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="codeline">  // (todo).</td>
    <td class="lineNumber">783</td>
    <td class="codeline">  // (todo).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class="codeline">  // For now, check against (Q << i).</td>
    <td class="lineNumber">784</td>
    <td class="codeline">  // For now, check against (Q << i).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class="codeline">  if (!match(T, m_Shl(m_Value(Q), m_Specific(CIV))) &&</td>
    <td class="lineNumber">785</td>
    <td class="codeline">  if (!match(T, m_Shl(m_Value(Q), m_Specific(CIV))) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class="codeline">      !match(T, m_Shl(m_ZExt(m_Value(Q)), m_ZExt(m_Specific(CIV)))))</td>
    <td class="lineNumber">786</td>
    <td class="codeline">      !match(T, m_Shl(m_ZExt(m_Value(Q)), m_ZExt(m_Specific(CIV)))))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">787</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="codeline">  // Matched: select +++ ? R : R ^ (Q << i)</td>
    <td class="lineNumber">788</td>
    <td class="codeline">  // Matched: select +++ ? R : R ^ (Q << i)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class="codeline">  //          select +++ ? R ^ (Q << i) : R</td>
    <td class="lineNumber">789</td>
    <td class="codeline">  //          select +++ ? R ^ (Q << i) : R</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class="codeline"></td>
    <td class="lineNumber">790</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class="codeline">  PV.X = X;</td>
    <td class="lineNumber">791</td>
    <td class="codeline">  PV.X = X;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class="codeline">  PV.Q = Q;</td>
    <td class="lineNumber">792</td>
    <td class="codeline">  PV.Q = Q;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="codeline">  PV.R = R;</td>
    <td class="lineNumber">793</td>
    <td class="codeline">  PV.R = R;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class="codeline">  PV.Left = true;</td>
    <td class="lineNumber">794</td>
    <td class="codeline">  PV.Left = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="codeline">  return true;</td>
    <td class="lineNumber">795</td>
    <td class="codeline">  return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class="codeline">}</td>
    <td class="lineNumber">796</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class="codeline"></td>
    <td class="lineNumber">797</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class="codeline">bool PolynomialMultiplyRecognize::matchRightShift(SelectInst *SelI,</td>
    <td class="lineNumber">798</td>
    <td class="codeline">bool PolynomialMultiplyRecognize::matchRightShift(SelectInst *SelI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class="codeline">      ParsedValues &PV) {</td>
    <td class="lineNumber">799</td>
    <td class="codeline">      ParsedValues &PV) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class="codeline">  // Match the following:</td>
    <td class="lineNumber">800</td>
    <td class="codeline">  // Match the following:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class="codeline">  //   select (X & 1) != 0 ? (R >> 1) ^ Q : (R >> 1)</td>
    <td class="lineNumber">801</td>
    <td class="codeline">  //   select (X & 1) != 0 ? (R >> 1) ^ Q : (R >> 1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class="codeline">  //   select (X & 1) == 0 ? (R >> 1) : (R >> 1) ^ Q</td>
    <td class="lineNumber">802</td>
    <td class="codeline">  //   select (X & 1) == 0 ? (R >> 1) : (R >> 1) ^ Q</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class="codeline">  // The condition may also check for equality with the masked value, i.e</td>
    <td class="lineNumber">803</td>
    <td class="codeline">  // The condition may also check for equality with the masked value, i.e</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class="codeline">  //   select (X & 1) == 1 ? (R >> 1) ^ Q : (R >> 1)</td>
    <td class="lineNumber">804</td>
    <td class="codeline">  //   select (X & 1) == 1 ? (R >> 1) ^ Q : (R >> 1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class="codeline">  //   select (X & 1) != 1 ? (R >> 1) : (R >> 1) ^ Q</td>
    <td class="lineNumber">805</td>
    <td class="codeline">  //   select (X & 1) != 1 ? (R >> 1) : (R >> 1) ^ Q</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class="codeline"></td>
    <td class="lineNumber">806</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class="codeline">  Value *CondV = SelI->getCondition();</td>
    <td class="lineNumber">807</td>
    <td class="codeline">  Value *CondV = SelI->getCondition();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class="codeline">  Value *TrueV = SelI->getTrueValue();</td>
    <td class="lineNumber">808</td>
    <td class="codeline">  Value *TrueV = SelI->getTrueValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class="codeline">  Value *FalseV = SelI->getFalseValue();</td>
    <td class="lineNumber">809</td>
    <td class="codeline">  Value *FalseV = SelI->getFalseValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class="codeline"></td>
    <td class="lineNumber">810</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class="codeline">  using namespace PatternMatch;</td>
    <td class="lineNumber">811</td>
    <td class="codeline">  using namespace PatternMatch;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class="codeline"></td>
    <td class="lineNumber">812</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class="codeline">  Value *C = nullptr;</td>
    <td class="lineNumber">813</td>
    <td class="codeline">  Value *C = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class="codeline">  CmpInst::Predicate P;</td>
    <td class="lineNumber">814</td>
    <td class="codeline">  CmpInst::Predicate P;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class="codeline">  bool TrueIfZero;</td>
    <td class="lineNumber">815</td>
    <td class="codeline">  bool TrueIfZero;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class="codeline"></td>
    <td class="lineNumber">816</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class="codeline">  if (match(CondV, m_ICmp(P, m_Value(C), m_Zero())) ||</td>
    <td class="lineNumber">817</td>
    <td class="codeline">  if (match(CondV, m_ICmp(P, m_Value(C), m_Zero())) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class="codeline">      match(CondV, m_ICmp(P, m_Zero(), m_Value(C)))) {</td>
    <td class="lineNumber">818</td>
    <td class="codeline">      match(CondV, m_ICmp(P, m_Zero(), m_Value(C)))) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class="codeline">    if (P != CmpInst::ICMP_EQ && P != CmpInst::ICMP_NE)</td>
    <td class="lineNumber">819</td>
    <td class="codeline">    if (P != CmpInst::ICMP_EQ && P != CmpInst::ICMP_NE)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">820</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class="codeline">    // Matched: select C == 0 ? ... : ...</td>
    <td class="lineNumber">821</td>
    <td class="codeline">    // Matched: select C == 0 ? ... : ...</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class="codeline">    //          select C != 0 ? ... : ...</td>
    <td class="lineNumber">822</td>
    <td class="codeline">    //          select C != 0 ? ... : ...</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class="codeline">    TrueIfZero = (P == CmpInst::ICMP_EQ);</td>
    <td class="lineNumber">823</td>
    <td class="codeline">    TrueIfZero = (P == CmpInst::ICMP_EQ);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class="codeline">  } else if (match(CondV, m_ICmp(P, m_Value(C), m_One())) ||</td>
    <td class="lineNumber">824</td>
    <td class="codeline">  } else if (match(CondV, m_ICmp(P, m_Value(C), m_One())) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class="codeline">             match(CondV, m_ICmp(P, m_One(), m_Value(C)))) {</td>
    <td class="lineNumber">825</td>
    <td class="codeline">             match(CondV, m_ICmp(P, m_One(), m_Value(C)))) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class="codeline">    if (P != CmpInst::ICMP_EQ && P != CmpInst::ICMP_NE)</td>
    <td class="lineNumber">826</td>
    <td class="codeline">    if (P != CmpInst::ICMP_EQ && P != CmpInst::ICMP_NE)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">827</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class="codeline">    // Matched: select C == 1 ? ... : ...</td>
    <td class="lineNumber">828</td>
    <td class="codeline">    // Matched: select C == 1 ? ... : ...</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class="codeline">    //          select C != 1 ? ... : ...</td>
    <td class="lineNumber">829</td>
    <td class="codeline">    //          select C != 1 ? ... : ...</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class="codeline">    TrueIfZero = (P == CmpInst::ICMP_NE);</td>
    <td class="lineNumber">830</td>
    <td class="codeline">    TrueIfZero = (P == CmpInst::ICMP_NE);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class="codeline">  } else</td>
    <td class="lineNumber">831</td>
    <td class="codeline">  } else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">832</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class="codeline"></td>
    <td class="lineNumber">833</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class="codeline">  Value *X = nullptr;</td>
    <td class="lineNumber">834</td>
    <td class="codeline">  Value *X = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class="codeline">  if (!match(C, m_And(m_Value(X), m_One())) &&</td>
    <td class="lineNumber">835</td>
    <td class="codeline">  if (!match(C, m_And(m_Value(X), m_One())) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class="codeline">      !match(C, m_And(m_One(), m_Value(X))))</td>
    <td class="lineNumber">836</td>
    <td class="codeline">      !match(C, m_And(m_One(), m_Value(X))))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">837</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class="codeline">  // Matched: select (X & 1) == +++ ? ... : ...</td>
    <td class="lineNumber">838</td>
    <td class="codeline">  // Matched: select (X & 1) == +++ ? ... : ...</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class="codeline">  //          select (X & 1) != +++ ? ... : ...</td>
    <td class="lineNumber">839</td>
    <td class="codeline">  //          select (X & 1) != +++ ? ... : ...</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class="codeline"></td>
    <td class="lineNumber">840</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class="codeline">  Value *R = nullptr, *Q = nullptr;</td>
    <td class="lineNumber">841</td>
    <td class="codeline">  Value *R = nullptr, *Q = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class="codeline">  if (TrueIfZero) {</td>
    <td class="lineNumber">842</td>
    <td class="codeline">  if (TrueIfZero) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class="codeline">    // The select's condition is true if the tested bit is 0.</td>
    <td class="lineNumber">843</td>
    <td class="codeline">    // The select's condition is true if the tested bit is 0.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class="codeline">    // TrueV must be the shift, FalseV must be the xor.</td>
    <td class="lineNumber">844</td>
    <td class="codeline">    // TrueV must be the shift, FalseV must be the xor.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class="codeline">    if (!match(TrueV, m_LShr(m_Value(R), m_One())))</td>
    <td class="lineNumber">845</td>
    <td class="codeline">    if (!match(TrueV, m_LShr(m_Value(R), m_One())))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">846</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class="codeline">    // Matched: select +++ ? (R >> 1) : ...</td>
    <td class="lineNumber">847</td>
    <td class="codeline">    // Matched: select +++ ? (R >> 1) : ...</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class="codeline">    if (!match(FalseV, m_Xor(m_Specific(TrueV), m_Value(Q))) &&</td>
    <td class="lineNumber">848</td>
    <td class="codeline">    if (!match(FalseV, m_Xor(m_Specific(TrueV), m_Value(Q))) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class="codeline">        !match(FalseV, m_Xor(m_Value(Q), m_Specific(TrueV))))</td>
    <td class="lineNumber">849</td>
    <td class="codeline">        !match(FalseV, m_Xor(m_Value(Q), m_Specific(TrueV))))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">850</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class="codeline">    // Matched: select +++ ? (R >> 1) : (R >> 1) ^ Q</td>
    <td class="lineNumber">851</td>
    <td class="codeline">    // Matched: select +++ ? (R >> 1) : (R >> 1) ^ Q</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class="codeline">    // with commuting ^.</td>
    <td class="lineNumber">852</td>
    <td class="codeline">    // with commuting ^.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">853</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class="codeline">    // The select's condition is true if the tested bit is 1.</td>
    <td class="lineNumber">854</td>
    <td class="codeline">    // The select's condition is true if the tested bit is 1.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class="codeline">    // TrueV must be the xor, FalseV must be the shift.</td>
    <td class="lineNumber">855</td>
    <td class="codeline">    // TrueV must be the xor, FalseV must be the shift.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class="codeline">    if (!match(FalseV, m_LShr(m_Value(R), m_One())))</td>
    <td class="lineNumber">856</td>
    <td class="codeline">    if (!match(FalseV, m_LShr(m_Value(R), m_One())))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">857</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class="codeline">    // Matched: select +++ ? ... : (R >> 1)</td>
    <td class="lineNumber">858</td>
    <td class="codeline">    // Matched: select +++ ? ... : (R >> 1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class="codeline">    if (!match(TrueV, m_Xor(m_Specific(FalseV), m_Value(Q))) &&</td>
    <td class="lineNumber">859</td>
    <td class="codeline">    if (!match(TrueV, m_Xor(m_Specific(FalseV), m_Value(Q))) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class="codeline">        !match(TrueV, m_Xor(m_Value(Q), m_Specific(FalseV))))</td>
    <td class="lineNumber">860</td>
    <td class="codeline">        !match(TrueV, m_Xor(m_Value(Q), m_Specific(FalseV))))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">861</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class="codeline">    // Matched: select +++ ? (R >> 1) ^ Q : (R >> 1)</td>
    <td class="lineNumber">862</td>
    <td class="codeline">    // Matched: select +++ ? (R >> 1) ^ Q : (R >> 1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class="codeline">    // with commuting ^.</td>
    <td class="lineNumber">863</td>
    <td class="codeline">    // with commuting ^.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">864</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class="codeline"></td>
    <td class="lineNumber">865</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class="codeline">  PV.X = X;</td>
    <td class="lineNumber">866</td>
    <td class="codeline">  PV.X = X;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class="codeline">  PV.Q = Q;</td>
    <td class="lineNumber">867</td>
    <td class="codeline">  PV.Q = Q;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class="codeline">  PV.R = R;</td>
    <td class="lineNumber">868</td>
    <td class="codeline">  PV.R = R;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class="codeline">  PV.Left = false;</td>
    <td class="lineNumber">869</td>
    <td class="codeline">  PV.Left = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="codeline">  return true;</td>
    <td class="lineNumber">870</td>
    <td class="codeline">  return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class="codeline">}</td>
    <td class="lineNumber">871</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">872</td>
    <td class="codeline"></td>
    <td class="lineNumber">872</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">873</td>
    <td class="codeline">bool PolynomialMultiplyRecognize::scanSelect(SelectInst *SelI,</td>
    <td class="lineNumber">873</td>
    <td class="codeline">bool PolynomialMultiplyRecognize::scanSelect(SelectInst *SelI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">874</td>
    <td class="codeline">      BasicBlock *LoopB, BasicBlock *PrehB, Value *CIV, ParsedValues &PV,</td>
    <td class="lineNumber">874</td>
    <td class="codeline">      BasicBlock *LoopB, BasicBlock *PrehB, Value *CIV, ParsedValues &PV,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">875</td>
    <td class="codeline">      bool PreScan) {</td>
    <td class="lineNumber">875</td>
    <td class="codeline">      bool PreScan) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">876</td>
    <td class="codeline">  using namespace PatternMatch;</td>
    <td class="lineNumber">876</td>
    <td class="codeline">  using namespace PatternMatch;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">877</td>
    <td class="codeline"></td>
    <td class="lineNumber">877</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">878</td>
    <td class="codeline">  // The basic pattern for R = P.Q is:</td>
    <td class="lineNumber">878</td>
    <td class="codeline">  // The basic pattern for R = P.Q is:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">879</td>
    <td class="codeline">  // for i = 0..31</td>
    <td class="lineNumber">879</td>
    <td class="codeline">  // for i = 0..31</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">880</td>
    <td class="codeline">  //   R = phi (0, R')</td>
    <td class="lineNumber">880</td>
    <td class="codeline">  //   R = phi (0, R')</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">881</td>
    <td class="codeline">  //   if (P & (1 << i))        ; test-bit(P, i)</td>
    <td class="lineNumber">881</td>
    <td class="codeline">  //   if (P & (1 << i))        ; test-bit(P, i)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">882</td>
    <td class="codeline">  //     R' = R ^ (Q << i)</td>
    <td class="lineNumber">882</td>
    <td class="codeline">  //     R' = R ^ (Q << i)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">883</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">883</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">884</td>
    <td class="codeline">  // Similarly, the basic pattern for R = (P/Q).Q - P</td>
    <td class="lineNumber">884</td>
    <td class="codeline">  // Similarly, the basic pattern for R = (P/Q).Q - P</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">885</td>
    <td class="codeline">  // for i = 0..31</td>
    <td class="lineNumber">885</td>
    <td class="codeline">  // for i = 0..31</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">886</td>
    <td class="codeline">  //   R = phi(P, R')</td>
    <td class="lineNumber">886</td>
    <td class="codeline">  //   R = phi(P, R')</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">887</td>
    <td class="codeline">  //   if (R & (1 << i))</td>
    <td class="lineNumber">887</td>
    <td class="codeline">  //   if (R & (1 << i))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">888</td>
    <td class="codeline">  //     R' = R ^ (Q << i)</td>
    <td class="lineNumber">888</td>
    <td class="codeline">  //     R' = R ^ (Q << i)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">889</td>
    <td class="codeline"></td>
    <td class="lineNumber">889</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">890</td>
    <td class="codeline">  // There exist idioms, where instead of Q being shifted left, P is shifted</td>
    <td class="lineNumber">890</td>
    <td class="codeline">  // There exist idioms, where instead of Q being shifted left, P is shifted</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">891</td>
    <td class="codeline">  // right. This produces a result that is shifted right by 32 bits (the</td>
    <td class="lineNumber">891</td>
    <td class="codeline">  // right. This produces a result that is shifted right by 32 bits (the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">892</td>
    <td class="codeline">  // non-shifted result is 64-bit).</td>
    <td class="lineNumber">892</td>
    <td class="codeline">  // non-shifted result is 64-bit).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">893</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">893</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">894</td>
    <td class="codeline">  // For R = P.Q, this would be:</td>
    <td class="lineNumber">894</td>
    <td class="codeline">  // For R = P.Q, this would be:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">895</td>
    <td class="codeline">  // for i = 0..31</td>
    <td class="lineNumber">895</td>
    <td class="codeline">  // for i = 0..31</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">896</td>
    <td class="codeline">  //   R = phi (0, R')</td>
    <td class="lineNumber">896</td>
    <td class="codeline">  //   R = phi (0, R')</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">897</td>
    <td class="codeline">  //   if ((P >> i) & 1)</td>
    <td class="lineNumber">897</td>
    <td class="codeline">  //   if ((P >> i) & 1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">898</td>
    <td class="codeline">  //     R' = (R >> 1) ^ Q      ; R is cycled through the loop, so it must</td>
    <td class="lineNumber">898</td>
    <td class="codeline">  //     R' = (R >> 1) ^ Q      ; R is cycled through the loop, so it must</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">899</td>
    <td class="codeline">  //   else                     ; be shifted by 1, not i.</td>
    <td class="lineNumber">899</td>
    <td class="codeline">  //   else                     ; be shifted by 1, not i.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">900</td>
    <td class="codeline">  //     R' = R >> 1</td>
    <td class="lineNumber">900</td>
    <td class="codeline">  //     R' = R >> 1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">901</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">901</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">902</td>
    <td class="codeline">  // And for the inverse:</td>
    <td class="lineNumber">902</td>
    <td class="codeline">  // And for the inverse:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">903</td>
    <td class="codeline">  // for i = 0..31</td>
    <td class="lineNumber">903</td>
    <td class="codeline">  // for i = 0..31</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">904</td>
    <td class="codeline">  //   R = phi (P, R')</td>
    <td class="lineNumber">904</td>
    <td class="codeline">  //   R = phi (P, R')</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">905</td>
    <td class="codeline">  //   if (R & 1)</td>
    <td class="lineNumber">905</td>
    <td class="codeline">  //   if (R & 1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">906</td>
    <td class="codeline">  //     R' = (R >> 1) ^ Q</td>
    <td class="lineNumber">906</td>
    <td class="codeline">  //     R' = (R >> 1) ^ Q</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">907</td>
    <td class="codeline">  //   else</td>
    <td class="lineNumber">907</td>
    <td class="codeline">  //   else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">908</td>
    <td class="codeline">  //     R' = R >> 1</td>
    <td class="lineNumber">908</td>
    <td class="codeline">  //     R' = R >> 1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">909</td>
    <td class="codeline"></td>
    <td class="lineNumber">909</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">910</td>
    <td class="codeline">  // The left-shifting idioms share the same pattern:</td>
    <td class="lineNumber">910</td>
    <td class="codeline">  // The left-shifting idioms share the same pattern:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">911</td>
    <td class="codeline">  //   select (X & (1 << i)) ? R ^ (Q << i) : R</td>
    <td class="lineNumber">911</td>
    <td class="codeline">  //   select (X & (1 << i)) ? R ^ (Q << i) : R</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">912</td>
    <td class="codeline">  // Similarly for right-shifting idioms:</td>
    <td class="lineNumber">912</td>
    <td class="codeline">  // Similarly for right-shifting idioms:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">913</td>
    <td class="codeline">  //   select (X & 1) ? (R >> 1) ^ Q</td>
    <td class="lineNumber">913</td>
    <td class="codeline">  //   select (X & 1) ? (R >> 1) ^ Q</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">914</td>
    <td class="codeline"></td>
    <td class="lineNumber">914</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">915</td>
    <td class="codeline">  if (matchLeftShift(SelI, CIV, PV)) {</td>
    <td class="lineNumber">915</td>
    <td class="codeline">  if (matchLeftShift(SelI, CIV, PV)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">916</td>
    <td class="codeline">    // If this is a pre-scan, getting this far is sufficient.</td>
    <td class="lineNumber">916</td>
    <td class="codeline">    // If this is a pre-scan, getting this far is sufficient.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">917</td>
    <td class="codeline">    if (PreScan)</td>
    <td class="lineNumber">917</td>
    <td class="codeline">    if (PreScan)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">918</td>
    <td class="codeline">      return true;</td>
    <td class="lineNumber">918</td>
    <td class="codeline">      return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">919</td>
    <td class="codeline"></td>
    <td class="lineNumber">919</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">920</td>
    <td class="codeline">    // Need to make sure that the SelI goes back into R.</td>
    <td class="lineNumber">920</td>
    <td class="codeline">    // Need to make sure that the SelI goes back into R.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">921</td>
    <td class="codeline">    auto *RPhi = dyn_cast<PHINode>(PV.R);</td>
    <td class="lineNumber">921</td>
    <td class="codeline">    auto *RPhi = dyn_cast<PHINode>(PV.R);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">922</td>
    <td class="codeline">    if (!RPhi)</td>
    <td class="lineNumber">922</td>
    <td class="codeline">    if (!RPhi)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">923</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">923</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">924</td>
    <td class="codeline">    if (SelI != RPhi->getIncomingValueForBlock(LoopB))</td>
    <td class="lineNumber">924</td>
    <td class="codeline">    if (SelI != RPhi->getIncomingValueForBlock(LoopB))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">925</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">925</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">926</td>
    <td class="codeline">    PV.Res = SelI;</td>
    <td class="lineNumber">926</td>
    <td class="codeline">    PV.Res = SelI;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">927</td>
    <td class="codeline"></td>
    <td class="lineNumber">927</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">928</td>
    <td class="codeline">    // If X is loop invariant, it must be the input polynomial, and the</td>
    <td class="lineNumber">928</td>
    <td class="codeline">    // If X is loop invariant, it must be the input polynomial, and the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">929</td>
    <td class="codeline">    // idiom is the basic polynomial multiply.</td>
    <td class="lineNumber">929</td>
    <td class="codeline">    // idiom is the basic polynomial multiply.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">930</td>
    <td class="codeline">    if (CurLoop->isLoopInvariant(PV.X)) {</td>
    <td class="lineNumber">930</td>
    <td class="codeline">    if (CurLoop->isLoopInvariant(PV.X)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">931</td>
    <td class="codeline">      PV.P = PV.X;</td>
    <td class="lineNumber">931</td>
    <td class="codeline">      PV.P = PV.X;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">932</td>
    <td class="codeline">      PV.Inv = false;</td>
    <td class="lineNumber">932</td>
    <td class="codeline">      PV.Inv = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">933</td>
    <td class="codeline">    } else {</td>
    <td class="lineNumber">933</td>
    <td class="codeline">    } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">934</td>
    <td class="codeline">      // X is not loop invariant. If X == R, this is the inverse pmpy.</td>
    <td class="lineNumber">934</td>
    <td class="codeline">      // X is not loop invariant. If X == R, this is the inverse pmpy.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">935</td>
    <td class="codeline">      // Otherwise, check for an xor with an invariant value. If the</td>
    <td class="lineNumber">935</td>
    <td class="codeline">      // Otherwise, check for an xor with an invariant value. If the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">936</td>
    <td class="codeline">      // variable argument to the xor is R, then this is still a valid</td>
    <td class="lineNumber">936</td>
    <td class="codeline">      // variable argument to the xor is R, then this is still a valid</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">937</td>
    <td class="codeline">      // inverse pmpy.</td>
    <td class="lineNumber">937</td>
    <td class="codeline">      // inverse pmpy.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">938</td>
    <td class="codeline">      PV.Inv = true;</td>
    <td class="lineNumber">938</td>
    <td class="codeline">      PV.Inv = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">939</td>
    <td class="codeline">      if (PV.X != PV.R) {</td>
    <td class="lineNumber">939</td>
    <td class="codeline">      if (PV.X != PV.R) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">940</td>
    <td class="codeline">        Value *Var = nullptr, *Inv = nullptr, *X1 = nullptr, *X2 = nullptr;</td>
    <td class="lineNumber">940</td>
    <td class="codeline">        Value *Var = nullptr, *Inv = nullptr, *X1 = nullptr, *X2 = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">941</td>
    <td class="codeline">        if (!match(PV.X, m_Xor(m_Value(X1), m_Value(X2))))</td>
    <td class="lineNumber">941</td>
    <td class="codeline">        if (!match(PV.X, m_Xor(m_Value(X1), m_Value(X2))))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">942</td>
    <td class="codeline">          return false;</td>
    <td class="lineNumber">942</td>
    <td class="codeline">          return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">943</td>
    <td class="codeline">        auto *I1 = dyn_cast<Instruction>(X1);</td>
    <td class="lineNumber">943</td>
    <td class="codeline">        auto *I1 = dyn_cast<Instruction>(X1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">944</td>
    <td class="codeline">        auto *I2 = dyn_cast<Instruction>(X2);</td>
    <td class="lineNumber">944</td>
    <td class="codeline">        auto *I2 = dyn_cast<Instruction>(X2);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">945</td>
    <td class="codeline">        if (!I1 || I1->getParent() != LoopB) {</td>
    <td class="lineNumber">945</td>
    <td class="codeline">        if (!I1 || I1->getParent() != LoopB) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">946</td>
    <td class="codeline">          Var = X2;</td>
    <td class="lineNumber">946</td>
    <td class="codeline">          Var = X2;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">947</td>
    <td class="codeline">          Inv = X1;</td>
    <td class="lineNumber">947</td>
    <td class="codeline">          Inv = X1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">948</td>
    <td class="codeline">        } else if (!I2 || I2->getParent() != LoopB) {</td>
    <td class="lineNumber">948</td>
    <td class="codeline">        } else if (!I2 || I2->getParent() != LoopB) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">949</td>
    <td class="codeline">          Var = X1;</td>
    <td class="lineNumber">949</td>
    <td class="codeline">          Var = X1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">950</td>
    <td class="codeline">          Inv = X2;</td>
    <td class="lineNumber">950</td>
    <td class="codeline">          Inv = X2;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">951</td>
    <td class="codeline">        } else</td>
    <td class="lineNumber">951</td>
    <td class="codeline">        } else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">952</td>
    <td class="codeline">          return false;</td>
    <td class="lineNumber">952</td>
    <td class="codeline">          return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">953</td>
    <td class="codeline">        if (Var != PV.R)</td>
    <td class="lineNumber">953</td>
    <td class="codeline">        if (Var != PV.R)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">954</td>
    <td class="codeline">          return false;</td>
    <td class="lineNumber">954</td>
    <td class="codeline">          return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">955</td>
    <td class="codeline">        PV.M = Inv;</td>
    <td class="lineNumber">955</td>
    <td class="codeline">        PV.M = Inv;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">956</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">956</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">957</td>
    <td class="codeline">      // The input polynomial P still needs to be determined. It will be</td>
    <td class="lineNumber">957</td>
    <td class="codeline">      // The input polynomial P still needs to be determined. It will be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">958</td>
    <td class="codeline">      // the entry value of R.</td>
    <td class="lineNumber">958</td>
    <td class="codeline">      // the entry value of R.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">959</td>
    <td class="codeline">      Value *EntryP = RPhi->getIncomingValueForBlock(PrehB);</td>
    <td class="lineNumber">959</td>
    <td class="codeline">      Value *EntryP = RPhi->getIncomingValueForBlock(PrehB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">960</td>
    <td class="codeline">      PV.P = EntryP;</td>
    <td class="lineNumber">960</td>
    <td class="codeline">      PV.P = EntryP;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">961</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">961</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">962</td>
    <td class="codeline"></td>
    <td class="lineNumber">962</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">963</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">963</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">964</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">964</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">965</td>
    <td class="codeline"></td>
    <td class="lineNumber">965</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">966</td>
    <td class="codeline">  if (matchRightShift(SelI, PV)) {</td>
    <td class="lineNumber">966</td>
    <td class="codeline">  if (matchRightShift(SelI, PV)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">967</td>
    <td class="codeline">    // If this is an inverse pattern, the Q polynomial must be known at</td>
    <td class="lineNumber">967</td>
    <td class="codeline">    // If this is an inverse pattern, the Q polynomial must be known at</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">968</td>
    <td class="codeline">    // compile time.</td>
    <td class="lineNumber">968</td>
    <td class="codeline">    // compile time.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">969</td>
    <td class="codeline">    if (PV.Inv && !isa<ConstantInt>(PV.Q))</td>
    <td class="lineNumber">969</td>
    <td class="codeline">    if (PV.Inv && !isa<ConstantInt>(PV.Q))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">970</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">970</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">971</td>
    <td class="codeline">    if (PreScan)</td>
    <td class="lineNumber">971</td>
    <td class="codeline">    if (PreScan)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">972</td>
    <td class="codeline">      return true;</td>
    <td class="lineNumber">972</td>
    <td class="codeline">      return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">973</td>
    <td class="codeline">    // There is no exact matching of right-shift pmpy.</td>
    <td class="lineNumber">973</td>
    <td class="codeline">    // There is no exact matching of right-shift pmpy.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">974</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">974</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">975</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">975</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">976</td>
    <td class="codeline"></td>
    <td class="lineNumber">976</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">977</td>
    <td class="codeline">  return false;</td>
    <td class="lineNumber">977</td>
    <td class="codeline">  return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">978</td>
    <td class="codeline">}</td>
    <td class="lineNumber">978</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">979</td>
    <td class="codeline"></td>
    <td class="lineNumber">979</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">980</td>
    <td class="codeline">bool PolynomialMultiplyRecognize::isPromotableTo(Value *Val,</td>
    <td class="lineNumber">980</td>
    <td class="codeline">bool PolynomialMultiplyRecognize::isPromotableTo(Value *Val,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">981</td>
    <td class="codeline">      IntegerType *DestTy) {</td>
    <td class="lineNumber">981</td>
    <td class="codeline">      IntegerType *DestTy) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">982</td>
    <td class="codeline">  IntegerType *T = dyn_cast<IntegerType>(Val->getType());</td>
    <td class="lineNumber">982</td>
    <td class="codeline">  IntegerType *T = dyn_cast<IntegerType>(Val->getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">983</td>
    <td class="codeline">  if (!T || T->getBitWidth() > DestTy->getBitWidth())</td>
    <td class="lineNumber">983</td>
    <td class="codeline">  if (!T || T->getBitWidth() > DestTy->getBitWidth())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">984</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">984</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">985</td>
    <td class="codeline">  if (T->getBitWidth() == DestTy->getBitWidth())</td>
    <td class="lineNumber">985</td>
    <td class="codeline">  if (T->getBitWidth() == DestTy->getBitWidth())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">986</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">986</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">987</td>
    <td class="codeline">  // Non-instructions are promotable. The reason why an instruction may not</td>
    <td class="lineNumber">987</td>
    <td class="codeline">  // Non-instructions are promotable. The reason why an instruction may not</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">988</td>
    <td class="codeline">  // be promotable is that it may produce a different result if its operands</td>
    <td class="lineNumber">988</td>
    <td class="codeline">  // be promotable is that it may produce a different result if its operands</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">989</td>
    <td class="codeline">  // and the result are promoted, for example, it may produce more non-zero</td>
    <td class="lineNumber">989</td>
    <td class="codeline">  // and the result are promoted, for example, it may produce more non-zero</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">990</td>
    <td class="codeline">  // bits. While it would still be possible to represent the proper result</td>
    <td class="lineNumber">990</td>
    <td class="codeline">  // bits. While it would still be possible to represent the proper result</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">991</td>
    <td class="codeline">  // in a wider type, it may require adding additional instructions (which</td>
    <td class="lineNumber">991</td>
    <td class="codeline">  // in a wider type, it may require adding additional instructions (which</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">992</td>
    <td class="codeline">  // we don't want to do).</td>
    <td class="lineNumber">992</td>
    <td class="codeline">  // we don't want to do).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">993</td>
    <td class="codeline">  Instruction *In = dyn_cast<Instruction>(Val);</td>
    <td class="lineNumber">993</td>
    <td class="codeline">  Instruction *In = dyn_cast<Instruction>(Val);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">994</td>
    <td class="codeline">  if (!In)</td>
    <td class="lineNumber">994</td>
    <td class="codeline">  if (!In)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">995</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">995</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">996</td>
    <td class="codeline">  // The bitwidth of the source type is smaller than the destination.</td>
    <td class="lineNumber">996</td>
    <td class="codeline">  // The bitwidth of the source type is smaller than the destination.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">997</td>
    <td class="codeline">  // Check if the individual operation can be promoted.</td>
    <td class="lineNumber">997</td>
    <td class="codeline">  // Check if the individual operation can be promoted.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">998</td>
    <td class="codeline">  switch (In->getOpcode()) {</td>
    <td class="lineNumber">998</td>
    <td class="codeline">  switch (In->getOpcode()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">999</td>
    <td class="codeline">    case Instruction::PHI:</td>
    <td class="lineNumber">999</td>
    <td class="codeline">    case Instruction::PHI:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1000</td>
    <td class="codeline">    case Instruction::ZExt:</td>
    <td class="lineNumber">1000</td>
    <td class="codeline">    case Instruction::ZExt:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1001</td>
    <td class="codeline">    case Instruction::And:</td>
    <td class="lineNumber">1001</td>
    <td class="codeline">    case Instruction::And:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1002</td>
    <td class="codeline">    case Instruction::Or:</td>
    <td class="lineNumber">1002</td>
    <td class="codeline">    case Instruction::Or:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1003</td>
    <td class="codeline">    case Instruction::Xor:</td>
    <td class="lineNumber">1003</td>
    <td class="codeline">    case Instruction::Xor:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1004</td>
    <td class="codeline">    case Instruction::LShr: // Shift right is ok.</td>
    <td class="lineNumber">1004</td>
    <td class="codeline">    case Instruction::LShr: // Shift right is ok.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1005</td>
    <td class="codeline">    case Instruction::Select:</td>
    <td class="lineNumber">1005</td>
    <td class="codeline">    case Instruction::Select:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1006</td>
    <td class="codeline">    case Instruction::Trunc:</td>
    <td class="lineNumber">1006</td>
    <td class="codeline">    case Instruction::Trunc:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1007</td>
    <td class="codeline">      return true;</td>
    <td class="lineNumber">1007</td>
    <td class="codeline">      return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1008</td>
    <td class="codeline">    case Instruction::ICmp:</td>
    <td class="lineNumber">1008</td>
    <td class="codeline">    case Instruction::ICmp:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1009</td>
    <td class="codeline">      if (CmpInst *CI = cast<CmpInst>(In))</td>
    <td class="lineNumber">1009</td>
    <td class="codeline">      if (CmpInst *CI = cast<CmpInst>(In))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1010</td>
    <td class="codeline">        return CI->isEquality() || CI->isUnsigned();</td>
    <td class="lineNumber">1010</td>
    <td class="codeline">        return CI->isEquality() || CI->isUnsigned();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1011</td>
    <td class="codeline">      llvm_unreachable("Cast failed unexpectedly");</td>
    <td class="lineNumber">1011</td>
    <td class="codeline">      llvm_unreachable("Cast failed unexpectedly");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1012</td>
    <td class="codeline">    case Instruction::Add:</td>
    <td class="lineNumber">1012</td>
    <td class="codeline">    case Instruction::Add:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1013</td>
    <td class="codeline">      return In->hasNoSignedWrap() && In->hasNoUnsignedWrap();</td>
    <td class="lineNumber">1013</td>
    <td class="codeline">      return In->hasNoSignedWrap() && In->hasNoUnsignedWrap();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1014</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1014</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1015</td>
    <td class="codeline">  return false;</td>
    <td class="lineNumber">1015</td>
    <td class="codeline">  return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1016</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1016</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1017</td>
    <td class="codeline"></td>
    <td class="lineNumber">1017</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1018</td>
    <td class="codeline">void PolynomialMultiplyRecognize::promoteTo(Instruction *In,</td>
    <td class="lineNumber">1018</td>
    <td class="codeline">void PolynomialMultiplyRecognize::promoteTo(Instruction *In,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1019</td>
    <td class="codeline">      IntegerType *DestTy, BasicBlock *LoopB) {</td>
    <td class="lineNumber">1019</td>
    <td class="codeline">      IntegerType *DestTy, BasicBlock *LoopB) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1020</td>
    <td class="codeline">  Type *OrigTy = In->getType();</td>
    <td class="lineNumber">1020</td>
    <td class="codeline">  Type *OrigTy = In->getType();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1021</td>
    <td class="codeline">  assert(!OrigTy->isVoidTy() && "Invalid instruction to promote");</td>
    <td class="lineNumber">1021</td>
    <td class="codeline">  assert(!OrigTy->isVoidTy() && "Invalid instruction to promote");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1022</td>
    <td class="codeline"></td>
    <td class="lineNumber">1022</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1023</td>
    <td class="codeline">  // Leave boolean values alone.</td>
    <td class="lineNumber">1023</td>
    <td class="codeline">  // Leave boolean values alone.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1024</td>
    <td class="codeline">  if (!In->getType()->isIntegerTy(1))</td>
    <td class="lineNumber">1024</td>
    <td class="codeline">  if (!In->getType()->isIntegerTy(1))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1025</td>
    <td class="codeline">    In->mutateType(DestTy);</td>
    <td class="lineNumber">1025</td>
    <td class="codeline">    In->mutateType(DestTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1026</td>
    <td class="codeline">  unsigned DestBW = DestTy->getBitWidth();</td>
    <td class="lineNumber">1026</td>
    <td class="codeline">  unsigned DestBW = DestTy->getBitWidth();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1027</td>
    <td class="codeline"></td>
    <td class="lineNumber">1027</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1028</td>
    <td class="codeline">  // Handle PHIs.</td>
    <td class="lineNumber">1028</td>
    <td class="codeline">  // Handle PHIs.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1029</td>
    <td class="codeline">  if (PHINode *P = dyn_cast<PHINode>(In)) {</td>
    <td class="lineNumber">1029</td>
    <td class="codeline">  if (PHINode *P = dyn_cast<PHINode>(In)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1030</td>
    <td class="codeline">    unsigned N = P->getNumIncomingValues();</td>
    <td class="lineNumber">1030</td>
    <td class="codeline">    unsigned N = P->getNumIncomingValues();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1031</td>
    <td class="codeline">    for (unsigned i = 0; i != N; ++i) {</td>
    <td class="lineNumber">1031</td>
    <td class="codeline">    for (unsigned i = 0; i != N; ++i) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1032</td>
    <td class="codeline">      BasicBlock *InB = P->getIncomingBlock(i);</td>
    <td class="lineNumber">1032</td>
    <td class="codeline">      BasicBlock *InB = P->getIncomingBlock(i);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1033</td>
    <td class="codeline">      if (InB == LoopB)</td>
    <td class="lineNumber">1033</td>
    <td class="codeline">      if (InB == LoopB)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1034</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">1034</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1035</td>
    <td class="codeline">      Value *InV = P->getIncomingValue(i);</td>
    <td class="lineNumber">1035</td>
    <td class="codeline">      Value *InV = P->getIncomingValue(i);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1036</td>
    <td class="codeline">      IntegerType *Ty = cast<IntegerType>(InV->getType());</td>
    <td class="lineNumber">1036</td>
    <td class="codeline">      IntegerType *Ty = cast<IntegerType>(InV->getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1037</td>
    <td class="codeline">      // Do not promote values in PHI nodes of type i1.</td>
    <td class="lineNumber">1037</td>
    <td class="codeline">      // Do not promote values in PHI nodes of type i1.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1038</td>
    <td class="codeline">      if (Ty != P->getType()) {</td>
    <td class="lineNumber">1038</td>
    <td class="codeline">      if (Ty != P->getType()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1039</td>
    <td class="codeline">        // If the value type does not match the PHI type, the PHI type</td>
    <td class="lineNumber">1039</td>
    <td class="codeline">        // If the value type does not match the PHI type, the PHI type</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1040</td>
    <td class="codeline">        // must have been promoted.</td>
    <td class="lineNumber">1040</td>
    <td class="codeline">        // must have been promoted.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1041</td>
    <td class="codeline">        assert(Ty->getBitWidth() < DestBW);</td>
    <td class="lineNumber">1041</td>
    <td class="codeline">        assert(Ty->getBitWidth() < DestBW);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1042</td>
    <td class="codeline">        InV = IRBuilder<>(InB->getTerminator()).CreateZExt(InV, DestTy);</td>
    <td class="lineNumber">1042</td>
    <td class="codeline">        InV = IRBuilder<>(InB->getTerminator()).CreateZExt(InV, DestTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1043</td>
    <td class="codeline">        P->setIncomingValue(i, InV);</td>
    <td class="lineNumber">1043</td>
    <td class="codeline">        P->setIncomingValue(i, InV);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1044</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1044</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1045</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1045</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1046</td>
    <td class="codeline">  } else if (ZExtInst *Z = dyn_cast<ZExtInst>(In)) {</td>
    <td class="lineNumber">1046</td>
    <td class="codeline">  } else if (ZExtInst *Z = dyn_cast<ZExtInst>(In)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1047</td>
    <td class="codeline">    Value *Op = Z->getOperand(0);</td>
    <td class="lineNumber">1047</td>
    <td class="codeline">    Value *Op = Z->getOperand(0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1048</td>
    <td class="codeline">    if (Op->getType() == Z->getType())</td>
    <td class="lineNumber">1048</td>
    <td class="codeline">    if (Op->getType() == Z->getType())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1049</td>
    <td class="codeline">      Z->replaceAllUsesWith(Op);</td>
    <td class="lineNumber">1049</td>
    <td class="codeline">      Z->replaceAllUsesWith(Op);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1050</td>
    <td class="codeline">    Z->eraseFromParent();</td>
    <td class="lineNumber">1050</td>
    <td class="codeline">    Z->eraseFromParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1051</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">1051</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1052</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1052</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1053</td>
    <td class="codeline">  if (TruncInst *T = dyn_cast<TruncInst>(In)) {</td>
    <td class="lineNumber">1053</td>
    <td class="codeline">  if (TruncInst *T = dyn_cast<TruncInst>(In)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1054</td>
    <td class="codeline">    IntegerType *TruncTy = cast<IntegerType>(OrigTy);</td>
    <td class="lineNumber">1054</td>
    <td class="codeline">    IntegerType *TruncTy = cast<IntegerType>(OrigTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1055</td>
    <td class="codeline">    Value *Mask = ConstantInt::get(DestTy, (1u << TruncTy->getBitWidth()) - 1);</td>
    <td class="lineNumber">1055</td>
    <td class="codeline">    Value *Mask = ConstantInt::get(DestTy, (1u << TruncTy->getBitWidth()) - 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1056</td>
    <td class="codeline">    Value *And = IRBuilder<>(In).CreateAnd(T->getOperand(0), Mask);</td>
    <td class="lineNumber">1056</td>
    <td class="codeline">    Value *And = IRBuilder<>(In).CreateAnd(T->getOperand(0), Mask);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1057</td>
    <td class="codeline">    T->replaceAllUsesWith(And);</td>
    <td class="lineNumber">1057</td>
    <td class="codeline">    T->replaceAllUsesWith(And);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1058</td>
    <td class="codeline">    T->eraseFromParent();</td>
    <td class="lineNumber">1058</td>
    <td class="codeline">    T->eraseFromParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1059</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">1059</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1060</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1060</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1061</td>
    <td class="codeline"></td>
    <td class="lineNumber">1061</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1062</td>
    <td class="codeline">  // Promote immediates.</td>
    <td class="lineNumber">1062</td>
    <td class="codeline">  // Promote immediates.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1063</td>
    <td class="codeline">  for (unsigned i = 0, n = In->getNumOperands(); i != n; ++i) {</td>
    <td class="lineNumber">1063</td>
    <td class="codeline">  for (unsigned i = 0, n = In->getNumOperands(); i != n; ++i) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1064</td>
    <td class="codeline">    if (ConstantInt *CI = dyn_cast<ConstantInt>(In->getOperand(i)))</td>
    <td class="lineNumber">1064</td>
    <td class="codeline">    if (ConstantInt *CI = dyn_cast<ConstantInt>(In->getOperand(i)))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1065</td>
    <td class="codeline">      if (CI->getType()->getBitWidth() < DestBW)</td>
    <td class="lineNumber">1065</td>
    <td class="codeline">      if (CI->getType()->getBitWidth() < DestBW)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1066</td>
    <td class="codeline">        In->setOperand(i, ConstantInt::get(DestTy, CI->getZExtValue()));</td>
    <td class="lineNumber">1066</td>
    <td class="codeline">        In->setOperand(i, ConstantInt::get(DestTy, CI->getZExtValue()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1067</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1067</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1068</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1068</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1069</td>
    <td class="codeline"></td>
    <td class="lineNumber">1069</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1070</td>
    <td class="codeline">bool PolynomialMultiplyRecognize::promoteTypes(BasicBlock *LoopB,</td>
    <td class="lineNumber">1070</td>
    <td class="codeline">bool PolynomialMultiplyRecognize::promoteTypes(BasicBlock *LoopB,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1071</td>
    <td class="codeline">      BasicBlock *ExitB) {</td>
    <td class="lineNumber">1071</td>
    <td class="codeline">      BasicBlock *ExitB) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1072</td>
    <td class="codeline">  assert(LoopB);</td>
    <td class="lineNumber">1072</td>
    <td class="codeline">  assert(LoopB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1073</td>
    <td class="codeline">  // Skip loops where the exit block has more than one predecessor. The values</td>
    <td class="lineNumber">1073</td>
    <td class="codeline">  // Skip loops where the exit block has more than one predecessor. The values</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1074</td>
    <td class="codeline">  // coming from the loop block will be promoted to another type, and so the</td>
    <td class="lineNumber">1074</td>
    <td class="codeline">  // coming from the loop block will be promoted to another type, and so the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1075</td>
    <td class="codeline">  // values coming into the exit block from other predecessors would also have</td>
    <td class="lineNumber">1075</td>
    <td class="codeline">  // values coming into the exit block from other predecessors would also have</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1076</td>
    <td class="codeline">  // to be promoted.</td>
    <td class="lineNumber">1076</td>
    <td class="codeline">  // to be promoted.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1077</td>
    <td class="codeline">  if (!ExitB || (ExitB->getSinglePredecessor() != LoopB))</td>
    <td class="lineNumber">1077</td>
    <td class="codeline">  if (!ExitB || (ExitB->getSinglePredecessor() != LoopB))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1078</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1078</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1079</td>
    <td class="codeline">  IntegerType *DestTy = getPmpyType();</td>
    <td class="lineNumber">1079</td>
    <td class="codeline">  IntegerType *DestTy = getPmpyType();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1080</td>
    <td class="codeline">  // Check if the exit values have types that are no wider than the type</td>
    <td class="lineNumber">1080</td>
    <td class="codeline">  // Check if the exit values have types that are no wider than the type</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1081</td>
    <td class="codeline">  // that we want to promote to.</td>
    <td class="lineNumber">1081</td>
    <td class="codeline">  // that we want to promote to.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1082</td>
    <td class="codeline">  unsigned DestBW = DestTy->getBitWidth();</td>
    <td class="lineNumber">1082</td>
    <td class="codeline">  unsigned DestBW = DestTy->getBitWidth();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1083</td>
    <td class="codeline">  for (PHINode &P : ExitB->phis()) {</td>
    <td class="lineNumber">1083</td>
    <td class="codeline">  for (PHINode &P : ExitB->phis()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1084</td>
    <td class="codeline">    if (P.getNumIncomingValues() != 1)</td>
    <td class="lineNumber">1084</td>
    <td class="codeline">    if (P.getNumIncomingValues() != 1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1085</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">1085</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1086</td>
    <td class="codeline">    assert(P.getIncomingBlock(0) == LoopB);</td>
    <td class="lineNumber">1086</td>
    <td class="codeline">    assert(P.getIncomingBlock(0) == LoopB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1087</td>
    <td class="codeline">    IntegerType *T = dyn_cast<IntegerType>(P.getType());</td>
    <td class="lineNumber">1087</td>
    <td class="codeline">    IntegerType *T = dyn_cast<IntegerType>(P.getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1088</td>
    <td class="codeline">    if (!T || T->getBitWidth() > DestBW)</td>
    <td class="lineNumber">1088</td>
    <td class="codeline">    if (!T || T->getBitWidth() > DestBW)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1089</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">1089</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1090</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1090</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1091</td>
    <td class="codeline"></td>
    <td class="lineNumber">1091</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1092</td>
    <td class="codeline">  // Check all instructions in the loop.</td>
    <td class="lineNumber">1092</td>
    <td class="codeline">  // Check all instructions in the loop.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1093</td>
    <td class="codeline">  for (Instruction &In : *LoopB)</td>
    <td class="lineNumber">1093</td>
    <td class="codeline">  for (Instruction &In : *LoopB)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1094</td>
    <td class="codeline">    if (!In.isTerminator() && !isPromotableTo(&In, DestTy))</td>
    <td class="lineNumber">1094</td>
    <td class="codeline">    if (!In.isTerminator() && !isPromotableTo(&In, DestTy))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1095</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">1095</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1096</td>
    <td class="codeline"></td>
    <td class="lineNumber">1096</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1097</td>
    <td class="codeline">  // Perform the promotion.</td>
    <td class="lineNumber">1097</td>
    <td class="codeline">  // Perform the promotion.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1098</td>
    <td class="codeline">  std::vector<Instruction*> LoopIns;</td>
    <td class="lineNumber">1098</td>
    <td class="codeline">  std::vector<Instruction*> LoopIns;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1099</td>
    <td class="codeline">  std::transform(LoopB->begin(), LoopB->end(), std::back_inserter(LoopIns),</td>
    <td class="lineNumber">1099</td>
    <td class="codeline">  std::transform(LoopB->begin(), LoopB->end(), std::back_inserter(LoopIns),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1100</td>
    <td class="codeline">                 [](Instruction &In) { return &In; });</td>
    <td class="lineNumber">1100</td>
    <td class="codeline">                 [](Instruction &In) { return &In; });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1101</td>
    <td class="codeline">  for (Instruction *In : LoopIns)</td>
    <td class="lineNumber">1101</td>
    <td class="codeline">  for (Instruction *In : LoopIns)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1102</td>
    <td class="codeline">    if (!In->isTerminator())</td>
    <td class="lineNumber">1102</td>
    <td class="codeline">    if (!In->isTerminator())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1103</td>
    <td class="codeline">      promoteTo(In, DestTy, LoopB);</td>
    <td class="lineNumber">1103</td>
    <td class="codeline">      promoteTo(In, DestTy, LoopB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1104</td>
    <td class="codeline"></td>
    <td class="lineNumber">1104</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1105</td>
    <td class="codeline">  // Fix up the PHI nodes in the exit block.</td>
    <td class="lineNumber">1105</td>
    <td class="codeline">  // Fix up the PHI nodes in the exit block.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1106</td>
    <td class="codeline">  Instruction *EndI = ExitB->getFirstNonPHI();</td>
    <td class="lineNumber">1106</td>
    <td class="codeline">  Instruction *EndI = ExitB->getFirstNonPHI();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1107</td>
    <td class="codeline">  BasicBlock::iterator End = EndI ? EndI->getIterator() : ExitB->end();</td>
    <td class="lineNumber">1107</td>
    <td class="codeline">  BasicBlock::iterator End = EndI ? EndI->getIterator() : ExitB->end();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1108</td>
    <td class="codeline">  for (auto I = ExitB->begin(); I != End; ++I) {</td>
    <td class="lineNumber">1108</td>
    <td class="codeline">  for (auto I = ExitB->begin(); I != End; ++I) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1109</td>
    <td class="codeline">    PHINode *P = dyn_cast<PHINode>(I);</td>
    <td class="lineNumber">1109</td>
    <td class="codeline">    PHINode *P = dyn_cast<PHINode>(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1110</td>
    <td class="codeline">    if (!P)</td>
    <td class="lineNumber">1110</td>
    <td class="codeline">    if (!P)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1111</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">1111</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1112</td>
    <td class="codeline">    Type *Ty0 = P->getIncomingValue(0)->getType();</td>
    <td class="lineNumber">1112</td>
    <td class="codeline">    Type *Ty0 = P->getIncomingValue(0)->getType();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1113</td>
    <td class="codeline">    Type *PTy = P->getType();</td>
    <td class="lineNumber">1113</td>
    <td class="codeline">    Type *PTy = P->getType();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1114</td>
    <td class="codeline">    if (PTy != Ty0) {</td>
    <td class="lineNumber">1114</td>
    <td class="codeline">    if (PTy != Ty0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1115</td>
    <td class="codeline">      assert(Ty0 == DestTy);</td>
    <td class="lineNumber">1115</td>
    <td class="codeline">      assert(Ty0 == DestTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1116</td>
    <td class="codeline">      // In order to create the trunc, P must have the promoted type.</td>
    <td class="lineNumber">1116</td>
    <td class="codeline">      // In order to create the trunc, P must have the promoted type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1117</td>
    <td class="codeline">      P->mutateType(Ty0);</td>
    <td class="lineNumber">1117</td>
    <td class="codeline">      P->mutateType(Ty0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1118</td>
    <td class="codeline">      Value *T = IRBuilder<>(ExitB, End).CreateTrunc(P, PTy);</td>
    <td class="lineNumber">1118</td>
    <td class="codeline">      Value *T = IRBuilder<>(ExitB, End).CreateTrunc(P, PTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1119</td>
    <td class="codeline">      // In order for the RAUW to work, the types of P and T must match.</td>
    <td class="lineNumber">1119</td>
    <td class="codeline">      // In order for the RAUW to work, the types of P and T must match.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1120</td>
    <td class="codeline">      P->mutateType(PTy);</td>
    <td class="lineNumber">1120</td>
    <td class="codeline">      P->mutateType(PTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1121</td>
    <td class="codeline">      P->replaceAllUsesWith(T);</td>
    <td class="lineNumber">1121</td>
    <td class="codeline">      P->replaceAllUsesWith(T);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1122</td>
    <td class="codeline">      // Final update of the P's type.</td>
    <td class="lineNumber">1122</td>
    <td class="codeline">      // Final update of the P's type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1123</td>
    <td class="codeline">      P->mutateType(Ty0);</td>
    <td class="lineNumber">1123</td>
    <td class="codeline">      P->mutateType(Ty0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1124</td>
    <td class="codeline">      cast<Instruction>(T)->setOperand(0, P);</td>
    <td class="lineNumber">1124</td>
    <td class="codeline">      cast<Instruction>(T)->setOperand(0, P);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1125</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1125</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1126</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1126</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1127</td>
    <td class="codeline"></td>
    <td class="lineNumber">1127</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1128</td>
    <td class="codeline">  return true;</td>
    <td class="lineNumber">1128</td>
    <td class="codeline">  return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1129</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1129</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1130</td>
    <td class="codeline"></td>
    <td class="lineNumber">1130</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1131</td>
    <td class="codeline">bool PolynomialMultiplyRecognize::findCycle(Value *Out, Value *In,</td>
    <td class="lineNumber">1131</td>
    <td class="codeline">bool PolynomialMultiplyRecognize::findCycle(Value *Out, Value *In,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1132</td>
    <td class="codeline">      ValueSeq &Cycle) {</td>
    <td class="lineNumber">1132</td>
    <td class="codeline">      ValueSeq &Cycle) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1133</td>
    <td class="codeline">  // Out = ..., In, ...</td>
    <td class="lineNumber">1133</td>
    <td class="codeline">  // Out = ..., In, ...</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1134</td>
    <td class="codeline">  if (Out == In)</td>
    <td class="lineNumber">1134</td>
    <td class="codeline">  if (Out == In)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1135</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">1135</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1136</td>
    <td class="codeline"></td>
    <td class="lineNumber">1136</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1137</td>
    <td class="codeline">  auto *BB = cast<Instruction>(Out)->getParent();</td>
    <td class="lineNumber">1137</td>
    <td class="codeline">  auto *BB = cast<Instruction>(Out)->getParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1138</td>
    <td class="codeline">  bool HadPhi = false;</td>
    <td class="lineNumber">1138</td>
    <td class="codeline">  bool HadPhi = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1139</td>
    <td class="codeline"></td>
    <td class="lineNumber">1139</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1140</td>
    <td class="codeline">  for (auto *U : Out->users()) {</td>
    <td class="lineNumber">1140</td>
    <td class="codeline">  for (auto *U : Out->users()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1141</td>
    <td class="codeline">    auto *I = dyn_cast<Instruction>(&*U);</td>
    <td class="lineNumber">1141</td>
    <td class="codeline">    auto *I = dyn_cast<Instruction>(&*U);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1142</td>
    <td class="codeline">    if (I == nullptr || I->getParent() != BB)</td>
    <td class="lineNumber">1142</td>
    <td class="codeline">    if (I == nullptr || I->getParent() != BB)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1143</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">1143</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1144</td>
    <td class="codeline">    // Make sure that there are no multi-iteration cycles, e.g.</td>
    <td class="lineNumber">1144</td>
    <td class="codeline">    // Make sure that there are no multi-iteration cycles, e.g.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1145</td>
    <td class="codeline">    //   p1 = phi(p2)</td>
    <td class="lineNumber">1145</td>
    <td class="codeline">    //   p1 = phi(p2)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1146</td>
    <td class="codeline">    //   p2 = phi(p1)</td>
    <td class="lineNumber">1146</td>
    <td class="codeline">    //   p2 = phi(p1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1147</td>
    <td class="codeline">    // The cycle p1->p2->p1 would span two loop iterations.</td>
    <td class="lineNumber">1147</td>
    <td class="codeline">    // The cycle p1->p2->p1 would span two loop iterations.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1148</td>
    <td class="codeline">    // Check that there is only one phi in the cycle.</td>
    <td class="lineNumber">1148</td>
    <td class="codeline">    // Check that there is only one phi in the cycle.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1149</td>
    <td class="codeline">    bool IsPhi = isa<PHINode>(I);</td>
    <td class="lineNumber">1149</td>
    <td class="codeline">    bool IsPhi = isa<PHINode>(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1150</td>
    <td class="codeline">    if (IsPhi && HadPhi)</td>
    <td class="lineNumber">1150</td>
    <td class="codeline">    if (IsPhi && HadPhi)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1151</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">1151</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1152</td>
    <td class="codeline">    HadPhi |= IsPhi;</td>
    <td class="lineNumber">1152</td>
    <td class="codeline">    HadPhi |= IsPhi;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1153</td>
    <td class="codeline">    if (!Cycle.insert(I))</td>
    <td class="lineNumber">1153</td>
    <td class="codeline">    if (!Cycle.insert(I))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1154</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">1154</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1155</td>
    <td class="codeline">    if (findCycle(I, In, Cycle))</td>
    <td class="lineNumber">1155</td>
    <td class="codeline">    if (findCycle(I, In, Cycle))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1156</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">1156</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1157</td>
    <td class="codeline">    Cycle.remove(I);</td>
    <td class="lineNumber">1157</td>
    <td class="codeline">    Cycle.remove(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1158</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1158</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1159</td>
    <td class="codeline">  return !Cycle.empty();</td>
    <td class="lineNumber">1159</td>
    <td class="codeline">  return !Cycle.empty();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1160</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1160</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1161</td>
    <td class="codeline"></td>
    <td class="lineNumber">1161</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1162</td>
    <td class="codeline">void PolynomialMultiplyRecognize::classifyCycle(Instruction *DivI,</td>
    <td class="lineNumber">1162</td>
    <td class="codeline">void PolynomialMultiplyRecognize::classifyCycle(Instruction *DivI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1163</td>
    <td class="codeline">      ValueSeq &Cycle, ValueSeq &Early, ValueSeq &Late) {</td>
    <td class="lineNumber">1163</td>
    <td class="codeline">      ValueSeq &Cycle, ValueSeq &Early, ValueSeq &Late) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1164</td>
    <td class="codeline">  // All the values in the cycle that are between the phi node and the</td>
    <td class="lineNumber">1164</td>
    <td class="codeline">  // All the values in the cycle that are between the phi node and the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1165</td>
    <td class="codeline">  // divider instruction will be classified as "early", all other values</td>
    <td class="lineNumber">1165</td>
    <td class="codeline">  // divider instruction will be classified as "early", all other values</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1166</td>
    <td class="codeline">  // will be "late".</td>
    <td class="lineNumber">1166</td>
    <td class="codeline">  // will be "late".</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1167</td>
    <td class="codeline"></td>
    <td class="lineNumber">1167</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1168</td>
    <td class="codeline">  bool IsE = true;</td>
    <td class="lineNumber">1168</td>
    <td class="codeline">  bool IsE = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1169</td>
    <td class="codeline">  unsigned I, N = Cycle.size();</td>
    <td class="lineNumber">1169</td>
    <td class="codeline">  unsigned I, N = Cycle.size();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1170</td>
    <td class="codeline">  for (I = 0; I < N; ++I) {</td>
    <td class="lineNumber">1170</td>
    <td class="codeline">  for (I = 0; I < N; ++I) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1171</td>
    <td class="codeline">    Value *V = Cycle[I];</td>
    <td class="lineNumber">1171</td>
    <td class="codeline">    Value *V = Cycle[I];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1172</td>
    <td class="codeline">    if (DivI == V)</td>
    <td class="lineNumber">1172</td>
    <td class="codeline">    if (DivI == V)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1173</td>
    <td class="codeline">      IsE = false;</td>
    <td class="lineNumber">1173</td>
    <td class="codeline">      IsE = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1174</td>
    <td class="codeline">    else if (!isa<PHINode>(V))</td>
    <td class="lineNumber">1174</td>
    <td class="codeline">    else if (!isa<PHINode>(V))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1175</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">1175</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1176</td>
    <td class="codeline">    // Stop if found either.</td>
    <td class="lineNumber">1176</td>
    <td class="codeline">    // Stop if found either.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1177</td>
    <td class="codeline">    break;</td>
    <td class="lineNumber">1177</td>
    <td class="codeline">    break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1178</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1178</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1179</td>
    <td class="codeline">  // "I" is the index of either DivI or the phi node, whichever was first.</td>
    <td class="lineNumber">1179</td>
    <td class="codeline">  // "I" is the index of either DivI or the phi node, whichever was first.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1180</td>
    <td class="codeline">  // "E" is "false" or "true" respectively.</td>
    <td class="lineNumber">1180</td>
    <td class="codeline">  // "E" is "false" or "true" respectively.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1181</td>
    <td class="codeline">  ValueSeq &First = !IsE ? Early : Late;</td>
    <td class="lineNumber">1181</td>
    <td class="codeline">  ValueSeq &First = !IsE ? Early : Late;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1182</td>
    <td class="codeline">  for (unsigned J = 0; J < I; ++J)</td>
    <td class="lineNumber">1182</td>
    <td class="codeline">  for (unsigned J = 0; J < I; ++J)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1183</td>
    <td class="codeline">    First.insert(Cycle[J]);</td>
    <td class="lineNumber">1183</td>
    <td class="codeline">    First.insert(Cycle[J]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1184</td>
    <td class="codeline"></td>
    <td class="lineNumber">1184</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1185</td>
    <td class="codeline">  ValueSeq &Second = IsE ? Early : Late;</td>
    <td class="lineNumber">1185</td>
    <td class="codeline">  ValueSeq &Second = IsE ? Early : Late;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1186</td>
    <td class="codeline">  Second.insert(Cycle[I]);</td>
    <td class="lineNumber">1186</td>
    <td class="codeline">  Second.insert(Cycle[I]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1187</td>
    <td class="codeline">  for (++I; I < N; ++I) {</td>
    <td class="lineNumber">1187</td>
    <td class="codeline">  for (++I; I < N; ++I) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1188</td>
    <td class="codeline">    Value *V = Cycle[I];</td>
    <td class="lineNumber">1188</td>
    <td class="codeline">    Value *V = Cycle[I];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1189</td>
    <td class="codeline">    if (DivI == V || isa<PHINode>(V))</td>
    <td class="lineNumber">1189</td>
    <td class="codeline">    if (DivI == V || isa<PHINode>(V))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1190</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">1190</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1191</td>
    <td class="codeline">    Second.insert(V);</td>
    <td class="lineNumber">1191</td>
    <td class="codeline">    Second.insert(V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1192</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1192</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1193</td>
    <td class="codeline"></td>
    <td class="lineNumber">1193</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1194</td>
    <td class="codeline">  for (; I < N; ++I)</td>
    <td class="lineNumber">1194</td>
    <td class="codeline">  for (; I < N; ++I)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1195</td>
    <td class="codeline">    First.insert(Cycle[I]);</td>
    <td class="lineNumber">1195</td>
    <td class="codeline">    First.insert(Cycle[I]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1196</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1196</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1197</td>
    <td class="codeline"></td>
    <td class="lineNumber">1197</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1198</td>
    <td class="codeline">bool PolynomialMultiplyRecognize::classifyInst(Instruction *UseI,</td>
    <td class="lineNumber">1198</td>
    <td class="codeline">bool PolynomialMultiplyRecognize::classifyInst(Instruction *UseI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1199</td>
    <td class="codeline">      ValueSeq &Early, ValueSeq &Late) {</td>
    <td class="lineNumber">1199</td>
    <td class="codeline">      ValueSeq &Early, ValueSeq &Late) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1200</td>
    <td class="codeline">  // Select is an exception, since the condition value does not have to be</td>
    <td class="lineNumber">1200</td>
    <td class="codeline">  // Select is an exception, since the condition value does not have to be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1201</td>
    <td class="codeline">  // classified in the same way as the true/false values. The true/false</td>
    <td class="lineNumber">1201</td>
    <td class="codeline">  // classified in the same way as the true/false values. The true/false</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1202</td>
    <td class="codeline">  // values do have to be both early or both late.</td>
    <td class="lineNumber">1202</td>
    <td class="codeline">  // values do have to be both early or both late.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1203</td>
    <td class="codeline">  if (UseI->getOpcode() == Instruction::Select) {</td>
    <td class="lineNumber">1203</td>
    <td class="codeline">  if (UseI->getOpcode() == Instruction::Select) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1204</td>
    <td class="codeline">    Value *TV = UseI->getOperand(1), *FV = UseI->getOperand(2);</td>
    <td class="lineNumber">1204</td>
    <td class="codeline">    Value *TV = UseI->getOperand(1), *FV = UseI->getOperand(2);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1205</td>
    <td class="codeline">    if (Early.count(TV) || Early.count(FV)) {</td>
    <td class="lineNumber">1205</td>
    <td class="codeline">    if (Early.count(TV) || Early.count(FV)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1206</td>
    <td class="codeline">      if (Late.count(TV) || Late.count(FV))</td>
    <td class="lineNumber">1206</td>
    <td class="codeline">      if (Late.count(TV) || Late.count(FV))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1207</td>
    <td class="codeline">        return false;</td>
    <td class="lineNumber">1207</td>
    <td class="codeline">        return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1208</td>
    <td class="codeline">      Early.insert(UseI);</td>
    <td class="lineNumber">1208</td>
    <td class="codeline">      Early.insert(UseI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1209</td>
    <td class="codeline">    } else if (Late.count(TV) || Late.count(FV)) {</td>
    <td class="lineNumber">1209</td>
    <td class="codeline">    } else if (Late.count(TV) || Late.count(FV)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1210</td>
    <td class="codeline">      if (Early.count(TV) || Early.count(FV))</td>
    <td class="lineNumber">1210</td>
    <td class="codeline">      if (Early.count(TV) || Early.count(FV))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1211</td>
    <td class="codeline">        return false;</td>
    <td class="lineNumber">1211</td>
    <td class="codeline">        return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1212</td>
    <td class="codeline">      Late.insert(UseI);</td>
    <td class="lineNumber">1212</td>
    <td class="codeline">      Late.insert(UseI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1213</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1213</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1214</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">1214</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1215</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1215</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1216</td>
    <td class="codeline"></td>
    <td class="lineNumber">1216</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1217</td>
    <td class="codeline">  // Not sure what would be the example of this, but the code below relies</td>
    <td class="lineNumber">1217</td>
    <td class="codeline">  // Not sure what would be the example of this, but the code below relies</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1218</td>
    <td class="codeline">  // on having at least one operand.</td>
    <td class="lineNumber">1218</td>
    <td class="codeline">  // on having at least one operand.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1219</td>
    <td class="codeline">  if (UseI->getNumOperands() == 0)</td>
    <td class="lineNumber">1219</td>
    <td class="codeline">  if (UseI->getNumOperands() == 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1220</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">1220</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1221</td>
    <td class="codeline"></td>
    <td class="lineNumber">1221</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1222</td>
    <td class="codeline">  bool AE = true, AL = true;</td>
    <td class="lineNumber">1222</td>
    <td class="codeline">  bool AE = true, AL = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1223</td>
    <td class="codeline">  for (auto &I : UseI->operands()) {</td>
    <td class="lineNumber">1223</td>
    <td class="codeline">  for (auto &I : UseI->operands()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1224</td>
    <td class="codeline">    if (Early.count(&*I))</td>
    <td class="lineNumber">1224</td>
    <td class="codeline">    if (Early.count(&*I))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1225</td>
    <td class="codeline">      AL = false;</td>
    <td class="lineNumber">1225</td>
    <td class="codeline">      AL = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1226</td>
    <td class="codeline">    else if (Late.count(&*I))</td>
    <td class="lineNumber">1226</td>
    <td class="codeline">    else if (Late.count(&*I))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1227</td>
    <td class="codeline">      AE = false;</td>
    <td class="lineNumber">1227</td>
    <td class="codeline">      AE = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1228</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1228</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1229</td>
    <td class="codeline">  // If the operands appear "all early" and "all late" at the same time,</td>
    <td class="lineNumber">1229</td>
    <td class="codeline">  // If the operands appear "all early" and "all late" at the same time,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1230</td>
    <td class="codeline">  // then it means that none of them are actually classified as either.</td>
    <td class="lineNumber">1230</td>
    <td class="codeline">  // then it means that none of them are actually classified as either.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1231</td>
    <td class="codeline">  // This is harmless.</td>
    <td class="lineNumber">1231</td>
    <td class="codeline">  // This is harmless.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1232</td>
    <td class="codeline">  if (AE && AL)</td>
    <td class="lineNumber">1232</td>
    <td class="codeline">  if (AE && AL)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1233</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">1233</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1234</td>
    <td class="codeline">  // Conversely, if they are neither "all early" nor "all late", then</td>
    <td class="lineNumber">1234</td>
    <td class="codeline">  // Conversely, if they are neither "all early" nor "all late", then</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1235</td>
    <td class="codeline">  // we have a mixture of early and late operands that is not a known</td>
    <td class="lineNumber">1235</td>
    <td class="codeline">  // we have a mixture of early and late operands that is not a known</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1236</td>
    <td class="codeline">  // exception.</td>
    <td class="lineNumber">1236</td>
    <td class="codeline">  // exception.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1237</td>
    <td class="codeline">  if (!AE && !AL)</td>
    <td class="lineNumber">1237</td>
    <td class="codeline">  if (!AE && !AL)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1238</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1238</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1239</td>
    <td class="codeline"></td>
    <td class="lineNumber">1239</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1240</td>
    <td class="codeline">  // Check that we have covered the two special cases.</td>
    <td class="lineNumber">1240</td>
    <td class="codeline">  // Check that we have covered the two special cases.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1241</td>
    <td class="codeline">  assert(AE != AL);</td>
    <td class="lineNumber">1241</td>
    <td class="codeline">  assert(AE != AL);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1242</td>
    <td class="codeline"></td>
    <td class="lineNumber">1242</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1243</td>
    <td class="codeline">  if (AE)</td>
    <td class="lineNumber">1243</td>
    <td class="codeline">  if (AE)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1244</td>
    <td class="codeline">    Early.insert(UseI);</td>
    <td class="lineNumber">1244</td>
    <td class="codeline">    Early.insert(UseI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1245</td>
    <td class="codeline">  else</td>
    <td class="lineNumber">1245</td>
    <td class="codeline">  else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1246</td>
    <td class="codeline">    Late.insert(UseI);</td>
    <td class="lineNumber">1246</td>
    <td class="codeline">    Late.insert(UseI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1247</td>
    <td class="codeline">  return true;</td>
    <td class="lineNumber">1247</td>
    <td class="codeline">  return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1248</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1248</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1249</td>
    <td class="codeline"></td>
    <td class="lineNumber">1249</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1250</td>
    <td class="codeline">bool PolynomialMultiplyRecognize::commutesWithShift(Instruction *I) {</td>
    <td class="lineNumber">1250</td>
    <td class="codeline">bool PolynomialMultiplyRecognize::commutesWithShift(Instruction *I) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1251</td>
    <td class="codeline">  switch (I->getOpcode()) {</td>
    <td class="lineNumber">1251</td>
    <td class="codeline">  switch (I->getOpcode()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1252</td>
    <td class="codeline">    case Instruction::And:</td>
    <td class="lineNumber">1252</td>
    <td class="codeline">    case Instruction::And:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1253</td>
    <td class="codeline">    case Instruction::Or:</td>
    <td class="lineNumber">1253</td>
    <td class="codeline">    case Instruction::Or:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1254</td>
    <td class="codeline">    case Instruction::Xor:</td>
    <td class="lineNumber">1254</td>
    <td class="codeline">    case Instruction::Xor:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1255</td>
    <td class="codeline">    case Instruction::LShr:</td>
    <td class="lineNumber">1255</td>
    <td class="codeline">    case Instruction::LShr:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1256</td>
    <td class="codeline">    case Instruction::Shl:</td>
    <td class="lineNumber">1256</td>
    <td class="codeline">    case Instruction::Shl:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1257</td>
    <td class="codeline">    case Instruction::Select:</td>
    <td class="lineNumber">1257</td>
    <td class="codeline">    case Instruction::Select:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1258</td>
    <td class="codeline">    case Instruction::ICmp:</td>
    <td class="lineNumber">1258</td>
    <td class="codeline">    case Instruction::ICmp:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1259</td>
    <td class="codeline">    case Instruction::PHI:</td>
    <td class="lineNumber">1259</td>
    <td class="codeline">    case Instruction::PHI:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1260</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">1260</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1261</td>
    <td class="codeline">    default:</td>
    <td class="lineNumber">1261</td>
    <td class="codeline">    default:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1262</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">1262</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1263</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1263</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1264</td>
    <td class="codeline">  return true;</td>
    <td class="lineNumber">1264</td>
    <td class="codeline">  return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1265</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1265</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1266</td>
    <td class="codeline"></td>
    <td class="lineNumber">1266</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1267</td>
    <td class="codeline">bool PolynomialMultiplyRecognize::highBitsAreZero(Value *V,</td>
    <td class="lineNumber">1267</td>
    <td class="codeline">bool PolynomialMultiplyRecognize::highBitsAreZero(Value *V,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1268</td>
    <td class="codeline">      unsigned IterCount) {</td>
    <td class="lineNumber">1268</td>
    <td class="codeline">      unsigned IterCount) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1269</td>
    <td class="codeline">  auto *T = dyn_cast<IntegerType>(V->getType());</td>
    <td class="lineNumber">1269</td>
    <td class="codeline">  auto *T = dyn_cast<IntegerType>(V->getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1270</td>
    <td class="codeline">  if (!T)</td>
    <td class="lineNumber">1270</td>
    <td class="codeline">  if (!T)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1271</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1271</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1272</td>
    <td class="codeline"></td>
    <td class="lineNumber">1272</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1273</td>
    <td class="codeline">  KnownBits Known(T->getBitWidth());</td>
    <td class="lineNumber">1273</td>
    <td class="codeline">  KnownBits Known(T->getBitWidth());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1274</td>
    <td class="codeline">  computeKnownBits(V, Known, DL);</td>
    <td class="lineNumber">1274</td>
    <td class="codeline">  computeKnownBits(V, Known, DL);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1275</td>
    <td class="codeline">  return Known.countMinLeadingZeros() >= IterCount;</td>
    <td class="lineNumber">1275</td>
    <td class="codeline">  return Known.countMinLeadingZeros() >= IterCount;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1276</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1276</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1277</td>
    <td class="codeline"></td>
    <td class="lineNumber">1277</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1278</td>
    <td class="codeline">bool PolynomialMultiplyRecognize::keepsHighBitsZero(Value *V,</td>
    <td class="lineNumber">1278</td>
    <td class="codeline">bool PolynomialMultiplyRecognize::keepsHighBitsZero(Value *V,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1279</td>
    <td class="codeline">      unsigned IterCount) {</td>
    <td class="lineNumber">1279</td>
    <td class="codeline">      unsigned IterCount) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1280</td>
    <td class="codeline">  // Assume that all inputs to the value have the high bits zero.</td>
    <td class="lineNumber">1280</td>
    <td class="codeline">  // Assume that all inputs to the value have the high bits zero.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1281</td>
    <td class="codeline">  // Check if the value itself preserves the zeros in the high bits.</td>
    <td class="lineNumber">1281</td>
    <td class="codeline">  // Check if the value itself preserves the zeros in the high bits.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1282</td>
    <td class="codeline">  if (auto *C = dyn_cast<ConstantInt>(V))</td>
    <td class="lineNumber">1282</td>
    <td class="codeline">  if (auto *C = dyn_cast<ConstantInt>(V))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1283</td>
    <td class="codeline">    return C->getValue().countl_zero() >= IterCount;</td>
    <td class="lineNumber">1283</td>
    <td class="codeline">    return C->getValue().countl_zero() >= IterCount;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1284</td>
    <td class="codeline"></td>
    <td class="lineNumber">1284</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1285</td>
    <td class="codeline">  if (auto *I = dyn_cast<Instruction>(V)) {</td>
    <td class="lineNumber">1285</td>
    <td class="codeline">  if (auto *I = dyn_cast<Instruction>(V)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1286</td>
    <td class="codeline">    switch (I->getOpcode()) {</td>
    <td class="lineNumber">1286</td>
    <td class="codeline">    switch (I->getOpcode()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1287</td>
    <td class="codeline">      case Instruction::And:</td>
    <td class="lineNumber">1287</td>
    <td class="codeline">      case Instruction::And:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1288</td>
    <td class="codeline">      case Instruction::Or:</td>
    <td class="lineNumber">1288</td>
    <td class="codeline">      case Instruction::Or:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1289</td>
    <td class="codeline">      case Instruction::Xor:</td>
    <td class="lineNumber">1289</td>
    <td class="codeline">      case Instruction::Xor:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1290</td>
    <td class="codeline">      case Instruction::LShr:</td>
    <td class="lineNumber">1290</td>
    <td class="codeline">      case Instruction::LShr:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1291</td>
    <td class="codeline">      case Instruction::Select:</td>
    <td class="lineNumber">1291</td>
    <td class="codeline">      case Instruction::Select:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1292</td>
    <td class="codeline">      case Instruction::ICmp:</td>
    <td class="lineNumber">1292</td>
    <td class="codeline">      case Instruction::ICmp:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1293</td>
    <td class="codeline">      case Instruction::PHI:</td>
    <td class="lineNumber">1293</td>
    <td class="codeline">      case Instruction::PHI:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1294</td>
    <td class="codeline">      case Instruction::ZExt:</td>
    <td class="lineNumber">1294</td>
    <td class="codeline">      case Instruction::ZExt:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1295</td>
    <td class="codeline">        return true;</td>
    <td class="lineNumber">1295</td>
    <td class="codeline">        return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1296</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1296</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1297</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1297</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1298</td>
    <td class="codeline"></td>
    <td class="lineNumber">1298</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1299</td>
    <td class="codeline">  return false;</td>
    <td class="lineNumber">1299</td>
    <td class="codeline">  return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1300</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1300</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1301</td>
    <td class="codeline"></td>
    <td class="lineNumber">1301</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1302</td>
    <td class="codeline">bool PolynomialMultiplyRecognize::isOperandShifted(Instruction *I, Value *Op) {</td>
    <td class="lineNumber">1302</td>
    <td class="codeline">bool PolynomialMultiplyRecognize::isOperandShifted(Instruction *I, Value *Op) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1303</td>
    <td class="codeline">  unsigned Opc = I->getOpcode();</td>
    <td class="lineNumber">1303</td>
    <td class="codeline">  unsigned Opc = I->getOpcode();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1304</td>
    <td class="codeline">  if (Opc == Instruction::Shl || Opc == Instruction::LShr)</td>
    <td class="lineNumber">1304</td>
    <td class="codeline">  if (Opc == Instruction::Shl || Opc == Instruction::LShr)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1305</td>
    <td class="codeline">    return Op != I->getOperand(1);</td>
    <td class="lineNumber">1305</td>
    <td class="codeline">    return Op != I->getOperand(1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1306</td>
    <td class="codeline">  return true;</td>
    <td class="lineNumber">1306</td>
    <td class="codeline">  return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1307</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1307</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1308</td>
    <td class="codeline"></td>
    <td class="lineNumber">1308</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1309</td>
    <td class="codeline">bool PolynomialMultiplyRecognize::convertShiftsToLeft(BasicBlock *LoopB,</td>
    <td class="lineNumber">1309</td>
    <td class="codeline">bool PolynomialMultiplyRecognize::convertShiftsToLeft(BasicBlock *LoopB,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1310</td>
    <td class="codeline">      BasicBlock *ExitB, unsigned IterCount) {</td>
    <td class="lineNumber">1310</td>
    <td class="codeline">      BasicBlock *ExitB, unsigned IterCount) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1311</td>
    <td class="codeline">  Value *CIV = getCountIV(LoopB);</td>
    <td class="lineNumber">1311</td>
    <td class="codeline">  Value *CIV = getCountIV(LoopB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1312</td>
    <td class="codeline">  if (CIV == nullptr)</td>
    <td class="lineNumber">1312</td>
    <td class="codeline">  if (CIV == nullptr)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1313</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1313</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1314</td>
    <td class="codeline">  auto *CIVTy = dyn_cast<IntegerType>(CIV->getType());</td>
    <td class="lineNumber">1314</td>
    <td class="codeline">  auto *CIVTy = dyn_cast<IntegerType>(CIV->getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1315</td>
    <td class="codeline">  if (CIVTy == nullptr)</td>
    <td class="lineNumber">1315</td>
    <td class="codeline">  if (CIVTy == nullptr)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1316</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1316</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1317</td>
    <td class="codeline"></td>
    <td class="lineNumber">1317</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1318</td>
    <td class="codeline">  ValueSeq RShifts;</td>
    <td class="lineNumber">1318</td>
    <td class="codeline">  ValueSeq RShifts;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1319</td>
    <td class="codeline">  ValueSeq Early, Late, Cycled;</td>
    <td class="lineNumber">1319</td>
    <td class="codeline">  ValueSeq Early, Late, Cycled;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1320</td>
    <td class="codeline"></td>
    <td class="lineNumber">1320</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1321</td>
    <td class="codeline">  // Find all value cycles that contain logical right shifts by 1.</td>
    <td class="lineNumber">1321</td>
    <td class="codeline">  // Find all value cycles that contain logical right shifts by 1.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1322</td>
    <td class="codeline">  for (Instruction &I : *LoopB) {</td>
    <td class="lineNumber">1322</td>
    <td class="codeline">  for (Instruction &I : *LoopB) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1323</td>
    <td class="codeline">    using namespace PatternMatch;</td>
    <td class="lineNumber">1323</td>
    <td class="codeline">    using namespace PatternMatch;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1324</td>
    <td class="codeline"></td>
    <td class="lineNumber">1324</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1325</td>
    <td class="codeline">    Value *V = nullptr;</td>
    <td class="lineNumber">1325</td>
    <td class="codeline">    Value *V = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1326</td>
    <td class="codeline">    if (!match(&I, m_LShr(m_Value(V), m_One())))</td>
    <td class="lineNumber">1326</td>
    <td class="codeline">    if (!match(&I, m_LShr(m_Value(V), m_One())))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1327</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">1327</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1328</td>
    <td class="codeline">    ValueSeq C;</td>
    <td class="lineNumber">1328</td>
    <td class="codeline">    ValueSeq C;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1329</td>
    <td class="codeline">    if (!findCycle(&I, V, C))</td>
    <td class="lineNumber">1329</td>
    <td class="codeline">    if (!findCycle(&I, V, C))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1330</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">1330</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1331</td>
    <td class="codeline"></td>
    <td class="lineNumber">1331</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1332</td>
    <td class="codeline">    // Found a cycle.</td>
    <td class="lineNumber">1332</td>
    <td class="codeline">    // Found a cycle.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1333</td>
    <td class="codeline">    C.insert(&I);</td>
    <td class="lineNumber">1333</td>
    <td class="codeline">    C.insert(&I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1334</td>
    <td class="codeline">    classifyCycle(&I, C, Early, Late);</td>
    <td class="lineNumber">1334</td>
    <td class="codeline">    classifyCycle(&I, C, Early, Late);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1335</td>
    <td class="codeline">    Cycled.insert(C.begin(), C.end());</td>
    <td class="lineNumber">1335</td>
    <td class="codeline">    Cycled.insert(C.begin(), C.end());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1336</td>
    <td class="codeline">    RShifts.insert(&I);</td>
    <td class="lineNumber">1336</td>
    <td class="codeline">    RShifts.insert(&I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1337</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1337</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1338</td>
    <td class="codeline"></td>
    <td class="lineNumber">1338</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1339</td>
    <td class="codeline">  // Find the set of all values affected by the shift cycles, i.e. all</td>
    <td class="lineNumber">1339</td>
    <td class="codeline">  // Find the set of all values affected by the shift cycles, i.e. all</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1340</td>
    <td class="codeline">  // cycled values, and (recursively) all their users.</td>
    <td class="lineNumber">1340</td>
    <td class="codeline">  // cycled values, and (recursively) all their users.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1341</td>
    <td class="codeline">  ValueSeq Users(Cycled.begin(), Cycled.end());</td>
    <td class="lineNumber">1341</td>
    <td class="codeline">  ValueSeq Users(Cycled.begin(), Cycled.end());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1342</td>
    <td class="codeline">  for (unsigned i = 0; i < Users.size(); ++i) {</td>
    <td class="lineNumber">1342</td>
    <td class="codeline">  for (unsigned i = 0; i < Users.size(); ++i) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1343</td>
    <td class="codeline">    Value *V = Users[i];</td>
    <td class="lineNumber">1343</td>
    <td class="codeline">    Value *V = Users[i];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1344</td>
    <td class="codeline">    if (!isa<IntegerType>(V->getType()))</td>
    <td class="lineNumber">1344</td>
    <td class="codeline">    if (!isa<IntegerType>(V->getType()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1345</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">1345</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1346</td>
    <td class="codeline">    auto *R = cast<Instruction>(V);</td>
    <td class="lineNumber">1346</td>
    <td class="codeline">    auto *R = cast<Instruction>(V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1347</td>
    <td class="codeline">    // If the instruction does not commute with shifts, the loop cannot</td>
    <td class="lineNumber">1347</td>
    <td class="codeline">    // If the instruction does not commute with shifts, the loop cannot</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1348</td>
    <td class="codeline">    // be unshifted.</td>
    <td class="lineNumber">1348</td>
    <td class="codeline">    // be unshifted.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1349</td>
    <td class="codeline">    if (!commutesWithShift(R))</td>
    <td class="lineNumber">1349</td>
    <td class="codeline">    if (!commutesWithShift(R))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1350</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">1350</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1351</td>
    <td class="codeline">    for (User *U : R->users()) {</td>
    <td class="lineNumber">1351</td>
    <td class="codeline">    for (User *U : R->users()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1352</td>
    <td class="codeline">      auto *T = cast<Instruction>(U);</td>
    <td class="lineNumber">1352</td>
    <td class="codeline">      auto *T = cast<Instruction>(U);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1353</td>
    <td class="codeline">      // Skip users from outside of the loop. They will be handled later.</td>
    <td class="lineNumber">1353</td>
    <td class="codeline">      // Skip users from outside of the loop. They will be handled later.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1354</td>
    <td class="codeline">      // Also, skip the right-shifts and phi nodes, since they mix early</td>
    <td class="lineNumber">1354</td>
    <td class="codeline">      // Also, skip the right-shifts and phi nodes, since they mix early</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1355</td>
    <td class="codeline">      // and late values.</td>
    <td class="lineNumber">1355</td>
    <td class="codeline">      // and late values.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1356</td>
    <td class="codeline">      if (T->getParent() != LoopB || RShifts.count(T) || isa<PHINode>(T))</td>
    <td class="lineNumber">1356</td>
    <td class="codeline">      if (T->getParent() != LoopB || RShifts.count(T) || isa<PHINode>(T))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1357</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">1357</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1358</td>
    <td class="codeline"></td>
    <td class="lineNumber">1358</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1359</td>
    <td class="codeline">      Users.insert(T);</td>
    <td class="lineNumber">1359</td>
    <td class="codeline">      Users.insert(T);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1360</td>
    <td class="codeline">      if (!classifyInst(T, Early, Late))</td>
    <td class="lineNumber">1360</td>
    <td class="codeline">      if (!classifyInst(T, Early, Late))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1361</td>
    <td class="codeline">        return false;</td>
    <td class="lineNumber">1361</td>
    <td class="codeline">        return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1362</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1362</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1363</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1363</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1364</td>
    <td class="codeline"></td>
    <td class="lineNumber">1364</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1365</td>
    <td class="codeline">  if (Users.empty())</td>
    <td class="lineNumber">1365</td>
    <td class="codeline">  if (Users.empty())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1366</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1366</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1367</td>
    <td class="codeline"></td>
    <td class="lineNumber">1367</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1368</td>
    <td class="codeline">  // Verify that high bits remain zero.</td>
    <td class="lineNumber">1368</td>
    <td class="codeline">  // Verify that high bits remain zero.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1369</td>
    <td class="codeline">  ValueSeq Internal(Users.begin(), Users.end());</td>
    <td class="lineNumber">1369</td>
    <td class="codeline">  ValueSeq Internal(Users.begin(), Users.end());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1370</td>
    <td class="codeline">  ValueSeq Inputs;</td>
    <td class="lineNumber">1370</td>
    <td class="codeline">  ValueSeq Inputs;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1371</td>
    <td class="codeline">  for (unsigned i = 0; i < Internal.size(); ++i) {</td>
    <td class="lineNumber">1371</td>
    <td class="codeline">  for (unsigned i = 0; i < Internal.size(); ++i) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1372</td>
    <td class="codeline">    auto *R = dyn_cast<Instruction>(Internal[i]);</td>
    <td class="lineNumber">1372</td>
    <td class="codeline">    auto *R = dyn_cast<Instruction>(Internal[i]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1373</td>
    <td class="codeline">    if (!R)</td>
    <td class="lineNumber">1373</td>
    <td class="codeline">    if (!R)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1374</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">1374</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1375</td>
    <td class="codeline">    for (Value *Op : R->operands()) {</td>
    <td class="lineNumber">1375</td>
    <td class="codeline">    for (Value *Op : R->operands()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1376</td>
    <td class="codeline">      auto *T = dyn_cast<Instruction>(Op);</td>
    <td class="lineNumber">1376</td>
    <td class="codeline">      auto *T = dyn_cast<Instruction>(Op);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1377</td>
    <td class="codeline">      if (T && T->getParent() != LoopB)</td>
    <td class="lineNumber">1377</td>
    <td class="codeline">      if (T && T->getParent() != LoopB)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1378</td>
    <td class="codeline">        Inputs.insert(Op);</td>
    <td class="lineNumber">1378</td>
    <td class="codeline">        Inputs.insert(Op);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1379</td>
    <td class="codeline">      else</td>
    <td class="lineNumber">1379</td>
    <td class="codeline">      else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1380</td>
    <td class="codeline">        Internal.insert(Op);</td>
    <td class="lineNumber">1380</td>
    <td class="codeline">        Internal.insert(Op);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1381</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1381</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1382</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1382</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1383</td>
    <td class="codeline">  for (Value *V : Inputs)</td>
    <td class="lineNumber">1383</td>
    <td class="codeline">  for (Value *V : Inputs)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1384</td>
    <td class="codeline">    if (!highBitsAreZero(V, IterCount))</td>
    <td class="lineNumber">1384</td>
    <td class="codeline">    if (!highBitsAreZero(V, IterCount))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1385</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">1385</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1386</td>
    <td class="codeline">  for (Value *V : Internal)</td>
    <td class="lineNumber">1386</td>
    <td class="codeline">  for (Value *V : Internal)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1387</td>
    <td class="codeline">    if (!keepsHighBitsZero(V, IterCount))</td>
    <td class="lineNumber">1387</td>
    <td class="codeline">    if (!keepsHighBitsZero(V, IterCount))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1388</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">1388</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1389</td>
    <td class="codeline"></td>
    <td class="lineNumber">1389</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1390</td>
    <td class="codeline">  // Finally, the work can be done. Unshift each user.</td>
    <td class="lineNumber">1390</td>
    <td class="codeline">  // Finally, the work can be done. Unshift each user.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1391</td>
    <td class="codeline">  IRBuilder<> IRB(LoopB);</td>
    <td class="lineNumber">1391</td>
    <td class="codeline">  IRBuilder<> IRB(LoopB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1392</td>
    <td class="codeline">  std::map<Value*,Value*> ShiftMap;</td>
    <td class="lineNumber">1392</td>
    <td class="codeline">  std::map<Value*,Value*> ShiftMap;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1393</td>
    <td class="codeline"></td>
    <td class="lineNumber">1393</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1394</td>
    <td class="codeline">  using CastMapType = std::map<std::pair<Value *, Type *>, Value *>;</td>
    <td class="lineNumber">1394</td>
    <td class="codeline">  using CastMapType = std::map<std::pair<Value *, Type *>, Value *>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1395</td>
    <td class="codeline"></td>
    <td class="lineNumber">1395</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1396</td>
    <td class="codeline">  CastMapType CastMap;</td>
    <td class="lineNumber">1396</td>
    <td class="codeline">  CastMapType CastMap;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1397</td>
    <td class="codeline"></td>
    <td class="lineNumber">1397</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1398</td>
    <td class="codeline">  auto upcast = [] (CastMapType &CM, IRBuilder<> &IRB, Value *V,</td>
    <td class="lineNumber">1398</td>
    <td class="codeline">  auto upcast = [] (CastMapType &CM, IRBuilder<> &IRB, Value *V,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1399</td>
    <td class="codeline">        IntegerType *Ty) -> Value* {</td>
    <td class="lineNumber">1399</td>
    <td class="codeline">        IntegerType *Ty) -> Value* {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1400</td>
    <td class="codeline">    auto H = CM.find(std::make_pair(V, Ty));</td>
    <td class="lineNumber">1400</td>
    <td class="codeline">    auto H = CM.find(std::make_pair(V, Ty));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1401</td>
    <td class="codeline">    if (H != CM.end())</td>
    <td class="lineNumber">1401</td>
    <td class="codeline">    if (H != CM.end())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1402</td>
    <td class="codeline">      return H->second;</td>
    <td class="lineNumber">1402</td>
    <td class="codeline">      return H->second;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1403</td>
    <td class="codeline">    Value *CV = IRB.CreateIntCast(V, Ty, false);</td>
    <td class="lineNumber">1403</td>
    <td class="codeline">    Value *CV = IRB.CreateIntCast(V, Ty, false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1404</td>
    <td class="codeline">    CM.insert(std::make_pair(std::make_pair(V, Ty), CV));</td>
    <td class="lineNumber">1404</td>
    <td class="codeline">    CM.insert(std::make_pair(std::make_pair(V, Ty), CV));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1405</td>
    <td class="codeline">    return CV;</td>
    <td class="lineNumber">1405</td>
    <td class="codeline">    return CV;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1406</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">1406</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1407</td>
    <td class="codeline"></td>
    <td class="lineNumber">1407</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1408</td>
    <td class="codeline">  for (auto I = LoopB->begin(), E = LoopB->end(); I != E; ++I) {</td>
    <td class="lineNumber">1408</td>
    <td class="codeline">  for (auto I = LoopB->begin(), E = LoopB->end(); I != E; ++I) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1409</td>
    <td class="codeline">    using namespace PatternMatch;</td>
    <td class="lineNumber">1409</td>
    <td class="codeline">    using namespace PatternMatch;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1410</td>
    <td class="codeline"></td>
    <td class="lineNumber">1410</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1411</td>
    <td class="codeline">    if (isa<PHINode>(I) || !Users.count(&*I))</td>
    <td class="lineNumber">1411</td>
    <td class="codeline">    if (isa<PHINode>(I) || !Users.count(&*I))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1412</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">1412</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1413</td>
    <td class="codeline"></td>
    <td class="lineNumber">1413</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1414</td>
    <td class="codeline">    // Match lshr x, 1.</td>
    <td class="lineNumber">1414</td>
    <td class="codeline">    // Match lshr x, 1.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1415</td>
    <td class="codeline">    Value *V = nullptr;</td>
    <td class="lineNumber">1415</td>
    <td class="codeline">    Value *V = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1416</td>
    <td class="codeline">    if (match(&*I, m_LShr(m_Value(V), m_One()))) {</td>
    <td class="lineNumber">1416</td>
    <td class="codeline">    if (match(&*I, m_LShr(m_Value(V), m_One()))) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1417</td>
    <td class="codeline">      replaceAllUsesOfWithIn(&*I, V, LoopB);</td>
    <td class="lineNumber">1417</td>
    <td class="codeline">      replaceAllUsesOfWithIn(&*I, V, LoopB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1418</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">1418</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1419</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1419</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1420</td>
    <td class="codeline">    // For each non-cycled operand, replace it with the corresponding</td>
    <td class="lineNumber">1420</td>
    <td class="codeline">    // For each non-cycled operand, replace it with the corresponding</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1421</td>
    <td class="codeline">    // value shifted left.</td>
    <td class="lineNumber">1421</td>
    <td class="codeline">    // value shifted left.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1422</td>
    <td class="codeline">    for (auto &J : I->operands()) {</td>
    <td class="lineNumber">1422</td>
    <td class="codeline">    for (auto &J : I->operands()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1423</td>
    <td class="codeline">      Value *Op = J.get();</td>
    <td class="lineNumber">1423</td>
    <td class="codeline">      Value *Op = J.get();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1424</td>
    <td class="codeline">      if (!isOperandShifted(&*I, Op))</td>
    <td class="lineNumber">1424</td>
    <td class="codeline">      if (!isOperandShifted(&*I, Op))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1425</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">1425</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1426</td>
    <td class="codeline">      if (Users.count(Op))</td>
    <td class="lineNumber">1426</td>
    <td class="codeline">      if (Users.count(Op))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1427</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">1427</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1428</td>
    <td class="codeline">      // Skip shifting zeros.</td>
    <td class="lineNumber">1428</td>
    <td class="codeline">      // Skip shifting zeros.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1429</td>
    <td class="codeline">      if (isa<ConstantInt>(Op) && cast<ConstantInt>(Op)->isZero())</td>
    <td class="lineNumber">1429</td>
    <td class="codeline">      if (isa<ConstantInt>(Op) && cast<ConstantInt>(Op)->isZero())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1430</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">1430</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1431</td>
    <td class="codeline">      // Check if we have already generated a shift for this value.</td>
    <td class="lineNumber">1431</td>
    <td class="codeline">      // Check if we have already generated a shift for this value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1432</td>
    <td class="codeline">      auto F = ShiftMap.find(Op);</td>
    <td class="lineNumber">1432</td>
    <td class="codeline">      auto F = ShiftMap.find(Op);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1433</td>
    <td class="codeline">      Value *W = (F != ShiftMap.end()) ? F->second : nullptr;</td>
    <td class="lineNumber">1433</td>
    <td class="codeline">      Value *W = (F != ShiftMap.end()) ? F->second : nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1434</td>
    <td class="codeline">      if (W == nullptr) {</td>
    <td class="lineNumber">1434</td>
    <td class="codeline">      if (W == nullptr) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1435</td>
    <td class="codeline">        IRB.SetInsertPoint(&*I);</td>
    <td class="lineNumber">1435</td>
    <td class="codeline">        IRB.SetInsertPoint(&*I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1436</td>
    <td class="codeline">        // First, the shift amount will be CIV or CIV+1, depending on</td>
    <td class="lineNumber">1436</td>
    <td class="codeline">        // First, the shift amount will be CIV or CIV+1, depending on</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1437</td>
    <td class="codeline">        // whether the value is early or late. Instead of creating CIV+1,</td>
    <td class="lineNumber">1437</td>
    <td class="codeline">        // whether the value is early or late. Instead of creating CIV+1,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1438</td>
    <td class="codeline">        // do a single shift of the value.</td>
    <td class="lineNumber">1438</td>
    <td class="codeline">        // do a single shift of the value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1439</td>
    <td class="codeline">        Value *ShAmt = CIV, *ShVal = Op;</td>
    <td class="lineNumber">1439</td>
    <td class="codeline">        Value *ShAmt = CIV, *ShVal = Op;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1440</td>
    <td class="codeline">        auto *VTy = cast<IntegerType>(ShVal->getType());</td>
    <td class="lineNumber">1440</td>
    <td class="codeline">        auto *VTy = cast<IntegerType>(ShVal->getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1441</td>
    <td class="codeline">        auto *ATy = cast<IntegerType>(ShAmt->getType());</td>
    <td class="lineNumber">1441</td>
    <td class="codeline">        auto *ATy = cast<IntegerType>(ShAmt->getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1442</td>
    <td class="codeline">        if (Late.count(&*I))</td>
    <td class="lineNumber">1442</td>
    <td class="codeline">        if (Late.count(&*I))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1443</td>
    <td class="codeline">          ShVal = IRB.CreateShl(Op, ConstantInt::get(VTy, 1));</td>
    <td class="lineNumber">1443</td>
    <td class="codeline">          ShVal = IRB.CreateShl(Op, ConstantInt::get(VTy, 1));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1444</td>
    <td class="codeline">        // Second, the types of the shifted value and the shift amount</td>
    <td class="lineNumber">1444</td>
    <td class="codeline">        // Second, the types of the shifted value and the shift amount</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1445</td>
    <td class="codeline">        // must match.</td>
    <td class="lineNumber">1445</td>
    <td class="codeline">        // must match.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1446</td>
    <td class="codeline">        if (VTy != ATy) {</td>
    <td class="lineNumber">1446</td>
    <td class="codeline">        if (VTy != ATy) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1447</td>
    <td class="codeline">          if (VTy->getBitWidth() < ATy->getBitWidth())</td>
    <td class="lineNumber">1447</td>
    <td class="codeline">          if (VTy->getBitWidth() < ATy->getBitWidth())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1448</td>
    <td class="codeline">            ShVal = upcast(CastMap, IRB, ShVal, ATy);</td>
    <td class="lineNumber">1448</td>
    <td class="codeline">            ShVal = upcast(CastMap, IRB, ShVal, ATy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1449</td>
    <td class="codeline">          else</td>
    <td class="lineNumber">1449</td>
    <td class="codeline">          else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1450</td>
    <td class="codeline">            ShAmt = upcast(CastMap, IRB, ShAmt, VTy);</td>
    <td class="lineNumber">1450</td>
    <td class="codeline">            ShAmt = upcast(CastMap, IRB, ShAmt, VTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1451</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">1451</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1452</td>
    <td class="codeline">        // Ready to generate the shift and memoize it.</td>
    <td class="lineNumber">1452</td>
    <td class="codeline">        // Ready to generate the shift and memoize it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1453</td>
    <td class="codeline">        W = IRB.CreateShl(ShVal, ShAmt);</td>
    <td class="lineNumber">1453</td>
    <td class="codeline">        W = IRB.CreateShl(ShVal, ShAmt);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1454</td>
    <td class="codeline">        ShiftMap.insert(std::make_pair(Op, W));</td>
    <td class="lineNumber">1454</td>
    <td class="codeline">        ShiftMap.insert(std::make_pair(Op, W));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1455</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1455</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1456</td>
    <td class="codeline">      I->replaceUsesOfWith(Op, W);</td>
    <td class="lineNumber">1456</td>
    <td class="codeline">      I->replaceUsesOfWith(Op, W);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1457</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1457</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1458</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1458</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1459</td>
    <td class="codeline"></td>
    <td class="lineNumber">1459</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1460</td>
    <td class="codeline">  // Update the users outside of the loop to account for having left</td>
    <td class="lineNumber">1460</td>
    <td class="codeline">  // Update the users outside of the loop to account for having left</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1461</td>
    <td class="codeline">  // shifts. They would normally be shifted right in the loop, so shift</td>
    <td class="lineNumber">1461</td>
    <td class="codeline">  // shifts. They would normally be shifted right in the loop, so shift</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1462</td>
    <td class="codeline">  // them right after the loop exit.</td>
    <td class="lineNumber">1462</td>
    <td class="codeline">  // them right after the loop exit.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1463</td>
    <td class="codeline">  // Take advantage of the loop-closed SSA form, which has all the post-</td>
    <td class="lineNumber">1463</td>
    <td class="codeline">  // Take advantage of the loop-closed SSA form, which has all the post-</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1464</td>
    <td class="codeline">  // loop values in phi nodes.</td>
    <td class="lineNumber">1464</td>
    <td class="codeline">  // loop values in phi nodes.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1465</td>
    <td class="codeline">  IRB.SetInsertPoint(ExitB, ExitB->getFirstInsertionPt());</td>
    <td class="lineNumber">1465</td>
    <td class="codeline">  IRB.SetInsertPoint(ExitB, ExitB->getFirstInsertionPt());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1466</td>
    <td class="codeline">  for (auto P = ExitB->begin(), Q = ExitB->end(); P != Q; ++P) {</td>
    <td class="lineNumber">1466</td>
    <td class="codeline">  for (auto P = ExitB->begin(), Q = ExitB->end(); P != Q; ++P) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1467</td>
    <td class="codeline">    if (!isa<PHINode>(P))</td>
    <td class="lineNumber">1467</td>
    <td class="codeline">    if (!isa<PHINode>(P))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1468</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">1468</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1469</td>
    <td class="codeline">    auto *PN = cast<PHINode>(P);</td>
    <td class="lineNumber">1469</td>
    <td class="codeline">    auto *PN = cast<PHINode>(P);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1470</td>
    <td class="codeline">    Value *U = PN->getIncomingValueForBlock(LoopB);</td>
    <td class="lineNumber">1470</td>
    <td class="codeline">    Value *U = PN->getIncomingValueForBlock(LoopB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1471</td>
    <td class="codeline">    if (!Users.count(U))</td>
    <td class="lineNumber">1471</td>
    <td class="codeline">    if (!Users.count(U))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1472</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">1472</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1473</td>
    <td class="codeline">    Value *S = IRB.CreateLShr(PN, ConstantInt::get(PN->getType(), IterCount));</td>
    <td class="lineNumber">1473</td>
    <td class="codeline">    Value *S = IRB.CreateLShr(PN, ConstantInt::get(PN->getType(), IterCount));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1474</td>
    <td class="codeline">    PN->replaceAllUsesWith(S);</td>
    <td class="lineNumber">1474</td>
    <td class="codeline">    PN->replaceAllUsesWith(S);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1475</td>
    <td class="codeline">    // The above RAUW will create</td>
    <td class="lineNumber">1475</td>
    <td class="codeline">    // The above RAUW will create</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1476</td>
    <td class="codeline">    //   S = lshr S, IterCount</td>
    <td class="lineNumber">1476</td>
    <td class="codeline">    //   S = lshr S, IterCount</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1477</td>
    <td class="codeline">    // so we need to fix it back into</td>
    <td class="lineNumber">1477</td>
    <td class="codeline">    // so we need to fix it back into</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1478</td>
    <td class="codeline">    //   S = lshr PN, IterCount</td>
    <td class="lineNumber">1478</td>
    <td class="codeline">    //   S = lshr PN, IterCount</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1479</td>
    <td class="codeline">    cast<User>(S)->replaceUsesOfWith(S, PN);</td>
    <td class="lineNumber">1479</td>
    <td class="codeline">    cast<User>(S)->replaceUsesOfWith(S, PN);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1480</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1480</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1481</td>
    <td class="codeline"></td>
    <td class="lineNumber">1481</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1482</td>
    <td class="codeline">  return true;</td>
    <td class="lineNumber">1482</td>
    <td class="codeline">  return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1483</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1483</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1484</td>
    <td class="codeline"></td>
    <td class="lineNumber">1484</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1485</td>
    <td class="codeline">void PolynomialMultiplyRecognize::cleanupLoopBody(BasicBlock *LoopB) {</td>
    <td class="lineNumber">1485</td>
    <td class="codeline">void PolynomialMultiplyRecognize::cleanupLoopBody(BasicBlock *LoopB) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1486</td>
    <td class="codeline">  for (auto &I : *LoopB)</td>
    <td class="lineNumber">1486</td>
    <td class="codeline">  for (auto &I : *LoopB)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1487</td>
    <td class="codeline">    if (Value *SV = simplifyInstruction(&I, {DL, &TLI, &DT}))</td>
    <td class="lineNumber">1487</td>
    <td class="codeline">    if (Value *SV = simplifyInstruction(&I, {DL, &TLI, &DT}))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1488</td>
    <td class="codeline">      I.replaceAllUsesWith(SV);</td>
    <td class="lineNumber">1488</td>
    <td class="codeline">      I.replaceAllUsesWith(SV);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1489</td>
    <td class="codeline"></td>
    <td class="lineNumber">1489</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1490</td>
    <td class="codeline">  for (Instruction &I : llvm::make_early_inc_range(*LoopB))</td>
    <td class="lineNumber">1490</td>
    <td class="codeline">  for (Instruction &I : llvm::make_early_inc_range(*LoopB))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1491</td>
    <td class="codeline">    RecursivelyDeleteTriviallyDeadInstructions(&I, &TLI);</td>
    <td class="lineNumber">1491</td>
    <td class="codeline">    RecursivelyDeleteTriviallyDeadInstructions(&I, &TLI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1492</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1492</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1493</td>
    <td class="codeline"></td>
    <td class="lineNumber">1493</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1494</td>
    <td class="codeline">unsigned PolynomialMultiplyRecognize::getInverseMxN(unsigned QP) {</td>
    <td class="lineNumber">1494</td>
    <td class="codeline">unsigned PolynomialMultiplyRecognize::getInverseMxN(unsigned QP) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1495</td>
    <td class="codeline">  // Arrays of coefficients of Q and the inverse, C.</td>
    <td class="lineNumber">1495</td>
    <td class="codeline">  // Arrays of coefficients of Q and the inverse, C.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1496</td>
    <td class="codeline">  // Q[i] = coefficient at x^i.</td>
    <td class="lineNumber">1496</td>
    <td class="codeline">  // Q[i] = coefficient at x^i.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1497</td>
    <td class="codeline">  std::array<char,32> Q, C;</td>
    <td class="lineNumber">1497</td>
    <td class="codeline">  std::array<char,32> Q, C;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1498</td>
    <td class="codeline"></td>
    <td class="lineNumber">1498</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1499</td>
    <td class="codeline">  for (unsigned i = 0; i < 32; ++i) {</td>
    <td class="lineNumber">1499</td>
    <td class="codeline">  for (unsigned i = 0; i < 32; ++i) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1500</td>
    <td class="codeline">    Q[i] = QP & 1;</td>
    <td class="lineNumber">1500</td>
    <td class="codeline">    Q[i] = QP & 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1501</td>
    <td class="codeline">    QP >>= 1;</td>
    <td class="lineNumber">1501</td>
    <td class="codeline">    QP >>= 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1502</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1502</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1503</td>
    <td class="codeline">  assert(Q[0] == 1);</td>
    <td class="lineNumber">1503</td>
    <td class="codeline">  assert(Q[0] == 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1504</td>
    <td class="codeline"></td>
    <td class="lineNumber">1504</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1505</td>
    <td class="codeline">  // Find C, such that</td>
    <td class="lineNumber">1505</td>
    <td class="codeline">  // Find C, such that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1506</td>
    <td class="codeline">  // (Q[n]*x^n + ... + Q[1]*x + Q[0]) * (C[n]*x^n + ... + C[1]*x + C[0]) = 1</td>
    <td class="lineNumber">1506</td>
    <td class="codeline">  // (Q[n]*x^n + ... + Q[1]*x + Q[0]) * (C[n]*x^n + ... + C[1]*x + C[0]) = 1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1507</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">1507</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1508</td>
    <td class="codeline">  // For it to have a solution, Q[0] must be 1. Since this is Z2[x], the</td>
    <td class="lineNumber">1508</td>
    <td class="codeline">  // For it to have a solution, Q[0] must be 1. Since this is Z2[x], the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1509</td>
    <td class="codeline">  // operations * and + are & and ^ respectively.</td>
    <td class="lineNumber">1509</td>
    <td class="codeline">  // operations * and + are & and ^ respectively.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1510</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">1510</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1511</td>
    <td class="codeline">  // Find C[i] recursively, by comparing i-th coefficient in the product</td>
    <td class="lineNumber">1511</td>
    <td class="codeline">  // Find C[i] recursively, by comparing i-th coefficient in the product</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1512</td>
    <td class="codeline">  // with 0 (or 1 for i=0).</td>
    <td class="lineNumber">1512</td>
    <td class="codeline">  // with 0 (or 1 for i=0).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1513</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">1513</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1514</td>
    <td class="codeline">  // C[0] = 1, since C[0] = Q[0], and Q[0] = 1.</td>
    <td class="lineNumber">1514</td>
    <td class="codeline">  // C[0] = 1, since C[0] = Q[0], and Q[0] = 1.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1515</td>
    <td class="codeline">  C[0] = 1;</td>
    <td class="lineNumber">1515</td>
    <td class="codeline">  C[0] = 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1516</td>
    <td class="codeline">  for (unsigned i = 1; i < 32; ++i) {</td>
    <td class="lineNumber">1516</td>
    <td class="codeline">  for (unsigned i = 1; i < 32; ++i) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1517</td>
    <td class="codeline">    // Solve for C[i] in:</td>
    <td class="lineNumber">1517</td>
    <td class="codeline">    // Solve for C[i] in:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1518</td>
    <td class="codeline">    //   C[0]Q[i] ^ C[1]Q[i-1] ^ ... ^ C[i-1]Q[1] ^ C[i]Q[0] = 0</td>
    <td class="lineNumber">1518</td>
    <td class="codeline">    //   C[0]Q[i] ^ C[1]Q[i-1] ^ ... ^ C[i-1]Q[1] ^ C[i]Q[0] = 0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1519</td>
    <td class="codeline">    // This is equivalent to</td>
    <td class="lineNumber">1519</td>
    <td class="codeline">    // This is equivalent to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1520</td>
    <td class="codeline">    //   C[0]Q[i] ^ C[1]Q[i-1] ^ ... ^ C[i-1]Q[1] ^ C[i] = 0</td>
    <td class="lineNumber">1520</td>
    <td class="codeline">    //   C[0]Q[i] ^ C[1]Q[i-1] ^ ... ^ C[i-1]Q[1] ^ C[i] = 0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1521</td>
    <td class="codeline">    // which is</td>
    <td class="lineNumber">1521</td>
    <td class="codeline">    // which is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1522</td>
    <td class="codeline">    //   C[0]Q[i] ^ C[1]Q[i-1] ^ ... ^ C[i-1]Q[1] = C[i]</td>
    <td class="lineNumber">1522</td>
    <td class="codeline">    //   C[0]Q[i] ^ C[1]Q[i-1] ^ ... ^ C[i-1]Q[1] = C[i]</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1523</td>
    <td class="codeline">    unsigned T = 0;</td>
    <td class="lineNumber">1523</td>
    <td class="codeline">    unsigned T = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1524</td>
    <td class="codeline">    for (unsigned j = 0; j < i; ++j)</td>
    <td class="lineNumber">1524</td>
    <td class="codeline">    for (unsigned j = 0; j < i; ++j)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1525</td>
    <td class="codeline">      T = T ^ (C[j] & Q[i-j]);</td>
    <td class="lineNumber">1525</td>
    <td class="codeline">      T = T ^ (C[j] & Q[i-j]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1526</td>
    <td class="codeline">    C[i] = T;</td>
    <td class="lineNumber">1526</td>
    <td class="codeline">    C[i] = T;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1527</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1527</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1528</td>
    <td class="codeline"></td>
    <td class="lineNumber">1528</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1529</td>
    <td class="codeline">  unsigned QV = 0;</td>
    <td class="lineNumber">1529</td>
    <td class="codeline">  unsigned QV = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1530</td>
    <td class="codeline">  for (unsigned i = 0; i < 32; ++i)</td>
    <td class="lineNumber">1530</td>
    <td class="codeline">  for (unsigned i = 0; i < 32; ++i)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1531</td>
    <td class="codeline">    if (C[i])</td>
    <td class="lineNumber">1531</td>
    <td class="codeline">    if (C[i])</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1532</td>
    <td class="codeline">      QV |= (1 << i);</td>
    <td class="lineNumber">1532</td>
    <td class="codeline">      QV |= (1 << i);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1533</td>
    <td class="codeline"></td>
    <td class="lineNumber">1533</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1534</td>
    <td class="codeline">  return QV;</td>
    <td class="lineNumber">1534</td>
    <td class="codeline">  return QV;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1535</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1535</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1536</td>
    <td class="codeline"></td>
    <td class="lineNumber">1536</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1537</td>
    <td class="codeline">Value *PolynomialMultiplyRecognize::generate(BasicBlock::iterator At,</td>
    <td class="lineNumber">1537</td>
    <td class="codeline">Value *PolynomialMultiplyRecognize::generate(BasicBlock::iterator At,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1538</td>
    <td class="codeline">      ParsedValues &PV) {</td>
    <td class="lineNumber">1538</td>
    <td class="codeline">      ParsedValues &PV) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1539</td>
    <td class="codeline">  IRBuilder<> B(&*At);</td>
    <td class="lineNumber">1539</td>
    <td class="codeline">  IRBuilder<> B(&*At);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1540</td>
    <td class="codeline">  Module *M = At->getParent()->getParent()->getParent();</td>
    <td class="lineNumber">1540</td>
    <td class="codeline">  Module *M = At->getParent()->getParent()->getParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1541</td>
    <td class="codeline">  Function *PMF = Intrinsic::getDeclaration(M, Intrinsic::hexagon_M4_pmpyw);</td>
    <td class="lineNumber">1541</td>
    <td class="codeline">  Function *PMF = Intrinsic::getDeclaration(M, Intrinsic::hexagon_M4_pmpyw);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1542</td>
    <td class="codeline"></td>
    <td class="lineNumber">1542</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1543</td>
    <td class="codeline">  Value *P = PV.P, *Q = PV.Q, *P0 = P;</td>
    <td class="lineNumber">1543</td>
    <td class="codeline">  Value *P = PV.P, *Q = PV.Q, *P0 = P;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1544</td>
    <td class="codeline">  unsigned IC = PV.IterCount;</td>
    <td class="lineNumber">1544</td>
    <td class="codeline">  unsigned IC = PV.IterCount;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1545</td>
    <td class="codeline"></td>
    <td class="lineNumber">1545</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1546</td>
    <td class="codeline">  if (PV.M != nullptr)</td>
    <td class="lineNumber">1546</td>
    <td class="codeline">  if (PV.M != nullptr)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1547</td>
    <td class="codeline">    P0 = P = B.CreateXor(P, PV.M);</td>
    <td class="lineNumber">1547</td>
    <td class="codeline">    P0 = P = B.CreateXor(P, PV.M);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1548</td>
    <td class="codeline"></td>
    <td class="lineNumber">1548</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1549</td>
    <td class="codeline">  // Create a bit mask to clear the high bits beyond IterCount.</td>
    <td class="lineNumber">1549</td>
    <td class="codeline">  // Create a bit mask to clear the high bits beyond IterCount.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1550</td>
    <td class="codeline">  auto *BMI = ConstantInt::get(P->getType(), APInt::getLowBitsSet(32, IC));</td>
    <td class="lineNumber">1550</td>
    <td class="codeline">  auto *BMI = ConstantInt::get(P->getType(), APInt::getLowBitsSet(32, IC));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1551</td>
    <td class="codeline"></td>
    <td class="lineNumber">1551</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1552</td>
    <td class="codeline">  if (PV.IterCount != 32)</td>
    <td class="lineNumber">1552</td>
    <td class="codeline">  if (PV.IterCount != 32)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1553</td>
    <td class="codeline">    P = B.CreateAnd(P, BMI);</td>
    <td class="lineNumber">1553</td>
    <td class="codeline">    P = B.CreateAnd(P, BMI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1554</td>
    <td class="codeline"></td>
    <td class="lineNumber">1554</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1555</td>
    <td class="codeline">  if (PV.Inv) {</td>
    <td class="lineNumber">1555</td>
    <td class="codeline">  if (PV.Inv) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1556</td>
    <td class="codeline">    auto *QI = dyn_cast<ConstantInt>(PV.Q);</td>
    <td class="lineNumber">1556</td>
    <td class="codeline">    auto *QI = dyn_cast<ConstantInt>(PV.Q);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1557</td>
    <td class="codeline">    assert(QI && QI->getBitWidth() <= 32);</td>
    <td class="lineNumber">1557</td>
    <td class="codeline">    assert(QI && QI->getBitWidth() <= 32);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1558</td>
    <td class="codeline"></td>
    <td class="lineNumber">1558</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1559</td>
    <td class="codeline">    // Again, clearing bits beyond IterCount.</td>
    <td class="lineNumber">1559</td>
    <td class="codeline">    // Again, clearing bits beyond IterCount.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1560</td>
    <td class="codeline">    unsigned M = (1 << PV.IterCount) - 1;</td>
    <td class="lineNumber">1560</td>
    <td class="codeline">    unsigned M = (1 << PV.IterCount) - 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1561</td>
    <td class="codeline">    unsigned Tmp = (QI->getZExtValue() | 1) & M;</td>
    <td class="lineNumber">1561</td>
    <td class="codeline">    unsigned Tmp = (QI->getZExtValue() | 1) & M;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1562</td>
    <td class="codeline">    unsigned QV = getInverseMxN(Tmp) & M;</td>
    <td class="lineNumber">1562</td>
    <td class="codeline">    unsigned QV = getInverseMxN(Tmp) & M;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1563</td>
    <td class="codeline">    auto *QVI = ConstantInt::get(QI->getType(), QV);</td>
    <td class="lineNumber">1563</td>
    <td class="codeline">    auto *QVI = ConstantInt::get(QI->getType(), QV);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1564</td>
    <td class="codeline">    P = B.CreateCall(PMF, {P, QVI});</td>
    <td class="lineNumber">1564</td>
    <td class="codeline">    P = B.CreateCall(PMF, {P, QVI});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1565</td>
    <td class="codeline">    P = B.CreateTrunc(P, QI->getType());</td>
    <td class="lineNumber">1565</td>
    <td class="codeline">    P = B.CreateTrunc(P, QI->getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1566</td>
    <td class="codeline">    if (IC != 32)</td>
    <td class="lineNumber">1566</td>
    <td class="codeline">    if (IC != 32)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1567</td>
    <td class="codeline">      P = B.CreateAnd(P, BMI);</td>
    <td class="lineNumber">1567</td>
    <td class="codeline">      P = B.CreateAnd(P, BMI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1568</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1568</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1569</td>
    <td class="codeline"></td>
    <td class="lineNumber">1569</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1570</td>
    <td class="codeline">  Value *R = B.CreateCall(PMF, {P, Q});</td>
    <td class="lineNumber">1570</td>
    <td class="codeline">  Value *R = B.CreateCall(PMF, {P, Q});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1571</td>
    <td class="codeline"></td>
    <td class="lineNumber">1571</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1572</td>
    <td class="codeline">  if (PV.M != nullptr)</td>
    <td class="lineNumber">1572</td>
    <td class="codeline">  if (PV.M != nullptr)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1573</td>
    <td class="codeline">    R = B.CreateXor(R, B.CreateIntCast(P0, R->getType(), false));</td>
    <td class="lineNumber">1573</td>
    <td class="codeline">    R = B.CreateXor(R, B.CreateIntCast(P0, R->getType(), false));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1574</td>
    <td class="codeline"></td>
    <td class="lineNumber">1574</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1575</td>
    <td class="codeline">  return R;</td>
    <td class="lineNumber">1575</td>
    <td class="codeline">  return R;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1576</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1576</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1577</td>
    <td class="codeline"></td>
    <td class="lineNumber">1577</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1578</td>
    <td class="codeline">static bool hasZeroSignBit(const Value *V) {</td>
    <td class="lineNumber">1578</td>
    <td class="codeline">static bool hasZeroSignBit(const Value *V) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1579</td>
    <td class="codeline">  if (const auto *CI = dyn_cast<const ConstantInt>(V))</td>
    <td class="lineNumber">1579</td>
    <td class="codeline">  if (const auto *CI = dyn_cast<const ConstantInt>(V))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1580</td>
    <td class="codeline">    return (CI->getType()->getSignBit() & CI->getSExtValue()) == 0;</td>
    <td class="lineNumber">1580</td>
    <td class="codeline">    return (CI->getType()->getSignBit() & CI->getSExtValue()) == 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1581</td>
    <td class="codeline">  const Instruction *I = dyn_cast<const Instruction>(V);</td>
    <td class="lineNumber">1581</td>
    <td class="codeline">  const Instruction *I = dyn_cast<const Instruction>(V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1582</td>
    <td class="codeline">  if (!I)</td>
    <td class="lineNumber">1582</td>
    <td class="codeline">  if (!I)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1583</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1583</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1584</td>
    <td class="codeline">  switch (I->getOpcode()) {</td>
    <td class="lineNumber">1584</td>
    <td class="codeline">  switch (I->getOpcode()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1585</td>
    <td class="codeline">    case Instruction::LShr:</td>
    <td class="lineNumber">1585</td>
    <td class="codeline">    case Instruction::LShr:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1586</td>
    <td class="codeline">      if (const auto SI = dyn_cast<const ConstantInt>(I->getOperand(1)))</td>
    <td class="lineNumber">1586</td>
    <td class="codeline">      if (const auto SI = dyn_cast<const ConstantInt>(I->getOperand(1)))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1587</td>
    <td class="codeline">        return SI->getZExtValue() > 0;</td>
    <td class="lineNumber">1587</td>
    <td class="codeline">        return SI->getZExtValue() > 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1588</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">1588</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1589</td>
    <td class="codeline">    case Instruction::Or:</td>
    <td class="lineNumber">1589</td>
    <td class="codeline">    case Instruction::Or:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1590</td>
    <td class="codeline">    case Instruction::Xor:</td>
    <td class="lineNumber">1590</td>
    <td class="codeline">    case Instruction::Xor:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1591</td>
    <td class="codeline">      return hasZeroSignBit(I->getOperand(0)) &&</td>
    <td class="lineNumber">1591</td>
    <td class="codeline">      return hasZeroSignBit(I->getOperand(0)) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1592</td>
    <td class="codeline">             hasZeroSignBit(I->getOperand(1));</td>
    <td class="lineNumber">1592</td>
    <td class="codeline">             hasZeroSignBit(I->getOperand(1));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1593</td>
    <td class="codeline">    case Instruction::And:</td>
    <td class="lineNumber">1593</td>
    <td class="codeline">    case Instruction::And:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1594</td>
    <td class="codeline">      return hasZeroSignBit(I->getOperand(0)) ||</td>
    <td class="lineNumber">1594</td>
    <td class="codeline">      return hasZeroSignBit(I->getOperand(0)) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1595</td>
    <td class="codeline">             hasZeroSignBit(I->getOperand(1));</td>
    <td class="lineNumber">1595</td>
    <td class="codeline">             hasZeroSignBit(I->getOperand(1));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1596</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1596</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1597</td>
    <td class="codeline">  return false;</td>
    <td class="lineNumber">1597</td>
    <td class="codeline">  return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1598</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1598</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1599</td>
    <td class="codeline"></td>
    <td class="lineNumber">1599</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1600</td>
    <td class="codeline">void PolynomialMultiplyRecognize::setupPreSimplifier(Simplifier &S) {</td>
    <td class="lineNumber">1600</td>
    <td class="codeline">void PolynomialMultiplyRecognize::setupPreSimplifier(Simplifier &S) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1601</td>
    <td class="codeline">  S.addRule("sink-zext",</td>
    <td class="lineNumber">1601</td>
    <td class="codeline">  S.addRule("sink-zext",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1602</td>
    <td class="codeline">    // Sink zext past bitwise operations.</td>
    <td class="lineNumber">1602</td>
    <td class="codeline">    // Sink zext past bitwise operations.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1603</td>
    <td class="codeline">    [](Instruction *I, LLVMContext &Ctx) -> Value* {</td>
    <td class="lineNumber">1603</td>
    <td class="codeline">    [](Instruction *I, LLVMContext &Ctx) -> Value* {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1604</td>
    <td class="codeline">      if (I->getOpcode() != Instruction::ZExt)</td>
    <td class="lineNumber">1604</td>
    <td class="codeline">      if (I->getOpcode() != Instruction::ZExt)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1605</td>
    <td class="codeline">        return nullptr;</td>
    <td class="lineNumber">1605</td>
    <td class="codeline">        return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1606</td>
    <td class="codeline">      Instruction *T = dyn_cast<Instruction>(I->getOperand(0));</td>
    <td class="lineNumber">1606</td>
    <td class="codeline">      Instruction *T = dyn_cast<Instruction>(I->getOperand(0));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1607</td>
    <td class="codeline">      if (!T)</td>
    <td class="lineNumber">1607</td>
    <td class="codeline">      if (!T)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1608</td>
    <td class="codeline">        return nullptr;</td>
    <td class="lineNumber">1608</td>
    <td class="codeline">        return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1609</td>
    <td class="codeline">      switch (T->getOpcode()) {</td>
    <td class="lineNumber">1609</td>
    <td class="codeline">      switch (T->getOpcode()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1610</td>
    <td class="codeline">        case Instruction::And:</td>
    <td class="lineNumber">1610</td>
    <td class="codeline">        case Instruction::And:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1611</td>
    <td class="codeline">        case Instruction::Or:</td>
    <td class="lineNumber">1611</td>
    <td class="codeline">        case Instruction::Or:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1612</td>
    <td class="codeline">        case Instruction::Xor:</td>
    <td class="lineNumber">1612</td>
    <td class="codeline">        case Instruction::Xor:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1613</td>
    <td class="codeline">          break;</td>
    <td class="lineNumber">1613</td>
    <td class="codeline">          break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1614</td>
    <td class="codeline">        default:</td>
    <td class="lineNumber">1614</td>
    <td class="codeline">        default:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1615</td>
    <td class="codeline">          return nullptr;</td>
    <td class="lineNumber">1615</td>
    <td class="codeline">          return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1616</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1616</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1617</td>
    <td class="codeline">      IRBuilder<> B(Ctx);</td>
    <td class="lineNumber">1617</td>
    <td class="codeline">      IRBuilder<> B(Ctx);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1618</td>
    <td class="codeline">      return B.CreateBinOp(cast<BinaryOperator>(T)->getOpcode(),</td>
    <td class="lineNumber">1618</td>
    <td class="codeline">      return B.CreateBinOp(cast<BinaryOperator>(T)->getOpcode(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1619</td>
    <td class="codeline">                           B.CreateZExt(T->getOperand(0), I->getType()),</td>
    <td class="lineNumber">1619</td>
    <td class="codeline">                           B.CreateZExt(T->getOperand(0), I->getType()),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1620</td>
    <td class="codeline">                           B.CreateZExt(T->getOperand(1), I->getType()));</td>
    <td class="lineNumber">1620</td>
    <td class="codeline">                           B.CreateZExt(T->getOperand(1), I->getType()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1621</td>
    <td class="codeline">    });</td>
    <td class="lineNumber">1621</td>
    <td class="codeline">    });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1622</td>
    <td class="codeline">  S.addRule("xor/and -> and/xor",</td>
    <td class="lineNumber">1622</td>
    <td class="codeline">  S.addRule("xor/and -> and/xor",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1623</td>
    <td class="codeline">    // (xor (and x a) (and y a)) -> (and (xor x y) a)</td>
    <td class="lineNumber">1623</td>
    <td class="codeline">    // (xor (and x a) (and y a)) -> (and (xor x y) a)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1624</td>
    <td class="codeline">    [](Instruction *I, LLVMContext &Ctx) -> Value* {</td>
    <td class="lineNumber">1624</td>
    <td class="codeline">    [](Instruction *I, LLVMContext &Ctx) -> Value* {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1625</td>
    <td class="codeline">      if (I->getOpcode() != Instruction::Xor)</td>
    <td class="lineNumber">1625</td>
    <td class="codeline">      if (I->getOpcode() != Instruction::Xor)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1626</td>
    <td class="codeline">        return nullptr;</td>
    <td class="lineNumber">1626</td>
    <td class="codeline">        return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1627</td>
    <td class="codeline">      Instruction *And0 = dyn_cast<Instruction>(I->getOperand(0));</td>
    <td class="lineNumber">1627</td>
    <td class="codeline">      Instruction *And0 = dyn_cast<Instruction>(I->getOperand(0));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1628</td>
    <td class="codeline">      Instruction *And1 = dyn_cast<Instruction>(I->getOperand(1));</td>
    <td class="lineNumber">1628</td>
    <td class="codeline">      Instruction *And1 = dyn_cast<Instruction>(I->getOperand(1));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1629</td>
    <td class="codeline">      if (!And0 || !And1)</td>
    <td class="lineNumber">1629</td>
    <td class="codeline">      if (!And0 || !And1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1630</td>
    <td class="codeline">        return nullptr;</td>
    <td class="lineNumber">1630</td>
    <td class="codeline">        return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1631</td>
    <td class="codeline">      if (And0->getOpcode() != Instruction::And ||</td>
    <td class="lineNumber">1631</td>
    <td class="codeline">      if (And0->getOpcode() != Instruction::And ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1632</td>
    <td class="codeline">          And1->getOpcode() != Instruction::And)</td>
    <td class="lineNumber">1632</td>
    <td class="codeline">          And1->getOpcode() != Instruction::And)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1633</td>
    <td class="codeline">        return nullptr;</td>
    <td class="lineNumber">1633</td>
    <td class="codeline">        return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1634</td>
    <td class="codeline">      if (And0->getOperand(1) != And1->getOperand(1))</td>
    <td class="lineNumber">1634</td>
    <td class="codeline">      if (And0->getOperand(1) != And1->getOperand(1))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1635</td>
    <td class="codeline">        return nullptr;</td>
    <td class="lineNumber">1635</td>
    <td class="codeline">        return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1636</td>
    <td class="codeline">      IRBuilder<> B(Ctx);</td>
    <td class="lineNumber">1636</td>
    <td class="codeline">      IRBuilder<> B(Ctx);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1637</td>
    <td class="codeline">      return B.CreateAnd(B.CreateXor(And0->getOperand(0), And1->getOperand(0)),</td>
    <td class="lineNumber">1637</td>
    <td class="codeline">      return B.CreateAnd(B.CreateXor(And0->getOperand(0), And1->getOperand(0)),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1638</td>
    <td class="codeline">                         And0->getOperand(1));</td>
    <td class="lineNumber">1638</td>
    <td class="codeline">                         And0->getOperand(1));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1639</td>
    <td class="codeline">    });</td>
    <td class="lineNumber">1639</td>
    <td class="codeline">    });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1640</td>
    <td class="codeline">  S.addRule("sink binop into select",</td>
    <td class="lineNumber">1640</td>
    <td class="codeline">  S.addRule("sink binop into select",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1641</td>
    <td class="codeline">    // (Op (select c x y) z) -> (select c (Op x z) (Op y z))</td>
    <td class="lineNumber">1641</td>
    <td class="codeline">    // (Op (select c x y) z) -> (select c (Op x z) (Op y z))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1642</td>
    <td class="codeline">    // (Op x (select c y z)) -> (select c (Op x y) (Op x z))</td>
    <td class="lineNumber">1642</td>
    <td class="codeline">    // (Op x (select c y z)) -> (select c (Op x y) (Op x z))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1643</td>
    <td class="codeline">    [](Instruction *I, LLVMContext &Ctx) -> Value* {</td>
    <td class="lineNumber">1643</td>
    <td class="codeline">    [](Instruction *I, LLVMContext &Ctx) -> Value* {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1644</td>
    <td class="codeline">      BinaryOperator *BO = dyn_cast<BinaryOperator>(I);</td>
    <td class="lineNumber">1644</td>
    <td class="codeline">      BinaryOperator *BO = dyn_cast<BinaryOperator>(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1645</td>
    <td class="codeline">      if (!BO)</td>
    <td class="lineNumber">1645</td>
    <td class="codeline">      if (!BO)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1646</td>
    <td class="codeline">        return nullptr;</td>
    <td class="lineNumber">1646</td>
    <td class="codeline">        return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1647</td>
    <td class="codeline">      Instruction::BinaryOps Op = BO->getOpcode();</td>
    <td class="lineNumber">1647</td>
    <td class="codeline">      Instruction::BinaryOps Op = BO->getOpcode();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1648</td>
    <td class="codeline">      if (SelectInst *Sel = dyn_cast<SelectInst>(BO->getOperand(0))) {</td>
    <td class="lineNumber">1648</td>
    <td class="codeline">      if (SelectInst *Sel = dyn_cast<SelectInst>(BO->getOperand(0))) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1649</td>
    <td class="codeline">        IRBuilder<> B(Ctx);</td>
    <td class="lineNumber">1649</td>
    <td class="codeline">        IRBuilder<> B(Ctx);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1650</td>
    <td class="codeline">        Value *X = Sel->getTrueValue(), *Y = Sel->getFalseValue();</td>
    <td class="lineNumber">1650</td>
    <td class="codeline">        Value *X = Sel->getTrueValue(), *Y = Sel->getFalseValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1651</td>
    <td class="codeline">        Value *Z = BO->getOperand(1);</td>
    <td class="lineNumber">1651</td>
    <td class="codeline">        Value *Z = BO->getOperand(1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1652</td>
    <td class="codeline">        return B.CreateSelect(Sel->getCondition(),</td>
    <td class="lineNumber">1652</td>
    <td class="codeline">        return B.CreateSelect(Sel->getCondition(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1653</td>
    <td class="codeline">                              B.CreateBinOp(Op, X, Z),</td>
    <td class="lineNumber">1653</td>
    <td class="codeline">                              B.CreateBinOp(Op, X, Z),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1654</td>
    <td class="codeline">                              B.CreateBinOp(Op, Y, Z));</td>
    <td class="lineNumber">1654</td>
    <td class="codeline">                              B.CreateBinOp(Op, Y, Z));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1655</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1655</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1656</td>
    <td class="codeline">      if (SelectInst *Sel = dyn_cast<SelectInst>(BO->getOperand(1))) {</td>
    <td class="lineNumber">1656</td>
    <td class="codeline">      if (SelectInst *Sel = dyn_cast<SelectInst>(BO->getOperand(1))) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1657</td>
    <td class="codeline">        IRBuilder<> B(Ctx);</td>
    <td class="lineNumber">1657</td>
    <td class="codeline">        IRBuilder<> B(Ctx);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1658</td>
    <td class="codeline">        Value *X = BO->getOperand(0);</td>
    <td class="lineNumber">1658</td>
    <td class="codeline">        Value *X = BO->getOperand(0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1659</td>
    <td class="codeline">        Value *Y = Sel->getTrueValue(), *Z = Sel->getFalseValue();</td>
    <td class="lineNumber">1659</td>
    <td class="codeline">        Value *Y = Sel->getTrueValue(), *Z = Sel->getFalseValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1660</td>
    <td class="codeline">        return B.CreateSelect(Sel->getCondition(),</td>
    <td class="lineNumber">1660</td>
    <td class="codeline">        return B.CreateSelect(Sel->getCondition(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1661</td>
    <td class="codeline">                              B.CreateBinOp(Op, X, Y),</td>
    <td class="lineNumber">1661</td>
    <td class="codeline">                              B.CreateBinOp(Op, X, Y),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1662</td>
    <td class="codeline">                              B.CreateBinOp(Op, X, Z));</td>
    <td class="lineNumber">1662</td>
    <td class="codeline">                              B.CreateBinOp(Op, X, Z));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1663</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1663</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1664</td>
    <td class="codeline">      return nullptr;</td>
    <td class="lineNumber">1664</td>
    <td class="codeline">      return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1665</td>
    <td class="codeline">    });</td>
    <td class="lineNumber">1665</td>
    <td class="codeline">    });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1666</td>
    <td class="codeline">  S.addRule("fold select-select",</td>
    <td class="lineNumber">1666</td>
    <td class="codeline">  S.addRule("fold select-select",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1667</td>
    <td class="codeline">    // (select c (select c x y) z) -> (select c x z)</td>
    <td class="lineNumber">1667</td>
    <td class="codeline">    // (select c (select c x y) z) -> (select c x z)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1668</td>
    <td class="codeline">    // (select c x (select c y z)) -> (select c x z)</td>
    <td class="lineNumber">1668</td>
    <td class="codeline">    // (select c x (select c y z)) -> (select c x z)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1669</td>
    <td class="codeline">    [](Instruction *I, LLVMContext &Ctx) -> Value* {</td>
    <td class="lineNumber">1669</td>
    <td class="codeline">    [](Instruction *I, LLVMContext &Ctx) -> Value* {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1670</td>
    <td class="codeline">      SelectInst *Sel = dyn_cast<SelectInst>(I);</td>
    <td class="lineNumber">1670</td>
    <td class="codeline">      SelectInst *Sel = dyn_cast<SelectInst>(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1671</td>
    <td class="codeline">      if (!Sel)</td>
    <td class="lineNumber">1671</td>
    <td class="codeline">      if (!Sel)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1672</td>
    <td class="codeline">        return nullptr;</td>
    <td class="lineNumber">1672</td>
    <td class="codeline">        return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1673</td>
    <td class="codeline">      IRBuilder<> B(Ctx);</td>
    <td class="lineNumber">1673</td>
    <td class="codeline">      IRBuilder<> B(Ctx);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1674</td>
    <td class="codeline">      Value *C = Sel->getCondition();</td>
    <td class="lineNumber">1674</td>
    <td class="codeline">      Value *C = Sel->getCondition();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1675</td>
    <td class="codeline">      if (SelectInst *Sel0 = dyn_cast<SelectInst>(Sel->getTrueValue())) {</td>
    <td class="lineNumber">1675</td>
    <td class="codeline">      if (SelectInst *Sel0 = dyn_cast<SelectInst>(Sel->getTrueValue())) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1676</td>
    <td class="codeline">        if (Sel0->getCondition() == C)</td>
    <td class="lineNumber">1676</td>
    <td class="codeline">        if (Sel0->getCondition() == C)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1677</td>
    <td class="codeline">          return B.CreateSelect(C, Sel0->getTrueValue(), Sel->getFalseValue());</td>
    <td class="lineNumber">1677</td>
    <td class="codeline">          return B.CreateSelect(C, Sel0->getTrueValue(), Sel->getFalseValue());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1678</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1678</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1679</td>
    <td class="codeline">      if (SelectInst *Sel1 = dyn_cast<SelectInst>(Sel->getFalseValue())) {</td>
    <td class="lineNumber">1679</td>
    <td class="codeline">      if (SelectInst *Sel1 = dyn_cast<SelectInst>(Sel->getFalseValue())) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1680</td>
    <td class="codeline">        if (Sel1->getCondition() == C)</td>
    <td class="lineNumber">1680</td>
    <td class="codeline">        if (Sel1->getCondition() == C)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1681</td>
    <td class="codeline">          return B.CreateSelect(C, Sel->getTrueValue(), Sel1->getFalseValue());</td>
    <td class="lineNumber">1681</td>
    <td class="codeline">          return B.CreateSelect(C, Sel->getTrueValue(), Sel1->getFalseValue());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1682</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1682</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1683</td>
    <td class="codeline">      return nullptr;</td>
    <td class="lineNumber">1683</td>
    <td class="codeline">      return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1684</td>
    <td class="codeline">    });</td>
    <td class="lineNumber">1684</td>
    <td class="codeline">    });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1685</td>
    <td class="codeline">  S.addRule("or-signbit -> xor-signbit",</td>
    <td class="lineNumber">1685</td>
    <td class="codeline">  S.addRule("or-signbit -> xor-signbit",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1686</td>
    <td class="codeline">    // (or (lshr x 1) 0x800.0) -> (xor (lshr x 1) 0x800.0)</td>
    <td class="lineNumber">1686</td>
    <td class="codeline">    // (or (lshr x 1) 0x800.0) -> (xor (lshr x 1) 0x800.0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1687</td>
    <td class="codeline">    [](Instruction *I, LLVMContext &Ctx) -> Value* {</td>
    <td class="lineNumber">1687</td>
    <td class="codeline">    [](Instruction *I, LLVMContext &Ctx) -> Value* {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1688</td>
    <td class="codeline">      if (I->getOpcode() != Instruction::Or)</td>
    <td class="lineNumber">1688</td>
    <td class="codeline">      if (I->getOpcode() != Instruction::Or)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1689</td>
    <td class="codeline">        return nullptr;</td>
    <td class="lineNumber">1689</td>
    <td class="codeline">        return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1690</td>
    <td class="codeline">      ConstantInt *Msb = dyn_cast<ConstantInt>(I->getOperand(1));</td>
    <td class="lineNumber">1690</td>
    <td class="codeline">      ConstantInt *Msb = dyn_cast<ConstantInt>(I->getOperand(1));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1691</td>
    <td class="codeline">      if (!Msb || Msb->getZExtValue() != Msb->getType()->getSignBit())</td>
    <td class="lineNumber">1691</td>
    <td class="codeline">      if (!Msb || Msb->getZExtValue() != Msb->getType()->getSignBit())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1692</td>
    <td class="codeline">        return nullptr;</td>
    <td class="lineNumber">1692</td>
    <td class="codeline">        return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1693</td>
    <td class="codeline">      if (!hasZeroSignBit(I->getOperand(0)))</td>
    <td class="lineNumber">1693</td>
    <td class="codeline">      if (!hasZeroSignBit(I->getOperand(0)))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1694</td>
    <td class="codeline">        return nullptr;</td>
    <td class="lineNumber">1694</td>
    <td class="codeline">        return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1695</td>
    <td class="codeline">      return IRBuilder<>(Ctx).CreateXor(I->getOperand(0), Msb);</td>
    <td class="lineNumber">1695</td>
    <td class="codeline">      return IRBuilder<>(Ctx).CreateXor(I->getOperand(0), Msb);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1696</td>
    <td class="codeline">    });</td>
    <td class="lineNumber">1696</td>
    <td class="codeline">    });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1697</td>
    <td class="codeline">  S.addRule("sink lshr into binop",</td>
    <td class="lineNumber">1697</td>
    <td class="codeline">  S.addRule("sink lshr into binop",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1698</td>
    <td class="codeline">    // (lshr (BitOp x y) c) -> (BitOp (lshr x c) (lshr y c))</td>
    <td class="lineNumber">1698</td>
    <td class="codeline">    // (lshr (BitOp x y) c) -> (BitOp (lshr x c) (lshr y c))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1699</td>
    <td class="codeline">    [](Instruction *I, LLVMContext &Ctx) -> Value* {</td>
    <td class="lineNumber">1699</td>
    <td class="codeline">    [](Instruction *I, LLVMContext &Ctx) -> Value* {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1700</td>
    <td class="codeline">      if (I->getOpcode() != Instruction::LShr)</td>
    <td class="lineNumber">1700</td>
    <td class="codeline">      if (I->getOpcode() != Instruction::LShr)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1701</td>
    <td class="codeline">        return nullptr;</td>
    <td class="lineNumber">1701</td>
    <td class="codeline">        return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1702</td>
    <td class="codeline">      BinaryOperator *BitOp = dyn_cast<BinaryOperator>(I->getOperand(0));</td>
    <td class="lineNumber">1702</td>
    <td class="codeline">      BinaryOperator *BitOp = dyn_cast<BinaryOperator>(I->getOperand(0));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1703</td>
    <td class="codeline">      if (!BitOp)</td>
    <td class="lineNumber">1703</td>
    <td class="codeline">      if (!BitOp)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1704</td>
    <td class="codeline">        return nullptr;</td>
    <td class="lineNumber">1704</td>
    <td class="codeline">        return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1705</td>
    <td class="codeline">      switch (BitOp->getOpcode()) {</td>
    <td class="lineNumber">1705</td>
    <td class="codeline">      switch (BitOp->getOpcode()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1706</td>
    <td class="codeline">        case Instruction::And:</td>
    <td class="lineNumber">1706</td>
    <td class="codeline">        case Instruction::And:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1707</td>
    <td class="codeline">        case Instruction::Or:</td>
    <td class="lineNumber">1707</td>
    <td class="codeline">        case Instruction::Or:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1708</td>
    <td class="codeline">        case Instruction::Xor:</td>
    <td class="lineNumber">1708</td>
    <td class="codeline">        case Instruction::Xor:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1709</td>
    <td class="codeline">          break;</td>
    <td class="lineNumber">1709</td>
    <td class="codeline">          break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1710</td>
    <td class="codeline">        default:</td>
    <td class="lineNumber">1710</td>
    <td class="codeline">        default:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1711</td>
    <td class="codeline">          return nullptr;</td>
    <td class="lineNumber">1711</td>
    <td class="codeline">          return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1712</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1712</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1713</td>
    <td class="codeline">      IRBuilder<> B(Ctx);</td>
    <td class="lineNumber">1713</td>
    <td class="codeline">      IRBuilder<> B(Ctx);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1714</td>
    <td class="codeline">      Value *S = I->getOperand(1);</td>
    <td class="lineNumber">1714</td>
    <td class="codeline">      Value *S = I->getOperand(1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1715</td>
    <td class="codeline">      return B.CreateBinOp(BitOp->getOpcode(),</td>
    <td class="lineNumber">1715</td>
    <td class="codeline">      return B.CreateBinOp(BitOp->getOpcode(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1716</td>
    <td class="codeline">                B.CreateLShr(BitOp->getOperand(0), S),</td>
    <td class="lineNumber">1716</td>
    <td class="codeline">                B.CreateLShr(BitOp->getOperand(0), S),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1717</td>
    <td class="codeline">                B.CreateLShr(BitOp->getOperand(1), S));</td>
    <td class="lineNumber">1717</td>
    <td class="codeline">                B.CreateLShr(BitOp->getOperand(1), S));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1718</td>
    <td class="codeline">    });</td>
    <td class="lineNumber">1718</td>
    <td class="codeline">    });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1719</td>
    <td class="codeline">  S.addRule("expose bitop-const",</td>
    <td class="lineNumber">1719</td>
    <td class="codeline">  S.addRule("expose bitop-const",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1720</td>
    <td class="codeline">    // (BitOp1 (BitOp2 x a) b) -> (BitOp2 x (BitOp1 a b))</td>
    <td class="lineNumber">1720</td>
    <td class="codeline">    // (BitOp1 (BitOp2 x a) b) -> (BitOp2 x (BitOp1 a b))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1721</td>
    <td class="codeline">    [](Instruction *I, LLVMContext &Ctx) -> Value* {</td>
    <td class="lineNumber">1721</td>
    <td class="codeline">    [](Instruction *I, LLVMContext &Ctx) -> Value* {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1722</td>
    <td class="codeline">      auto IsBitOp = [](unsigned Op) -> bool {</td>
    <td class="lineNumber">1722</td>
    <td class="codeline">      auto IsBitOp = [](unsigned Op) -> bool {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1723</td>
    <td class="codeline">        switch (Op) {</td>
    <td class="lineNumber">1723</td>
    <td class="codeline">        switch (Op) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1724</td>
    <td class="codeline">          case Instruction::And:</td>
    <td class="lineNumber">1724</td>
    <td class="codeline">          case Instruction::And:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1725</td>
    <td class="codeline">          case Instruction::Or:</td>
    <td class="lineNumber">1725</td>
    <td class="codeline">          case Instruction::Or:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1726</td>
    <td class="codeline">          case Instruction::Xor:</td>
    <td class="lineNumber">1726</td>
    <td class="codeline">          case Instruction::Xor:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1727</td>
    <td class="codeline">            return true;</td>
    <td class="lineNumber">1727</td>
    <td class="codeline">            return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1728</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">1728</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1729</td>
    <td class="codeline">        return false;</td>
    <td class="lineNumber">1729</td>
    <td class="codeline">        return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1730</td>
    <td class="codeline">      };</td>
    <td class="lineNumber">1730</td>
    <td class="codeline">      };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1731</td>
    <td class="codeline">      BinaryOperator *BitOp1 = dyn_cast<BinaryOperator>(I);</td>
    <td class="lineNumber">1731</td>
    <td class="codeline">      BinaryOperator *BitOp1 = dyn_cast<BinaryOperator>(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1732</td>
    <td class="codeline">      if (!BitOp1 || !IsBitOp(BitOp1->getOpcode()))</td>
    <td class="lineNumber">1732</td>
    <td class="codeline">      if (!BitOp1 || !IsBitOp(BitOp1->getOpcode()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1733</td>
    <td class="codeline">        return nullptr;</td>
    <td class="lineNumber">1733</td>
    <td class="codeline">        return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1734</td>
    <td class="codeline">      BinaryOperator *BitOp2 = dyn_cast<BinaryOperator>(BitOp1->getOperand(0));</td>
    <td class="lineNumber">1734</td>
    <td class="codeline">      BinaryOperator *BitOp2 = dyn_cast<BinaryOperator>(BitOp1->getOperand(0));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1735</td>
    <td class="codeline">      if (!BitOp2 || !IsBitOp(BitOp2->getOpcode()))</td>
    <td class="lineNumber">1735</td>
    <td class="codeline">      if (!BitOp2 || !IsBitOp(BitOp2->getOpcode()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1736</td>
    <td class="codeline">        return nullptr;</td>
    <td class="lineNumber">1736</td>
    <td class="codeline">        return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1737</td>
    <td class="codeline">      ConstantInt *CA = dyn_cast<ConstantInt>(BitOp2->getOperand(1));</td>
    <td class="lineNumber">1737</td>
    <td class="codeline">      ConstantInt *CA = dyn_cast<ConstantInt>(BitOp2->getOperand(1));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1738</td>
    <td class="codeline">      ConstantInt *CB = dyn_cast<ConstantInt>(BitOp1->getOperand(1));</td>
    <td class="lineNumber">1738</td>
    <td class="codeline">      ConstantInt *CB = dyn_cast<ConstantInt>(BitOp1->getOperand(1));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1739</td>
    <td class="codeline">      if (!CA || !CB)</td>
    <td class="lineNumber">1739</td>
    <td class="codeline">      if (!CA || !CB)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1740</td>
    <td class="codeline">        return nullptr;</td>
    <td class="lineNumber">1740</td>
    <td class="codeline">        return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1741</td>
    <td class="codeline">      IRBuilder<> B(Ctx);</td>
    <td class="lineNumber">1741</td>
    <td class="codeline">      IRBuilder<> B(Ctx);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1742</td>
    <td class="codeline">      Value *X = BitOp2->getOperand(0);</td>
    <td class="lineNumber">1742</td>
    <td class="codeline">      Value *X = BitOp2->getOperand(0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1743</td>
    <td class="codeline">      return B.CreateBinOp(BitOp2->getOpcode(), X,</td>
    <td class="lineNumber">1743</td>
    <td class="codeline">      return B.CreateBinOp(BitOp2->getOpcode(), X,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1744</td>
    <td class="codeline">                B.CreateBinOp(BitOp1->getOpcode(), CA, CB));</td>
    <td class="lineNumber">1744</td>
    <td class="codeline">                B.CreateBinOp(BitOp1->getOpcode(), CA, CB));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1745</td>
    <td class="codeline">    });</td>
    <td class="lineNumber">1745</td>
    <td class="codeline">    });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1746</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1746</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1747</td>
    <td class="codeline"></td>
    <td class="lineNumber">1747</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1748</td>
    <td class="codeline">void PolynomialMultiplyRecognize::setupPostSimplifier(Simplifier &S) {</td>
    <td class="lineNumber">1748</td>
    <td class="codeline">void PolynomialMultiplyRecognize::setupPostSimplifier(Simplifier &S) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1749</td>
    <td class="codeline">  S.addRule("(and (xor (and x a) y) b) -> (and (xor x y) b), if b == b&a",</td>
    <td class="lineNumber">1749</td>
    <td class="codeline">  S.addRule("(and (xor (and x a) y) b) -> (and (xor x y) b), if b == b&a",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1750</td>
    <td class="codeline">    [](Instruction *I, LLVMContext &Ctx) -> Value* {</td>
    <td class="lineNumber">1750</td>
    <td class="codeline">    [](Instruction *I, LLVMContext &Ctx) -> Value* {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1751</td>
    <td class="codeline">      if (I->getOpcode() != Instruction::And)</td>
    <td class="lineNumber">1751</td>
    <td class="codeline">      if (I->getOpcode() != Instruction::And)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1752</td>
    <td class="codeline">        return nullptr;</td>
    <td class="lineNumber">1752</td>
    <td class="codeline">        return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1753</td>
    <td class="codeline">      Instruction *Xor = dyn_cast<Instruction>(I->getOperand(0));</td>
    <td class="lineNumber">1753</td>
    <td class="codeline">      Instruction *Xor = dyn_cast<Instruction>(I->getOperand(0));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1754</td>
    <td class="codeline">      ConstantInt *C0 = dyn_cast<ConstantInt>(I->getOperand(1));</td>
    <td class="lineNumber">1754</td>
    <td class="codeline">      ConstantInt *C0 = dyn_cast<ConstantInt>(I->getOperand(1));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1755</td>
    <td class="codeline">      if (!Xor || !C0)</td>
    <td class="lineNumber">1755</td>
    <td class="codeline">      if (!Xor || !C0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1756</td>
    <td class="codeline">        return nullptr;</td>
    <td class="lineNumber">1756</td>
    <td class="codeline">        return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1757</td>
    <td class="codeline">      if (Xor->getOpcode() != Instruction::Xor)</td>
    <td class="lineNumber">1757</td>
    <td class="codeline">      if (Xor->getOpcode() != Instruction::Xor)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1758</td>
    <td class="codeline">        return nullptr;</td>
    <td class="lineNumber">1758</td>
    <td class="codeline">        return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1759</td>
    <td class="codeline">      Instruction *And0 = dyn_cast<Instruction>(Xor->getOperand(0));</td>
    <td class="lineNumber">1759</td>
    <td class="codeline">      Instruction *And0 = dyn_cast<Instruction>(Xor->getOperand(0));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1760</td>
    <td class="codeline">      Instruction *And1 = dyn_cast<Instruction>(Xor->getOperand(1));</td>
    <td class="lineNumber">1760</td>
    <td class="codeline">      Instruction *And1 = dyn_cast<Instruction>(Xor->getOperand(1));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1761</td>
    <td class="codeline">      // Pick the first non-null and.</td>
    <td class="lineNumber">1761</td>
    <td class="codeline">      // Pick the first non-null and.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1762</td>
    <td class="codeline">      if (!And0 || And0->getOpcode() != Instruction::And)</td>
    <td class="lineNumber">1762</td>
    <td class="codeline">      if (!And0 || And0->getOpcode() != Instruction::And)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1763</td>
    <td class="codeline">        std::swap(And0, And1);</td>
    <td class="lineNumber">1763</td>
    <td class="codeline">        std::swap(And0, And1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1764</td>
    <td class="codeline">      ConstantInt *C1 = dyn_cast<ConstantInt>(And0->getOperand(1));</td>
    <td class="lineNumber">1764</td>
    <td class="codeline">      ConstantInt *C1 = dyn_cast<ConstantInt>(And0->getOperand(1));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1765</td>
    <td class="codeline">      if (!C1)</td>
    <td class="lineNumber">1765</td>
    <td class="codeline">      if (!C1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1766</td>
    <td class="codeline">        return nullptr;</td>
    <td class="lineNumber">1766</td>
    <td class="codeline">        return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1767</td>
    <td class="codeline">      uint32_t V0 = C0->getZExtValue();</td>
    <td class="lineNumber">1767</td>
    <td class="codeline">      uint32_t V0 = C0->getZExtValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1768</td>
    <td class="codeline">      uint32_t V1 = C1->getZExtValue();</td>
    <td class="lineNumber">1768</td>
    <td class="codeline">      uint32_t V1 = C1->getZExtValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1769</td>
    <td class="codeline">      if (V0 != (V0 & V1))</td>
    <td class="lineNumber">1769</td>
    <td class="codeline">      if (V0 != (V0 & V1))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1770</td>
    <td class="codeline">        return nullptr;</td>
    <td class="lineNumber">1770</td>
    <td class="codeline">        return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1771</td>
    <td class="codeline">      IRBuilder<> B(Ctx);</td>
    <td class="lineNumber">1771</td>
    <td class="codeline">      IRBuilder<> B(Ctx);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1772</td>
    <td class="codeline">      return B.CreateAnd(B.CreateXor(And0->getOperand(0), And1), C0);</td>
    <td class="lineNumber">1772</td>
    <td class="codeline">      return B.CreateAnd(B.CreateXor(And0->getOperand(0), And1), C0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1773</td>
    <td class="codeline">    });</td>
    <td class="lineNumber">1773</td>
    <td class="codeline">    });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1774</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1774</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1775</td>
    <td class="codeline"></td>
    <td class="lineNumber">1775</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1776</td>
    <td class="codeline">bool PolynomialMultiplyRecognize::recognize() {</td>
    <td class="lineNumber">1776</td>
    <td class="codeline">bool PolynomialMultiplyRecognize::recognize() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1777</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "Starting PolynomialMultiplyRecognize on loop\n"</td>
    <td class="lineNumber">1777</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "Starting PolynomialMultiplyRecognize on loop\n"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1778</td>
    <td class="codeline">                    << *CurLoop << '\n');</td>
    <td class="lineNumber">1778</td>
    <td class="codeline">                    << *CurLoop << '\n');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1779</td>
    <td class="codeline">  // Restrictions:</td>
    <td class="lineNumber">1779</td>
    <td class="codeline">  // Restrictions:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1780</td>
    <td class="codeline">  // - The loop must consist of a single block.</td>
    <td class="lineNumber">1780</td>
    <td class="codeline">  // - The loop must consist of a single block.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1781</td>
    <td class="codeline">  // - The iteration count must be known at compile-time.</td>
    <td class="lineNumber">1781</td>
    <td class="codeline">  // - The iteration count must be known at compile-time.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1782</td>
    <td class="codeline">  // - The loop must have an induction variable starting from 0, and</td>
    <td class="lineNumber">1782</td>
    <td class="codeline">  // - The loop must have an induction variable starting from 0, and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1783</td>
    <td class="codeline">  //   incremented in each iteration of the loop.</td>
    <td class="lineNumber">1783</td>
    <td class="codeline">  //   incremented in each iteration of the loop.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1784</td>
    <td class="codeline">  BasicBlock *LoopB = CurLoop->getHeader();</td>
    <td class="lineNumber">1784</td>
    <td class="codeline">  BasicBlock *LoopB = CurLoop->getHeader();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1785</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "Loop header:\n" << *LoopB);</td>
    <td class="lineNumber">1785</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "Loop header:\n" << *LoopB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1786</td>
    <td class="codeline"></td>
    <td class="lineNumber">1786</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1787</td>
    <td class="codeline">  if (LoopB != CurLoop->getLoopLatch())</td>
    <td class="lineNumber">1787</td>
    <td class="codeline">  if (LoopB != CurLoop->getLoopLatch())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1788</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1788</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1789</td>
    <td class="codeline">  BasicBlock *ExitB = CurLoop->getExitBlock();</td>
    <td class="lineNumber">1789</td>
    <td class="codeline">  BasicBlock *ExitB = CurLoop->getExitBlock();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1790</td>
    <td class="codeline">  if (ExitB == nullptr)</td>
    <td class="lineNumber">1790</td>
    <td class="codeline">  if (ExitB == nullptr)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1791</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1791</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1792</td>
    <td class="codeline">  BasicBlock *EntryB = CurLoop->getLoopPreheader();</td>
    <td class="lineNumber">1792</td>
    <td class="codeline">  BasicBlock *EntryB = CurLoop->getLoopPreheader();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1793</td>
    <td class="codeline">  if (EntryB == nullptr)</td>
    <td class="lineNumber">1793</td>
    <td class="codeline">  if (EntryB == nullptr)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1794</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1794</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1795</td>
    <td class="codeline"></td>
    <td class="lineNumber">1795</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1796</td>
    <td class="codeline">  unsigned IterCount = 0;</td>
    <td class="lineNumber">1796</td>
    <td class="codeline">  unsigned IterCount = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1797</td>
    <td class="codeline">  const SCEV *CT = SE.getBackedgeTakenCount(CurLoop);</td>
    <td class="lineNumber">1797</td>
    <td class="codeline">  const SCEV *CT = SE.getBackedgeTakenCount(CurLoop);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1798</td>
    <td class="codeline">  if (isa<SCEVCouldNotCompute>(CT))</td>
    <td class="lineNumber">1798</td>
    <td class="codeline">  if (isa<SCEVCouldNotCompute>(CT))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1799</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1799</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1800</td>
    <td class="codeline">  if (auto *CV = dyn_cast<SCEVConstant>(CT))</td>
    <td class="lineNumber">1800</td>
    <td class="codeline">  if (auto *CV = dyn_cast<SCEVConstant>(CT))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1801</td>
    <td class="codeline">    IterCount = CV->getValue()->getZExtValue() + 1;</td>
    <td class="lineNumber">1801</td>
    <td class="codeline">    IterCount = CV->getValue()->getZExtValue() + 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1802</td>
    <td class="codeline"></td>
    <td class="lineNumber">1802</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1803</td>
    <td class="codeline">  Value *CIV = getCountIV(LoopB);</td>
    <td class="lineNumber">1803</td>
    <td class="codeline">  Value *CIV = getCountIV(LoopB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1804</td>
    <td class="codeline">  ParsedValues PV;</td>
    <td class="lineNumber">1804</td>
    <td class="codeline">  ParsedValues PV;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1805</td>
    <td class="codeline">  Simplifier PreSimp;</td>
    <td class="lineNumber">1805</td>
    <td class="codeline">  Simplifier PreSimp;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1806</td>
    <td class="codeline">  PV.IterCount = IterCount;</td>
    <td class="lineNumber">1806</td>
    <td class="codeline">  PV.IterCount = IterCount;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1807</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "Loop IV: " << *CIV << "\nIterCount: " << IterCount</td>
    <td class="lineNumber">1807</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "Loop IV: " << *CIV << "\nIterCount: " << IterCount</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1808</td>
    <td class="codeline">                    << '\n');</td>
    <td class="lineNumber">1808</td>
    <td class="codeline">                    << '\n');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1809</td>
    <td class="codeline"></td>
    <td class="lineNumber">1809</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1810</td>
    <td class="codeline">  setupPreSimplifier(PreSimp);</td>
    <td class="lineNumber">1810</td>
    <td class="codeline">  setupPreSimplifier(PreSimp);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1811</td>
    <td class="codeline"></td>
    <td class="lineNumber">1811</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1812</td>
    <td class="codeline">  // Perform a preliminary scan of select instructions to see if any of them</td>
    <td class="lineNumber">1812</td>
    <td class="codeline">  // Perform a preliminary scan of select instructions to see if any of them</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1813</td>
    <td class="codeline">  // looks like a generator of the polynomial multiply steps. Assume that a</td>
    <td class="lineNumber">1813</td>
    <td class="codeline">  // looks like a generator of the polynomial multiply steps. Assume that a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1814</td>
    <td class="codeline">  // loop can only contain a single transformable operation, so stop the</td>
    <td class="lineNumber">1814</td>
    <td class="codeline">  // loop can only contain a single transformable operation, so stop the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1815</td>
    <td class="codeline">  // traversal after the first reasonable candidate was found.</td>
    <td class="lineNumber">1815</td>
    <td class="codeline">  // traversal after the first reasonable candidate was found.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1816</td>
    <td class="codeline">  // XXX: Currently this approach can modify the loop before being 100% sure</td>
    <td class="lineNumber">1816</td>
    <td class="codeline">  // XXX: Currently this approach can modify the loop before being 100% sure</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1817</td>
    <td class="codeline">  // that the transformation can be carried out.</td>
    <td class="lineNumber">1817</td>
    <td class="codeline">  // that the transformation can be carried out.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1818</td>
    <td class="codeline">  bool FoundPreScan = false;</td>
    <td class="lineNumber">1818</td>
    <td class="codeline">  bool FoundPreScan = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1819</td>
    <td class="codeline">  auto FeedsPHI = [LoopB](const Value *V) -> bool {</td>
    <td class="lineNumber">1819</td>
    <td class="codeline">  auto FeedsPHI = [LoopB](const Value *V) -> bool {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1820</td>
    <td class="codeline">    for (const Value *U : V->users()) {</td>
    <td class="lineNumber">1820</td>
    <td class="codeline">    for (const Value *U : V->users()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1821</td>
    <td class="codeline">      if (const auto *P = dyn_cast<const PHINode>(U))</td>
    <td class="lineNumber">1821</td>
    <td class="codeline">      if (const auto *P = dyn_cast<const PHINode>(U))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1822</td>
    <td class="codeline">        if (P->getParent() == LoopB)</td>
    <td class="lineNumber">1822</td>
    <td class="codeline">        if (P->getParent() == LoopB)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1823</td>
    <td class="codeline">          return true;</td>
    <td class="lineNumber">1823</td>
    <td class="codeline">          return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1824</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1824</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1825</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1825</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1826</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">1826</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1827</td>
    <td class="codeline">  for (Instruction &In : *LoopB) {</td>
    <td class="lineNumber">1827</td>
    <td class="codeline">  for (Instruction &In : *LoopB) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1828</td>
    <td class="codeline">    SelectInst *SI = dyn_cast<SelectInst>(&In);</td>
    <td class="lineNumber">1828</td>
    <td class="codeline">    SelectInst *SI = dyn_cast<SelectInst>(&In);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1829</td>
    <td class="codeline">    if (!SI || !FeedsPHI(SI))</td>
    <td class="lineNumber">1829</td>
    <td class="codeline">    if (!SI || !FeedsPHI(SI))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1830</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">1830</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1831</td>
    <td class="codeline"></td>
    <td class="lineNumber">1831</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1832</td>
    <td class="codeline">    Simplifier::Context C(SI);</td>
    <td class="lineNumber">1832</td>
    <td class="codeline">    Simplifier::Context C(SI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1833</td>
    <td class="codeline">    Value *T = PreSimp.simplify(C);</td>
    <td class="lineNumber">1833</td>
    <td class="codeline">    Value *T = PreSimp.simplify(C);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1834</td>
    <td class="codeline">    SelectInst *SelI = (T && isa<SelectInst>(T)) ? cast<SelectInst>(T) : SI;</td>
    <td class="lineNumber">1834</td>
    <td class="codeline">    SelectInst *SelI = (T && isa<SelectInst>(T)) ? cast<SelectInst>(T) : SI;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1835</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "scanSelect(pre-scan): " << PE(C, SelI) << '\n');</td>
    <td class="lineNumber">1835</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "scanSelect(pre-scan): " << PE(C, SelI) << '\n');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1836</td>
    <td class="codeline">    if (scanSelect(SelI, LoopB, EntryB, CIV, PV, true)) {</td>
    <td class="lineNumber">1836</td>
    <td class="codeline">    if (scanSelect(SelI, LoopB, EntryB, CIV, PV, true)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1837</td>
    <td class="codeline">      FoundPreScan = true;</td>
    <td class="lineNumber">1837</td>
    <td class="codeline">      FoundPreScan = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1838</td>
    <td class="codeline">      if (SelI != SI) {</td>
    <td class="lineNumber">1838</td>
    <td class="codeline">      if (SelI != SI) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1839</td>
    <td class="codeline">        Value *NewSel = C.materialize(LoopB, SI->getIterator());</td>
    <td class="lineNumber">1839</td>
    <td class="codeline">        Value *NewSel = C.materialize(LoopB, SI->getIterator());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1840</td>
    <td class="codeline">        SI->replaceAllUsesWith(NewSel);</td>
    <td class="lineNumber">1840</td>
    <td class="codeline">        SI->replaceAllUsesWith(NewSel);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1841</td>
    <td class="codeline">        RecursivelyDeleteTriviallyDeadInstructions(SI, &TLI);</td>
    <td class="lineNumber">1841</td>
    <td class="codeline">        RecursivelyDeleteTriviallyDeadInstructions(SI, &TLI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1842</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1842</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1843</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">1843</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1844</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1844</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1845</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1845</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1846</td>
    <td class="codeline"></td>
    <td class="lineNumber">1846</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1847</td>
    <td class="codeline">  if (!FoundPreScan) {</td>
    <td class="lineNumber">1847</td>
    <td class="codeline">  if (!FoundPreScan) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1848</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "Have not found candidates for pmpy\n");</td>
    <td class="lineNumber">1848</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "Have not found candidates for pmpy\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1849</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1849</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1850</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1850</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1851</td>
    <td class="codeline"></td>
    <td class="lineNumber">1851</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1852</td>
    <td class="codeline">  if (!PV.Left) {</td>
    <td class="lineNumber">1852</td>
    <td class="codeline">  if (!PV.Left) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1853</td>
    <td class="codeline">    // The right shift version actually only returns the higher bits of</td>
    <td class="lineNumber">1853</td>
    <td class="codeline">    // The right shift version actually only returns the higher bits of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1854</td>
    <td class="codeline">    // the result (each iteration discards the LSB). If we want to convert it</td>
    <td class="lineNumber">1854</td>
    <td class="codeline">    // the result (each iteration discards the LSB). If we want to convert it</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1855</td>
    <td class="codeline">    // to a left-shifting loop, the working data type must be at least as</td>
    <td class="lineNumber">1855</td>
    <td class="codeline">    // to a left-shifting loop, the working data type must be at least as</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1856</td>
    <td class="codeline">    // wide as the target's pmpy instruction.</td>
    <td class="lineNumber">1856</td>
    <td class="codeline">    // wide as the target's pmpy instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1857</td>
    <td class="codeline">    if (!promoteTypes(LoopB, ExitB))</td>
    <td class="lineNumber">1857</td>
    <td class="codeline">    if (!promoteTypes(LoopB, ExitB))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1858</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">1858</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1859</td>
    <td class="codeline">    // Run post-promotion simplifications.</td>
    <td class="lineNumber">1859</td>
    <td class="codeline">    // Run post-promotion simplifications.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1860</td>
    <td class="codeline">    Simplifier PostSimp;</td>
    <td class="lineNumber">1860</td>
    <td class="codeline">    Simplifier PostSimp;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1861</td>
    <td class="codeline">    setupPostSimplifier(PostSimp);</td>
    <td class="lineNumber">1861</td>
    <td class="codeline">    setupPostSimplifier(PostSimp);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1862</td>
    <td class="codeline">    for (Instruction &In : *LoopB) {</td>
    <td class="lineNumber">1862</td>
    <td class="codeline">    for (Instruction &In : *LoopB) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1863</td>
    <td class="codeline">      SelectInst *SI = dyn_cast<SelectInst>(&In);</td>
    <td class="lineNumber">1863</td>
    <td class="codeline">      SelectInst *SI = dyn_cast<SelectInst>(&In);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1864</td>
    <td class="codeline">      if (!SI || !FeedsPHI(SI))</td>
    <td class="lineNumber">1864</td>
    <td class="codeline">      if (!SI || !FeedsPHI(SI))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1865</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">1865</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1866</td>
    <td class="codeline">      Simplifier::Context C(SI);</td>
    <td class="lineNumber">1866</td>
    <td class="codeline">      Simplifier::Context C(SI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1867</td>
    <td class="codeline">      Value *T = PostSimp.simplify(C);</td>
    <td class="lineNumber">1867</td>
    <td class="codeline">      Value *T = PostSimp.simplify(C);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1868</td>
    <td class="codeline">      SelectInst *SelI = dyn_cast_or_null<SelectInst>(T);</td>
    <td class="lineNumber">1868</td>
    <td class="codeline">      SelectInst *SelI = dyn_cast_or_null<SelectInst>(T);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1869</td>
    <td class="codeline">      if (SelI != SI) {</td>
    <td class="lineNumber">1869</td>
    <td class="codeline">      if (SelI != SI) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1870</td>
    <td class="codeline">        Value *NewSel = C.materialize(LoopB, SI->getIterator());</td>
    <td class="lineNumber">1870</td>
    <td class="codeline">        Value *NewSel = C.materialize(LoopB, SI->getIterator());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1871</td>
    <td class="codeline">        SI->replaceAllUsesWith(NewSel);</td>
    <td class="lineNumber">1871</td>
    <td class="codeline">        SI->replaceAllUsesWith(NewSel);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1872</td>
    <td class="codeline">        RecursivelyDeleteTriviallyDeadInstructions(SI, &TLI);</td>
    <td class="lineNumber">1872</td>
    <td class="codeline">        RecursivelyDeleteTriviallyDeadInstructions(SI, &TLI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1873</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1873</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1874</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">1874</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1875</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1875</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1876</td>
    <td class="codeline"></td>
    <td class="lineNumber">1876</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1877</td>
    <td class="codeline">    if (!convertShiftsToLeft(LoopB, ExitB, IterCount))</td>
    <td class="lineNumber">1877</td>
    <td class="codeline">    if (!convertShiftsToLeft(LoopB, ExitB, IterCount))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1878</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">1878</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1879</td>
    <td class="codeline">    cleanupLoopBody(LoopB);</td>
    <td class="lineNumber">1879</td>
    <td class="codeline">    cleanupLoopBody(LoopB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1880</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1880</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1881</td>
    <td class="codeline"></td>
    <td class="lineNumber">1881</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1882</td>
    <td class="codeline">  // Scan the loop again, find the generating select instruction.</td>
    <td class="lineNumber">1882</td>
    <td class="codeline">  // Scan the loop again, find the generating select instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1883</td>
    <td class="codeline">  bool FoundScan = false;</td>
    <td class="lineNumber">1883</td>
    <td class="codeline">  bool FoundScan = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1884</td>
    <td class="codeline">  for (Instruction &In : *LoopB) {</td>
    <td class="lineNumber">1884</td>
    <td class="codeline">  for (Instruction &In : *LoopB) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1885</td>
    <td class="codeline">    SelectInst *SelI = dyn_cast<SelectInst>(&In);</td>
    <td class="lineNumber">1885</td>
    <td class="codeline">    SelectInst *SelI = dyn_cast<SelectInst>(&In);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1886</td>
    <td class="codeline">    if (!SelI)</td>
    <td class="lineNumber">1886</td>
    <td class="codeline">    if (!SelI)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1887</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">1887</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1888</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "scanSelect: " << *SelI << '\n');</td>
    <td class="lineNumber">1888</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "scanSelect: " << *SelI << '\n');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1889</td>
    <td class="codeline">    FoundScan = scanSelect(SelI, LoopB, EntryB, CIV, PV, false);</td>
    <td class="lineNumber">1889</td>
    <td class="codeline">    FoundScan = scanSelect(SelI, LoopB, EntryB, CIV, PV, false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1890</td>
    <td class="codeline">    if (FoundScan)</td>
    <td class="lineNumber">1890</td>
    <td class="codeline">    if (FoundScan)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1891</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">1891</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1892</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1892</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1893</td>
    <td class="codeline">  assert(FoundScan);</td>
    <td class="lineNumber">1893</td>
    <td class="codeline">  assert(FoundScan);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1894</td>
    <td class="codeline"></td>
    <td class="lineNumber">1894</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1895</td>
    <td class="codeline">  LLVM_DEBUG({</td>
    <td class="lineNumber">1895</td>
    <td class="codeline">  LLVM_DEBUG({</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1896</td>
    <td class="codeline">    StringRef PP = (PV.M ? "(P+M)" : "P");</td>
    <td class="lineNumber">1896</td>
    <td class="codeline">    StringRef PP = (PV.M ? "(P+M)" : "P");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1897</td>
    <td class="codeline">    if (!PV.Inv)</td>
    <td class="lineNumber">1897</td>
    <td class="codeline">    if (!PV.Inv)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1898</td>
    <td class="codeline">      dbgs() << "Found pmpy idiom: R = " << PP << ".Q\n";</td>
    <td class="lineNumber">1898</td>
    <td class="codeline">      dbgs() << "Found pmpy idiom: R = " << PP << ".Q\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1899</td>
    <td class="codeline">    else</td>
    <td class="lineNumber">1899</td>
    <td class="codeline">    else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1900</td>
    <td class="codeline">      dbgs() << "Found inverse pmpy idiom: R = (" << PP << "/Q).Q) + "</td>
    <td class="lineNumber">1900</td>
    <td class="codeline">      dbgs() << "Found inverse pmpy idiom: R = (" << PP << "/Q).Q) + "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1901</td>
    <td class="codeline">             << PP << "\n";</td>
    <td class="lineNumber">1901</td>
    <td class="codeline">             << PP << "\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1902</td>
    <td class="codeline">    dbgs() << "  Res:" << *PV.Res << "\n  P:" << *PV.P << "\n";</td>
    <td class="lineNumber">1902</td>
    <td class="codeline">    dbgs() << "  Res:" << *PV.Res << "\n  P:" << *PV.P << "\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1903</td>
    <td class="codeline">    if (PV.M)</td>
    <td class="lineNumber">1903</td>
    <td class="codeline">    if (PV.M)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1904</td>
    <td class="codeline">      dbgs() << "  M:" << *PV.M << "\n";</td>
    <td class="lineNumber">1904</td>
    <td class="codeline">      dbgs() << "  M:" << *PV.M << "\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1905</td>
    <td class="codeline">    dbgs() << "  Q:" << *PV.Q << "\n";</td>
    <td class="lineNumber">1905</td>
    <td class="codeline">    dbgs() << "  Q:" << *PV.Q << "\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1906</td>
    <td class="codeline">    dbgs() << "  Iteration count:" << PV.IterCount << "\n";</td>
    <td class="lineNumber">1906</td>
    <td class="codeline">    dbgs() << "  Iteration count:" << PV.IterCount << "\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1907</td>
    <td class="codeline">  });</td>
    <td class="lineNumber">1907</td>
    <td class="codeline">  });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1908</td>
    <td class="codeline"></td>
    <td class="lineNumber">1908</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1909</td>
    <td class="codeline">  BasicBlock::iterator At(EntryB->getTerminator());</td>
    <td class="lineNumber">1909</td>
    <td class="codeline">  BasicBlock::iterator At(EntryB->getTerminator());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1910</td>
    <td class="codeline">  Value *PM = generate(At, PV);</td>
    <td class="lineNumber">1910</td>
    <td class="codeline">  Value *PM = generate(At, PV);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1911</td>
    <td class="codeline">  if (PM == nullptr)</td>
    <td class="lineNumber">1911</td>
    <td class="codeline">  if (PM == nullptr)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1912</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1912</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1913</td>
    <td class="codeline"></td>
    <td class="lineNumber">1913</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1914</td>
    <td class="codeline">  if (PM->getType() != PV.Res->getType())</td>
    <td class="lineNumber">1914</td>
    <td class="codeline">  if (PM->getType() != PV.Res->getType())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1915</td>
    <td class="codeline">    PM = IRBuilder<>(&*At).CreateIntCast(PM, PV.Res->getType(), false);</td>
    <td class="lineNumber">1915</td>
    <td class="codeline">    PM = IRBuilder<>(&*At).CreateIntCast(PM, PV.Res->getType(), false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1916</td>
    <td class="codeline"></td>
    <td class="lineNumber">1916</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1917</td>
    <td class="codeline">  PV.Res->replaceAllUsesWith(PM);</td>
    <td class="lineNumber">1917</td>
    <td class="codeline">  PV.Res->replaceAllUsesWith(PM);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1918</td>
    <td class="codeline">  PV.Res->eraseFromParent();</td>
    <td class="lineNumber">1918</td>
    <td class="codeline">  PV.Res->eraseFromParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1919</td>
    <td class="codeline">  return true;</td>
    <td class="lineNumber">1919</td>
    <td class="codeline">  return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1920</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1920</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1921</td>
    <td class="codeline"></td>
    <td class="lineNumber">1921</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1922</td>
    <td class="codeline">int HexagonLoopIdiomRecognize::getSCEVStride(const SCEVAddRecExpr *S) {</td>
    <td class="lineNumber">1922</td>
    <td class="codeline">int HexagonLoopIdiomRecognize::getSCEVStride(const SCEVAddRecExpr *S) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1923</td>
    <td class="codeline">  if (const SCEVConstant *SC = dyn_cast<SCEVConstant>(S->getOperand(1)))</td>
    <td class="lineNumber">1923</td>
    <td class="codeline">  if (const SCEVConstant *SC = dyn_cast<SCEVConstant>(S->getOperand(1)))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1924</td>
    <td class="codeline">    return SC->getAPInt().getSExtValue();</td>
    <td class="lineNumber">1924</td>
    <td class="codeline">    return SC->getAPInt().getSExtValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1925</td>
    <td class="codeline">  return 0;</td>
    <td class="lineNumber">1925</td>
    <td class="codeline">  return 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1926</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1926</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1927</td>
    <td class="codeline"></td>
    <td class="lineNumber">1927</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1928</td>
    <td class="codeline">bool HexagonLoopIdiomRecognize::isLegalStore(Loop *CurLoop, StoreInst *SI) {</td>
    <td class="lineNumber">1928</td>
    <td class="codeline">bool HexagonLoopIdiomRecognize::isLegalStore(Loop *CurLoop, StoreInst *SI) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1929</td>
    <td class="codeline">  // Allow volatile stores if HexagonVolatileMemcpy is enabled.</td>
    <td class="lineNumber">1929</td>
    <td class="codeline">  // Allow volatile stores if HexagonVolatileMemcpy is enabled.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1930</td>
    <td class="codeline">  if (!(SI->isVolatile() && HexagonVolatileMemcpy) && !SI->isSimple())</td>
    <td class="lineNumber">1930</td>
    <td class="codeline">  if (!(SI->isVolatile() && HexagonVolatileMemcpy) && !SI->isSimple())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1931</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1931</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1932</td>
    <td class="codeline"></td>
    <td class="lineNumber">1932</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1933</td>
    <td class="codeline">  Value *StoredVal = SI->getValueOperand();</td>
    <td class="lineNumber">1933</td>
    <td class="codeline">  Value *StoredVal = SI->getValueOperand();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1934</td>
    <td class="codeline">  Value *StorePtr = SI->getPointerOperand();</td>
    <td class="lineNumber">1934</td>
    <td class="codeline">  Value *StorePtr = SI->getPointerOperand();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1935</td>
    <td class="codeline"></td>
    <td class="lineNumber">1935</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1936</td>
    <td class="codeline">  // Reject stores that are so large that they overflow an unsigned.</td>
    <td class="lineNumber">1936</td>
    <td class="codeline">  // Reject stores that are so large that they overflow an unsigned.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1937</td>
    <td class="codeline">  uint64_t SizeInBits = DL->getTypeSizeInBits(StoredVal->getType());</td>
    <td class="lineNumber">1937</td>
    <td class="codeline">  uint64_t SizeInBits = DL->getTypeSizeInBits(StoredVal->getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1938</td>
    <td class="codeline">  if ((SizeInBits & 7) || (SizeInBits >> 32) != 0)</td>
    <td class="lineNumber">1938</td>
    <td class="codeline">  if ((SizeInBits & 7) || (SizeInBits >> 32) != 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1939</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1939</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1940</td>
    <td class="codeline"></td>
    <td class="lineNumber">1940</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1941</td>
    <td class="codeline">  // See if the pointer expression is an AddRec like {base,+,1} on the current</td>
    <td class="lineNumber">1941</td>
    <td class="codeline">  // See if the pointer expression is an AddRec like {base,+,1} on the current</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1942</td>
    <td class="codeline">  // loop, which indicates a strided store.  If we have something else, it's a</td>
    <td class="lineNumber">1942</td>
    <td class="codeline">  // loop, which indicates a strided store.  If we have something else, it's a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1943</td>
    <td class="codeline">  // random store we can't handle.</td>
    <td class="lineNumber">1943</td>
    <td class="codeline">  // random store we can't handle.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1944</td>
    <td class="codeline">  auto *StoreEv = dyn_cast<SCEVAddRecExpr>(SE->getSCEV(StorePtr));</td>
    <td class="lineNumber">1944</td>
    <td class="codeline">  auto *StoreEv = dyn_cast<SCEVAddRecExpr>(SE->getSCEV(StorePtr));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1945</td>
    <td class="codeline">  if (!StoreEv || StoreEv->getLoop() != CurLoop || !StoreEv->isAffine())</td>
    <td class="lineNumber">1945</td>
    <td class="codeline">  if (!StoreEv || StoreEv->getLoop() != CurLoop || !StoreEv->isAffine())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1946</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1946</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1947</td>
    <td class="codeline"></td>
    <td class="lineNumber">1947</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1948</td>
    <td class="codeline">  // Check to see if the stride matches the size of the store.  If so, then we</td>
    <td class="lineNumber">1948</td>
    <td class="codeline">  // Check to see if the stride matches the size of the store.  If so, then we</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1949</td>
    <td class="codeline">  // know that every byte is touched in the loop.</td>
    <td class="lineNumber">1949</td>
    <td class="codeline">  // know that every byte is touched in the loop.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1950</td>
    <td class="codeline">  int Stride = getSCEVStride(StoreEv);</td>
    <td class="lineNumber">1950</td>
    <td class="codeline">  int Stride = getSCEVStride(StoreEv);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1951</td>
    <td class="codeline">  if (Stride == 0)</td>
    <td class="lineNumber">1951</td>
    <td class="codeline">  if (Stride == 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1952</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1952</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1953</td>
    <td class="codeline">  unsigned StoreSize = DL->getTypeStoreSize(SI->getValueOperand()->getType());</td>
    <td class="lineNumber">1953</td>
    <td class="codeline">  unsigned StoreSize = DL->getTypeStoreSize(SI->getValueOperand()->getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1954</td>
    <td class="codeline">  if (StoreSize != unsigned(std::abs(Stride)))</td>
    <td class="lineNumber">1954</td>
    <td class="codeline">  if (StoreSize != unsigned(std::abs(Stride)))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1955</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1955</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1956</td>
    <td class="codeline"></td>
    <td class="lineNumber">1956</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1957</td>
    <td class="codeline">  // The store must be feeding a non-volatile load.</td>
    <td class="lineNumber">1957</td>
    <td class="codeline">  // The store must be feeding a non-volatile load.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1958</td>
    <td class="codeline">  LoadInst *LI = dyn_cast<LoadInst>(SI->getValueOperand());</td>
    <td class="lineNumber">1958</td>
    <td class="codeline">  LoadInst *LI = dyn_cast<LoadInst>(SI->getValueOperand());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1959</td>
    <td class="codeline">  if (!LI || !LI->isSimple())</td>
    <td class="lineNumber">1959</td>
    <td class="codeline">  if (!LI || !LI->isSimple())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1960</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1960</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1961</td>
    <td class="codeline"></td>
    <td class="lineNumber">1961</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1962</td>
    <td class="codeline">  // See if the pointer expression is an AddRec like {base,+,1} on the current</td>
    <td class="lineNumber">1962</td>
    <td class="codeline">  // See if the pointer expression is an AddRec like {base,+,1} on the current</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1963</td>
    <td class="codeline">  // loop, which indicates a strided load.  If we have something else, it's a</td>
    <td class="lineNumber">1963</td>
    <td class="codeline">  // loop, which indicates a strided load.  If we have something else, it's a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1964</td>
    <td class="codeline">  // random load we can't handle.</td>
    <td class="lineNumber">1964</td>
    <td class="codeline">  // random load we can't handle.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1965</td>
    <td class="codeline">  Value *LoadPtr = LI->getPointerOperand();</td>
    <td class="lineNumber">1965</td>
    <td class="codeline">  Value *LoadPtr = LI->getPointerOperand();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1966</td>
    <td class="codeline">  auto *LoadEv = dyn_cast<SCEVAddRecExpr>(SE->getSCEV(LoadPtr));</td>
    <td class="lineNumber">1966</td>
    <td class="codeline">  auto *LoadEv = dyn_cast<SCEVAddRecExpr>(SE->getSCEV(LoadPtr));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1967</td>
    <td class="codeline">  if (!LoadEv || LoadEv->getLoop() != CurLoop || !LoadEv->isAffine())</td>
    <td class="lineNumber">1967</td>
    <td class="codeline">  if (!LoadEv || LoadEv->getLoop() != CurLoop || !LoadEv->isAffine())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1968</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1968</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1969</td>
    <td class="codeline"></td>
    <td class="lineNumber">1969</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1970</td>
    <td class="codeline">  // The store and load must share the same stride.</td>
    <td class="lineNumber">1970</td>
    <td class="codeline">  // The store and load must share the same stride.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1971</td>
    <td class="codeline">  if (StoreEv->getOperand(1) != LoadEv->getOperand(1))</td>
    <td class="lineNumber">1971</td>
    <td class="codeline">  if (StoreEv->getOperand(1) != LoadEv->getOperand(1))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1972</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1972</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1973</td>
    <td class="codeline"></td>
    <td class="lineNumber">1973</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1974</td>
    <td class="codeline">  // Success.  This store can be converted into a memcpy.</td>
    <td class="lineNumber">1974</td>
    <td class="codeline">  // Success.  This store can be converted into a memcpy.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1975</td>
    <td class="codeline">  return true;</td>
    <td class="lineNumber">1975</td>
    <td class="codeline">  return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1976</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1976</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1977</td>
    <td class="codeline"></td>
    <td class="lineNumber">1977</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1978</td>
    <td class="codeline">/// mayLoopAccessLocation - Return true if the specified loop might access the</td>
    <td class="lineNumber">1978</td>
    <td class="codeline">/// mayLoopAccessLocation - Return true if the specified loop might access the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1979</td>
    <td class="codeline">/// specified pointer location, which is a loop-strided access.  The 'Access'</td>
    <td class="lineNumber">1979</td>
    <td class="codeline">/// specified pointer location, which is a loop-strided access.  The 'Access'</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1980</td>
    <td class="codeline">/// argument specifies what the verboten forms of access are (read or write).</td>
    <td class="lineNumber">1980</td>
    <td class="codeline">/// argument specifies what the verboten forms of access are (read or write).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1981</td>
    <td class="codeline">static bool</td>
    <td class="lineNumber">1981</td>
    <td class="codeline">static bool</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1982</td>
    <td class="codeline">mayLoopAccessLocation(Value *Ptr, ModRefInfo Access, Loop *L,</td>
    <td class="lineNumber">1982</td>
    <td class="codeline">mayLoopAccessLocation(Value *Ptr, ModRefInfo Access, Loop *L,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1983</td>
    <td class="codeline">                      const SCEV *BECount, unsigned StoreSize,</td>
    <td class="lineNumber">1983</td>
    <td class="codeline">                      const SCEV *BECount, unsigned StoreSize,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1984</td>
    <td class="codeline">                      AliasAnalysis &AA,</td>
    <td class="lineNumber">1984</td>
    <td class="codeline">                      AliasAnalysis &AA,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1985</td>
    <td class="codeline">                      SmallPtrSetImpl<Instruction *> &Ignored) {</td>
    <td class="lineNumber">1985</td>
    <td class="codeline">                      SmallPtrSetImpl<Instruction *> &Ignored) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1986</td>
    <td class="codeline">  // Get the location that may be stored across the loop.  Since the access</td>
    <td class="lineNumber">1986</td>
    <td class="codeline">  // Get the location that may be stored across the loop.  Since the access</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1987</td>
    <td class="codeline">  // is strided positively through memory, we say that the modified location</td>
    <td class="lineNumber">1987</td>
    <td class="codeline">  // is strided positively through memory, we say that the modified location</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1988</td>
    <td class="codeline">  // starts at the pointer and has infinite size.</td>
    <td class="lineNumber">1988</td>
    <td class="codeline">  // starts at the pointer and has infinite size.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1989</td>
    <td class="codeline">  LocationSize AccessSize = LocationSize::afterPointer();</td>
    <td class="lineNumber">1989</td>
    <td class="codeline">  LocationSize AccessSize = LocationSize::afterPointer();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1990</td>
    <td class="codeline"></td>
    <td class="lineNumber">1990</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1991</td>
    <td class="codeline">  // If the loop iterates a fixed number of times, we can refine the access</td>
    <td class="lineNumber">1991</td>
    <td class="codeline">  // If the loop iterates a fixed number of times, we can refine the access</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1992</td>
    <td class="codeline">  // size to be exactly the size of the memset, which is (BECount+1)*StoreSize</td>
    <td class="lineNumber">1992</td>
    <td class="codeline">  // size to be exactly the size of the memset, which is (BECount+1)*StoreSize</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1993</td>
    <td class="codeline">  if (const SCEVConstant *BECst = dyn_cast<SCEVConstant>(BECount))</td>
    <td class="lineNumber">1993</td>
    <td class="codeline">  if (const SCEVConstant *BECst = dyn_cast<SCEVConstant>(BECount))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1994</td>
    <td class="codeline">    AccessSize = LocationSize::precise((BECst->getValue()->getZExtValue() + 1) *</td>
    <td class="lineNumber">1994</td>
    <td class="codeline">    AccessSize = LocationSize::precise((BECst->getValue()->getZExtValue() + 1) *</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1995</td>
    <td class="codeline">                                       StoreSize);</td>
    <td class="lineNumber">1995</td>
    <td class="codeline">                                       StoreSize);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1996</td>
    <td class="codeline"></td>
    <td class="lineNumber">1996</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1997</td>
    <td class="codeline">  // TODO: For this to be really effective, we have to dive into the pointer</td>
    <td class="lineNumber">1997</td>
    <td class="codeline">  // TODO: For this to be really effective, we have to dive into the pointer</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1998</td>
    <td class="codeline">  // operand in the store.  Store to &A[i] of 100 will always return may alias</td>
    <td class="lineNumber">1998</td>
    <td class="codeline">  // operand in the store.  Store to &A[i] of 100 will always return may alias</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1999</td>
    <td class="codeline">  // with store of &A[100], we need to StoreLoc to be "A" with size of 100,</td>
    <td class="lineNumber">1999</td>
    <td class="codeline">  // with store of &A[100], we need to StoreLoc to be "A" with size of 100,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2000</td>
    <td class="codeline">  // which will then no-alias a store to &A[100].</td>
    <td class="lineNumber">2000</td>
    <td class="codeline">  // which will then no-alias a store to &A[100].</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2001</td>
    <td class="codeline">  MemoryLocation StoreLoc(Ptr, AccessSize);</td>
    <td class="lineNumber">2001</td>
    <td class="codeline">  MemoryLocation StoreLoc(Ptr, AccessSize);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2002</td>
    <td class="codeline"></td>
    <td class="lineNumber">2002</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2003</td>
    <td class="codeline">  for (auto *B : L->blocks())</td>
    <td class="lineNumber">2003</td>
    <td class="codeline">  for (auto *B : L->blocks())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2004</td>
    <td class="codeline">    for (auto &I : *B)</td>
    <td class="lineNumber">2004</td>
    <td class="codeline">    for (auto &I : *B)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2005</td>
    <td class="codeline">      if (Ignored.count(&I) == 0 &&</td>
    <td class="lineNumber">2005</td>
    <td class="codeline">      if (Ignored.count(&I) == 0 &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2006</td>
    <td class="codeline">          isModOrRefSet(AA.getModRefInfo(&I, StoreLoc) & Access))</td>
    <td class="lineNumber">2006</td>
    <td class="codeline">          isModOrRefSet(AA.getModRefInfo(&I, StoreLoc) & Access))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2007</td>
    <td class="codeline">        return true;</td>
    <td class="lineNumber">2007</td>
    <td class="codeline">        return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2008</td>
    <td class="codeline"></td>
    <td class="lineNumber">2008</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2009</td>
    <td class="codeline">  return false;</td>
    <td class="lineNumber">2009</td>
    <td class="codeline">  return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2010</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2010</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2011</td>
    <td class="codeline"></td>
    <td class="lineNumber">2011</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2012</td>
    <td class="codeline">void HexagonLoopIdiomRecognize::collectStores(Loop *CurLoop, BasicBlock *BB,</td>
    <td class="lineNumber">2012</td>
    <td class="codeline">void HexagonLoopIdiomRecognize::collectStores(Loop *CurLoop, BasicBlock *BB,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2013</td>
    <td class="codeline">      SmallVectorImpl<StoreInst*> &Stores) {</td>
    <td class="lineNumber">2013</td>
    <td class="codeline">      SmallVectorImpl<StoreInst*> &Stores) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2014</td>
    <td class="codeline">  Stores.clear();</td>
    <td class="lineNumber">2014</td>
    <td class="codeline">  Stores.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2015</td>
    <td class="codeline">  for (Instruction &I : *BB)</td>
    <td class="lineNumber">2015</td>
    <td class="codeline">  for (Instruction &I : *BB)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2016</td>
    <td class="codeline">    if (StoreInst *SI = dyn_cast<StoreInst>(&I))</td>
    <td class="lineNumber">2016</td>
    <td class="codeline">    if (StoreInst *SI = dyn_cast<StoreInst>(&I))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2017</td>
    <td class="codeline">      if (isLegalStore(CurLoop, SI))</td>
    <td class="lineNumber">2017</td>
    <td class="codeline">      if (isLegalStore(CurLoop, SI))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2018</td>
    <td class="codeline">        Stores.push_back(SI);</td>
    <td class="lineNumber">2018</td>
    <td class="codeline">        Stores.push_back(SI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2019</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2019</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2020</td>
    <td class="codeline"></td>
    <td class="lineNumber">2020</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2021</td>
    <td class="codeline">bool HexagonLoopIdiomRecognize::processCopyingStore(Loop *CurLoop,</td>
    <td class="lineNumber">2021</td>
    <td class="codeline">bool HexagonLoopIdiomRecognize::processCopyingStore(Loop *CurLoop,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2022</td>
    <td class="codeline">      StoreInst *SI, const SCEV *BECount) {</td>
    <td class="lineNumber">2022</td>
    <td class="codeline">      StoreInst *SI, const SCEV *BECount) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2023</td>
    <td class="codeline">  assert((SI->isSimple() || (SI->isVolatile() && HexagonVolatileMemcpy)) &&</td>
    <td class="lineNumber">2023</td>
    <td class="codeline">  assert((SI->isSimple() || (SI->isVolatile() && HexagonVolatileMemcpy)) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2024</td>
    <td class="codeline">         "Expected only non-volatile stores, or Hexagon-specific memcpy"</td>
    <td class="lineNumber">2024</td>
    <td class="codeline">         "Expected only non-volatile stores, or Hexagon-specific memcpy"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2025</td>
    <td class="codeline">         "to volatile destination.");</td>
    <td class="lineNumber">2025</td>
    <td class="codeline">         "to volatile destination.");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2026</td>
    <td class="codeline"></td>
    <td class="lineNumber">2026</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2027</td>
    <td class="codeline">  Value *StorePtr = SI->getPointerOperand();</td>
    <td class="lineNumber">2027</td>
    <td class="codeline">  Value *StorePtr = SI->getPointerOperand();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2028</td>
    <td class="codeline">  auto *StoreEv = cast<SCEVAddRecExpr>(SE->getSCEV(StorePtr));</td>
    <td class="lineNumber">2028</td>
    <td class="codeline">  auto *StoreEv = cast<SCEVAddRecExpr>(SE->getSCEV(StorePtr));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2029</td>
    <td class="codeline">  unsigned Stride = getSCEVStride(StoreEv);</td>
    <td class="lineNumber">2029</td>
    <td class="codeline">  unsigned Stride = getSCEVStride(StoreEv);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2030</td>
    <td class="codeline">  unsigned StoreSize = DL->getTypeStoreSize(SI->getValueOperand()->getType());</td>
    <td class="lineNumber">2030</td>
    <td class="codeline">  unsigned StoreSize = DL->getTypeStoreSize(SI->getValueOperand()->getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2031</td>
    <td class="codeline">  if (Stride != StoreSize)</td>
    <td class="lineNumber">2031</td>
    <td class="codeline">  if (Stride != StoreSize)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2032</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">2032</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2033</td>
    <td class="codeline"></td>
    <td class="lineNumber">2033</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2034</td>
    <td class="codeline">  // See if the pointer expression is an AddRec like {base,+,1} on the current</td>
    <td class="lineNumber">2034</td>
    <td class="codeline">  // See if the pointer expression is an AddRec like {base,+,1} on the current</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2035</td>
    <td class="codeline">  // loop, which indicates a strided load.  If we have something else, it's a</td>
    <td class="lineNumber">2035</td>
    <td class="codeline">  // loop, which indicates a strided load.  If we have something else, it's a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2036</td>
    <td class="codeline">  // random load we can't handle.</td>
    <td class="lineNumber">2036</td>
    <td class="codeline">  // random load we can't handle.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2037</td>
    <td class="codeline">  auto *LI = cast<LoadInst>(SI->getValueOperand());</td>
    <td class="lineNumber">2037</td>
    <td class="codeline">  auto *LI = cast<LoadInst>(SI->getValueOperand());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2038</td>
    <td class="codeline">  auto *LoadEv = cast<SCEVAddRecExpr>(SE->getSCEV(LI->getPointerOperand()));</td>
    <td class="lineNumber">2038</td>
    <td class="codeline">  auto *LoadEv = cast<SCEVAddRecExpr>(SE->getSCEV(LI->getPointerOperand()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2039</td>
    <td class="codeline"></td>
    <td class="lineNumber">2039</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2040</td>
    <td class="codeline">  // The trip count of the loop and the base pointer of the addrec SCEV is</td>
    <td class="lineNumber">2040</td>
    <td class="codeline">  // The trip count of the loop and the base pointer of the addrec SCEV is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2041</td>
    <td class="codeline">  // guaranteed to be loop invariant, which means that it should dominate the</td>
    <td class="lineNumber">2041</td>
    <td class="codeline">  // guaranteed to be loop invariant, which means that it should dominate the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2042</td>
    <td class="codeline">  // header.  This allows us to insert code for it in the preheader.</td>
    <td class="lineNumber">2042</td>
    <td class="codeline">  // header.  This allows us to insert code for it in the preheader.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2043</td>
    <td class="codeline">  BasicBlock *Preheader = CurLoop->getLoopPreheader();</td>
    <td class="lineNumber">2043</td>
    <td class="codeline">  BasicBlock *Preheader = CurLoop->getLoopPreheader();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2044</td>
    <td class="codeline">  Instruction *ExpPt = Preheader->getTerminator();</td>
    <td class="lineNumber">2044</td>
    <td class="codeline">  Instruction *ExpPt = Preheader->getTerminator();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2045</td>
    <td class="codeline">  IRBuilder<> Builder(ExpPt);</td>
    <td class="lineNumber">2045</td>
    <td class="codeline">  IRBuilder<> Builder(ExpPt);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2046</td>
    <td class="codeline">  SCEVExpander Expander(*SE, *DL, "hexagon-loop-idiom");</td>
    <td class="lineNumber">2046</td>
    <td class="codeline">  SCEVExpander Expander(*SE, *DL, "hexagon-loop-idiom");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2047</td>
    <td class="codeline"></td>
    <td class="lineNumber">2047</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2048</td>
    <td class="codeline">  Type *IntPtrTy = Builder.getIntPtrTy(*DL, SI->getPointerAddressSpace());</td>
    <td class="lineNumber">2048</td>
    <td class="codeline">  Type *IntPtrTy = Builder.getIntPtrTy(*DL, SI->getPointerAddressSpace());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2049</td>
    <td class="codeline"></td>
    <td class="lineNumber">2049</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2050</td>
    <td class="codeline">  // Okay, we have a strided store "p[i]" of a loaded value.  We can turn</td>
    <td class="lineNumber">2050</td>
    <td class="codeline">  // Okay, we have a strided store "p[i]" of a loaded value.  We can turn</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2051</td>
    <td class="codeline">  // this into a memcpy/memmove in the loop preheader now if we want.  However,</td>
    <td class="lineNumber">2051</td>
    <td class="codeline">  // this into a memcpy/memmove in the loop preheader now if we want.  However,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2052</td>
    <td class="codeline">  // this would be unsafe to do if there is anything else in the loop that may</td>
    <td class="lineNumber">2052</td>
    <td class="codeline">  // this would be unsafe to do if there is anything else in the loop that may</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2053</td>
    <td class="codeline">  // read or write the memory region we're storing to.  For memcpy, this</td>
    <td class="lineNumber">2053</td>
    <td class="codeline">  // read or write the memory region we're storing to.  For memcpy, this</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2054</td>
    <td class="codeline">  // includes the load that feeds the stores.  Check for an alias by generating</td>
    <td class="lineNumber">2054</td>
    <td class="codeline">  // includes the load that feeds the stores.  Check for an alias by generating</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2055</td>
    <td class="codeline">  // the base address and checking everything.</td>
    <td class="lineNumber">2055</td>
    <td class="codeline">  // the base address and checking everything.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2056</td>
    <td class="codeline">  Value *StoreBasePtr = Expander.expandCodeFor(StoreEv->getStart(),</td>
    <td class="lineNumber">2056</td>
    <td class="codeline">  Value *StoreBasePtr = Expander.expandCodeFor(StoreEv->getStart(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2057</td>
    <td class="codeline">      Builder.getInt8PtrTy(SI->getPointerAddressSpace()), ExpPt);</td>
    <td class="lineNumber">2057</td>
    <td class="codeline">      Builder.getInt8PtrTy(SI->getPointerAddressSpace()), ExpPt);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2058</td>
    <td class="codeline">  Value *LoadBasePtr = nullptr;</td>
    <td class="lineNumber">2058</td>
    <td class="codeline">  Value *LoadBasePtr = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2059</td>
    <td class="codeline"></td>
    <td class="lineNumber">2059</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2060</td>
    <td class="codeline">  bool Overlap = false;</td>
    <td class="lineNumber">2060</td>
    <td class="codeline">  bool Overlap = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2061</td>
    <td class="codeline">  bool DestVolatile = SI->isVolatile();</td>
    <td class="lineNumber">2061</td>
    <td class="codeline">  bool DestVolatile = SI->isVolatile();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2062</td>
    <td class="codeline">  Type *BECountTy = BECount->getType();</td>
    <td class="lineNumber">2062</td>
    <td class="codeline">  Type *BECountTy = BECount->getType();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2063</td>
    <td class="codeline"></td>
    <td class="lineNumber">2063</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2064</td>
    <td class="codeline">  if (DestVolatile) {</td>
    <td class="lineNumber">2064</td>
    <td class="codeline">  if (DestVolatile) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2065</td>
    <td class="codeline">    // The trip count must fit in i32, since it is the type of the "num_words"</td>
    <td class="lineNumber">2065</td>
    <td class="codeline">    // The trip count must fit in i32, since it is the type of the "num_words"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2066</td>
    <td class="codeline">    // argument to hexagon_memcpy_forward_vp4cp4n2.</td>
    <td class="lineNumber">2066</td>
    <td class="codeline">    // argument to hexagon_memcpy_forward_vp4cp4n2.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2067</td>
    <td class="codeline">    if (StoreSize != 4 || DL->getTypeSizeInBits(BECountTy) > 32) {</td>
    <td class="lineNumber">2067</td>
    <td class="codeline">    if (StoreSize != 4 || DL->getTypeSizeInBits(BECountTy) > 32) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2068</td>
    <td class="codeline">CleanupAndExit:</td>
    <td class="lineNumber">2068</td>
    <td class="codeline">CleanupAndExit:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2069</td>
    <td class="codeline">      // If we generated new code for the base pointer, clean up.</td>
    <td class="lineNumber">2069</td>
    <td class="codeline">      // If we generated new code for the base pointer, clean up.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2070</td>
    <td class="codeline">      Expander.clear();</td>
    <td class="lineNumber">2070</td>
    <td class="codeline">      Expander.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2071</td>
    <td class="codeline">      if (StoreBasePtr && (LoadBasePtr != StoreBasePtr)) {</td>
    <td class="lineNumber">2071</td>
    <td class="codeline">      if (StoreBasePtr && (LoadBasePtr != StoreBasePtr)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2072</td>
    <td class="codeline">        RecursivelyDeleteTriviallyDeadInstructions(StoreBasePtr, TLI);</td>
    <td class="lineNumber">2072</td>
    <td class="codeline">        RecursivelyDeleteTriviallyDeadInstructions(StoreBasePtr, TLI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2073</td>
    <td class="codeline">        StoreBasePtr = nullptr;</td>
    <td class="lineNumber">2073</td>
    <td class="codeline">        StoreBasePtr = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2074</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">2074</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2075</td>
    <td class="codeline">      if (LoadBasePtr) {</td>
    <td class="lineNumber">2075</td>
    <td class="codeline">      if (LoadBasePtr) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2076</td>
    <td class="codeline">        RecursivelyDeleteTriviallyDeadInstructions(LoadBasePtr, TLI);</td>
    <td class="lineNumber">2076</td>
    <td class="codeline">        RecursivelyDeleteTriviallyDeadInstructions(LoadBasePtr, TLI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2077</td>
    <td class="codeline">        LoadBasePtr = nullptr;</td>
    <td class="lineNumber">2077</td>
    <td class="codeline">        LoadBasePtr = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2078</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">2078</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2079</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">2079</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2080</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2080</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2081</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2081</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2082</td>
    <td class="codeline"></td>
    <td class="lineNumber">2082</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2083</td>
    <td class="codeline">  SmallPtrSet<Instruction*, 2> Ignore1;</td>
    <td class="lineNumber">2083</td>
    <td class="codeline">  SmallPtrSet<Instruction*, 2> Ignore1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2084</td>
    <td class="codeline">  Ignore1.insert(SI);</td>
    <td class="lineNumber">2084</td>
    <td class="codeline">  Ignore1.insert(SI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2085</td>
    <td class="codeline">  if (mayLoopAccessLocation(StoreBasePtr, ModRefInfo::ModRef, CurLoop, BECount,</td>
    <td class="lineNumber">2085</td>
    <td class="codeline">  if (mayLoopAccessLocation(StoreBasePtr, ModRefInfo::ModRef, CurLoop, BECount,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2086</td>
    <td class="codeline">                            StoreSize, *AA, Ignore1)) {</td>
    <td class="lineNumber">2086</td>
    <td class="codeline">                            StoreSize, *AA, Ignore1)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2087</td>
    <td class="codeline">    // Check if the load is the offending instruction.</td>
    <td class="lineNumber">2087</td>
    <td class="codeline">    // Check if the load is the offending instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2088</td>
    <td class="codeline">    Ignore1.insert(LI);</td>
    <td class="lineNumber">2088</td>
    <td class="codeline">    Ignore1.insert(LI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2089</td>
    <td class="codeline">    if (mayLoopAccessLocation(StoreBasePtr, ModRefInfo::ModRef, CurLoop,</td>
    <td class="lineNumber">2089</td>
    <td class="codeline">    if (mayLoopAccessLocation(StoreBasePtr, ModRefInfo::ModRef, CurLoop,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2090</td>
    <td class="codeline">                              BECount, StoreSize, *AA, Ignore1)) {</td>
    <td class="lineNumber">2090</td>
    <td class="codeline">                              BECount, StoreSize, *AA, Ignore1)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2091</td>
    <td class="codeline">      // Still bad. Nothing we can do.</td>
    <td class="lineNumber">2091</td>
    <td class="codeline">      // Still bad. Nothing we can do.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2092</td>
    <td class="codeline">      goto CleanupAndExit;</td>
    <td class="lineNumber">2092</td>
    <td class="codeline">      goto CleanupAndExit;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2093</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2093</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2094</td>
    <td class="codeline">    // It worked with the load ignored.</td>
    <td class="lineNumber">2094</td>
    <td class="codeline">    // It worked with the load ignored.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2095</td>
    <td class="codeline">    Overlap = true;</td>
    <td class="lineNumber">2095</td>
    <td class="codeline">    Overlap = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2096</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2096</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2097</td>
    <td class="codeline"></td>
    <td class="lineNumber">2097</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2098</td>
    <td class="codeline">  if (!Overlap) {</td>
    <td class="lineNumber">2098</td>
    <td class="codeline">  if (!Overlap) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2099</td>
    <td class="codeline">    if (DisableMemcpyIdiom || !HasMemcpy)</td>
    <td class="lineNumber">2099</td>
    <td class="codeline">    if (DisableMemcpyIdiom || !HasMemcpy)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2100</td>
    <td class="codeline">      goto CleanupAndExit;</td>
    <td class="lineNumber">2100</td>
    <td class="codeline">      goto CleanupAndExit;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2101</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">2101</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2102</td>
    <td class="codeline">    // Don't generate memmove if this function will be inlined. This is</td>
    <td class="lineNumber">2102</td>
    <td class="codeline">    // Don't generate memmove if this function will be inlined. This is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2103</td>
    <td class="codeline">    // because the caller will undergo this transformation after inlining.</td>
    <td class="lineNumber">2103</td>
    <td class="codeline">    // because the caller will undergo this transformation after inlining.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2104</td>
    <td class="codeline">    Function *Func = CurLoop->getHeader()->getParent();</td>
    <td class="lineNumber">2104</td>
    <td class="codeline">    Function *Func = CurLoop->getHeader()->getParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2105</td>
    <td class="codeline">    if (Func->hasFnAttribute(Attribute::AlwaysInline))</td>
    <td class="lineNumber">2105</td>
    <td class="codeline">    if (Func->hasFnAttribute(Attribute::AlwaysInline))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2106</td>
    <td class="codeline">      goto CleanupAndExit;</td>
    <td class="lineNumber">2106</td>
    <td class="codeline">      goto CleanupAndExit;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2107</td>
    <td class="codeline"></td>
    <td class="lineNumber">2107</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2108</td>
    <td class="codeline">    // In case of a memmove, the call to memmove will be executed instead</td>
    <td class="lineNumber">2108</td>
    <td class="codeline">    // In case of a memmove, the call to memmove will be executed instead</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2109</td>
    <td class="codeline">    // of the loop, so we need to make sure that there is nothing else in</td>
    <td class="lineNumber">2109</td>
    <td class="codeline">    // of the loop, so we need to make sure that there is nothing else in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2110</td>
    <td class="codeline">    // the loop than the load, store and instructions that these two depend</td>
    <td class="lineNumber">2110</td>
    <td class="codeline">    // the loop than the load, store and instructions that these two depend</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2111</td>
    <td class="codeline">    // on.</td>
    <td class="lineNumber">2111</td>
    <td class="codeline">    // on.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2112</td>
    <td class="codeline">    SmallVector<Instruction*,2> Insts;</td>
    <td class="lineNumber">2112</td>
    <td class="codeline">    SmallVector<Instruction*,2> Insts;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2113</td>
    <td class="codeline">    Insts.push_back(SI);</td>
    <td class="lineNumber">2113</td>
    <td class="codeline">    Insts.push_back(SI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2114</td>
    <td class="codeline">    Insts.push_back(LI);</td>
    <td class="lineNumber">2114</td>
    <td class="codeline">    Insts.push_back(LI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2115</td>
    <td class="codeline">    if (!coverLoop(CurLoop, Insts))</td>
    <td class="lineNumber">2115</td>
    <td class="codeline">    if (!coverLoop(CurLoop, Insts))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2116</td>
    <td class="codeline">      goto CleanupAndExit;</td>
    <td class="lineNumber">2116</td>
    <td class="codeline">      goto CleanupAndExit;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2117</td>
    <td class="codeline"></td>
    <td class="lineNumber">2117</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2118</td>
    <td class="codeline">    if (DisableMemmoveIdiom || !HasMemmove)</td>
    <td class="lineNumber">2118</td>
    <td class="codeline">    if (DisableMemmoveIdiom || !HasMemmove)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2119</td>
    <td class="codeline">      goto CleanupAndExit;</td>
    <td class="lineNumber">2119</td>
    <td class="codeline">      goto CleanupAndExit;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2120</td>
    <td class="codeline">    bool IsNested = CurLoop->getParentLoop() != nullptr;</td>
    <td class="lineNumber">2120</td>
    <td class="codeline">    bool IsNested = CurLoop->getParentLoop() != nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2121</td>
    <td class="codeline">    if (IsNested && OnlyNonNestedMemmove)</td>
    <td class="lineNumber">2121</td>
    <td class="codeline">    if (IsNested && OnlyNonNestedMemmove)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2122</td>
    <td class="codeline">      goto CleanupAndExit;</td>
    <td class="lineNumber">2122</td>
    <td class="codeline">      goto CleanupAndExit;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2123</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2123</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2124</td>
    <td class="codeline"></td>
    <td class="lineNumber">2124</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2125</td>
    <td class="codeline">  // For a memcpy, we have to make sure that the input array is not being</td>
    <td class="lineNumber">2125</td>
    <td class="codeline">  // For a memcpy, we have to make sure that the input array is not being</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2126</td>
    <td class="codeline">  // mutated by the loop.</td>
    <td class="lineNumber">2126</td>
    <td class="codeline">  // mutated by the loop.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2127</td>
    <td class="codeline">  LoadBasePtr = Expander.expandCodeFor(LoadEv->getStart(),</td>
    <td class="lineNumber">2127</td>
    <td class="codeline">  LoadBasePtr = Expander.expandCodeFor(LoadEv->getStart(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2128</td>
    <td class="codeline">      Builder.getInt8PtrTy(LI->getPointerAddressSpace()), ExpPt);</td>
    <td class="lineNumber">2128</td>
    <td class="codeline">      Builder.getInt8PtrTy(LI->getPointerAddressSpace()), ExpPt);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2129</td>
    <td class="codeline"></td>
    <td class="lineNumber">2129</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2130</td>
    <td class="codeline">  SmallPtrSet<Instruction*, 2> Ignore2;</td>
    <td class="lineNumber">2130</td>
    <td class="codeline">  SmallPtrSet<Instruction*, 2> Ignore2;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2131</td>
    <td class="codeline">  Ignore2.insert(SI);</td>
    <td class="lineNumber">2131</td>
    <td class="codeline">  Ignore2.insert(SI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2132</td>
    <td class="codeline">  if (mayLoopAccessLocation(LoadBasePtr, ModRefInfo::Mod, CurLoop, BECount,</td>
    <td class="lineNumber">2132</td>
    <td class="codeline">  if (mayLoopAccessLocation(LoadBasePtr, ModRefInfo::Mod, CurLoop, BECount,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2133</td>
    <td class="codeline">                            StoreSize, *AA, Ignore2))</td>
    <td class="lineNumber">2133</td>
    <td class="codeline">                            StoreSize, *AA, Ignore2))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2134</td>
    <td class="codeline">    goto CleanupAndExit;</td>
    <td class="lineNumber">2134</td>
    <td class="codeline">    goto CleanupAndExit;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2135</td>
    <td class="codeline"></td>
    <td class="lineNumber">2135</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2136</td>
    <td class="codeline">  // Check the stride.</td>
    <td class="lineNumber">2136</td>
    <td class="codeline">  // Check the stride.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2137</td>
    <td class="codeline">  bool StridePos = getSCEVStride(LoadEv) >= 0;</td>
    <td class="lineNumber">2137</td>
    <td class="codeline">  bool StridePos = getSCEVStride(LoadEv) >= 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2138</td>
    <td class="codeline"></td>
    <td class="lineNumber">2138</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2139</td>
    <td class="codeline">  // Currently, the volatile memcpy only emulates traversing memory forward.</td>
    <td class="lineNumber">2139</td>
    <td class="codeline">  // Currently, the volatile memcpy only emulates traversing memory forward.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2140</td>
    <td class="codeline">  if (!StridePos && DestVolatile)</td>
    <td class="lineNumber">2140</td>
    <td class="codeline">  if (!StridePos && DestVolatile)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2141</td>
    <td class="codeline">    goto CleanupAndExit;</td>
    <td class="lineNumber">2141</td>
    <td class="codeline">    goto CleanupAndExit;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2142</td>
    <td class="codeline"></td>
    <td class="lineNumber">2142</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2143</td>
    <td class="codeline">  bool RuntimeCheck = (Overlap || DestVolatile);</td>
    <td class="lineNumber">2143</td>
    <td class="codeline">  bool RuntimeCheck = (Overlap || DestVolatile);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2144</td>
    <td class="codeline"></td>
    <td class="lineNumber">2144</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2145</td>
    <td class="codeline">  BasicBlock *ExitB;</td>
    <td class="lineNumber">2145</td>
    <td class="codeline">  BasicBlock *ExitB;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2146</td>
    <td class="codeline">  if (RuntimeCheck) {</td>
    <td class="lineNumber">2146</td>
    <td class="codeline">  if (RuntimeCheck) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2147</td>
    <td class="codeline">    // The runtime check needs a single exit block.</td>
    <td class="lineNumber">2147</td>
    <td class="codeline">    // The runtime check needs a single exit block.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2148</td>
    <td class="codeline">    SmallVector<BasicBlock*, 8> ExitBlocks;</td>
    <td class="lineNumber">2148</td>
    <td class="codeline">    SmallVector<BasicBlock*, 8> ExitBlocks;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2149</td>
    <td class="codeline">    CurLoop->getUniqueExitBlocks(ExitBlocks);</td>
    <td class="lineNumber">2149</td>
    <td class="codeline">    CurLoop->getUniqueExitBlocks(ExitBlocks);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2150</td>
    <td class="codeline">    if (ExitBlocks.size() != 1)</td>
    <td class="lineNumber">2150</td>
    <td class="codeline">    if (ExitBlocks.size() != 1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2151</td>
    <td class="codeline">      goto CleanupAndExit;</td>
    <td class="lineNumber">2151</td>
    <td class="codeline">      goto CleanupAndExit;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2152</td>
    <td class="codeline">    ExitB = ExitBlocks[0];</td>
    <td class="lineNumber">2152</td>
    <td class="codeline">    ExitB = ExitBlocks[0];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2153</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2153</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2154</td>
    <td class="codeline"></td>
    <td class="lineNumber">2154</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2155</td>
    <td class="codeline">  // The # stored bytes is (BECount+1)*Size.  Expand the trip count out to</td>
    <td class="lineNumber">2155</td>
    <td class="codeline">  // The # stored bytes is (BECount+1)*Size.  Expand the trip count out to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2156</td>
    <td class="codeline">  // pointer size if it isn't already.</td>
    <td class="lineNumber">2156</td>
    <td class="codeline">  // pointer size if it isn't already.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2157</td>
    <td class="codeline">  LLVMContext &Ctx = SI->getContext();</td>
    <td class="lineNumber">2157</td>
    <td class="codeline">  LLVMContext &Ctx = SI->getContext();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2158</td>
    <td class="codeline">  BECount = SE->getTruncateOrZeroExtend(BECount, IntPtrTy);</td>
    <td class="lineNumber">2158</td>
    <td class="codeline">  BECount = SE->getTruncateOrZeroExtend(BECount, IntPtrTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2159</td>
    <td class="codeline">  DebugLoc DLoc = SI->getDebugLoc();</td>
    <td class="lineNumber">2159</td>
    <td class="codeline">  DebugLoc DLoc = SI->getDebugLoc();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2160</td>
    <td class="codeline"></td>
    <td class="lineNumber">2160</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2161</td>
    <td class="codeline">  const SCEV *NumBytesS =</td>
    <td class="lineNumber">2161</td>
    <td class="codeline">  const SCEV *NumBytesS =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2162</td>
    <td class="codeline">      SE->getAddExpr(BECount, SE->getOne(IntPtrTy), SCEV::FlagNUW);</td>
    <td class="lineNumber">2162</td>
    <td class="codeline">      SE->getAddExpr(BECount, SE->getOne(IntPtrTy), SCEV::FlagNUW);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2163</td>
    <td class="codeline">  if (StoreSize != 1)</td>
    <td class="lineNumber">2163</td>
    <td class="codeline">  if (StoreSize != 1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2164</td>
    <td class="codeline">    NumBytesS = SE->getMulExpr(NumBytesS, SE->getConstant(IntPtrTy, StoreSize),</td>
    <td class="lineNumber">2164</td>
    <td class="codeline">    NumBytesS = SE->getMulExpr(NumBytesS, SE->getConstant(IntPtrTy, StoreSize),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2165</td>
    <td class="codeline">                               SCEV::FlagNUW);</td>
    <td class="lineNumber">2165</td>
    <td class="codeline">                               SCEV::FlagNUW);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2166</td>
    <td class="codeline">  Value *NumBytes = Expander.expandCodeFor(NumBytesS, IntPtrTy, ExpPt);</td>
    <td class="lineNumber">2166</td>
    <td class="codeline">  Value *NumBytes = Expander.expandCodeFor(NumBytesS, IntPtrTy, ExpPt);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2167</td>
    <td class="codeline">  if (Instruction *In = dyn_cast<Instruction>(NumBytes))</td>
    <td class="lineNumber">2167</td>
    <td class="codeline">  if (Instruction *In = dyn_cast<Instruction>(NumBytes))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2168</td>
    <td class="codeline">    if (Value *Simp = simplifyInstruction(In, {*DL, TLI, DT}))</td>
    <td class="lineNumber">2168</td>
    <td class="codeline">    if (Value *Simp = simplifyInstruction(In, {*DL, TLI, DT}))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2169</td>
    <td class="codeline">      NumBytes = Simp;</td>
    <td class="lineNumber">2169</td>
    <td class="codeline">      NumBytes = Simp;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2170</td>
    <td class="codeline"></td>
    <td class="lineNumber">2170</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2171</td>
    <td class="codeline">  CallInst *NewCall;</td>
    <td class="lineNumber">2171</td>
    <td class="codeline">  CallInst *NewCall;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2172</td>
    <td class="codeline"></td>
    <td class="lineNumber">2172</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2173</td>
    <td class="codeline">  if (RuntimeCheck) {</td>
    <td class="lineNumber">2173</td>
    <td class="codeline">  if (RuntimeCheck) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2174</td>
    <td class="codeline">    unsigned Threshold = RuntimeMemSizeThreshold;</td>
    <td class="lineNumber">2174</td>
    <td class="codeline">    unsigned Threshold = RuntimeMemSizeThreshold;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2175</td>
    <td class="codeline">    if (ConstantInt *CI = dyn_cast<ConstantInt>(NumBytes)) {</td>
    <td class="lineNumber">2175</td>
    <td class="codeline">    if (ConstantInt *CI = dyn_cast<ConstantInt>(NumBytes)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2176</td>
    <td class="codeline">      uint64_t C = CI->getZExtValue();</td>
    <td class="lineNumber">2176</td>
    <td class="codeline">      uint64_t C = CI->getZExtValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2177</td>
    <td class="codeline">      if (Threshold != 0 && C < Threshold)</td>
    <td class="lineNumber">2177</td>
    <td class="codeline">      if (Threshold != 0 && C < Threshold)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2178</td>
    <td class="codeline">        goto CleanupAndExit;</td>
    <td class="lineNumber">2178</td>
    <td class="codeline">        goto CleanupAndExit;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2179</td>
    <td class="codeline">      if (C < CompileTimeMemSizeThreshold)</td>
    <td class="lineNumber">2179</td>
    <td class="codeline">      if (C < CompileTimeMemSizeThreshold)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2180</td>
    <td class="codeline">        goto CleanupAndExit;</td>
    <td class="lineNumber">2180</td>
    <td class="codeline">        goto CleanupAndExit;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2181</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2181</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2182</td>
    <td class="codeline"></td>
    <td class="lineNumber">2182</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2183</td>
    <td class="codeline">    BasicBlock *Header = CurLoop->getHeader();</td>
    <td class="lineNumber">2183</td>
    <td class="codeline">    BasicBlock *Header = CurLoop->getHeader();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2184</td>
    <td class="codeline">    Function *Func = Header->getParent();</td>
    <td class="lineNumber">2184</td>
    <td class="codeline">    Function *Func = Header->getParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2185</td>
    <td class="codeline">    Loop *ParentL = LF->getLoopFor(Preheader);</td>
    <td class="lineNumber">2185</td>
    <td class="codeline">    Loop *ParentL = LF->getLoopFor(Preheader);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2186</td>
    <td class="codeline">    StringRef HeaderName = Header->getName();</td>
    <td class="lineNumber">2186</td>
    <td class="codeline">    StringRef HeaderName = Header->getName();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2187</td>
    <td class="codeline"></td>
    <td class="lineNumber">2187</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2188</td>
    <td class="codeline">    // Create a new (empty) preheader, and update the PHI nodes in the</td>
    <td class="lineNumber">2188</td>
    <td class="codeline">    // Create a new (empty) preheader, and update the PHI nodes in the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2189</td>
    <td class="codeline">    // header to use the new preheader.</td>
    <td class="lineNumber">2189</td>
    <td class="codeline">    // header to use the new preheader.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2190</td>
    <td class="codeline">    BasicBlock *NewPreheader = BasicBlock::Create(Ctx, HeaderName+".rtli.ph",</td>
    <td class="lineNumber">2190</td>
    <td class="codeline">    BasicBlock *NewPreheader = BasicBlock::Create(Ctx, HeaderName+".rtli.ph",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2191</td>
    <td class="codeline">                                                  Func, Header);</td>
    <td class="lineNumber">2191</td>
    <td class="codeline">                                                  Func, Header);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2192</td>
    <td class="codeline">    if (ParentL)</td>
    <td class="lineNumber">2192</td>
    <td class="codeline">    if (ParentL)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2193</td>
    <td class="codeline">      ParentL->addBasicBlockToLoop(NewPreheader, *LF);</td>
    <td class="lineNumber">2193</td>
    <td class="codeline">      ParentL->addBasicBlockToLoop(NewPreheader, *LF);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2194</td>
    <td class="codeline">    IRBuilder<>(NewPreheader).CreateBr(Header);</td>
    <td class="lineNumber">2194</td>
    <td class="codeline">    IRBuilder<>(NewPreheader).CreateBr(Header);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2195</td>
    <td class="codeline">    for (auto &In : *Header) {</td>
    <td class="lineNumber">2195</td>
    <td class="codeline">    for (auto &In : *Header) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2196</td>
    <td class="codeline">      PHINode *PN = dyn_cast<PHINode>(&In);</td>
    <td class="lineNumber">2196</td>
    <td class="codeline">      PHINode *PN = dyn_cast<PHINode>(&In);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2197</td>
    <td class="codeline">      if (!PN)</td>
    <td class="lineNumber">2197</td>
    <td class="codeline">      if (!PN)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2198</td>
    <td class="codeline">        break;</td>
    <td class="lineNumber">2198</td>
    <td class="codeline">        break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2199</td>
    <td class="codeline">      int bx = PN->getBasicBlockIndex(Preheader);</td>
    <td class="lineNumber">2199</td>
    <td class="codeline">      int bx = PN->getBasicBlockIndex(Preheader);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2200</td>
    <td class="codeline">      if (bx >= 0)</td>
    <td class="lineNumber">2200</td>
    <td class="codeline">      if (bx >= 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2201</td>
    <td class="codeline">        PN->setIncomingBlock(bx, NewPreheader);</td>
    <td class="lineNumber">2201</td>
    <td class="codeline">        PN->setIncomingBlock(bx, NewPreheader);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2202</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2202</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2203</td>
    <td class="codeline">    DT->addNewBlock(NewPreheader, Preheader);</td>
    <td class="lineNumber">2203</td>
    <td class="codeline">    DT->addNewBlock(NewPreheader, Preheader);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2204</td>
    <td class="codeline">    DT->changeImmediateDominator(Header, NewPreheader);</td>
    <td class="lineNumber">2204</td>
    <td class="codeline">    DT->changeImmediateDominator(Header, NewPreheader);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2205</td>
    <td class="codeline"></td>
    <td class="lineNumber">2205</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2206</td>
    <td class="codeline">    // Check for safe conditions to execute memmove.</td>
    <td class="lineNumber">2206</td>
    <td class="codeline">    // Check for safe conditions to execute memmove.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2207</td>
    <td class="codeline">    // If stride is positive, copying things from higher to lower addresses</td>
    <td class="lineNumber">2207</td>
    <td class="codeline">    // If stride is positive, copying things from higher to lower addresses</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2208</td>
    <td class="codeline">    // is equivalent to memmove.  For negative stride, it's the other way</td>
    <td class="lineNumber">2208</td>
    <td class="codeline">    // is equivalent to memmove.  For negative stride, it's the other way</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2209</td>
    <td class="codeline">    // around.  Copying forward in memory with positive stride may not be</td>
    <td class="lineNumber">2209</td>
    <td class="codeline">    // around.  Copying forward in memory with positive stride may not be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2210</td>
    <td class="codeline">    // same as memmove since we may be copying values that we just stored</td>
    <td class="lineNumber">2210</td>
    <td class="codeline">    // same as memmove since we may be copying values that we just stored</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2211</td>
    <td class="codeline">    // in some previous iteration.</td>
    <td class="lineNumber">2211</td>
    <td class="codeline">    // in some previous iteration.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2212</td>
    <td class="codeline">    Value *LA = Builder.CreatePtrToInt(LoadBasePtr, IntPtrTy);</td>
    <td class="lineNumber">2212</td>
    <td class="codeline">    Value *LA = Builder.CreatePtrToInt(LoadBasePtr, IntPtrTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2213</td>
    <td class="codeline">    Value *SA = Builder.CreatePtrToInt(StoreBasePtr, IntPtrTy);</td>
    <td class="lineNumber">2213</td>
    <td class="codeline">    Value *SA = Builder.CreatePtrToInt(StoreBasePtr, IntPtrTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2214</td>
    <td class="codeline">    Value *LowA = StridePos ? SA : LA;</td>
    <td class="lineNumber">2214</td>
    <td class="codeline">    Value *LowA = StridePos ? SA : LA;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2215</td>
    <td class="codeline">    Value *HighA = StridePos ? LA : SA;</td>
    <td class="lineNumber">2215</td>
    <td class="codeline">    Value *HighA = StridePos ? LA : SA;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2216</td>
    <td class="codeline">    Value *CmpA = Builder.CreateICmpULT(LowA, HighA);</td>
    <td class="lineNumber">2216</td>
    <td class="codeline">    Value *CmpA = Builder.CreateICmpULT(LowA, HighA);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2217</td>
    <td class="codeline">    Value *Cond = CmpA;</td>
    <td class="lineNumber">2217</td>
    <td class="codeline">    Value *Cond = CmpA;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2218</td>
    <td class="codeline"></td>
    <td class="lineNumber">2218</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2219</td>
    <td class="codeline">    // Check for distance between pointers. Since the case LowA < HighA</td>
    <td class="lineNumber">2219</td>
    <td class="codeline">    // Check for distance between pointers. Since the case LowA < HighA</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2220</td>
    <td class="codeline">    // is checked for above, assume LowA >= HighA.</td>
    <td class="lineNumber">2220</td>
    <td class="codeline">    // is checked for above, assume LowA >= HighA.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2221</td>
    <td class="codeline">    Value *Dist = Builder.CreateSub(LowA, HighA);</td>
    <td class="lineNumber">2221</td>
    <td class="codeline">    Value *Dist = Builder.CreateSub(LowA, HighA);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2222</td>
    <td class="codeline">    Value *CmpD = Builder.CreateICmpSLE(NumBytes, Dist);</td>
    <td class="lineNumber">2222</td>
    <td class="codeline">    Value *CmpD = Builder.CreateICmpSLE(NumBytes, Dist);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2223</td>
    <td class="codeline">    Value *CmpEither = Builder.CreateOr(Cond, CmpD);</td>
    <td class="lineNumber">2223</td>
    <td class="codeline">    Value *CmpEither = Builder.CreateOr(Cond, CmpD);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2224</td>
    <td class="codeline">    Cond = CmpEither;</td>
    <td class="lineNumber">2224</td>
    <td class="codeline">    Cond = CmpEither;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2225</td>
    <td class="codeline"></td>
    <td class="lineNumber">2225</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2226</td>
    <td class="codeline">    if (Threshold != 0) {</td>
    <td class="lineNumber">2226</td>
    <td class="codeline">    if (Threshold != 0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2227</td>
    <td class="codeline">      Type *Ty = NumBytes->getType();</td>
    <td class="lineNumber">2227</td>
    <td class="codeline">      Type *Ty = NumBytes->getType();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2228</td>
    <td class="codeline">      Value *Thr = ConstantInt::get(Ty, Threshold);</td>
    <td class="lineNumber">2228</td>
    <td class="codeline">      Value *Thr = ConstantInt::get(Ty, Threshold);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2229</td>
    <td class="codeline">      Value *CmpB = Builder.CreateICmpULT(Thr, NumBytes);</td>
    <td class="lineNumber">2229</td>
    <td class="codeline">      Value *CmpB = Builder.CreateICmpULT(Thr, NumBytes);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2230</td>
    <td class="codeline">      Value *CmpBoth = Builder.CreateAnd(Cond, CmpB);</td>
    <td class="lineNumber">2230</td>
    <td class="codeline">      Value *CmpBoth = Builder.CreateAnd(Cond, CmpB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2231</td>
    <td class="codeline">      Cond = CmpBoth;</td>
    <td class="lineNumber">2231</td>
    <td class="codeline">      Cond = CmpBoth;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2232</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2232</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2233</td>
    <td class="codeline">    BasicBlock *MemmoveB = BasicBlock::Create(Ctx, Header->getName()+".rtli",</td>
    <td class="lineNumber">2233</td>
    <td class="codeline">    BasicBlock *MemmoveB = BasicBlock::Create(Ctx, Header->getName()+".rtli",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2234</td>
    <td class="codeline">                                              Func, NewPreheader);</td>
    <td class="lineNumber">2234</td>
    <td class="codeline">                                              Func, NewPreheader);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2235</td>
    <td class="codeline">    if (ParentL)</td>
    <td class="lineNumber">2235</td>
    <td class="codeline">    if (ParentL)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2236</td>
    <td class="codeline">      ParentL->addBasicBlockToLoop(MemmoveB, *LF);</td>
    <td class="lineNumber">2236</td>
    <td class="codeline">      ParentL->addBasicBlockToLoop(MemmoveB, *LF);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2237</td>
    <td class="codeline">    Instruction *OldT = Preheader->getTerminator();</td>
    <td class="lineNumber">2237</td>
    <td class="codeline">    Instruction *OldT = Preheader->getTerminator();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2238</td>
    <td class="codeline">    Builder.CreateCondBr(Cond, MemmoveB, NewPreheader);</td>
    <td class="lineNumber">2238</td>
    <td class="codeline">    Builder.CreateCondBr(Cond, MemmoveB, NewPreheader);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2239</td>
    <td class="codeline">    OldT->eraseFromParent();</td>
    <td class="lineNumber">2239</td>
    <td class="codeline">    OldT->eraseFromParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2240</td>
    <td class="codeline">    Preheader->setName(Preheader->getName()+".old");</td>
    <td class="lineNumber">2240</td>
    <td class="codeline">    Preheader->setName(Preheader->getName()+".old");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2241</td>
    <td class="codeline">    DT->addNewBlock(MemmoveB, Preheader);</td>
    <td class="lineNumber">2241</td>
    <td class="codeline">    DT->addNewBlock(MemmoveB, Preheader);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2242</td>
    <td class="codeline">    // Find the new immediate dominator of the exit block.</td>
    <td class="lineNumber">2242</td>
    <td class="codeline">    // Find the new immediate dominator of the exit block.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2243</td>
    <td class="codeline">    BasicBlock *ExitD = Preheader;</td>
    <td class="lineNumber">2243</td>
    <td class="codeline">    BasicBlock *ExitD = Preheader;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2244</td>
    <td class="codeline">    for (BasicBlock *PB : predecessors(ExitB)) {</td>
    <td class="lineNumber">2244</td>
    <td class="codeline">    for (BasicBlock *PB : predecessors(ExitB)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2245</td>
    <td class="codeline">      ExitD = DT->findNearestCommonDominator(ExitD, PB);</td>
    <td class="lineNumber">2245</td>
    <td class="codeline">      ExitD = DT->findNearestCommonDominator(ExitD, PB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2246</td>
    <td class="codeline">      if (!ExitD)</td>
    <td class="lineNumber">2246</td>
    <td class="codeline">      if (!ExitD)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2247</td>
    <td class="codeline">        break;</td>
    <td class="lineNumber">2247</td>
    <td class="codeline">        break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2248</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2248</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2249</td>
    <td class="codeline">    // If the prior immediate dominator of ExitB was dominated by the</td>
    <td class="lineNumber">2249</td>
    <td class="codeline">    // If the prior immediate dominator of ExitB was dominated by the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2250</td>
    <td class="codeline">    // old preheader, then the old preheader becomes the new immediate</td>
    <td class="lineNumber">2250</td>
    <td class="codeline">    // old preheader, then the old preheader becomes the new immediate</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2251</td>
    <td class="codeline">    // dominator.  Otherwise don't change anything (because the newly</td>
    <td class="lineNumber">2251</td>
    <td class="codeline">    // dominator.  Otherwise don't change anything (because the newly</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2252</td>
    <td class="codeline">    // added blocks are dominated by the old preheader).</td>
    <td class="lineNumber">2252</td>
    <td class="codeline">    // added blocks are dominated by the old preheader).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2253</td>
    <td class="codeline">    if (ExitD && DT->dominates(Preheader, ExitD)) {</td>
    <td class="lineNumber">2253</td>
    <td class="codeline">    if (ExitD && DT->dominates(Preheader, ExitD)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2254</td>
    <td class="codeline">      DomTreeNode *BN = DT->getNode(ExitB);</td>
    <td class="lineNumber">2254</td>
    <td class="codeline">      DomTreeNode *BN = DT->getNode(ExitB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2255</td>
    <td class="codeline">      DomTreeNode *DN = DT->getNode(ExitD);</td>
    <td class="lineNumber">2255</td>
    <td class="codeline">      DomTreeNode *DN = DT->getNode(ExitD);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2256</td>
    <td class="codeline">      BN->setIDom(DN);</td>
    <td class="lineNumber">2256</td>
    <td class="codeline">      BN->setIDom(DN);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2257</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2257</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2258</td>
    <td class="codeline"></td>
    <td class="lineNumber">2258</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2259</td>
    <td class="codeline">    // Add a call to memmove to the conditional block.</td>
    <td class="lineNumber">2259</td>
    <td class="codeline">    // Add a call to memmove to the conditional block.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2260</td>
    <td class="codeline">    IRBuilder<> CondBuilder(MemmoveB);</td>
    <td class="lineNumber">2260</td>
    <td class="codeline">    IRBuilder<> CondBuilder(MemmoveB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2261</td>
    <td class="codeline">    CondBuilder.CreateBr(ExitB);</td>
    <td class="lineNumber">2261</td>
    <td class="codeline">    CondBuilder.CreateBr(ExitB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2262</td>
    <td class="codeline">    CondBuilder.SetInsertPoint(MemmoveB->getTerminator());</td>
    <td class="lineNumber">2262</td>
    <td class="codeline">    CondBuilder.SetInsertPoint(MemmoveB->getTerminator());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2263</td>
    <td class="codeline"></td>
    <td class="lineNumber">2263</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2264</td>
    <td class="codeline">    if (DestVolatile) {</td>
    <td class="lineNumber">2264</td>
    <td class="codeline">    if (DestVolatile) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2265</td>
    <td class="codeline">      Type *Int32Ty = Type::getInt32Ty(Ctx);</td>
    <td class="lineNumber">2265</td>
    <td class="codeline">      Type *Int32Ty = Type::getInt32Ty(Ctx);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2266</td>
    <td class="codeline">      Type *Int32PtrTy = Type::getInt32PtrTy(Ctx);</td>
    <td class="lineNumber">2266</td>
    <td class="codeline">      Type *Int32PtrTy = Type::getInt32PtrTy(Ctx);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2267</td>
    <td class="codeline">      Type *VoidTy = Type::getVoidTy(Ctx);</td>
    <td class="lineNumber">2267</td>
    <td class="codeline">      Type *VoidTy = Type::getVoidTy(Ctx);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2268</td>
    <td class="codeline">      Module *M = Func->getParent();</td>
    <td class="lineNumber">2268</td>
    <td class="codeline">      Module *M = Func->getParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2269</td>
    <td class="codeline">      FunctionCallee Fn = M->getOrInsertFunction(</td>
    <td class="lineNumber">2269</td>
    <td class="codeline">      FunctionCallee Fn = M->getOrInsertFunction(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2270</td>
    <td class="codeline">          HexagonVolatileMemcpyName, VoidTy, Int32PtrTy, Int32PtrTy, Int32Ty);</td>
    <td class="lineNumber">2270</td>
    <td class="codeline">          HexagonVolatileMemcpyName, VoidTy, Int32PtrTy, Int32PtrTy, Int32Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2271</td>
    <td class="codeline"></td>
    <td class="lineNumber">2271</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2272</td>
    <td class="codeline">      const SCEV *OneS = SE->getConstant(Int32Ty, 1);</td>
    <td class="lineNumber">2272</td>
    <td class="codeline">      const SCEV *OneS = SE->getConstant(Int32Ty, 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2273</td>
    <td class="codeline">      const SCEV *BECount32 = SE->getTruncateOrZeroExtend(BECount, Int32Ty);</td>
    <td class="lineNumber">2273</td>
    <td class="codeline">      const SCEV *BECount32 = SE->getTruncateOrZeroExtend(BECount, Int32Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2274</td>
    <td class="codeline">      const SCEV *NumWordsS = SE->getAddExpr(BECount32, OneS, SCEV::FlagNUW);</td>
    <td class="lineNumber">2274</td>
    <td class="codeline">      const SCEV *NumWordsS = SE->getAddExpr(BECount32, OneS, SCEV::FlagNUW);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2275</td>
    <td class="codeline">      Value *NumWords = Expander.expandCodeFor(NumWordsS, Int32Ty,</td>
    <td class="lineNumber">2275</td>
    <td class="codeline">      Value *NumWords = Expander.expandCodeFor(NumWordsS, Int32Ty,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2276</td>
    <td class="codeline">                                               MemmoveB->getTerminator());</td>
    <td class="lineNumber">2276</td>
    <td class="codeline">                                               MemmoveB->getTerminator());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2277</td>
    <td class="codeline">      if (Instruction *In = dyn_cast<Instruction>(NumWords))</td>
    <td class="lineNumber">2277</td>
    <td class="codeline">      if (Instruction *In = dyn_cast<Instruction>(NumWords))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2278</td>
    <td class="codeline">        if (Value *Simp = simplifyInstruction(In, {*DL, TLI, DT}))</td>
    <td class="lineNumber">2278</td>
    <td class="codeline">        if (Value *Simp = simplifyInstruction(In, {*DL, TLI, DT}))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2279</td>
    <td class="codeline">          NumWords = Simp;</td>
    <td class="lineNumber">2279</td>
    <td class="codeline">          NumWords = Simp;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2280</td>
    <td class="codeline"></td>
    <td class="lineNumber">2280</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2281</td>
    <td class="codeline">      Value *Op0 = (StoreBasePtr->getType() == Int32PtrTy)</td>
    <td class="lineNumber">2281</td>
    <td class="codeline">      Value *Op0 = (StoreBasePtr->getType() == Int32PtrTy)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2282</td>
    <td class="codeline">                      ? StoreBasePtr</td>
    <td class="lineNumber">2282</td>
    <td class="codeline">                      ? StoreBasePtr</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2283</td>
    <td class="codeline">                      : CondBuilder.CreateBitCast(StoreBasePtr, Int32PtrTy);</td>
    <td class="lineNumber">2283</td>
    <td class="codeline">                      : CondBuilder.CreateBitCast(StoreBasePtr, Int32PtrTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2284</td>
    <td class="codeline">      Value *Op1 = (LoadBasePtr->getType() == Int32PtrTy)</td>
    <td class="lineNumber">2284</td>
    <td class="codeline">      Value *Op1 = (LoadBasePtr->getType() == Int32PtrTy)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2285</td>
    <td class="codeline">                      ? LoadBasePtr</td>
    <td class="lineNumber">2285</td>
    <td class="codeline">                      ? LoadBasePtr</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2286</td>
    <td class="codeline">                      : CondBuilder.CreateBitCast(LoadBasePtr, Int32PtrTy);</td>
    <td class="lineNumber">2286</td>
    <td class="codeline">                      : CondBuilder.CreateBitCast(LoadBasePtr, Int32PtrTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2287</td>
    <td class="codeline">      NewCall = CondBuilder.CreateCall(Fn, {Op0, Op1, NumWords});</td>
    <td class="lineNumber">2287</td>
    <td class="codeline">      NewCall = CondBuilder.CreateCall(Fn, {Op0, Op1, NumWords});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2288</td>
    <td class="codeline">    } else {</td>
    <td class="lineNumber">2288</td>
    <td class="codeline">    } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2289</td>
    <td class="codeline">      NewCall = CondBuilder.CreateMemMove(</td>
    <td class="lineNumber">2289</td>
    <td class="codeline">      NewCall = CondBuilder.CreateMemMove(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2290</td>
    <td class="codeline">          StoreBasePtr, SI->getAlign(), LoadBasePtr, LI->getAlign(), NumBytes);</td>
    <td class="lineNumber">2290</td>
    <td class="codeline">          StoreBasePtr, SI->getAlign(), LoadBasePtr, LI->getAlign(), NumBytes);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2291</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2291</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2292</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">2292</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2293</td>
    <td class="codeline">    NewCall = Builder.CreateMemCpy(StoreBasePtr, SI->getAlign(), LoadBasePtr,</td>
    <td class="lineNumber">2293</td>
    <td class="codeline">    NewCall = Builder.CreateMemCpy(StoreBasePtr, SI->getAlign(), LoadBasePtr,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2294</td>
    <td class="codeline">                                   LI->getAlign(), NumBytes);</td>
    <td class="lineNumber">2294</td>
    <td class="codeline">                                   LI->getAlign(), NumBytes);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2295</td>
    <td class="codeline">    // Okay, the memcpy has been formed.  Zap the original store and</td>
    <td class="lineNumber">2295</td>
    <td class="codeline">    // Okay, the memcpy has been formed.  Zap the original store and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2296</td>
    <td class="codeline">    // anything that feeds into it.</td>
    <td class="lineNumber">2296</td>
    <td class="codeline">    // anything that feeds into it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2297</td>
    <td class="codeline">    RecursivelyDeleteTriviallyDeadInstructions(SI, TLI);</td>
    <td class="lineNumber">2297</td>
    <td class="codeline">    RecursivelyDeleteTriviallyDeadInstructions(SI, TLI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2298</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2298</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2299</td>
    <td class="codeline"></td>
    <td class="lineNumber">2299</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2300</td>
    <td class="codeline">  NewCall->setDebugLoc(DLoc);</td>
    <td class="lineNumber">2300</td>
    <td class="codeline">  NewCall->setDebugLoc(DLoc);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2301</td>
    <td class="codeline"></td>
    <td class="lineNumber">2301</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2302</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "  Formed " << (Overlap ? "memmove: " : "memcpy: ")</td>
    <td class="lineNumber">2302</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "  Formed " << (Overlap ? "memmove: " : "memcpy: ")</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2303</td>
    <td class="codeline">                    << *NewCall << "\n"</td>
    <td class="lineNumber">2303</td>
    <td class="codeline">                    << *NewCall << "\n"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2304</td>
    <td class="codeline">                    << "    from load ptr=" << *LoadEv << " at: " << *LI << "\n"</td>
    <td class="lineNumber">2304</td>
    <td class="codeline">                    << "    from load ptr=" << *LoadEv << " at: " << *LI << "\n"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2305</td>
    <td class="codeline">                    << "    from store ptr=" << *StoreEv << " at: " << *SI</td>
    <td class="lineNumber">2305</td>
    <td class="codeline">                    << "    from store ptr=" << *StoreEv << " at: " << *SI</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2306</td>
    <td class="codeline">                    << "\n");</td>
    <td class="lineNumber">2306</td>
    <td class="codeline">                    << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2307</td>
    <td class="codeline"></td>
    <td class="lineNumber">2307</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2308</td>
    <td class="codeline">  return true;</td>
    <td class="lineNumber">2308</td>
    <td class="codeline">  return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2309</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2309</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2310</td>
    <td class="codeline"></td>
    <td class="lineNumber">2310</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2311</td>
    <td class="codeline">// Check if the instructions in Insts, together with their dependencies</td>
    <td class="lineNumber">2311</td>
    <td class="codeline">// Check if the instructions in Insts, together with their dependencies</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2312</td>
    <td class="codeline">// cover the loop in the sense that the loop could be safely eliminated once</td>
    <td class="lineNumber">2312</td>
    <td class="codeline">// cover the loop in the sense that the loop could be safely eliminated once</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2313</td>
    <td class="codeline">// the instructions in Insts are removed.</td>
    <td class="lineNumber">2313</td>
    <td class="codeline">// the instructions in Insts are removed.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2314</td>
    <td class="codeline">bool HexagonLoopIdiomRecognize::coverLoop(Loop *L,</td>
    <td class="lineNumber">2314</td>
    <td class="codeline">bool HexagonLoopIdiomRecognize::coverLoop(Loop *L,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2315</td>
    <td class="codeline">      SmallVectorImpl<Instruction*> &Insts) const {</td>
    <td class="lineNumber">2315</td>
    <td class="codeline">      SmallVectorImpl<Instruction*> &Insts) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2316</td>
    <td class="codeline">  SmallSet<BasicBlock*,8> LoopBlocks;</td>
    <td class="lineNumber">2316</td>
    <td class="codeline">  SmallSet<BasicBlock*,8> LoopBlocks;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2317</td>
    <td class="codeline">  for (auto *B : L->blocks())</td>
    <td class="lineNumber">2317</td>
    <td class="codeline">  for (auto *B : L->blocks())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2318</td>
    <td class="codeline">    LoopBlocks.insert(B);</td>
    <td class="lineNumber">2318</td>
    <td class="codeline">    LoopBlocks.insert(B);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2319</td>
    <td class="codeline"></td>
    <td class="lineNumber">2319</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2320</td>
    <td class="codeline">  SetVector<Instruction*> Worklist(Insts.begin(), Insts.end());</td>
    <td class="lineNumber">2320</td>
    <td class="codeline">  SetVector<Instruction*> Worklist(Insts.begin(), Insts.end());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2321</td>
    <td class="codeline"></td>
    <td class="lineNumber">2321</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2322</td>
    <td class="codeline">  // Collect all instructions from the loop that the instructions in Insts</td>
    <td class="lineNumber">2322</td>
    <td class="codeline">  // Collect all instructions from the loop that the instructions in Insts</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2323</td>
    <td class="codeline">  // depend on (plus their dependencies, etc.).  These instructions will</td>
    <td class="lineNumber">2323</td>
    <td class="codeline">  // depend on (plus their dependencies, etc.).  These instructions will</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2324</td>
    <td class="codeline">  // constitute the expression trees that feed those in Insts, but the trees</td>
    <td class="lineNumber">2324</td>
    <td class="codeline">  // constitute the expression trees that feed those in Insts, but the trees</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2325</td>
    <td class="codeline">  // will be limited only to instructions contained in the loop.</td>
    <td class="lineNumber">2325</td>
    <td class="codeline">  // will be limited only to instructions contained in the loop.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2326</td>
    <td class="codeline">  for (unsigned i = 0; i < Worklist.size(); ++i) {</td>
    <td class="lineNumber">2326</td>
    <td class="codeline">  for (unsigned i = 0; i < Worklist.size(); ++i) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2327</td>
    <td class="codeline">    Instruction *In = Worklist[i];</td>
    <td class="lineNumber">2327</td>
    <td class="codeline">    Instruction *In = Worklist[i];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2328</td>
    <td class="codeline">    for (auto I = In->op_begin(), E = In->op_end(); I != E; ++I) {</td>
    <td class="lineNumber">2328</td>
    <td class="codeline">    for (auto I = In->op_begin(), E = In->op_end(); I != E; ++I) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2329</td>
    <td class="codeline">      Instruction *OpI = dyn_cast<Instruction>(I);</td>
    <td class="lineNumber">2329</td>
    <td class="codeline">      Instruction *OpI = dyn_cast<Instruction>(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2330</td>
    <td class="codeline">      if (!OpI)</td>
    <td class="lineNumber">2330</td>
    <td class="codeline">      if (!OpI)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2331</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">2331</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2332</td>
    <td class="codeline">      BasicBlock *PB = OpI->getParent();</td>
    <td class="lineNumber">2332</td>
    <td class="codeline">      BasicBlock *PB = OpI->getParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2333</td>
    <td class="codeline">      if (!LoopBlocks.count(PB))</td>
    <td class="lineNumber">2333</td>
    <td class="codeline">      if (!LoopBlocks.count(PB))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2334</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">2334</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2335</td>
    <td class="codeline">      Worklist.insert(OpI);</td>
    <td class="lineNumber">2335</td>
    <td class="codeline">      Worklist.insert(OpI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2336</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2336</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2337</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2337</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2338</td>
    <td class="codeline"></td>
    <td class="lineNumber">2338</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2339</td>
    <td class="codeline">  // Scan all instructions in the loop, if any of them have a user outside</td>
    <td class="lineNumber">2339</td>
    <td class="codeline">  // Scan all instructions in the loop, if any of them have a user outside</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2340</td>
    <td class="codeline">  // of the loop, or outside of the expressions collected above, then either</td>
    <td class="lineNumber">2340</td>
    <td class="codeline">  // of the loop, or outside of the expressions collected above, then either</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2341</td>
    <td class="codeline">  // the loop has a side-effect visible outside of it, or there are</td>
    <td class="lineNumber">2341</td>
    <td class="codeline">  // the loop has a side-effect visible outside of it, or there are</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2342</td>
    <td class="codeline">  // instructions in it that are not involved in the original set Insts.</td>
    <td class="lineNumber">2342</td>
    <td class="codeline">  // instructions in it that are not involved in the original set Insts.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2343</td>
    <td class="codeline">  for (auto *B : L->blocks()) {</td>
    <td class="lineNumber">2343</td>
    <td class="codeline">  for (auto *B : L->blocks()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2344</td>
    <td class="codeline">    for (auto &In : *B) {</td>
    <td class="lineNumber">2344</td>
    <td class="codeline">    for (auto &In : *B) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2345</td>
    <td class="codeline">      if (isa<BranchInst>(In) || isa<DbgInfoIntrinsic>(In))</td>
    <td class="lineNumber">2345</td>
    <td class="codeline">      if (isa<BranchInst>(In) || isa<DbgInfoIntrinsic>(In))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2346</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">2346</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2347</td>
    <td class="codeline">      if (!Worklist.count(&In) && In.mayHaveSideEffects())</td>
    <td class="lineNumber">2347</td>
    <td class="codeline">      if (!Worklist.count(&In) && In.mayHaveSideEffects())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2348</td>
    <td class="codeline">        return false;</td>
    <td class="lineNumber">2348</td>
    <td class="codeline">        return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2349</td>
    <td class="codeline">      for (auto *K : In.users()) {</td>
    <td class="lineNumber">2349</td>
    <td class="codeline">      for (auto *K : In.users()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2350</td>
    <td class="codeline">        Instruction *UseI = dyn_cast<Instruction>(K);</td>
    <td class="lineNumber">2350</td>
    <td class="codeline">        Instruction *UseI = dyn_cast<Instruction>(K);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2351</td>
    <td class="codeline">        if (!UseI)</td>
    <td class="lineNumber">2351</td>
    <td class="codeline">        if (!UseI)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2352</td>
    <td class="codeline">          continue;</td>
    <td class="lineNumber">2352</td>
    <td class="codeline">          continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2353</td>
    <td class="codeline">        BasicBlock *UseB = UseI->getParent();</td>
    <td class="lineNumber">2353</td>
    <td class="codeline">        BasicBlock *UseB = UseI->getParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2354</td>
    <td class="codeline">        if (LF->getLoopFor(UseB) != L)</td>
    <td class="lineNumber">2354</td>
    <td class="codeline">        if (LF->getLoopFor(UseB) != L)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2355</td>
    <td class="codeline">          return false;</td>
    <td class="lineNumber">2355</td>
    <td class="codeline">          return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2356</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">2356</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2357</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2357</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2358</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2358</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2359</td>
    <td class="codeline"></td>
    <td class="lineNumber">2359</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2360</td>
    <td class="codeline">  return true;</td>
    <td class="lineNumber">2360</td>
    <td class="codeline">  return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2361</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2361</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2362</td>
    <td class="codeline"></td>
    <td class="lineNumber">2362</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2363</td>
    <td class="codeline">/// runOnLoopBlock - Process the specified block, which lives in a counted loop</td>
    <td class="lineNumber">2363</td>
    <td class="codeline">/// runOnLoopBlock - Process the specified block, which lives in a counted loop</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2364</td>
    <td class="codeline">/// with the specified backedge count.  This block is known to be in the current</td>
    <td class="lineNumber">2364</td>
    <td class="codeline">/// with the specified backedge count.  This block is known to be in the current</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2365</td>
    <td class="codeline">/// loop and not in any subloops.</td>
    <td class="lineNumber">2365</td>
    <td class="codeline">/// loop and not in any subloops.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2366</td>
    <td class="codeline">bool HexagonLoopIdiomRecognize::runOnLoopBlock(Loop *CurLoop, BasicBlock *BB,</td>
    <td class="lineNumber">2366</td>
    <td class="codeline">bool HexagonLoopIdiomRecognize::runOnLoopBlock(Loop *CurLoop, BasicBlock *BB,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2367</td>
    <td class="codeline">      const SCEV *BECount, SmallVectorImpl<BasicBlock*> &ExitBlocks) {</td>
    <td class="lineNumber">2367</td>
    <td class="codeline">      const SCEV *BECount, SmallVectorImpl<BasicBlock*> &ExitBlocks) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2368</td>
    <td class="codeline">  // We can only promote stores in this block if they are unconditionally</td>
    <td class="lineNumber">2368</td>
    <td class="codeline">  // We can only promote stores in this block if they are unconditionally</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2369</td>
    <td class="codeline">  // executed in the loop.  For a block to be unconditionally executed, it has</td>
    <td class="lineNumber">2369</td>
    <td class="codeline">  // executed in the loop.  For a block to be unconditionally executed, it has</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2370</td>
    <td class="codeline">  // to dominate all the exit blocks of the loop.  Verify this now.</td>
    <td class="lineNumber">2370</td>
    <td class="codeline">  // to dominate all the exit blocks of the loop.  Verify this now.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2371</td>
    <td class="codeline">  auto DominatedByBB = [this,BB] (BasicBlock *EB) -> bool {</td>
    <td class="lineNumber">2371</td>
    <td class="codeline">  auto DominatedByBB = [this,BB] (BasicBlock *EB) -> bool {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2372</td>
    <td class="codeline">    return DT->dominates(BB, EB);</td>
    <td class="lineNumber">2372</td>
    <td class="codeline">    return DT->dominates(BB, EB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2373</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">2373</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2374</td>
    <td class="codeline">  if (!all_of(ExitBlocks, DominatedByBB))</td>
    <td class="lineNumber">2374</td>
    <td class="codeline">  if (!all_of(ExitBlocks, DominatedByBB))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2375</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">2375</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2376</td>
    <td class="codeline"></td>
    <td class="lineNumber">2376</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2377</td>
    <td class="codeline">  bool MadeChange = false;</td>
    <td class="lineNumber">2377</td>
    <td class="codeline">  bool MadeChange = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2378</td>
    <td class="codeline">  // Look for store instructions, which may be optimized to memset/memcpy.</td>
    <td class="lineNumber">2378</td>
    <td class="codeline">  // Look for store instructions, which may be optimized to memset/memcpy.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2379</td>
    <td class="codeline">  SmallVector<StoreInst*,8> Stores;</td>
    <td class="lineNumber">2379</td>
    <td class="codeline">  SmallVector<StoreInst*,8> Stores;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2380</td>
    <td class="codeline">  collectStores(CurLoop, BB, Stores);</td>
    <td class="lineNumber">2380</td>
    <td class="codeline">  collectStores(CurLoop, BB, Stores);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2381</td>
    <td class="codeline"></td>
    <td class="lineNumber">2381</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2382</td>
    <td class="codeline">  // Optimize the store into a memcpy, if it feeds an similarly strided load.</td>
    <td class="lineNumber">2382</td>
    <td class="codeline">  // Optimize the store into a memcpy, if it feeds an similarly strided load.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2383</td>
    <td class="codeline">  for (auto &SI : Stores)</td>
    <td class="lineNumber">2383</td>
    <td class="codeline">  for (auto &SI : Stores)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2384</td>
    <td class="codeline">    MadeChange |= processCopyingStore(CurLoop, SI, BECount);</td>
    <td class="lineNumber">2384</td>
    <td class="codeline">    MadeChange |= processCopyingStore(CurLoop, SI, BECount);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2385</td>
    <td class="codeline"></td>
    <td class="lineNumber">2385</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2386</td>
    <td class="codeline">  return MadeChange;</td>
    <td class="lineNumber">2386</td>
    <td class="codeline">  return MadeChange;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2387</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2387</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2388</td>
    <td class="codeline"></td>
    <td class="lineNumber">2388</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2389</td>
    <td class="codeline">bool HexagonLoopIdiomRecognize::runOnCountableLoop(Loop *L) {</td>
    <td class="lineNumber">2389</td>
    <td class="codeline">bool HexagonLoopIdiomRecognize::runOnCountableLoop(Loop *L) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2390</td>
    <td class="codeline">  PolynomialMultiplyRecognize PMR(L, *DL, *DT, *TLI, *SE);</td>
    <td class="lineNumber">2390</td>
    <td class="codeline">  PolynomialMultiplyRecognize PMR(L, *DL, *DT, *TLI, *SE);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2391</td>
    <td class="codeline">  if (PMR.recognize())</td>
    <td class="lineNumber">2391</td>
    <td class="codeline">  if (PMR.recognize())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2392</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">2392</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2393</td>
    <td class="codeline"></td>
    <td class="lineNumber">2393</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2394</td>
    <td class="codeline">  if (!HasMemcpy && !HasMemmove)</td>
    <td class="lineNumber">2394</td>
    <td class="codeline">  if (!HasMemcpy && !HasMemmove)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2395</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">2395</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2396</td>
    <td class="codeline"></td>
    <td class="lineNumber">2396</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2397</td>
    <td class="codeline">  const SCEV *BECount = SE->getBackedgeTakenCount(L);</td>
    <td class="lineNumber">2397</td>
    <td class="codeline">  const SCEV *BECount = SE->getBackedgeTakenCount(L);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2398</td>
    <td class="codeline">  assert(!isa<SCEVCouldNotCompute>(BECount) &&</td>
    <td class="lineNumber">2398</td>
    <td class="codeline">  assert(!isa<SCEVCouldNotCompute>(BECount) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2399</td>
    <td class="codeline">         "runOnCountableLoop() called on a loop without a predictable"</td>
    <td class="lineNumber">2399</td>
    <td class="codeline">         "runOnCountableLoop() called on a loop without a predictable"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2400</td>
    <td class="codeline">         "backedge-taken count");</td>
    <td class="lineNumber">2400</td>
    <td class="codeline">         "backedge-taken count");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2401</td>
    <td class="codeline"></td>
    <td class="lineNumber">2401</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2402</td>
    <td class="codeline">  SmallVector<BasicBlock *, 8> ExitBlocks;</td>
    <td class="lineNumber">2402</td>
    <td class="codeline">  SmallVector<BasicBlock *, 8> ExitBlocks;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2403</td>
    <td class="codeline">  L->getUniqueExitBlocks(ExitBlocks);</td>
    <td class="lineNumber">2403</td>
    <td class="codeline">  L->getUniqueExitBlocks(ExitBlocks);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2404</td>
    <td class="codeline"></td>
    <td class="lineNumber">2404</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2405</td>
    <td class="codeline">  bool Changed = false;</td>
    <td class="lineNumber">2405</td>
    <td class="codeline">  bool Changed = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2406</td>
    <td class="codeline"></td>
    <td class="lineNumber">2406</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2407</td>
    <td class="codeline">  // Scan all the blocks in the loop that are not in subloops.</td>
    <td class="lineNumber">2407</td>
    <td class="codeline">  // Scan all the blocks in the loop that are not in subloops.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2408</td>
    <td class="codeline">  for (auto *BB : L->getBlocks()) {</td>
    <td class="lineNumber">2408</td>
    <td class="codeline">  for (auto *BB : L->getBlocks()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2409</td>
    <td class="codeline">    // Ignore blocks in subloops.</td>
    <td class="lineNumber">2409</td>
    <td class="codeline">    // Ignore blocks in subloops.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2410</td>
    <td class="codeline">    if (LF->getLoopFor(BB) != L)</td>
    <td class="lineNumber">2410</td>
    <td class="codeline">    if (LF->getLoopFor(BB) != L)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2411</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">2411</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2412</td>
    <td class="codeline">    Changed |= runOnLoopBlock(L, BB, BECount, ExitBlocks);</td>
    <td class="lineNumber">2412</td>
    <td class="codeline">    Changed |= runOnLoopBlock(L, BB, BECount, ExitBlocks);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2413</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2413</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2414</td>
    <td class="codeline"></td>
    <td class="lineNumber">2414</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2415</td>
    <td class="codeline">  return Changed;</td>
    <td class="lineNumber">2415</td>
    <td class="codeline">  return Changed;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2416</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2416</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2417</td>
    <td class="codeline"></td>
    <td class="lineNumber">2417</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2418</td>
    <td class="codeline">bool HexagonLoopIdiomRecognize::run(Loop *L) {</td>
    <td class="lineNumber">2418</td>
    <td class="codeline">bool HexagonLoopIdiomRecognize::run(Loop *L) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2419</td>
    <td class="codeline">  const Module &M = *L->getHeader()->getParent()->getParent();</td>
    <td class="lineNumber">2419</td>
    <td class="codeline">  const Module &M = *L->getHeader()->getParent()->getParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2420</td>
    <td class="codeline">  if (Triple(M.getTargetTriple()).getArch() != Triple::hexagon)</td>
    <td class="lineNumber">2420</td>
    <td class="codeline">  if (Triple(M.getTargetTriple()).getArch() != Triple::hexagon)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2421</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">2421</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2422</td>
    <td class="codeline"></td>
    <td class="lineNumber">2422</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2423</td>
    <td class="codeline">  // If the loop could not be converted to canonical form, it must have an</td>
    <td class="lineNumber">2423</td>
    <td class="codeline">  // If the loop could not be converted to canonical form, it must have an</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2424</td>
    <td class="codeline">  // indirectbr in it, just give up.</td>
    <td class="lineNumber">2424</td>
    <td class="codeline">  // indirectbr in it, just give up.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2425</td>
    <td class="codeline">  if (!L->getLoopPreheader())</td>
    <td class="lineNumber">2425</td>
    <td class="codeline">  if (!L->getLoopPreheader())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2426</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">2426</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2427</td>
    <td class="codeline"></td>
    <td class="lineNumber">2427</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2428</td>
    <td class="codeline">  // Disable loop idiom recognition if the function's name is a common idiom.</td>
    <td class="lineNumber">2428</td>
    <td class="codeline">  // Disable loop idiom recognition if the function's name is a common idiom.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2429</td>
    <td class="codeline">  StringRef Name = L->getHeader()->getParent()->getName();</td>
    <td class="lineNumber">2429</td>
    <td class="codeline">  StringRef Name = L->getHeader()->getParent()->getName();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2430</td>
    <td class="codeline">  if (Name == "memset" || Name == "memcpy" || Name == "memmove")</td>
    <td class="lineNumber">2430</td>
    <td class="codeline">  if (Name == "memset" || Name == "memcpy" || Name == "memmove")</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2431</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">2431</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2432</td>
    <td class="codeline"></td>
    <td class="lineNumber">2432</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2433</td>
    <td class="codeline">  DL = &L->getHeader()->getModule()->getDataLayout();</td>
    <td class="lineNumber">2433</td>
    <td class="codeline">  DL = &L->getHeader()->getModule()->getDataLayout();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2434</td>
    <td class="codeline"></td>
    <td class="lineNumber">2434</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2435</td>
    <td class="codeline">  HasMemcpy = TLI->has(LibFunc_memcpy);</td>
    <td class="lineNumber">2435</td>
    <td class="codeline">  HasMemcpy = TLI->has(LibFunc_memcpy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2436</td>
    <td class="codeline">  HasMemmove = TLI->has(LibFunc_memmove);</td>
    <td class="lineNumber">2436</td>
    <td class="codeline">  HasMemmove = TLI->has(LibFunc_memmove);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2437</td>
    <td class="codeline"></td>
    <td class="lineNumber">2437</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2438</td>
    <td class="codeline">  if (SE->hasLoopInvariantBackedgeTakenCount(L))</td>
    <td class="lineNumber">2438</td>
    <td class="codeline">  if (SE->hasLoopInvariantBackedgeTakenCount(L))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2439</td>
    <td class="codeline">    return runOnCountableLoop(L);</td>
    <td class="lineNumber">2439</td>
    <td class="codeline">    return runOnCountableLoop(L);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2440</td>
    <td class="codeline">  return false;</td>
    <td class="lineNumber">2440</td>
    <td class="codeline">  return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2441</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2441</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2442</td>
    <td class="codeline"></td>
    <td class="lineNumber">2442</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2443</td>
    <td class="codeline">bool HexagonLoopIdiomRecognizeLegacyPass::runOnLoop(Loop *L,</td>
    <td class="lineNumber">2443</td>
    <td class="codeline">bool HexagonLoopIdiomRecognizeLegacyPass::runOnLoop(Loop *L,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2444</td>
    <td class="codeline">                                                    LPPassManager &LPM) {</td>
    <td class="lineNumber">2444</td>
    <td class="codeline">                                                    LPPassManager &LPM) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2445</td>
    <td class="codeline">  if (skipLoop(L))</td>
    <td class="lineNumber">2445</td>
    <td class="codeline">  if (skipLoop(L))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2446</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">2446</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2447</td>
    <td class="codeline"></td>
    <td class="lineNumber">2447</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2448</td>
    <td class="codeline">  auto *AA = &getAnalysis<AAResultsWrapperPass>().getAAResults();</td>
    <td class="lineNumber">2448</td>
    <td class="codeline">  auto *AA = &getAnalysis<AAResultsWrapperPass>().getAAResults();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2449</td>
    <td class="codeline">  auto *DT = &getAnalysis<DominatorTreeWrapperPass>().getDomTree();</td>
    <td class="lineNumber">2449</td>
    <td class="codeline">  auto *DT = &getAnalysis<DominatorTreeWrapperPass>().getDomTree();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2450</td>
    <td class="codeline">  auto *LF = &getAnalysis<LoopInfoWrapperPass>().getLoopInfo();</td>
    <td class="lineNumber">2450</td>
    <td class="codeline">  auto *LF = &getAnalysis<LoopInfoWrapperPass>().getLoopInfo();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2451</td>
    <td class="codeline">  auto *TLI = &getAnalysis<TargetLibraryInfoWrapperPass>().getTLI(</td>
    <td class="lineNumber">2451</td>
    <td class="codeline">  auto *TLI = &getAnalysis<TargetLibraryInfoWrapperPass>().getTLI(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2452</td>
    <td class="codeline">      *L->getHeader()->getParent());</td>
    <td class="lineNumber">2452</td>
    <td class="codeline">      *L->getHeader()->getParent());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2453</td>
    <td class="codeline">  auto *SE = &getAnalysis<ScalarEvolutionWrapperPass>().getSE();</td>
    <td class="lineNumber">2453</td>
    <td class="codeline">  auto *SE = &getAnalysis<ScalarEvolutionWrapperPass>().getSE();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2454</td>
    <td class="codeline">  return HexagonLoopIdiomRecognize(AA, DT, LF, TLI, SE).run(L);</td>
    <td class="lineNumber">2454</td>
    <td class="codeline">  return HexagonLoopIdiomRecognize(AA, DT, LF, TLI, SE).run(L);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2455</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2455</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2456</td>
    <td class="codeline"></td>
    <td class="lineNumber">2456</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2457</td>
    <td class="codeline">Pass *llvm::createHexagonLoopIdiomPass() {</td>
    <td class="lineNumber">2457</td>
    <td class="codeline">Pass *llvm::createHexagonLoopIdiomPass() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2458</td>
    <td class="codeline">  return new HexagonLoopIdiomRecognizeLegacyPass();</td>
    <td class="lineNumber">2458</td>
    <td class="codeline">  return new HexagonLoopIdiomRecognizeLegacyPass();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2459</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2459</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2460</td>
    <td class="codeline"></td>
    <td class="lineNumber">2460</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2461</td>
    <td class="codeline">PreservedAnalyses</td>
    <td class="lineNumber">2461</td>
    <td class="codeline">PreservedAnalyses</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2462</td>
    <td class="codeline">HexagonLoopIdiomRecognitionPass::run(Loop &L, LoopAnalysisManager &AM,</td>
    <td class="lineNumber">2462</td>
    <td class="codeline">HexagonLoopIdiomRecognitionPass::run(Loop &L, LoopAnalysisManager &AM,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2463</td>
    <td class="codeline">                                     LoopStandardAnalysisResults &AR,</td>
    <td class="lineNumber">2463</td>
    <td class="codeline">                                     LoopStandardAnalysisResults &AR,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2464</td>
    <td class="codeline">                                     LPMUpdater &U) {</td>
    <td class="lineNumber">2464</td>
    <td class="codeline">                                     LPMUpdater &U) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2465</td>
    <td class="codeline">  return HexagonLoopIdiomRecognize(&AR.AA, &AR.DT, &AR.LI, &AR.TLI, &AR.SE)</td>
    <td class="lineNumber">2465</td>
    <td class="codeline">  return HexagonLoopIdiomRecognize(&AR.AA, &AR.DT, &AR.LI, &AR.TLI, &AR.SE)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2466</td>
    <td class="codeline">                 .run(&L)</td>
    <td class="lineNumber">2466</td>
    <td class="codeline">                 .run(&L)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2467</td>
    <td class="codeline">             ? getLoopPassPreservedAnalyses()</td>
    <td class="lineNumber">2467</td>
    <td class="codeline">             ? getLoopPassPreservedAnalyses()</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2468</td>
    <td class="codeline">             : PreservedAnalyses::all();</td>
    <td class="lineNumber">2468</td>
    <td class="codeline">             : PreservedAnalyses::all();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2469</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2469</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2470</td>
    <td class="codeline"></td>
    <td class="lineNumber">2470</td>
    <td class="codeline"></td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Side By Side Comparison</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Side By Side Comparison</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </th>
    <th class="mainTh">Hit count</th>
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </th>
    <th class="mainTh">Hit count</th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="codeLine">//===- HexagonLoopIdiomRecognition.cpp ------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1</td>
    <td class="codeLine">//===- HexagonLoopIdiomRecognition.cpp ------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="codeLine">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3</td>
    <td class="codeLine">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="codeLine">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4</td>
    <td class="codeLine">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="codeLine">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5</td>
    <td class="codeLine">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">6</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">7</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">8</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="codeLine">#include "HexagonLoopIdiomRecognition.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">9</td>
    <td class="codeLine">#include "HexagonLoopIdiomRecognition.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="codeLine">#include "llvm/ADT/APInt.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">10</td>
    <td class="codeLine">#include "llvm/ADT/APInt.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="codeLine">#include "llvm/ADT/DenseMap.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">11</td>
    <td class="codeLine">#include "llvm/ADT/DenseMap.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="codeLine">#include "llvm/ADT/SetVector.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">12</td>
    <td class="codeLine">#include "llvm/ADT/SetVector.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="codeLine">#include "llvm/ADT/SmallPtrSet.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">13</td>
    <td class="codeLine">#include "llvm/ADT/SmallPtrSet.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="codeLine">#include "llvm/ADT/SmallSet.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">14</td>
    <td class="codeLine">#include "llvm/ADT/SmallSet.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="codeLine">#include "llvm/ADT/SmallVector.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">15</td>
    <td class="codeLine">#include "llvm/ADT/SmallVector.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="codeLine">#include "llvm/ADT/StringRef.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">16</td>
    <td class="codeLine">#include "llvm/ADT/StringRef.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="codeLine">#include "llvm/Analysis/AliasAnalysis.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">17</td>
    <td class="codeLine">#include "llvm/Analysis/AliasAnalysis.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="codeLine">#include "llvm/Analysis/InstructionSimplify.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">18</td>
    <td class="codeLine">#include "llvm/Analysis/InstructionSimplify.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="codeLine">#include "llvm/Analysis/LoopAnalysisManager.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">19</td>
    <td class="codeLine">#include "llvm/Analysis/LoopAnalysisManager.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="codeLine">#include "llvm/Analysis/LoopInfo.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">20</td>
    <td class="codeLine">#include "llvm/Analysis/LoopInfo.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="codeLine">#include "llvm/Analysis/LoopPass.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">21</td>
    <td class="codeLine">#include "llvm/Analysis/LoopPass.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="codeLine">#include "llvm/Analysis/MemoryLocation.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">22</td>
    <td class="codeLine">#include "llvm/Analysis/MemoryLocation.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="codeLine">#include "llvm/Analysis/ScalarEvolution.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">23</td>
    <td class="codeLine">#include "llvm/Analysis/ScalarEvolution.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="codeLine">#include "llvm/Analysis/ScalarEvolutionExpressions.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">24</td>
    <td class="codeLine">#include "llvm/Analysis/ScalarEvolutionExpressions.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="codeLine">#include "llvm/Analysis/TargetLibraryInfo.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">25</td>
    <td class="codeLine">#include "llvm/Analysis/TargetLibraryInfo.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="codeLine">#include "llvm/Analysis/ValueTracking.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">26</td>
    <td class="codeLine">#include "llvm/Analysis/ValueTracking.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="codeLine">#include "llvm/IR/Attributes.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">27</td>
    <td class="codeLine">#include "llvm/IR/Attributes.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="codeLine">#include "llvm/IR/BasicBlock.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">28</td>
    <td class="codeLine">#include "llvm/IR/BasicBlock.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="codeLine">#include "llvm/IR/Constant.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">29</td>
    <td class="codeLine">#include "llvm/IR/Constant.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="codeLine">#include "llvm/IR/Constants.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">30</td>
    <td class="codeLine">#include "llvm/IR/Constants.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="codeLine">#include "llvm/IR/DataLayout.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">31</td>
    <td class="codeLine">#include "llvm/IR/DataLayout.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="codeLine">#include "llvm/IR/DebugLoc.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">32</td>
    <td class="codeLine">#include "llvm/IR/DebugLoc.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="codeLine">#include "llvm/IR/DerivedTypes.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">33</td>
    <td class="codeLine">#include "llvm/IR/DerivedTypes.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="codeLine">#include "llvm/IR/Dominators.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">34</td>
    <td class="codeLine">#include "llvm/IR/Dominators.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="codeLine">#include "llvm/IR/Function.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">35</td>
    <td class="codeLine">#include "llvm/IR/Function.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="codeLine">#include "llvm/IR/IRBuilder.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">36</td>
    <td class="codeLine">#include "llvm/IR/IRBuilder.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="codeLine">#include "llvm/IR/InstrTypes.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">37</td>
    <td class="codeLine">#include "llvm/IR/InstrTypes.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="codeLine">#include "llvm/IR/Instruction.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">38</td>
    <td class="codeLine">#include "llvm/IR/Instruction.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="codeLine">#include "llvm/IR/Instructions.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">39</td>
    <td class="codeLine">#include "llvm/IR/Instructions.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="codeLine">#include "llvm/IR/IntrinsicInst.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">40</td>
    <td class="codeLine">#include "llvm/IR/IntrinsicInst.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="codeLine">#include "llvm/IR/Intrinsics.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">41</td>
    <td class="codeLine">#include "llvm/IR/Intrinsics.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="codeLine">#include "llvm/IR/IntrinsicsHexagon.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">42</td>
    <td class="codeLine">#include "llvm/IR/IntrinsicsHexagon.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="codeLine">#include "llvm/IR/Module.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">43</td>
    <td class="codeLine">#include "llvm/IR/Module.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="codeLine">#include "llvm/IR/PassManager.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">44</td>
    <td class="codeLine">#include "llvm/IR/PassManager.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="codeLine">#include "llvm/IR/PatternMatch.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">45</td>
    <td class="codeLine">#include "llvm/IR/PatternMatch.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="codeLine">#include "llvm/IR/Type.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">46</td>
    <td class="codeLine">#include "llvm/IR/Type.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="codeLine">#include "llvm/IR/User.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">47</td>
    <td class="codeLine">#include "llvm/IR/User.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="codeLine">#include "llvm/IR/Value.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">48</td>
    <td class="codeLine">#include "llvm/IR/Value.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="codeLine">#include "llvm/InitializePasses.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">49</td>
    <td class="codeLine">#include "llvm/InitializePasses.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="codeLine">#include "llvm/Pass.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">50</td>
    <td class="codeLine">#include "llvm/Pass.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="codeLine">#include "llvm/Support/Casting.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">51</td>
    <td class="codeLine">#include "llvm/Support/Casting.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="codeLine">#include "llvm/Support/CommandLine.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">52</td>
    <td class="codeLine">#include "llvm/Support/CommandLine.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="codeLine">#include "llvm/Support/Compiler.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">53</td>
    <td class="codeLine">#include "llvm/Support/Compiler.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="codeLine">#include "llvm/Support/Debug.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">54</td>
    <td class="codeLine">#include "llvm/Support/Debug.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="codeLine">#include "llvm/Support/ErrorHandling.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">55</td>
    <td class="codeLine">#include "llvm/Support/ErrorHandling.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="codeLine">#include "llvm/Support/KnownBits.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">56</td>
    <td class="codeLine">#include "llvm/Support/KnownBits.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="codeLine">#include "llvm/Support/raw_ostream.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">57</td>
    <td class="codeLine">#include "llvm/Support/raw_ostream.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="codeLine">#include "llvm/TargetParser/Triple.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">58</td>
    <td class="codeLine">#include "llvm/TargetParser/Triple.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="codeLine">#include "llvm/Transforms/Scalar.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">59</td>
    <td class="codeLine">#include "llvm/Transforms/Scalar.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="codeLine">#include "llvm/Transforms/Utils.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">60</td>
    <td class="codeLine">#include "llvm/Transforms/Utils.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="codeLine">#include "llvm/Transforms/Utils/Local.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">61</td>
    <td class="codeLine">#include "llvm/Transforms/Utils/Local.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="codeLine">#include "llvm/Transforms/Utils/ScalarEvolutionExpander.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">62</td>
    <td class="codeLine">#include "llvm/Transforms/Utils/ScalarEvolutionExpander.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="codeLine">#include <algorithm></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">63</td>
    <td class="codeLine">#include <algorithm></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="codeLine">#include <array></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">64</td>
    <td class="codeLine">#include <array></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="codeLine">#include <cassert></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">65</td>
    <td class="codeLine">#include <cassert></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="codeLine">#include <cstdint></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">66</td>
    <td class="codeLine">#include <cstdint></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="codeLine">#include <cstdlib></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">67</td>
    <td class="codeLine">#include <cstdlib></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="codeLine">#include <deque></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">68</td>
    <td class="codeLine">#include <deque></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="codeLine">#include <functional></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">69</td>
    <td class="codeLine">#include <functional></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="codeLine">#include <iterator></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">70</td>
    <td class="codeLine">#include <iterator></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="codeLine">#include <map></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">71</td>
    <td class="codeLine">#include <map></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="codeLine">#include <set></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">72</td>
    <td class="codeLine">#include <set></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="codeLine">#include <utility></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">73</td>
    <td class="codeLine">#include <utility></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="codeLine">#include <vector></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">74</td>
    <td class="codeLine">#include <vector></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">75</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="codeLine">#define DEBUG_TYPE "hexagon-lir"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">76</td>
    <td class="codeLine">#define DEBUG_TYPE "hexagon-lir"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">77</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="codeLine">using namespace llvm;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">78</td>
    <td class="codeLine">using namespace llvm;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">79</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="codeLine">static cl::opt<bool> DisableMemcpyIdiom("disable-memcpy-idiom",</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">80</td>
    <td class="codeLine">static cl::opt<bool> DisableMemcpyIdiom("disable-memcpy-idiom",</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="codeLine">  cl::Hidden, cl::init(false),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">81</td>
    <td class="codeLine">  cl::Hidden, cl::init(false),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="codeLine">  cl::desc("Disable generation of memcpy in loop idiom recognition"));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">82</td>
    <td class="codeLine">  cl::desc("Disable generation of memcpy in loop idiom recognition"));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">83</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="codeLine">static cl::opt<bool> DisableMemmoveIdiom("disable-memmove-idiom",</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">84</td>
    <td class="codeLine">static cl::opt<bool> DisableMemmoveIdiom("disable-memmove-idiom",</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="codeLine">  cl::Hidden, cl::init(false),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">85</td>
    <td class="codeLine">  cl::Hidden, cl::init(false),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="codeLine">  cl::desc("Disable generation of memmove in loop idiom recognition"));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">86</td>
    <td class="codeLine">  cl::desc("Disable generation of memmove in loop idiom recognition"));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">87</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="codeLine">static cl::opt<unsigned> RuntimeMemSizeThreshold("runtime-mem-idiom-threshold",</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">88</td>
    <td class="codeLine">static cl::opt<unsigned> RuntimeMemSizeThreshold("runtime-mem-idiom-threshold",</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="codeLine">  cl::Hidden, cl::init(0), cl::desc("Threshold (in bytes) for the runtime "</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">89</td>
    <td class="codeLine">  cl::Hidden, cl::init(0), cl::desc("Threshold (in bytes) for the runtime "</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="codeLine">  "check guarding the memmove."));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">90</td>
    <td class="codeLine">  "check guarding the memmove."));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">91</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="codeLine">static cl::opt<unsigned> CompileTimeMemSizeThreshold(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">92</td>
    <td class="codeLine">static cl::opt<unsigned> CompileTimeMemSizeThreshold(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="codeLine">  "compile-time-mem-idiom-threshold", cl::Hidden, cl::init(64),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">93</td>
    <td class="codeLine">  "compile-time-mem-idiom-threshold", cl::Hidden, cl::init(64),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="codeLine">  cl::desc("Threshold (in bytes) to perform the transformation, if the "</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">94</td>
    <td class="codeLine">  cl::desc("Threshold (in bytes) to perform the transformation, if the "</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="codeLine">    "runtime loop count (mem transfer size) is known at compile-time."));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">95</td>
    <td class="codeLine">    "runtime loop count (mem transfer size) is known at compile-time."));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">96</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="codeLine">static cl::opt<bool> OnlyNonNestedMemmove("only-nonnested-memmove-idiom",</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">97</td>
    <td class="codeLine">static cl::opt<bool> OnlyNonNestedMemmove("only-nonnested-memmove-idiom",</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="codeLine">  cl::Hidden, cl::init(true),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">98</td>
    <td class="codeLine">  cl::Hidden, cl::init(true),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="codeLine">  cl::desc("Only enable generating memmove in non-nested loops"));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">99</td>
    <td class="codeLine">  cl::desc("Only enable generating memmove in non-nested loops"));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">100</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="codeLine">static cl::opt<bool> HexagonVolatileMemcpy(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">101</td>
    <td class="codeLine">static cl::opt<bool> HexagonVolatileMemcpy(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="codeLine">    "disable-hexagon-volatile-memcpy", cl::Hidden, cl::init(false),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">102</td>
    <td class="codeLine">    "disable-hexagon-volatile-memcpy", cl::Hidden, cl::init(false),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="codeLine">    cl::desc("Enable Hexagon-specific memcpy for volatile destination."));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">103</td>
    <td class="codeLine">    cl::desc("Enable Hexagon-specific memcpy for volatile destination."));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">104</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="codeLine">static cl::opt<unsigned> SimplifyLimit("hlir-simplify-limit", cl::init(10000),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">105</td>
    <td class="codeLine">static cl::opt<unsigned> SimplifyLimit("hlir-simplify-limit", cl::init(10000),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="codeLine">  cl::Hidden, cl::desc("Maximum number of simplification steps in HLIR"));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">106</td>
    <td class="codeLine">  cl::Hidden, cl::desc("Maximum number of simplification steps in HLIR"));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">107</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="codeLine">static const char *HexagonVolatileMemcpyName</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">108</td>
    <td class="codeLine">static const char *HexagonVolatileMemcpyName</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="codeLine">  = "hexagon_memcpy_forward_vp4cp4n2";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">109</td>
    <td class="codeLine">  = "hexagon_memcpy_forward_vp4cp4n2";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">110</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">111</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="codeLine">namespace llvm {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">112</td>
    <td class="codeLine">namespace llvm {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">113</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="codeLine">void initializeHexagonLoopIdiomRecognizeLegacyPassPass(PassRegistry &);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">114</td>
    <td class="codeLine">void initializeHexagonLoopIdiomRecognizeLegacyPassPass(PassRegistry &);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="codeLine">Pass *createHexagonLoopIdiomPass();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">115</td>
    <td class="codeLine">Pass *createHexagonLoopIdiomPass();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">116</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="codeLine">} // end namespace llvm</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">117</td>
    <td class="codeLine">} // end namespace llvm</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">118</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="codeLine">namespace {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">119</td>
    <td class="codeLine">namespace {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">120</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="codeLine">class HexagonLoopIdiomRecognize {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">121</td>
    <td class="codeLine">class HexagonLoopIdiomRecognize {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">122</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="codeLine">  explicit HexagonLoopIdiomRecognize(AliasAnalysis *AA, DominatorTree *DT,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">123</td>
    <td class="codeLine">  explicit HexagonLoopIdiomRecognize(AliasAnalysis *AA, DominatorTree *DT,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="codeLine">                                     LoopInfo *LF, const TargetLibraryInfo *TLI,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">124</td>
    <td class="codeLine">                                     LoopInfo *LF, const TargetLibraryInfo *TLI,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="codeLine">                                     ScalarEvolution *SE)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">125</td>
    <td class="codeLine">                                     ScalarEvolution *SE)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="codeLine">      : AA(AA), DT(DT), LF(LF), TLI(TLI), SE(SE) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">126</td>
    <td class="codeLine">      : AA(AA), DT(DT), LF(LF), TLI(TLI), SE(SE) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">127</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="codeLine">  bool run(Loop *L);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">128</td>
    <td class="codeLine">  bool run(Loop *L);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">129</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">130</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="codeLine">  int getSCEVStride(const SCEVAddRecExpr *StoreEv);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">131</td>
    <td class="codeLine">  int getSCEVStride(const SCEVAddRecExpr *StoreEv);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="codeLine">  bool isLegalStore(Loop *CurLoop, StoreInst *SI);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">132</td>
    <td class="codeLine">  bool isLegalStore(Loop *CurLoop, StoreInst *SI);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="codeLine">  void collectStores(Loop *CurLoop, BasicBlock *BB,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">133</td>
    <td class="codeLine">  void collectStores(Loop *CurLoop, BasicBlock *BB,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="codeLine">                     SmallVectorImpl<StoreInst *> &Stores);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">134</td>
    <td class="codeLine">                     SmallVectorImpl<StoreInst *> &Stores);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="codeLine">  bool processCopyingStore(Loop *CurLoop, StoreInst *SI, const SCEV *BECount);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">135</td>
    <td class="codeLine">  bool processCopyingStore(Loop *CurLoop, StoreInst *SI, const SCEV *BECount);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="codeLine">  bool coverLoop(Loop *L, SmallVectorImpl<Instruction *> &Insts) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">136</td>
    <td class="codeLine">  bool coverLoop(Loop *L, SmallVectorImpl<Instruction *> &Insts) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="codeLine">  bool runOnLoopBlock(Loop *CurLoop, BasicBlock *BB, const SCEV *BECount,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">137</td>
    <td class="codeLine">  bool runOnLoopBlock(Loop *CurLoop, BasicBlock *BB, const SCEV *BECount,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="codeLine">                      SmallVectorImpl<BasicBlock *> &ExitBlocks);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">138</td>
    <td class="codeLine">                      SmallVectorImpl<BasicBlock *> &ExitBlocks);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="codeLine">  bool runOnCountableLoop(Loop *L);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">139</td>
    <td class="codeLine">  bool runOnCountableLoop(Loop *L);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">140</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="codeLine">  AliasAnalysis *AA;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">141</td>
    <td class="codeLine">  AliasAnalysis *AA;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="codeLine">  const DataLayout *DL;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">142</td>
    <td class="codeLine">  const DataLayout *DL;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="codeLine">  DominatorTree *DT;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">143</td>
    <td class="codeLine">  DominatorTree *DT;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="codeLine">  LoopInfo *LF;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">144</td>
    <td class="codeLine">  LoopInfo *LF;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="codeLine">  const TargetLibraryInfo *TLI;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">145</td>
    <td class="codeLine">  const TargetLibraryInfo *TLI;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="codeLine">  ScalarEvolution *SE;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">146</td>
    <td class="codeLine">  ScalarEvolution *SE;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="codeLine">  bool HasMemcpy, HasMemmove;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">147</td>
    <td class="codeLine">  bool HasMemcpy, HasMemmove;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">148</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">149</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="codeLine">class HexagonLoopIdiomRecognizeLegacyPass : public LoopPass {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">150</td>
    <td class="codeLine">class HexagonLoopIdiomRecognizeLegacyPass : public LoopPass {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">151</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="codeLine">  static char ID;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">152</td>
    <td class="codeLine">  static char ID;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">153</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="codeLine">  explicit HexagonLoopIdiomRecognizeLegacyPass() : LoopPass(ID) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">154</td>
    <td class="codeLine">  explicit HexagonLoopIdiomRecognizeLegacyPass() : LoopPass(ID) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="codeLine">    initializeHexagonLoopIdiomRecognizeLegacyPassPass(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">155</td>
    <td class="codeLine">    initializeHexagonLoopIdiomRecognizeLegacyPassPass(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="codeLine">        *PassRegistry::getPassRegistry());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">156</td>
    <td class="codeLine">        *PassRegistry::getPassRegistry());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">157</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">158</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="codeLine">  StringRef getPassName() const override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">159</td>
    <td class="codeLine">  StringRef getPassName() const override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="codeLine">    return "Recognize Hexagon-specific loop idioms";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">160</td>
    <td class="codeLine">    return "Recognize Hexagon-specific loop idioms";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">161</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">162</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="codeLine">  void getAnalysisUsage(AnalysisUsage &AU) const override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">163</td>
    <td class="codeLine">  void getAnalysisUsage(AnalysisUsage &AU) const override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="codeLine">    AU.addRequired<LoopInfoWrapperPass>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">164</td>
    <td class="codeLine">    AU.addRequired<LoopInfoWrapperPass>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="codeLine">    AU.addRequiredID(LoopSimplifyID);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">165</td>
    <td class="codeLine">    AU.addRequiredID(LoopSimplifyID);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="codeLine">    AU.addRequiredID(LCSSAID);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">166</td>
    <td class="codeLine">    AU.addRequiredID(LCSSAID);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="codeLine">    AU.addRequired<AAResultsWrapperPass>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">167</td>
    <td class="codeLine">    AU.addRequired<AAResultsWrapperPass>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="codeLine">    AU.addRequired<ScalarEvolutionWrapperPass>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">168</td>
    <td class="codeLine">    AU.addRequired<ScalarEvolutionWrapperPass>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="codeLine">    AU.addRequired<DominatorTreeWrapperPass>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">169</td>
    <td class="codeLine">    AU.addRequired<DominatorTreeWrapperPass>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="codeLine">    AU.addRequired<TargetLibraryInfoWrapperPass>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">170</td>
    <td class="codeLine">    AU.addRequired<TargetLibraryInfoWrapperPass>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="codeLine">    AU.addPreserved<TargetLibraryInfoWrapperPass>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">171</td>
    <td class="codeLine">    AU.addPreserved<TargetLibraryInfoWrapperPass>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">172</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">173</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="codeLine">  bool runOnLoop(Loop *L, LPPassManager &LPM) override;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">174</td>
    <td class="codeLine">  bool runOnLoop(Loop *L, LPPassManager &LPM) override;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">175</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">176</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="codeLine">struct Simplifier {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">177</td>
    <td class="codeLine">struct Simplifier {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="codeLine">  struct Rule {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">178</td>
    <td class="codeLine">  struct Rule {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="codeLine">    using FuncType = std::function<Value *(Instruction *, LLVMContext &)>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">179</td>
    <td class="codeLine">    using FuncType = std::function<Value *(Instruction *, LLVMContext &)>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="codeLine">    Rule(StringRef N, FuncType F) : Name(N), Fn(F) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">180</td>
    <td class="codeLine">    Rule(StringRef N, FuncType F) : Name(N), Fn(F) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="codeLine">    StringRef Name; // For debugging.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">181</td>
    <td class="codeLine">    StringRef Name; // For debugging.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="codeLine">    FuncType Fn;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">182</td>
    <td class="codeLine">    FuncType Fn;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">183</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">184</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="codeLine">  void addRule(StringRef N, const Rule::FuncType &F) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">185</td>
    <td class="codeLine">  void addRule(StringRef N, const Rule::FuncType &F) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="codeLine">    Rules.push_back(Rule(N, F));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">186</td>
    <td class="codeLine">    Rules.push_back(Rule(N, F));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">187</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">188</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">189</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="codeLine">  struct WorkListType {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">190</td>
    <td class="codeLine">  struct WorkListType {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="codeLine">    WorkListType() = default;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">191</td>
    <td class="codeLine">    WorkListType() = default;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">192</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="codeLine">    void push_back(Value *V) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">193</td>
    <td class="codeLine">    void push_back(Value *V) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="codeLine">      // Do not push back duplicates.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">194</td>
    <td class="codeLine">      // Do not push back duplicates.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="codeLine">      if (S.insert(V).second)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">195</td>
    <td class="codeLine">      if (S.insert(V).second)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="codeLine">        Q.push_back(V);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">196</td>
    <td class="codeLine">        Q.push_back(V);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">197</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">198</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="codeLine">    Value *pop_front_val() {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">199</td>
    <td class="codeLine">    Value *pop_front_val() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="codeLine">      Value *V = Q.front();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">200</td>
    <td class="codeLine">      Value *V = Q.front();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="codeLine">      Q.pop_front();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">201</td>
    <td class="codeLine">      Q.pop_front();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="codeLine">      S.erase(V);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">202</td>
    <td class="codeLine">      S.erase(V);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="codeLine">      return V;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">203</td>
    <td class="codeLine">      return V;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">204</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">205</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="codeLine">    bool empty() const { return Q.empty(); }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">206</td>
    <td class="codeLine">    bool empty() const { return Q.empty(); }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">207</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="codeLine">  private:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">208</td>
    <td class="codeLine">  private:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="codeLine">    std::deque<Value *> Q;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">209</td>
    <td class="codeLine">    std::deque<Value *> Q;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="codeLine">    std::set<Value *> S;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">210</td>
    <td class="codeLine">    std::set<Value *> S;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">211</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">212</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="codeLine">  using ValueSetType = std::set<Value *>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">213</td>
    <td class="codeLine">  using ValueSetType = std::set<Value *>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">214</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="codeLine">  std::vector<Rule> Rules;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">215</td>
    <td class="codeLine">  std::vector<Rule> Rules;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">216</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">217</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="codeLine">  struct Context {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">218</td>
    <td class="codeLine">  struct Context {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="codeLine">    using ValueMapType = DenseMap<Value *, Value *>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">219</td>
    <td class="codeLine">    using ValueMapType = DenseMap<Value *, Value *>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">220</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="codeLine">    Value *Root;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">221</td>
    <td class="codeLine">    Value *Root;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="codeLine">    ValueSetType Used;   // The set of all cloned values used by Root.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">222</td>
    <td class="codeLine">    ValueSetType Used;   // The set of all cloned values used by Root.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="codeLine">    ValueSetType Clones; // The set of all cloned values.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">223</td>
    <td class="codeLine">    ValueSetType Clones; // The set of all cloned values.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="codeLine">    LLVMContext &Ctx;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">224</td>
    <td class="codeLine">    LLVMContext &Ctx;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">225</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="codeLine">    Context(Instruction *Exp)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">226</td>
    <td class="codeLine">    Context(Instruction *Exp)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="codeLine">        : Ctx(Exp->getParent()->getParent()->getContext()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">227</td>
    <td class="codeLine">        : Ctx(Exp->getParent()->getParent()->getContext()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="codeLine">      initialize(Exp);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">228</td>
    <td class="codeLine">      initialize(Exp);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">229</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">230</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="codeLine">    ~Context() { cleanup(); }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">231</td>
    <td class="codeLine">    ~Context() { cleanup(); }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">232</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="codeLine">    void print(raw_ostream &OS, const Value *V) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">233</td>
    <td class="codeLine">    void print(raw_ostream &OS, const Value *V) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="codeLine">    Value *materialize(BasicBlock *B, BasicBlock::iterator At);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">234</td>
    <td class="codeLine">    Value *materialize(BasicBlock *B, BasicBlock::iterator At);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">235</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="codeLine">  private:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">236</td>
    <td class="codeLine">  private:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="codeLine">    friend struct Simplifier;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">237</td>
    <td class="codeLine">    friend struct Simplifier;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">238</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="codeLine">    void initialize(Instruction *Exp);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">239</td>
    <td class="codeLine">    void initialize(Instruction *Exp);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="codeLine">    void cleanup();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">240</td>
    <td class="codeLine">    void cleanup();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">241</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="codeLine">    template <typename FuncT> void traverse(Value *V, FuncT F);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">242</td>
    <td class="codeLine">    template <typename FuncT> void traverse(Value *V, FuncT F);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="codeLine">    void record(Value *V);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">243</td>
    <td class="codeLine">    void record(Value *V);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="codeLine">    void use(Value *V);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">244</td>
    <td class="codeLine">    void use(Value *V);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="codeLine">    void unuse(Value *V);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">245</td>
    <td class="codeLine">    void unuse(Value *V);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">246</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="codeLine">    bool equal(const Instruction *I, const Instruction *J) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">247</td>
    <td class="codeLine">    bool equal(const Instruction *I, const Instruction *J) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="codeLine">    Value *find(Value *Tree, Value *Sub) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">248</td>
    <td class="codeLine">    Value *find(Value *Tree, Value *Sub) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="codeLine">    Value *subst(Value *Tree, Value *OldV, Value *NewV);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">249</td>
    <td class="codeLine">    Value *subst(Value *Tree, Value *OldV, Value *NewV);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="codeLine">    void replace(Value *OldV, Value *NewV);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">250</td>
    <td class="codeLine">    void replace(Value *OldV, Value *NewV);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="codeLine">    void link(Instruction *I, BasicBlock *B, BasicBlock::iterator At);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">251</td>
    <td class="codeLine">    void link(Instruction *I, BasicBlock *B, BasicBlock::iterator At);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">252</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">253</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="codeLine">  Value *simplify(Context &C);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">254</td>
    <td class="codeLine">  Value *simplify(Context &C);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">255</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">256</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="codeLine">  struct PE {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">257</td>
    <td class="codeLine">  struct PE {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="codeLine">    PE(const Simplifier::Context &c, Value *v = nullptr) : C(c), V(v) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">258</td>
    <td class="codeLine">    PE(const Simplifier::Context &c, Value *v = nullptr) : C(c), V(v) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">259</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="codeLine">    const Simplifier::Context &C;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">260</td>
    <td class="codeLine">    const Simplifier::Context &C;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="codeLine">    const Value *V;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">261</td>
    <td class="codeLine">    const Value *V;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">262</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">263</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="codeLine">  LLVM_ATTRIBUTE_USED</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">264</td>
    <td class="codeLine">  LLVM_ATTRIBUTE_USED</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="codeLine">  raw_ostream &operator<<(raw_ostream &OS, const PE &P) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">265</td>
    <td class="codeLine">  raw_ostream &operator<<(raw_ostream &OS, const PE &P) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="codeLine">    P.C.print(OS, P.V ? P.V : P.C.Root);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">266</td>
    <td class="codeLine">    P.C.print(OS, P.V ? P.V : P.C.Root);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="codeLine">    return OS;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">267</td>
    <td class="codeLine">    return OS;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">268</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">269</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="codeLine">} // end anonymous namespace</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">270</td>
    <td class="codeLine">} // end anonymous namespace</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">271</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="codeLine">char HexagonLoopIdiomRecognizeLegacyPass::ID = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">272</td>
    <td class="codeLine">char HexagonLoopIdiomRecognizeLegacyPass::ID = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">273</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_BEGIN(HexagonLoopIdiomRecognizeLegacyPass, "hexagon-loop-idiom",</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">274</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_BEGIN(HexagonLoopIdiomRecognizeLegacyPass, "hexagon-loop-idiom",</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="codeLine">                      "Recognize Hexagon-specific loop idioms", false, false)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">275</td>
    <td class="codeLine">                      "Recognize Hexagon-specific loop idioms", false, false)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(LoopInfoWrapperPass)</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">276</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(LoopInfoWrapperPass)</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(LoopSimplify)</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">277</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(LoopSimplify)</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(LCSSAWrapperPass)</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">278</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(LCSSAWrapperPass)</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(ScalarEvolutionWrapperPass)</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">279</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(ScalarEvolutionWrapperPass)</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(DominatorTreeWrapperPass)</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">280</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(DominatorTreeWrapperPass)</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(TargetLibraryInfoWrapperPass)</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">281</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(TargetLibraryInfoWrapperPass)</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(AAResultsWrapperPass)</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">282</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(AAResultsWrapperPass)</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_END(HexagonLoopIdiomRecognizeLegacyPass, "hexagon-loop-idiom",</td>
    <td class="lineNumber">2</td>
    <td class="lineNumber">283</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_END(HexagonLoopIdiomRecognizeLegacyPass, "hexagon-loop-idiom",</td>
    <td class="lineNumber">2</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="codeLine">                    "Recognize Hexagon-specific loop idioms", false, false)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">284</td>
    <td class="codeLine">                    "Recognize Hexagon-specific loop idioms", false, false)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">285</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="codeLine">template <typename FuncT></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">286</td>
    <td class="codeLine">template <typename FuncT></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="codeLine">void Simplifier::Context::traverse(Value *V, FuncT F) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">287</td>
    <td class="codeLine">void Simplifier::Context::traverse(Value *V, FuncT F) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="codeLine">  WorkListType Q;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">288</td>
    <td class="codeLine">  WorkListType Q;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="codeLine">  Q.push_back(V);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">289</td>
    <td class="codeLine">  Q.push_back(V);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">290</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="codeLine">  while (!Q.empty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">291</td>
    <td class="codeLine">  while (!Q.empty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="codeLine">    Instruction *U = dyn_cast<Instruction>(Q.pop_front_val());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">292</td>
    <td class="codeLine">    Instruction *U = dyn_cast<Instruction>(Q.pop_front_val());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="codeLine">    if (!U || U->getParent())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">293</td>
    <td class="codeLine">    if (!U || U->getParent())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">294</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="codeLine">    if (!F(U))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">295</td>
    <td class="codeLine">    if (!F(U))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">296</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="codeLine">    for (Value *Op : U->operands())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">297</td>
    <td class="codeLine">    for (Value *Op : U->operands())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="codeLine">      Q.push_back(Op);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">298</td>
    <td class="codeLine">      Q.push_back(Op);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">299</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">300</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">301</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="codeLine">void Simplifier::Context::print(raw_ostream &OS, const Value *V) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">302</td>
    <td class="codeLine">void Simplifier::Context::print(raw_ostream &OS, const Value *V) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="codeLine">  const auto *U = dyn_cast<const Instruction>(V);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">303</td>
    <td class="codeLine">  const auto *U = dyn_cast<const Instruction>(V);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="codeLine">  if (!U) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">304</td>
    <td class="codeLine">  if (!U) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="codeLine">    OS << V << '(' << *V << ')';</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">305</td>
    <td class="codeLine">    OS << V << '(' << *V << ')';</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">306</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">307</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">308</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="codeLine">  if (U->getParent()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">309</td>
    <td class="codeLine">  if (U->getParent()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="codeLine">    OS << U << '(';</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">310</td>
    <td class="codeLine">    OS << U << '(';</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="codeLine">    U->printAsOperand(OS, true);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">311</td>
    <td class="codeLine">    U->printAsOperand(OS, true);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="codeLine">    OS << ')';</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">312</td>
    <td class="codeLine">    OS << ')';</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">313</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">314</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">315</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="codeLine">  unsigned N = U->getNumOperands();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">316</td>
    <td class="codeLine">  unsigned N = U->getNumOperands();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="codeLine">  if (N != 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">317</td>
    <td class="codeLine">  if (N != 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="codeLine">    OS << U << '(';</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">318</td>
    <td class="codeLine">    OS << U << '(';</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="codeLine">  OS << U->getOpcodeName();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">319</td>
    <td class="codeLine">  OS << U->getOpcodeName();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="codeLine">  for (const Value *Op : U->operands()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">320</td>
    <td class="codeLine">  for (const Value *Op : U->operands()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="codeLine">    OS << ' ';</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">321</td>
    <td class="codeLine">    OS << ' ';</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="codeLine">    print(OS, Op);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">322</td>
    <td class="codeLine">    print(OS, Op);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">323</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="codeLine">  if (N != 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">324</td>
    <td class="codeLine">  if (N != 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="codeLine">    OS << ')';</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">325</td>
    <td class="codeLine">    OS << ')';</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">326</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">327</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="codeLine">void Simplifier::Context::initialize(Instruction *Exp) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">328</td>
    <td class="codeLine">void Simplifier::Context::initialize(Instruction *Exp) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="codeLine">  // Perform a deep clone of the expression, set Root to the root</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">329</td>
    <td class="codeLine">  // Perform a deep clone of the expression, set Root to the root</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="codeLine">  // of the clone, and build a map from the cloned values to the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">330</td>
    <td class="codeLine">  // of the clone, and build a map from the cloned values to the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="codeLine">  // original ones.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">331</td>
    <td class="codeLine">  // original ones.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="codeLine">  ValueMapType M;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">332</td>
    <td class="codeLine">  ValueMapType M;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="codeLine">  BasicBlock *Block = Exp->getParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">333</td>
    <td class="codeLine">  BasicBlock *Block = Exp->getParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="codeLine">  WorkListType Q;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">334</td>
    <td class="codeLine">  WorkListType Q;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="codeLine">  Q.push_back(Exp);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">335</td>
    <td class="codeLine">  Q.push_back(Exp);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">336</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="codeLine">  while (!Q.empty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">337</td>
    <td class="codeLine">  while (!Q.empty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="codeLine">    Value *V = Q.pop_front_val();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">338</td>
    <td class="codeLine">    Value *V = Q.pop_front_val();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="codeLine">    if (M.contains(V))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">339</td>
    <td class="codeLine">    if (M.contains(V))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">340</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="codeLine">    if (Instruction *U = dyn_cast<Instruction>(V)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">341</td>
    <td class="codeLine">    if (Instruction *U = dyn_cast<Instruction>(V)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="codeLine">      if (isa<PHINode>(U) || U->getParent() != Block)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">342</td>
    <td class="codeLine">      if (isa<PHINode>(U) || U->getParent() != Block)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">343</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="codeLine">      for (Value *Op : U->operands())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">344</td>
    <td class="codeLine">      for (Value *Op : U->operands())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="codeLine">        Q.push_back(Op);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">345</td>
    <td class="codeLine">        Q.push_back(Op);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="codeLine">      M.insert({U, U->clone()});</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">346</td>
    <td class="codeLine">      M.insert({U, U->clone()});</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">347</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">348</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">349</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="codeLine">  for (std::pair<Value*,Value*> P : M) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">350</td>
    <td class="codeLine">  for (std::pair<Value*,Value*> P : M) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="codeLine">    Instruction *U = cast<Instruction>(P.second);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">351</td>
    <td class="codeLine">    Instruction *U = cast<Instruction>(P.second);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="codeLine">    for (unsigned i = 0, n = U->getNumOperands(); i != n; ++i) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">352</td>
    <td class="codeLine">    for (unsigned i = 0, n = U->getNumOperands(); i != n; ++i) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="codeLine">      auto F = M.find(U->getOperand(i));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">353</td>
    <td class="codeLine">      auto F = M.find(U->getOperand(i));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="codeLine">      if (F != M.end())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">354</td>
    <td class="codeLine">      if (F != M.end())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="codeLine">        U->setOperand(i, F->second);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">355</td>
    <td class="codeLine">        U->setOperand(i, F->second);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">356</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">357</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">358</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="codeLine">  auto R = M.find(Exp);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">359</td>
    <td class="codeLine">  auto R = M.find(Exp);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="codeLine">  assert(R != M.end());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">360</td>
    <td class="codeLine">  assert(R != M.end());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="codeLine">  Root = R->second;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">361</td>
    <td class="codeLine">  Root = R->second;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">362</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="codeLine">  record(Root);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">363</td>
    <td class="codeLine">  record(Root);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="codeLine">  use(Root);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">364</td>
    <td class="codeLine">  use(Root);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">365</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">366</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="codeLine">void Simplifier::Context::record(Value *V) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">367</td>
    <td class="codeLine">void Simplifier::Context::record(Value *V) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="codeLine">  auto Record = [this](Instruction *U) -> bool {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">368</td>
    <td class="codeLine">  auto Record = [this](Instruction *U) -> bool {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="codeLine">    Clones.insert(U);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">369</td>
    <td class="codeLine">    Clones.insert(U);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">370</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">371</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="codeLine">  traverse(V, Record);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">372</td>
    <td class="codeLine">  traverse(V, Record);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">373</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">374</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="codeLine">void Simplifier::Context::use(Value *V) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">375</td>
    <td class="codeLine">void Simplifier::Context::use(Value *V) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="codeLine">  auto Use = [this](Instruction *U) -> bool {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">376</td>
    <td class="codeLine">  auto Use = [this](Instruction *U) -> bool {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="codeLine">    Used.insert(U);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">377</td>
    <td class="codeLine">    Used.insert(U);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">378</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">379</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="codeLine">  traverse(V, Use);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">380</td>
    <td class="codeLine">  traverse(V, Use);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">381</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">382</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="codeLine">void Simplifier::Context::unuse(Value *V) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">383</td>
    <td class="codeLine">void Simplifier::Context::unuse(Value *V) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="codeLine">  if (!isa<Instruction>(V) || cast<Instruction>(V)->getParent() != nullptr)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">384</td>
    <td class="codeLine">  if (!isa<Instruction>(V) || cast<Instruction>(V)->getParent() != nullptr)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">385</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">386</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="codeLine">  auto Unuse = [this](Instruction *U) -> bool {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">387</td>
    <td class="codeLine">  auto Unuse = [this](Instruction *U) -> bool {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="codeLine">    if (!U->use_empty())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">388</td>
    <td class="codeLine">    if (!U->use_empty())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">389</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="codeLine">    Used.erase(U);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">390</td>
    <td class="codeLine">    Used.erase(U);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">391</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">392</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="codeLine">  traverse(V, Unuse);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">393</td>
    <td class="codeLine">  traverse(V, Unuse);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">394</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">395</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="codeLine">Value *Simplifier::Context::subst(Value *Tree, Value *OldV, Value *NewV) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">396</td>
    <td class="codeLine">Value *Simplifier::Context::subst(Value *Tree, Value *OldV, Value *NewV) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="codeLine">  if (Tree == OldV)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">397</td>
    <td class="codeLine">  if (Tree == OldV)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="codeLine">    return NewV;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">398</td>
    <td class="codeLine">    return NewV;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="codeLine">  if (OldV == NewV)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">399</td>
    <td class="codeLine">  if (OldV == NewV)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="codeLine">    return Tree;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">400</td>
    <td class="codeLine">    return Tree;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">401</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="codeLine">  WorkListType Q;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">402</td>
    <td class="codeLine">  WorkListType Q;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="codeLine">  Q.push_back(Tree);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">403</td>
    <td class="codeLine">  Q.push_back(Tree);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="codeLine">  while (!Q.empty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">404</td>
    <td class="codeLine">  while (!Q.empty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="codeLine">    Instruction *U = dyn_cast<Instruction>(Q.pop_front_val());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">405</td>
    <td class="codeLine">    Instruction *U = dyn_cast<Instruction>(Q.pop_front_val());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="codeLine">    // If U is not an instruction, or it's not a clone, skip it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">406</td>
    <td class="codeLine">    // If U is not an instruction, or it's not a clone, skip it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="codeLine">    if (!U || U->getParent())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">407</td>
    <td class="codeLine">    if (!U || U->getParent())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">408</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="codeLine">    for (unsigned i = 0, n = U->getNumOperands(); i != n; ++i) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">409</td>
    <td class="codeLine">    for (unsigned i = 0, n = U->getNumOperands(); i != n; ++i) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="codeLine">      Value *Op = U->getOperand(i);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">410</td>
    <td class="codeLine">      Value *Op = U->getOperand(i);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="codeLine">      if (Op == OldV) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">411</td>
    <td class="codeLine">      if (Op == OldV) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="codeLine">        U->setOperand(i, NewV);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">412</td>
    <td class="codeLine">        U->setOperand(i, NewV);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="codeLine">        unuse(OldV);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">413</td>
    <td class="codeLine">        unuse(OldV);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">414</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="codeLine">        Q.push_back(Op);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">415</td>
    <td class="codeLine">        Q.push_back(Op);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">416</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">417</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">418</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="codeLine">  return Tree;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">419</td>
    <td class="codeLine">  return Tree;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">420</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">421</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="codeLine">void Simplifier::Context::replace(Value *OldV, Value *NewV) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">422</td>
    <td class="codeLine">void Simplifier::Context::replace(Value *OldV, Value *NewV) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="codeLine">  if (Root == OldV) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">423</td>
    <td class="codeLine">  if (Root == OldV) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="codeLine">    Root = NewV;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">424</td>
    <td class="codeLine">    Root = NewV;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="codeLine">    use(Root);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">425</td>
    <td class="codeLine">    use(Root);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">426</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">427</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">428</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="codeLine">  // NewV may be a complex tree that has just been created by one of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">429</td>
    <td class="codeLine">  // NewV may be a complex tree that has just been created by one of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="codeLine">  // transformation rules. We need to make sure that it is commoned with</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">430</td>
    <td class="codeLine">  // transformation rules. We need to make sure that it is commoned with</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="codeLine">  // the existing Root to the maximum extent possible.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">431</td>
    <td class="codeLine">  // the existing Root to the maximum extent possible.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="codeLine">  // Identify all subtrees of NewV (including NewV itself) that have</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">432</td>
    <td class="codeLine">  // Identify all subtrees of NewV (including NewV itself) that have</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="codeLine">  // equivalent counterparts in Root, and replace those subtrees with</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">433</td>
    <td class="codeLine">  // equivalent counterparts in Root, and replace those subtrees with</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="codeLine">  // these counterparts.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">434</td>
    <td class="codeLine">  // these counterparts.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="codeLine">  WorkListType Q;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">435</td>
    <td class="codeLine">  WorkListType Q;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="codeLine">  Q.push_back(NewV);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">436</td>
    <td class="codeLine">  Q.push_back(NewV);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="codeLine">  while (!Q.empty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">437</td>
    <td class="codeLine">  while (!Q.empty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="codeLine">    Value *V = Q.pop_front_val();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">438</td>
    <td class="codeLine">    Value *V = Q.pop_front_val();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="codeLine">    Instruction *U = dyn_cast<Instruction>(V);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">439</td>
    <td class="codeLine">    Instruction *U = dyn_cast<Instruction>(V);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="codeLine">    if (!U || U->getParent())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">440</td>
    <td class="codeLine">    if (!U || U->getParent())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">441</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="codeLine">    if (Value *DupV = find(Root, V)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">442</td>
    <td class="codeLine">    if (Value *DupV = find(Root, V)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="codeLine">      if (DupV != V)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">443</td>
    <td class="codeLine">      if (DupV != V)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="codeLine">        NewV = subst(NewV, V, DupV);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">444</td>
    <td class="codeLine">        NewV = subst(NewV, V, DupV);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">445</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="codeLine">      for (Value *Op : U->operands())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">446</td>
    <td class="codeLine">      for (Value *Op : U->operands())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="codeLine">        Q.push_back(Op);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">447</td>
    <td class="codeLine">        Q.push_back(Op);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">448</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">449</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">450</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="codeLine">  // Now, simply replace OldV with NewV in Root.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">451</td>
    <td class="codeLine">  // Now, simply replace OldV with NewV in Root.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="codeLine">  Root = subst(Root, OldV, NewV);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">452</td>
    <td class="codeLine">  Root = subst(Root, OldV, NewV);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="codeLine">  use(Root);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">453</td>
    <td class="codeLine">  use(Root);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">454</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">455</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="codeLine">void Simplifier::Context::cleanup() {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">456</td>
    <td class="codeLine">void Simplifier::Context::cleanup() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="codeLine">  for (Value *V : Clones) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">457</td>
    <td class="codeLine">  for (Value *V : Clones) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="codeLine">    Instruction *U = cast<Instruction>(V);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">458</td>
    <td class="codeLine">    Instruction *U = cast<Instruction>(V);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="codeLine">    if (!U->getParent())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">459</td>
    <td class="codeLine">    if (!U->getParent())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="codeLine">      U->dropAllReferences();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">460</td>
    <td class="codeLine">      U->dropAllReferences();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">461</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">462</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="codeLine">  for (Value *V : Clones) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">463</td>
    <td class="codeLine">  for (Value *V : Clones) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="codeLine">    Instruction *U = cast<Instruction>(V);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">464</td>
    <td class="codeLine">    Instruction *U = cast<Instruction>(V);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="codeLine">    if (!U->getParent())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">465</td>
    <td class="codeLine">    if (!U->getParent())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="codeLine">      U->deleteValue();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">466</td>
    <td class="codeLine">      U->deleteValue();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">467</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">468</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">469</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="codeLine">bool Simplifier::Context::equal(const Instruction *I,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">470</td>
    <td class="codeLine">bool Simplifier::Context::equal(const Instruction *I,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="codeLine">                                const Instruction *J) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">471</td>
    <td class="codeLine">                                const Instruction *J) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="codeLine">  if (I == J)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">472</td>
    <td class="codeLine">  if (I == J)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">473</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="codeLine">  if (!I->isSameOperationAs(J))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">474</td>
    <td class="codeLine">  if (!I->isSameOperationAs(J))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">475</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="codeLine">  if (isa<PHINode>(I))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">476</td>
    <td class="codeLine">  if (isa<PHINode>(I))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="codeLine">    return I->isIdenticalTo(J);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">477</td>
    <td class="codeLine">    return I->isIdenticalTo(J);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">478</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="codeLine">  for (unsigned i = 0, n = I->getNumOperands(); i != n; ++i) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">479</td>
    <td class="codeLine">  for (unsigned i = 0, n = I->getNumOperands(); i != n; ++i) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="codeLine">    Value *OpI = I->getOperand(i), *OpJ = J->getOperand(i);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">480</td>
    <td class="codeLine">    Value *OpI = I->getOperand(i), *OpJ = J->getOperand(i);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="codeLine">    if (OpI == OpJ)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">481</td>
    <td class="codeLine">    if (OpI == OpJ)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">482</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="codeLine">    auto *InI = dyn_cast<const Instruction>(OpI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">483</td>
    <td class="codeLine">    auto *InI = dyn_cast<const Instruction>(OpI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="codeLine">    auto *InJ = dyn_cast<const Instruction>(OpJ);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">484</td>
    <td class="codeLine">    auto *InJ = dyn_cast<const Instruction>(OpJ);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="codeLine">    if (InI && InJ) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">485</td>
    <td class="codeLine">    if (InI && InJ) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="codeLine">      if (!equal(InI, InJ))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">486</td>
    <td class="codeLine">      if (!equal(InI, InJ))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="codeLine">        return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">487</td>
    <td class="codeLine">        return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="codeLine">    } else if (InI != InJ || !InI)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">488</td>
    <td class="codeLine">    } else if (InI != InJ || !InI)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">489</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">490</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">491</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">492</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">493</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="codeLine">Value *Simplifier::Context::find(Value *Tree, Value *Sub) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">494</td>
    <td class="codeLine">Value *Simplifier::Context::find(Value *Tree, Value *Sub) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="codeLine">  Instruction *SubI = dyn_cast<Instruction>(Sub);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">495</td>
    <td class="codeLine">  Instruction *SubI = dyn_cast<Instruction>(Sub);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="codeLine">  WorkListType Q;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">496</td>
    <td class="codeLine">  WorkListType Q;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="codeLine">  Q.push_back(Tree);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">497</td>
    <td class="codeLine">  Q.push_back(Tree);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">498</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="codeLine">  while (!Q.empty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">499</td>
    <td class="codeLine">  while (!Q.empty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="codeLine">    Value *V = Q.pop_front_val();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">500</td>
    <td class="codeLine">    Value *V = Q.pop_front_val();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="codeLine">    if (V == Sub)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">501</td>
    <td class="codeLine">    if (V == Sub)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="codeLine">      return V;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">502</td>
    <td class="codeLine">      return V;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="codeLine">    Instruction *U = dyn_cast<Instruction>(V);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">503</td>
    <td class="codeLine">    Instruction *U = dyn_cast<Instruction>(V);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class="codeLine">    if (!U || U->getParent())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">504</td>
    <td class="codeLine">    if (!U || U->getParent())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">505</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="codeLine">    if (SubI && equal(SubI, U))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">506</td>
    <td class="codeLine">    if (SubI && equal(SubI, U))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="codeLine">      return U;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">507</td>
    <td class="codeLine">      return U;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="codeLine">    assert(!isa<PHINode>(U));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">508</td>
    <td class="codeLine">    assert(!isa<PHINode>(U));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="codeLine">    for (Value *Op : U->operands())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">509</td>
    <td class="codeLine">    for (Value *Op : U->operands())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="codeLine">      Q.push_back(Op);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">510</td>
    <td class="codeLine">      Q.push_back(Op);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">511</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="codeLine">  return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">512</td>
    <td class="codeLine">  return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">513</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">514</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="codeLine">void Simplifier::Context::link(Instruction *I, BasicBlock *B,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">515</td>
    <td class="codeLine">void Simplifier::Context::link(Instruction *I, BasicBlock *B,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="codeLine">      BasicBlock::iterator At) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">516</td>
    <td class="codeLine">      BasicBlock::iterator At) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class="codeLine">  if (I->getParent())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">517</td>
    <td class="codeLine">  if (I->getParent())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">518</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">519</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class="codeLine">  for (Value *Op : I->operands()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">520</td>
    <td class="codeLine">  for (Value *Op : I->operands()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="codeLine">    if (Instruction *OpI = dyn_cast<Instruction>(Op))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">521</td>
    <td class="codeLine">    if (Instruction *OpI = dyn_cast<Instruction>(Op))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="codeLine">      link(OpI, B, At);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">522</td>
    <td class="codeLine">      link(OpI, B, At);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">523</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">524</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="codeLine">  I->insertInto(B, At);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">525</td>
    <td class="codeLine">  I->insertInto(B, At);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">526</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">527</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="codeLine">Value *Simplifier::Context::materialize(BasicBlock *B,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">528</td>
    <td class="codeLine">Value *Simplifier::Context::materialize(BasicBlock *B,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="codeLine">      BasicBlock::iterator At) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">529</td>
    <td class="codeLine">      BasicBlock::iterator At) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="codeLine">  if (Instruction *RootI = dyn_cast<Instruction>(Root))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">530</td>
    <td class="codeLine">  if (Instruction *RootI = dyn_cast<Instruction>(Root))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="codeLine">    link(RootI, B, At);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">531</td>
    <td class="codeLine">    link(RootI, B, At);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="codeLine">  return Root;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">532</td>
    <td class="codeLine">  return Root;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">533</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">534</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="codeLine">Value *Simplifier::simplify(Context &C) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">535</td>
    <td class="codeLine">Value *Simplifier::simplify(Context &C) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="codeLine">  WorkListType Q;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">536</td>
    <td class="codeLine">  WorkListType Q;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="codeLine">  Q.push_back(C.Root);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">537</td>
    <td class="codeLine">  Q.push_back(C.Root);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="codeLine">  unsigned Count = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">538</td>
    <td class="codeLine">  unsigned Count = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="codeLine">  const unsigned Limit = SimplifyLimit;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">539</td>
    <td class="codeLine">  const unsigned Limit = SimplifyLimit;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">540</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="codeLine">  while (!Q.empty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">541</td>
    <td class="codeLine">  while (!Q.empty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="codeLine">    if (Count++ >= Limit)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">542</td>
    <td class="codeLine">    if (Count++ >= Limit)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">543</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="codeLine">    Instruction *U = dyn_cast<Instruction>(Q.pop_front_val());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">544</td>
    <td class="codeLine">    Instruction *U = dyn_cast<Instruction>(Q.pop_front_val());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="codeLine">    if (!U || U->getParent() || !C.Used.count(U))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">545</td>
    <td class="codeLine">    if (!U || U->getParent() || !C.Used.count(U))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">546</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="codeLine">    bool Changed = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">547</td>
    <td class="codeLine">    bool Changed = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="codeLine">    for (Rule &R : Rules) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">548</td>
    <td class="codeLine">    for (Rule &R : Rules) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="codeLine">      Value *W = R.Fn(U, C.Ctx);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">549</td>
    <td class="codeLine">      Value *W = R.Fn(U, C.Ctx);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="codeLine">      if (!W)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">550</td>
    <td class="codeLine">      if (!W)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">551</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="codeLine">      Changed = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">552</td>
    <td class="codeLine">      Changed = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="codeLine">      C.record(W);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">553</td>
    <td class="codeLine">      C.record(W);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="codeLine">      C.replace(U, W);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">554</td>
    <td class="codeLine">      C.replace(U, W);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="codeLine">      Q.push_back(C.Root);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">555</td>
    <td class="codeLine">      Q.push_back(C.Root);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">556</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">557</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="codeLine">    if (!Changed) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">558</td>
    <td class="codeLine">    if (!Changed) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="codeLine">      for (Value *Op : U->operands())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">559</td>
    <td class="codeLine">      for (Value *Op : U->operands())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="codeLine">        Q.push_back(Op);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">560</td>
    <td class="codeLine">        Q.push_back(Op);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">561</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">562</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="codeLine">  return Count < Limit ? C.Root : nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">563</td>
    <td class="codeLine">  return Count < Limit ? C.Root : nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">564</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">565</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">566</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">567</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="codeLine">//          Implementation of PolynomialMultiplyRecognize</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">568</td>
    <td class="codeLine">//          Implementation of PolynomialMultiplyRecognize</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">569</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">570</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">571</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="codeLine">namespace {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">572</td>
    <td class="codeLine">namespace {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">573</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="codeLine">  class PolynomialMultiplyRecognize {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">574</td>
    <td class="codeLine">  class PolynomialMultiplyRecognize {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="codeLine">  public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">575</td>
    <td class="codeLine">  public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="codeLine">    explicit PolynomialMultiplyRecognize(Loop *loop, const DataLayout &dl,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">576</td>
    <td class="codeLine">    explicit PolynomialMultiplyRecognize(Loop *loop, const DataLayout &dl,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="codeLine">        const DominatorTree &dt, const TargetLibraryInfo &tli,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">577</td>
    <td class="codeLine">        const DominatorTree &dt, const TargetLibraryInfo &tli,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="codeLine">        ScalarEvolution &se)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">578</td>
    <td class="codeLine">        ScalarEvolution &se)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class="codeLine">      : CurLoop(loop), DL(dl), DT(dt), TLI(tli), SE(se) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">579</td>
    <td class="codeLine">      : CurLoop(loop), DL(dl), DT(dt), TLI(tli), SE(se) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">580</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="codeLine">    bool recognize();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">581</td>
    <td class="codeLine">    bool recognize();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">582</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="codeLine">  private:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">583</td>
    <td class="codeLine">  private:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="codeLine">    using ValueSeq = SetVector<Value *>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">584</td>
    <td class="codeLine">    using ValueSeq = SetVector<Value *>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">585</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="codeLine">    IntegerType *getPmpyType() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">586</td>
    <td class="codeLine">    IntegerType *getPmpyType() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class="codeLine">      LLVMContext &Ctx = CurLoop->getHeader()->getParent()->getContext();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">587</td>
    <td class="codeLine">      LLVMContext &Ctx = CurLoop->getHeader()->getParent()->getContext();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="codeLine">      return IntegerType::get(Ctx, 32);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">588</td>
    <td class="codeLine">      return IntegerType::get(Ctx, 32);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">589</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">590</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="codeLine">    bool isPromotableTo(Value *V, IntegerType *Ty);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">591</td>
    <td class="codeLine">    bool isPromotableTo(Value *V, IntegerType *Ty);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="codeLine">    void promoteTo(Instruction *In, IntegerType *DestTy, BasicBlock *LoopB);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">592</td>
    <td class="codeLine">    void promoteTo(Instruction *In, IntegerType *DestTy, BasicBlock *LoopB);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="codeLine">    bool promoteTypes(BasicBlock *LoopB, BasicBlock *ExitB);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">593</td>
    <td class="codeLine">    bool promoteTypes(BasicBlock *LoopB, BasicBlock *ExitB);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">594</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="codeLine">    Value *getCountIV(BasicBlock *BB);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">595</td>
    <td class="codeLine">    Value *getCountIV(BasicBlock *BB);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="codeLine">    bool findCycle(Value *Out, Value *In, ValueSeq &Cycle);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">596</td>
    <td class="codeLine">    bool findCycle(Value *Out, Value *In, ValueSeq &Cycle);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class="codeLine">    void classifyCycle(Instruction *DivI, ValueSeq &Cycle, ValueSeq &Early,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">597</td>
    <td class="codeLine">    void classifyCycle(Instruction *DivI, ValueSeq &Cycle, ValueSeq &Early,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="codeLine">          ValueSeq &Late);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">598</td>
    <td class="codeLine">          ValueSeq &Late);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="codeLine">    bool classifyInst(Instruction *UseI, ValueSeq &Early, ValueSeq &Late);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">599</td>
    <td class="codeLine">    bool classifyInst(Instruction *UseI, ValueSeq &Early, ValueSeq &Late);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="codeLine">    bool commutesWithShift(Instruction *I);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">600</td>
    <td class="codeLine">    bool commutesWithShift(Instruction *I);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="codeLine">    bool highBitsAreZero(Value *V, unsigned IterCount);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">601</td>
    <td class="codeLine">    bool highBitsAreZero(Value *V, unsigned IterCount);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="codeLine">    bool keepsHighBitsZero(Value *V, unsigned IterCount);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">602</td>
    <td class="codeLine">    bool keepsHighBitsZero(Value *V, unsigned IterCount);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="codeLine">    bool isOperandShifted(Instruction *I, Value *Op);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">603</td>
    <td class="codeLine">    bool isOperandShifted(Instruction *I, Value *Op);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="codeLine">    bool convertShiftsToLeft(BasicBlock *LoopB, BasicBlock *ExitB,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">604</td>
    <td class="codeLine">    bool convertShiftsToLeft(BasicBlock *LoopB, BasicBlock *ExitB,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="codeLine">          unsigned IterCount);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">605</td>
    <td class="codeLine">          unsigned IterCount);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="codeLine">    void cleanupLoopBody(BasicBlock *LoopB);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">606</td>
    <td class="codeLine">    void cleanupLoopBody(BasicBlock *LoopB);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">607</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="codeLine">    struct ParsedValues {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">608</td>
    <td class="codeLine">    struct ParsedValues {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="codeLine">      ParsedValues() = default;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">609</td>
    <td class="codeLine">      ParsedValues() = default;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">610</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="codeLine">      Value *M = nullptr;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">611</td>
    <td class="codeLine">      Value *M = nullptr;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="codeLine">      Value *P = nullptr;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">612</td>
    <td class="codeLine">      Value *P = nullptr;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class="codeLine">      Value *Q = nullptr;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">613</td>
    <td class="codeLine">      Value *Q = nullptr;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class="codeLine">      Value *R = nullptr;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">614</td>
    <td class="codeLine">      Value *R = nullptr;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="codeLine">      Value *X = nullptr;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">615</td>
    <td class="codeLine">      Value *X = nullptr;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="codeLine">      Instruction *Res = nullptr;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">616</td>
    <td class="codeLine">      Instruction *Res = nullptr;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="codeLine">      unsigned IterCount = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">617</td>
    <td class="codeLine">      unsigned IterCount = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class="codeLine">      bool Left = false;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">618</td>
    <td class="codeLine">      bool Left = false;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="codeLine">      bool Inv = false;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">619</td>
    <td class="codeLine">      bool Inv = false;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="codeLine">    };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">620</td>
    <td class="codeLine">    };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">621</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="codeLine">    bool matchLeftShift(SelectInst *SelI, Value *CIV, ParsedValues &PV);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">622</td>
    <td class="codeLine">    bool matchLeftShift(SelectInst *SelI, Value *CIV, ParsedValues &PV);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="codeLine">    bool matchRightShift(SelectInst *SelI, ParsedValues &PV);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">623</td>
    <td class="codeLine">    bool matchRightShift(SelectInst *SelI, ParsedValues &PV);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="codeLine">    bool scanSelect(SelectInst *SI, BasicBlock *LoopB, BasicBlock *PrehB,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">624</td>
    <td class="codeLine">    bool scanSelect(SelectInst *SI, BasicBlock *LoopB, BasicBlock *PrehB,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="codeLine">          Value *CIV, ParsedValues &PV, bool PreScan);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">625</td>
    <td class="codeLine">          Value *CIV, ParsedValues &PV, bool PreScan);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="codeLine">    unsigned getInverseMxN(unsigned QP);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">626</td>
    <td class="codeLine">    unsigned getInverseMxN(unsigned QP);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="codeLine">    Value *generate(BasicBlock::iterator At, ParsedValues &PV);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">627</td>
    <td class="codeLine">    Value *generate(BasicBlock::iterator At, ParsedValues &PV);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">628</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="codeLine">    void setupPreSimplifier(Simplifier &S);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">629</td>
    <td class="codeLine">    void setupPreSimplifier(Simplifier &S);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class="codeLine">    void setupPostSimplifier(Simplifier &S);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">630</td>
    <td class="codeLine">    void setupPostSimplifier(Simplifier &S);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">631</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="codeLine">    Loop *CurLoop;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">632</td>
    <td class="codeLine">    Loop *CurLoop;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="codeLine">    const DataLayout &DL;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">633</td>
    <td class="codeLine">    const DataLayout &DL;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="codeLine">    const DominatorTree &DT;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">634</td>
    <td class="codeLine">    const DominatorTree &DT;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="codeLine">    const TargetLibraryInfo &TLI;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">635</td>
    <td class="codeLine">    const TargetLibraryInfo &TLI;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="codeLine">    ScalarEvolution &SE;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">636</td>
    <td class="codeLine">    ScalarEvolution &SE;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">637</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">638</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="codeLine">} // end anonymous namespace</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">639</td>
    <td class="codeLine">} // end anonymous namespace</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">640</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="codeLine">Value *PolynomialMultiplyRecognize::getCountIV(BasicBlock *BB) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">641</td>
    <td class="codeLine">Value *PolynomialMultiplyRecognize::getCountIV(BasicBlock *BB) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="codeLine">  pred_iterator PI = pred_begin(BB), PE = pred_end(BB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">642</td>
    <td class="codeLine">  pred_iterator PI = pred_begin(BB), PE = pred_end(BB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="codeLine">  if (std::distance(PI, PE) != 2)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">643</td>
    <td class="codeLine">  if (std::distance(PI, PE) != 2)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">644</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="codeLine">  BasicBlock *PB = (*PI == BB) ? *std::next(PI) : *PI;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">645</td>
    <td class="codeLine">  BasicBlock *PB = (*PI == BB) ? *std::next(PI) : *PI;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">646</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="codeLine">  for (auto I = BB->begin(), E = BB->end(); I != E && isa<PHINode>(I); ++I) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">647</td>
    <td class="codeLine">  for (auto I = BB->begin(), E = BB->end(); I != E && isa<PHINode>(I); ++I) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="codeLine">    auto *PN = cast<PHINode>(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">648</td>
    <td class="codeLine">    auto *PN = cast<PHINode>(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="codeLine">    Value *InitV = PN->getIncomingValueForBlock(PB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">649</td>
    <td class="codeLine">    Value *InitV = PN->getIncomingValueForBlock(PB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="codeLine">    if (!isa<ConstantInt>(InitV) || !cast<ConstantInt>(InitV)->isZero())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">650</td>
    <td class="codeLine">    if (!isa<ConstantInt>(InitV) || !cast<ConstantInt>(InitV)->isZero())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">651</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="codeLine">    Value *IterV = PN->getIncomingValueForBlock(BB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">652</td>
    <td class="codeLine">    Value *IterV = PN->getIncomingValueForBlock(BB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="codeLine">    auto *BO = dyn_cast<BinaryOperator>(IterV);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">653</td>
    <td class="codeLine">    auto *BO = dyn_cast<BinaryOperator>(IterV);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="codeLine">    if (!BO)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">654</td>
    <td class="codeLine">    if (!BO)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">655</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="codeLine">    if (BO->getOpcode() != Instruction::Add)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">656</td>
    <td class="codeLine">    if (BO->getOpcode() != Instruction::Add)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">657</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="codeLine">    Value *IncV = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">658</td>
    <td class="codeLine">    Value *IncV = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="codeLine">    if (BO->getOperand(0) == PN)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">659</td>
    <td class="codeLine">    if (BO->getOperand(0) == PN)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="codeLine">      IncV = BO->getOperand(1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">660</td>
    <td class="codeLine">      IncV = BO->getOperand(1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="codeLine">    else if (BO->getOperand(1) == PN)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">661</td>
    <td class="codeLine">    else if (BO->getOperand(1) == PN)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="codeLine">      IncV = BO->getOperand(0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">662</td>
    <td class="codeLine">      IncV = BO->getOperand(0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="codeLine">    if (IncV == nullptr)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">663</td>
    <td class="codeLine">    if (IncV == nullptr)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">664</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">665</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="codeLine">    if (auto *T = dyn_cast<ConstantInt>(IncV))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">666</td>
    <td class="codeLine">    if (auto *T = dyn_cast<ConstantInt>(IncV))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="codeLine">      if (T->isOne())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">667</td>
    <td class="codeLine">      if (T->isOne())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="codeLine">        return PN;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">668</td>
    <td class="codeLine">        return PN;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">669</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="codeLine">  return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">670</td>
    <td class="codeLine">  return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">671</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">672</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="codeLine">static void replaceAllUsesOfWithIn(Value *I, Value *J, BasicBlock *BB) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">673</td>
    <td class="codeLine">static void replaceAllUsesOfWithIn(Value *I, Value *J, BasicBlock *BB) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="codeLine">  for (auto UI = I->user_begin(), UE = I->user_end(); UI != UE;) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">674</td>
    <td class="codeLine">  for (auto UI = I->user_begin(), UE = I->user_end(); UI != UE;) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class="codeLine">    Use &TheUse = UI.getUse();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">675</td>
    <td class="codeLine">    Use &TheUse = UI.getUse();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class="codeLine">    ++UI;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">676</td>
    <td class="codeLine">    ++UI;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="codeLine">    if (auto *II = dyn_cast<Instruction>(TheUse.getUser()))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">677</td>
    <td class="codeLine">    if (auto *II = dyn_cast<Instruction>(TheUse.getUser()))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="codeLine">      if (BB == II->getParent())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">678</td>
    <td class="codeLine">      if (BB == II->getParent())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="codeLine">        II->replaceUsesOfWith(I, J);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">679</td>
    <td class="codeLine">        II->replaceUsesOfWith(I, J);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">680</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">681</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">682</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class="codeLine">bool PolynomialMultiplyRecognize::matchLeftShift(SelectInst *SelI,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">683</td>
    <td class="codeLine">bool PolynomialMultiplyRecognize::matchLeftShift(SelectInst *SelI,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="codeLine">      Value *CIV, ParsedValues &PV) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">684</td>
    <td class="codeLine">      Value *CIV, ParsedValues &PV) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class="codeLine">  // Match the following:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">685</td>
    <td class="codeLine">  // Match the following:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="codeLine">  //   select (X & (1 << i)) != 0 ? R ^ (Q << i) : R</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">686</td>
    <td class="codeLine">  //   select (X & (1 << i)) != 0 ? R ^ (Q << i) : R</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="codeLine">  //   select (X & (1 << i)) == 0 ? R : R ^ (Q << i)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">687</td>
    <td class="codeLine">  //   select (X & (1 << i)) == 0 ? R : R ^ (Q << i)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class="codeLine">  // The condition may also check for equality with the masked value, i.e</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">688</td>
    <td class="codeLine">  // The condition may also check for equality with the masked value, i.e</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class="codeLine">  //   select (X & (1 << i)) == (1 << i) ? R ^ (Q << i) : R</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">689</td>
    <td class="codeLine">  //   select (X & (1 << i)) == (1 << i) ? R ^ (Q << i) : R</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class="codeLine">  //   select (X & (1 << i)) != (1 << i) ? R : R ^ (Q << i);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">690</td>
    <td class="codeLine">  //   select (X & (1 << i)) != (1 << i) ? R : R ^ (Q << i);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">691</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="codeLine">  Value *CondV = SelI->getCondition();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">692</td>
    <td class="codeLine">  Value *CondV = SelI->getCondition();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class="codeLine">  Value *TrueV = SelI->getTrueValue();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">693</td>
    <td class="codeLine">  Value *TrueV = SelI->getTrueValue();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class="codeLine">  Value *FalseV = SelI->getFalseValue();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">694</td>
    <td class="codeLine">  Value *FalseV = SelI->getFalseValue();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">695</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="codeLine">  using namespace PatternMatch;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">696</td>
    <td class="codeLine">  using namespace PatternMatch;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">697</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class="codeLine">  CmpInst::Predicate P;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">698</td>
    <td class="codeLine">  CmpInst::Predicate P;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class="codeLine">  Value *A = nullptr, *B = nullptr, *C = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">699</td>
    <td class="codeLine">  Value *A = nullptr, *B = nullptr, *C = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">700</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="codeLine">  if (!match(CondV, m_ICmp(P, m_And(m_Value(A), m_Value(B)), m_Value(C))) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">701</td>
    <td class="codeLine">  if (!match(CondV, m_ICmp(P, m_And(m_Value(A), m_Value(B)), m_Value(C))) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class="codeLine">      !match(CondV, m_ICmp(P, m_Value(C), m_And(m_Value(A), m_Value(B)))))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">702</td>
    <td class="codeLine">      !match(CondV, m_ICmp(P, m_Value(C), m_And(m_Value(A), m_Value(B)))))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">703</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class="codeLine">  if (P != CmpInst::ICMP_EQ && P != CmpInst::ICMP_NE)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">704</td>
    <td class="codeLine">  if (P != CmpInst::ICMP_EQ && P != CmpInst::ICMP_NE)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">705</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class="codeLine">  // Matched: select (A & B) == C ? ... : ...</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">706</td>
    <td class="codeLine">  // Matched: select (A & B) == C ? ... : ...</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class="codeLine">  //          select (A & B) != C ? ... : ...</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">707</td>
    <td class="codeLine">  //          select (A & B) != C ? ... : ...</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">708</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class="codeLine">  Value *X = nullptr, *Sh1 = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">709</td>
    <td class="codeLine">  Value *X = nullptr, *Sh1 = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="codeLine">  // Check (A & B) for (X & (1 << i)):</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">710</td>
    <td class="codeLine">  // Check (A & B) for (X & (1 << i)):</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class="codeLine">  if (match(A, m_Shl(m_One(), m_Specific(CIV)))) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">711</td>
    <td class="codeLine">  if (match(A, m_Shl(m_One(), m_Specific(CIV)))) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class="codeLine">    Sh1 = A;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">712</td>
    <td class="codeLine">    Sh1 = A;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="codeLine">    X = B;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">713</td>
    <td class="codeLine">    X = B;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="codeLine">  } else if (match(B, m_Shl(m_One(), m_Specific(CIV)))) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">714</td>
    <td class="codeLine">  } else if (match(B, m_Shl(m_One(), m_Specific(CIV)))) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="codeLine">    Sh1 = B;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">715</td>
    <td class="codeLine">    Sh1 = B;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="codeLine">    X = A;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">716</td>
    <td class="codeLine">    X = A;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">717</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class="codeLine">    // TODO: Could also check for an induction variable containing single</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">718</td>
    <td class="codeLine">    // TODO: Could also check for an induction variable containing single</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class="codeLine">    // bit shifted left by 1 in each iteration.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">719</td>
    <td class="codeLine">    // bit shifted left by 1 in each iteration.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">720</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">721</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">722</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="codeLine">  bool TrueIfZero;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">723</td>
    <td class="codeLine">  bool TrueIfZero;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">724</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="codeLine">  // Check C against the possible values for comparison: 0 and (1 << i):</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">725</td>
    <td class="codeLine">  // Check C against the possible values for comparison: 0 and (1 << i):</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class="codeLine">  if (match(C, m_Zero()))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">726</td>
    <td class="codeLine">  if (match(C, m_Zero()))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class="codeLine">    TrueIfZero = (P == CmpInst::ICMP_EQ);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">727</td>
    <td class="codeLine">    TrueIfZero = (P == CmpInst::ICMP_EQ);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class="codeLine">  else if (C == Sh1)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">728</td>
    <td class="codeLine">  else if (C == Sh1)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="codeLine">    TrueIfZero = (P == CmpInst::ICMP_NE);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">729</td>
    <td class="codeLine">    TrueIfZero = (P == CmpInst::ICMP_NE);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">730</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">731</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">732</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="codeLine">  // So far, matched:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">733</td>
    <td class="codeLine">  // So far, matched:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="codeLine">  //   select (X & (1 << i)) ? ... : ...</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">734</td>
    <td class="codeLine">  //   select (X & (1 << i)) ? ... : ...</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class="codeLine">  // including variations of the check against zero/non-zero value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">735</td>
    <td class="codeLine">  // including variations of the check against zero/non-zero value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">736</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class="codeLine">  Value *ShouldSameV = nullptr, *ShouldXoredV = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">737</td>
    <td class="codeLine">  Value *ShouldSameV = nullptr, *ShouldXoredV = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class="codeLine">  if (TrueIfZero) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">738</td>
    <td class="codeLine">  if (TrueIfZero) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class="codeLine">    ShouldSameV = TrueV;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">739</td>
    <td class="codeLine">    ShouldSameV = TrueV;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="codeLine">    ShouldXoredV = FalseV;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">740</td>
    <td class="codeLine">    ShouldXoredV = FalseV;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">741</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class="codeLine">    ShouldSameV = FalseV;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">742</td>
    <td class="codeLine">    ShouldSameV = FalseV;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class="codeLine">    ShouldXoredV = TrueV;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">743</td>
    <td class="codeLine">    ShouldXoredV = TrueV;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">744</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">745</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class="codeLine">  Value *Q = nullptr, *R = nullptr, *Y = nullptr, *Z = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">746</td>
    <td class="codeLine">  Value *Q = nullptr, *R = nullptr, *Y = nullptr, *Z = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class="codeLine">  Value *T = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">747</td>
    <td class="codeLine">  Value *T = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="codeLine">  if (match(ShouldXoredV, m_Xor(m_Value(Y), m_Value(Z)))) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">748</td>
    <td class="codeLine">  if (match(ShouldXoredV, m_Xor(m_Value(Y), m_Value(Z)))) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="codeLine">    // Matched: select +++ ? ... : Y ^ Z</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">749</td>
    <td class="codeLine">    // Matched: select +++ ? ... : Y ^ Z</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="codeLine">    //          select +++ ? Y ^ Z : ...</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">750</td>
    <td class="codeLine">    //          select +++ ? Y ^ Z : ...</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class="codeLine">    // where +++ denotes previously checked matches.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">751</td>
    <td class="codeLine">    // where +++ denotes previously checked matches.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class="codeLine">    if (ShouldSameV == Y)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">752</td>
    <td class="codeLine">    if (ShouldSameV == Y)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class="codeLine">      T = Z;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">753</td>
    <td class="codeLine">      T = Z;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class="codeLine">    else if (ShouldSameV == Z)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">754</td>
    <td class="codeLine">    else if (ShouldSameV == Z)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class="codeLine">      T = Y;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">755</td>
    <td class="codeLine">      T = Y;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">756</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">757</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="codeLine">    R = ShouldSameV;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">758</td>
    <td class="codeLine">    R = ShouldSameV;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="codeLine">    // Matched: select +++ ? R : R ^ T</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">759</td>
    <td class="codeLine">    // Matched: select +++ ? R : R ^ T</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class="codeLine">    //          select +++ ? R ^ T : R</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">760</td>
    <td class="codeLine">    //          select +++ ? R ^ T : R</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class="codeLine">    // depending on TrueIfZero.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">761</td>
    <td class="codeLine">    // depending on TrueIfZero.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">762</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="codeLine">  } else if (match(ShouldSameV, m_Zero())) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">763</td>
    <td class="codeLine">  } else if (match(ShouldSameV, m_Zero())) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class="codeLine">    // Matched: select +++ ? 0 : ...</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">764</td>
    <td class="codeLine">    // Matched: select +++ ? 0 : ...</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class="codeLine">    //          select +++ ? ... : 0</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">765</td>
    <td class="codeLine">    //          select +++ ? ... : 0</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class="codeLine">    if (!SelI->hasOneUse())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">766</td>
    <td class="codeLine">    if (!SelI->hasOneUse())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">767</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class="codeLine">    T = ShouldXoredV;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">768</td>
    <td class="codeLine">    T = ShouldXoredV;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="codeLine">    // Matched: select +++ ? 0 : T</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">769</td>
    <td class="codeLine">    // Matched: select +++ ? 0 : T</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="codeLine">    //          select +++ ? T : 0</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">770</td>
    <td class="codeLine">    //          select +++ ? T : 0</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">771</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="codeLine">    Value *U = *SelI->user_begin();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">772</td>
    <td class="codeLine">    Value *U = *SelI->user_begin();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class="codeLine">    if (!match(U, m_Xor(m_Specific(SelI), m_Value(R))) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">773</td>
    <td class="codeLine">    if (!match(U, m_Xor(m_Specific(SelI), m_Value(R))) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="codeLine">        !match(U, m_Xor(m_Value(R), m_Specific(SelI))))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">774</td>
    <td class="codeLine">        !match(U, m_Xor(m_Value(R), m_Specific(SelI))))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">775</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class="codeLine">    // Matched: xor (select +++ ? 0 : T), R</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">776</td>
    <td class="codeLine">    // Matched: xor (select +++ ? 0 : T), R</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="codeLine">    //          xor (select +++ ? T : 0), R</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">777</td>
    <td class="codeLine">    //          xor (select +++ ? T : 0), R</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class="codeLine">  } else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">778</td>
    <td class="codeLine">  } else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">779</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">780</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class="codeLine">  // The xor input value T is isolated into its own match so that it could</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">781</td>
    <td class="codeLine">  // The xor input value T is isolated into its own match so that it could</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="codeLine">  // be checked against an induction variable containing a shifted bit</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">782</td>
    <td class="codeLine">  // be checked against an induction variable containing a shifted bit</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="codeLine">  // (todo).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">783</td>
    <td class="codeLine">  // (todo).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class="codeLine">  // For now, check against (Q << i).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">784</td>
    <td class="codeLine">  // For now, check against (Q << i).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class="codeLine">  if (!match(T, m_Shl(m_Value(Q), m_Specific(CIV))) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">785</td>
    <td class="codeLine">  if (!match(T, m_Shl(m_Value(Q), m_Specific(CIV))) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class="codeLine">      !match(T, m_Shl(m_ZExt(m_Value(Q)), m_ZExt(m_Specific(CIV)))))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">786</td>
    <td class="codeLine">      !match(T, m_Shl(m_ZExt(m_Value(Q)), m_ZExt(m_Specific(CIV)))))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">787</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="codeLine">  // Matched: select +++ ? R : R ^ (Q << i)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">788</td>
    <td class="codeLine">  // Matched: select +++ ? R : R ^ (Q << i)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class="codeLine">  //          select +++ ? R ^ (Q << i) : R</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">789</td>
    <td class="codeLine">  //          select +++ ? R ^ (Q << i) : R</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">790</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class="codeLine">  PV.X = X;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">791</td>
    <td class="codeLine">  PV.X = X;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class="codeLine">  PV.Q = Q;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">792</td>
    <td class="codeLine">  PV.Q = Q;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="codeLine">  PV.R = R;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">793</td>
    <td class="codeLine">  PV.R = R;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class="codeLine">  PV.Left = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">794</td>
    <td class="codeLine">  PV.Left = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">795</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">796</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">797</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class="codeLine">bool PolynomialMultiplyRecognize::matchRightShift(SelectInst *SelI,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">798</td>
    <td class="codeLine">bool PolynomialMultiplyRecognize::matchRightShift(SelectInst *SelI,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class="codeLine">      ParsedValues &PV) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">799</td>
    <td class="codeLine">      ParsedValues &PV) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class="codeLine">  // Match the following:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">800</td>
    <td class="codeLine">  // Match the following:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class="codeLine">  //   select (X & 1) != 0 ? (R >> 1) ^ Q : (R >> 1)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">801</td>
    <td class="codeLine">  //   select (X & 1) != 0 ? (R >> 1) ^ Q : (R >> 1)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class="codeLine">  //   select (X & 1) == 0 ? (R >> 1) : (R >> 1) ^ Q</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">802</td>
    <td class="codeLine">  //   select (X & 1) == 0 ? (R >> 1) : (R >> 1) ^ Q</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class="codeLine">  // The condition may also check for equality with the masked value, i.e</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">803</td>
    <td class="codeLine">  // The condition may also check for equality with the masked value, i.e</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class="codeLine">  //   select (X & 1) == 1 ? (R >> 1) ^ Q : (R >> 1)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">804</td>
    <td class="codeLine">  //   select (X & 1) == 1 ? (R >> 1) ^ Q : (R >> 1)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class="codeLine">  //   select (X & 1) != 1 ? (R >> 1) : (R >> 1) ^ Q</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">805</td>
    <td class="codeLine">  //   select (X & 1) != 1 ? (R >> 1) : (R >> 1) ^ Q</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">806</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class="codeLine">  Value *CondV = SelI->getCondition();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">807</td>
    <td class="codeLine">  Value *CondV = SelI->getCondition();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class="codeLine">  Value *TrueV = SelI->getTrueValue();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">808</td>
    <td class="codeLine">  Value *TrueV = SelI->getTrueValue();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class="codeLine">  Value *FalseV = SelI->getFalseValue();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">809</td>
    <td class="codeLine">  Value *FalseV = SelI->getFalseValue();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">810</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class="codeLine">  using namespace PatternMatch;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">811</td>
    <td class="codeLine">  using namespace PatternMatch;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">812</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class="codeLine">  Value *C = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">813</td>
    <td class="codeLine">  Value *C = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class="codeLine">  CmpInst::Predicate P;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">814</td>
    <td class="codeLine">  CmpInst::Predicate P;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class="codeLine">  bool TrueIfZero;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">815</td>
    <td class="codeLine">  bool TrueIfZero;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">816</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class="codeLine">  if (match(CondV, m_ICmp(P, m_Value(C), m_Zero())) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">817</td>
    <td class="codeLine">  if (match(CondV, m_ICmp(P, m_Value(C), m_Zero())) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class="codeLine">      match(CondV, m_ICmp(P, m_Zero(), m_Value(C)))) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">818</td>
    <td class="codeLine">      match(CondV, m_ICmp(P, m_Zero(), m_Value(C)))) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class="codeLine">    if (P != CmpInst::ICMP_EQ && P != CmpInst::ICMP_NE)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">819</td>
    <td class="codeLine">    if (P != CmpInst::ICMP_EQ && P != CmpInst::ICMP_NE)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">820</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class="codeLine">    // Matched: select C == 0 ? ... : ...</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">821</td>
    <td class="codeLine">    // Matched: select C == 0 ? ... : ...</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class="codeLine">    //          select C != 0 ? ... : ...</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">822</td>
    <td class="codeLine">    //          select C != 0 ? ... : ...</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class="codeLine">    TrueIfZero = (P == CmpInst::ICMP_EQ);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">823</td>
    <td class="codeLine">    TrueIfZero = (P == CmpInst::ICMP_EQ);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class="codeLine">  } else if (match(CondV, m_ICmp(P, m_Value(C), m_One())) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">824</td>
    <td class="codeLine">  } else if (match(CondV, m_ICmp(P, m_Value(C), m_One())) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class="codeLine">             match(CondV, m_ICmp(P, m_One(), m_Value(C)))) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">825</td>
    <td class="codeLine">             match(CondV, m_ICmp(P, m_One(), m_Value(C)))) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class="codeLine">    if (P != CmpInst::ICMP_EQ && P != CmpInst::ICMP_NE)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">826</td>
    <td class="codeLine">    if (P != CmpInst::ICMP_EQ && P != CmpInst::ICMP_NE)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">827</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class="codeLine">    // Matched: select C == 1 ? ... : ...</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">828</td>
    <td class="codeLine">    // Matched: select C == 1 ? ... : ...</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class="codeLine">    //          select C != 1 ? ... : ...</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">829</td>
    <td class="codeLine">    //          select C != 1 ? ... : ...</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class="codeLine">    TrueIfZero = (P == CmpInst::ICMP_NE);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">830</td>
    <td class="codeLine">    TrueIfZero = (P == CmpInst::ICMP_NE);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class="codeLine">  } else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">831</td>
    <td class="codeLine">  } else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">832</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">833</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class="codeLine">  Value *X = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">834</td>
    <td class="codeLine">  Value *X = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class="codeLine">  if (!match(C, m_And(m_Value(X), m_One())) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">835</td>
    <td class="codeLine">  if (!match(C, m_And(m_Value(X), m_One())) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class="codeLine">      !match(C, m_And(m_One(), m_Value(X))))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">836</td>
    <td class="codeLine">      !match(C, m_And(m_One(), m_Value(X))))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">837</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class="codeLine">  // Matched: select (X & 1) == +++ ? ... : ...</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">838</td>
    <td class="codeLine">  // Matched: select (X & 1) == +++ ? ... : ...</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class="codeLine">  //          select (X & 1) != +++ ? ... : ...</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">839</td>
    <td class="codeLine">  //          select (X & 1) != +++ ? ... : ...</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">840</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class="codeLine">  Value *R = nullptr, *Q = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">841</td>
    <td class="codeLine">  Value *R = nullptr, *Q = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class="codeLine">  if (TrueIfZero) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">842</td>
    <td class="codeLine">  if (TrueIfZero) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class="codeLine">    // The select's condition is true if the tested bit is 0.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">843</td>
    <td class="codeLine">    // The select's condition is true if the tested bit is 0.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class="codeLine">    // TrueV must be the shift, FalseV must be the xor.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">844</td>
    <td class="codeLine">    // TrueV must be the shift, FalseV must be the xor.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class="codeLine">    if (!match(TrueV, m_LShr(m_Value(R), m_One())))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">845</td>
    <td class="codeLine">    if (!match(TrueV, m_LShr(m_Value(R), m_One())))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">846</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class="codeLine">    // Matched: select +++ ? (R >> 1) : ...</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">847</td>
    <td class="codeLine">    // Matched: select +++ ? (R >> 1) : ...</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class="codeLine">    if (!match(FalseV, m_Xor(m_Specific(TrueV), m_Value(Q))) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">848</td>
    <td class="codeLine">    if (!match(FalseV, m_Xor(m_Specific(TrueV), m_Value(Q))) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class="codeLine">        !match(FalseV, m_Xor(m_Value(Q), m_Specific(TrueV))))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">849</td>
    <td class="codeLine">        !match(FalseV, m_Xor(m_Value(Q), m_Specific(TrueV))))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">850</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class="codeLine">    // Matched: select +++ ? (R >> 1) : (R >> 1) ^ Q</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">851</td>
    <td class="codeLine">    // Matched: select +++ ? (R >> 1) : (R >> 1) ^ Q</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class="codeLine">    // with commuting ^.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">852</td>
    <td class="codeLine">    // with commuting ^.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">853</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class="codeLine">    // The select's condition is true if the tested bit is 1.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">854</td>
    <td class="codeLine">    // The select's condition is true if the tested bit is 1.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class="codeLine">    // TrueV must be the xor, FalseV must be the shift.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">855</td>
    <td class="codeLine">    // TrueV must be the xor, FalseV must be the shift.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class="codeLine">    if (!match(FalseV, m_LShr(m_Value(R), m_One())))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">856</td>
    <td class="codeLine">    if (!match(FalseV, m_LShr(m_Value(R), m_One())))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">857</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class="codeLine">    // Matched: select +++ ? ... : (R >> 1)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">858</td>
    <td class="codeLine">    // Matched: select +++ ? ... : (R >> 1)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class="codeLine">    if (!match(TrueV, m_Xor(m_Specific(FalseV), m_Value(Q))) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">859</td>
    <td class="codeLine">    if (!match(TrueV, m_Xor(m_Specific(FalseV), m_Value(Q))) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class="codeLine">        !match(TrueV, m_Xor(m_Value(Q), m_Specific(FalseV))))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">860</td>
    <td class="codeLine">        !match(TrueV, m_Xor(m_Value(Q), m_Specific(FalseV))))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">861</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class="codeLine">    // Matched: select +++ ? (R >> 1) ^ Q : (R >> 1)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">862</td>
    <td class="codeLine">    // Matched: select +++ ? (R >> 1) ^ Q : (R >> 1)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class="codeLine">    // with commuting ^.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">863</td>
    <td class="codeLine">    // with commuting ^.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">864</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">865</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class="codeLine">  PV.X = X;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">866</td>
    <td class="codeLine">  PV.X = X;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class="codeLine">  PV.Q = Q;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">867</td>
    <td class="codeLine">  PV.Q = Q;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class="codeLine">  PV.R = R;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">868</td>
    <td class="codeLine">  PV.R = R;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class="codeLine">  PV.Left = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">869</td>
    <td class="codeLine">  PV.Left = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">870</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">871</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">872</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">872</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">873</td>
    <td class="codeLine">bool PolynomialMultiplyRecognize::scanSelect(SelectInst *SelI,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">873</td>
    <td class="codeLine">bool PolynomialMultiplyRecognize::scanSelect(SelectInst *SelI,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">874</td>
    <td class="codeLine">      BasicBlock *LoopB, BasicBlock *PrehB, Value *CIV, ParsedValues &PV,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">874</td>
    <td class="codeLine">      BasicBlock *LoopB, BasicBlock *PrehB, Value *CIV, ParsedValues &PV,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">875</td>
    <td class="codeLine">      bool PreScan) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">875</td>
    <td class="codeLine">      bool PreScan) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">876</td>
    <td class="codeLine">  using namespace PatternMatch;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">876</td>
    <td class="codeLine">  using namespace PatternMatch;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">877</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">877</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">878</td>
    <td class="codeLine">  // The basic pattern for R = P.Q is:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">878</td>
    <td class="codeLine">  // The basic pattern for R = P.Q is:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">879</td>
    <td class="codeLine">  // for i = 0..31</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">879</td>
    <td class="codeLine">  // for i = 0..31</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">880</td>
    <td class="codeLine">  //   R = phi (0, R')</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">880</td>
    <td class="codeLine">  //   R = phi (0, R')</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">881</td>
    <td class="codeLine">  //   if (P & (1 << i))        ; test-bit(P, i)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">881</td>
    <td class="codeLine">  //   if (P & (1 << i))        ; test-bit(P, i)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">882</td>
    <td class="codeLine">  //     R' = R ^ (Q << i)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">882</td>
    <td class="codeLine">  //     R' = R ^ (Q << i)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">883</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">883</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">884</td>
    <td class="codeLine">  // Similarly, the basic pattern for R = (P/Q).Q - P</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">884</td>
    <td class="codeLine">  // Similarly, the basic pattern for R = (P/Q).Q - P</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">885</td>
    <td class="codeLine">  // for i = 0..31</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">885</td>
    <td class="codeLine">  // for i = 0..31</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">886</td>
    <td class="codeLine">  //   R = phi(P, R')</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">886</td>
    <td class="codeLine">  //   R = phi(P, R')</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">887</td>
    <td class="codeLine">  //   if (R & (1 << i))</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">887</td>
    <td class="codeLine">  //   if (R & (1 << i))</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">888</td>
    <td class="codeLine">  //     R' = R ^ (Q << i)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">888</td>
    <td class="codeLine">  //     R' = R ^ (Q << i)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">889</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">889</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">890</td>
    <td class="codeLine">  // There exist idioms, where instead of Q being shifted left, P is shifted</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">890</td>
    <td class="codeLine">  // There exist idioms, where instead of Q being shifted left, P is shifted</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">891</td>
    <td class="codeLine">  // right. This produces a result that is shifted right by 32 bits (the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">891</td>
    <td class="codeLine">  // right. This produces a result that is shifted right by 32 bits (the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">892</td>
    <td class="codeLine">  // non-shifted result is 64-bit).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">892</td>
    <td class="codeLine">  // non-shifted result is 64-bit).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">893</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">893</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">894</td>
    <td class="codeLine">  // For R = P.Q, this would be:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">894</td>
    <td class="codeLine">  // For R = P.Q, this would be:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">895</td>
    <td class="codeLine">  // for i = 0..31</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">895</td>
    <td class="codeLine">  // for i = 0..31</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">896</td>
    <td class="codeLine">  //   R = phi (0, R')</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">896</td>
    <td class="codeLine">  //   R = phi (0, R')</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">897</td>
    <td class="codeLine">  //   if ((P >> i) & 1)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">897</td>
    <td class="codeLine">  //   if ((P >> i) & 1)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">898</td>
    <td class="codeLine">  //     R' = (R >> 1) ^ Q      ; R is cycled through the loop, so it must</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">898</td>
    <td class="codeLine">  //     R' = (R >> 1) ^ Q      ; R is cycled through the loop, so it must</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">899</td>
    <td class="codeLine">  //   else                     ; be shifted by 1, not i.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">899</td>
    <td class="codeLine">  //   else                     ; be shifted by 1, not i.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">900</td>
    <td class="codeLine">  //     R' = R >> 1</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">900</td>
    <td class="codeLine">  //     R' = R >> 1</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">901</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">901</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">902</td>
    <td class="codeLine">  // And for the inverse:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">902</td>
    <td class="codeLine">  // And for the inverse:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">903</td>
    <td class="codeLine">  // for i = 0..31</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">903</td>
    <td class="codeLine">  // for i = 0..31</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">904</td>
    <td class="codeLine">  //   R = phi (P, R')</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">904</td>
    <td class="codeLine">  //   R = phi (P, R')</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">905</td>
    <td class="codeLine">  //   if (R & 1)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">905</td>
    <td class="codeLine">  //   if (R & 1)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">906</td>
    <td class="codeLine">  //     R' = (R >> 1) ^ Q</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">906</td>
    <td class="codeLine">  //     R' = (R >> 1) ^ Q</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">907</td>
    <td class="codeLine">  //   else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">907</td>
    <td class="codeLine">  //   else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">908</td>
    <td class="codeLine">  //     R' = R >> 1</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">908</td>
    <td class="codeLine">  //     R' = R >> 1</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">909</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">909</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">910</td>
    <td class="codeLine">  // The left-shifting idioms share the same pattern:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">910</td>
    <td class="codeLine">  // The left-shifting idioms share the same pattern:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">911</td>
    <td class="codeLine">  //   select (X & (1 << i)) ? R ^ (Q << i) : R</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">911</td>
    <td class="codeLine">  //   select (X & (1 << i)) ? R ^ (Q << i) : R</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">912</td>
    <td class="codeLine">  // Similarly for right-shifting idioms:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">912</td>
    <td class="codeLine">  // Similarly for right-shifting idioms:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">913</td>
    <td class="codeLine">  //   select (X & 1) ? (R >> 1) ^ Q</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">913</td>
    <td class="codeLine">  //   select (X & 1) ? (R >> 1) ^ Q</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">914</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">914</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">915</td>
    <td class="codeLine">  if (matchLeftShift(SelI, CIV, PV)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">915</td>
    <td class="codeLine">  if (matchLeftShift(SelI, CIV, PV)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">916</td>
    <td class="codeLine">    // If this is a pre-scan, getting this far is sufficient.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">916</td>
    <td class="codeLine">    // If this is a pre-scan, getting this far is sufficient.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">917</td>
    <td class="codeLine">    if (PreScan)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">917</td>
    <td class="codeLine">    if (PreScan)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">918</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">918</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">919</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">919</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">920</td>
    <td class="codeLine">    // Need to make sure that the SelI goes back into R.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">920</td>
    <td class="codeLine">    // Need to make sure that the SelI goes back into R.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">921</td>
    <td class="codeLine">    auto *RPhi = dyn_cast<PHINode>(PV.R);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">921</td>
    <td class="codeLine">    auto *RPhi = dyn_cast<PHINode>(PV.R);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">922</td>
    <td class="codeLine">    if (!RPhi)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">922</td>
    <td class="codeLine">    if (!RPhi)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">923</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">923</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">924</td>
    <td class="codeLine">    if (SelI != RPhi->getIncomingValueForBlock(LoopB))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">924</td>
    <td class="codeLine">    if (SelI != RPhi->getIncomingValueForBlock(LoopB))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">925</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">925</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">926</td>
    <td class="codeLine">    PV.Res = SelI;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">926</td>
    <td class="codeLine">    PV.Res = SelI;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">927</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">927</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">928</td>
    <td class="codeLine">    // If X is loop invariant, it must be the input polynomial, and the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">928</td>
    <td class="codeLine">    // If X is loop invariant, it must be the input polynomial, and the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">929</td>
    <td class="codeLine">    // idiom is the basic polynomial multiply.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">929</td>
    <td class="codeLine">    // idiom is the basic polynomial multiply.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">930</td>
    <td class="codeLine">    if (CurLoop->isLoopInvariant(PV.X)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">930</td>
    <td class="codeLine">    if (CurLoop->isLoopInvariant(PV.X)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">931</td>
    <td class="codeLine">      PV.P = PV.X;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">931</td>
    <td class="codeLine">      PV.P = PV.X;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">932</td>
    <td class="codeLine">      PV.Inv = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">932</td>
    <td class="codeLine">      PV.Inv = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">933</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">933</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">934</td>
    <td class="codeLine">      // X is not loop invariant. If X == R, this is the inverse pmpy.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">934</td>
    <td class="codeLine">      // X is not loop invariant. If X == R, this is the inverse pmpy.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">935</td>
    <td class="codeLine">      // Otherwise, check for an xor with an invariant value. If the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">935</td>
    <td class="codeLine">      // Otherwise, check for an xor with an invariant value. If the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">936</td>
    <td class="codeLine">      // variable argument to the xor is R, then this is still a valid</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">936</td>
    <td class="codeLine">      // variable argument to the xor is R, then this is still a valid</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">937</td>
    <td class="codeLine">      // inverse pmpy.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">937</td>
    <td class="codeLine">      // inverse pmpy.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">938</td>
    <td class="codeLine">      PV.Inv = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">938</td>
    <td class="codeLine">      PV.Inv = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">939</td>
    <td class="codeLine">      if (PV.X != PV.R) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">939</td>
    <td class="codeLine">      if (PV.X != PV.R) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">940</td>
    <td class="codeLine">        Value *Var = nullptr, *Inv = nullptr, *X1 = nullptr, *X2 = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">940</td>
    <td class="codeLine">        Value *Var = nullptr, *Inv = nullptr, *X1 = nullptr, *X2 = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">941</td>
    <td class="codeLine">        if (!match(PV.X, m_Xor(m_Value(X1), m_Value(X2))))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">941</td>
    <td class="codeLine">        if (!match(PV.X, m_Xor(m_Value(X1), m_Value(X2))))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">942</td>
    <td class="codeLine">          return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">942</td>
    <td class="codeLine">          return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">943</td>
    <td class="codeLine">        auto *I1 = dyn_cast<Instruction>(X1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">943</td>
    <td class="codeLine">        auto *I1 = dyn_cast<Instruction>(X1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">944</td>
    <td class="codeLine">        auto *I2 = dyn_cast<Instruction>(X2);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">944</td>
    <td class="codeLine">        auto *I2 = dyn_cast<Instruction>(X2);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">945</td>
    <td class="codeLine">        if (!I1 || I1->getParent() != LoopB) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">945</td>
    <td class="codeLine">        if (!I1 || I1->getParent() != LoopB) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">946</td>
    <td class="codeLine">          Var = X2;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">946</td>
    <td class="codeLine">          Var = X2;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">947</td>
    <td class="codeLine">          Inv = X1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">947</td>
    <td class="codeLine">          Inv = X1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">948</td>
    <td class="codeLine">        } else if (!I2 || I2->getParent() != LoopB) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">948</td>
    <td class="codeLine">        } else if (!I2 || I2->getParent() != LoopB) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">949</td>
    <td class="codeLine">          Var = X1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">949</td>
    <td class="codeLine">          Var = X1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">950</td>
    <td class="codeLine">          Inv = X2;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">950</td>
    <td class="codeLine">          Inv = X2;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">951</td>
    <td class="codeLine">        } else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">951</td>
    <td class="codeLine">        } else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">952</td>
    <td class="codeLine">          return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">952</td>
    <td class="codeLine">          return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">953</td>
    <td class="codeLine">        if (Var != PV.R)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">953</td>
    <td class="codeLine">        if (Var != PV.R)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">954</td>
    <td class="codeLine">          return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">954</td>
    <td class="codeLine">          return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">955</td>
    <td class="codeLine">        PV.M = Inv;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">955</td>
    <td class="codeLine">        PV.M = Inv;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">956</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">956</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">957</td>
    <td class="codeLine">      // The input polynomial P still needs to be determined. It will be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">957</td>
    <td class="codeLine">      // The input polynomial P still needs to be determined. It will be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">958</td>
    <td class="codeLine">      // the entry value of R.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">958</td>
    <td class="codeLine">      // the entry value of R.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">959</td>
    <td class="codeLine">      Value *EntryP = RPhi->getIncomingValueForBlock(PrehB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">959</td>
    <td class="codeLine">      Value *EntryP = RPhi->getIncomingValueForBlock(PrehB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">960</td>
    <td class="codeLine">      PV.P = EntryP;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">960</td>
    <td class="codeLine">      PV.P = EntryP;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">961</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">961</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">962</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">962</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">963</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">963</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">964</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">964</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">965</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">965</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">966</td>
    <td class="codeLine">  if (matchRightShift(SelI, PV)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">966</td>
    <td class="codeLine">  if (matchRightShift(SelI, PV)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">967</td>
    <td class="codeLine">    // If this is an inverse pattern, the Q polynomial must be known at</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">967</td>
    <td class="codeLine">    // If this is an inverse pattern, the Q polynomial must be known at</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">968</td>
    <td class="codeLine">    // compile time.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">968</td>
    <td class="codeLine">    // compile time.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">969</td>
    <td class="codeLine">    if (PV.Inv && !isa<ConstantInt>(PV.Q))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">969</td>
    <td class="codeLine">    if (PV.Inv && !isa<ConstantInt>(PV.Q))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">970</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">970</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">971</td>
    <td class="codeLine">    if (PreScan)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">971</td>
    <td class="codeLine">    if (PreScan)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">972</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">972</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">973</td>
    <td class="codeLine">    // There is no exact matching of right-shift pmpy.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">973</td>
    <td class="codeLine">    // There is no exact matching of right-shift pmpy.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">974</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">974</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">975</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">975</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">976</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">976</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">977</td>
    <td class="codeLine">  return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">977</td>
    <td class="codeLine">  return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">978</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">978</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">979</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">979</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">980</td>
    <td class="codeLine">bool PolynomialMultiplyRecognize::isPromotableTo(Value *Val,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">980</td>
    <td class="codeLine">bool PolynomialMultiplyRecognize::isPromotableTo(Value *Val,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">981</td>
    <td class="codeLine">      IntegerType *DestTy) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">981</td>
    <td class="codeLine">      IntegerType *DestTy) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">982</td>
    <td class="codeLine">  IntegerType *T = dyn_cast<IntegerType>(Val->getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">982</td>
    <td class="codeLine">  IntegerType *T = dyn_cast<IntegerType>(Val->getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">983</td>
    <td class="codeLine">  if (!T || T->getBitWidth() > DestTy->getBitWidth())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">983</td>
    <td class="codeLine">  if (!T || T->getBitWidth() > DestTy->getBitWidth())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">984</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">984</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">985</td>
    <td class="codeLine">  if (T->getBitWidth() == DestTy->getBitWidth())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">985</td>
    <td class="codeLine">  if (T->getBitWidth() == DestTy->getBitWidth())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">986</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">986</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">987</td>
    <td class="codeLine">  // Non-instructions are promotable. The reason why an instruction may not</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">987</td>
    <td class="codeLine">  // Non-instructions are promotable. The reason why an instruction may not</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">988</td>
    <td class="codeLine">  // be promotable is that it may produce a different result if its operands</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">988</td>
    <td class="codeLine">  // be promotable is that it may produce a different result if its operands</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">989</td>
    <td class="codeLine">  // and the result are promoted, for example, it may produce more non-zero</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">989</td>
    <td class="codeLine">  // and the result are promoted, for example, it may produce more non-zero</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">990</td>
    <td class="codeLine">  // bits. While it would still be possible to represent the proper result</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">990</td>
    <td class="codeLine">  // bits. While it would still be possible to represent the proper result</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">991</td>
    <td class="codeLine">  // in a wider type, it may require adding additional instructions (which</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">991</td>
    <td class="codeLine">  // in a wider type, it may require adding additional instructions (which</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">992</td>
    <td class="codeLine">  // we don't want to do).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">992</td>
    <td class="codeLine">  // we don't want to do).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">993</td>
    <td class="codeLine">  Instruction *In = dyn_cast<Instruction>(Val);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">993</td>
    <td class="codeLine">  Instruction *In = dyn_cast<Instruction>(Val);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">994</td>
    <td class="codeLine">  if (!In)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">994</td>
    <td class="codeLine">  if (!In)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">995</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">995</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">996</td>
    <td class="codeLine">  // The bitwidth of the source type is smaller than the destination.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">996</td>
    <td class="codeLine">  // The bitwidth of the source type is smaller than the destination.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">997</td>
    <td class="codeLine">  // Check if the individual operation can be promoted.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">997</td>
    <td class="codeLine">  // Check if the individual operation can be promoted.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">998</td>
    <td class="codeLine">  switch (In->getOpcode()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">998</td>
    <td class="codeLine">  switch (In->getOpcode()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">999</td>
    <td class="codeLine">    case Instruction::PHI:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">999</td>
    <td class="codeLine">    case Instruction::PHI:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1000</td>
    <td class="codeLine">    case Instruction::ZExt:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1000</td>
    <td class="codeLine">    case Instruction::ZExt:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1001</td>
    <td class="codeLine">    case Instruction::And:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1001</td>
    <td class="codeLine">    case Instruction::And:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1002</td>
    <td class="codeLine">    case Instruction::Or:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1002</td>
    <td class="codeLine">    case Instruction::Or:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1003</td>
    <td class="codeLine">    case Instruction::Xor:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1003</td>
    <td class="codeLine">    case Instruction::Xor:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1004</td>
    <td class="codeLine">    case Instruction::LShr: // Shift right is ok.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1004</td>
    <td class="codeLine">    case Instruction::LShr: // Shift right is ok.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1005</td>
    <td class="codeLine">    case Instruction::Select:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1005</td>
    <td class="codeLine">    case Instruction::Select:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1006</td>
    <td class="codeLine">    case Instruction::Trunc:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1006</td>
    <td class="codeLine">    case Instruction::Trunc:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1007</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1007</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1008</td>
    <td class="codeLine">    case Instruction::ICmp:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1008</td>
    <td class="codeLine">    case Instruction::ICmp:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1009</td>
    <td class="codeLine">      if (CmpInst *CI = cast<CmpInst>(In))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1009</td>
    <td class="codeLine">      if (CmpInst *CI = cast<CmpInst>(In))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1010</td>
    <td class="codeLine">        return CI->isEquality() || CI->isUnsigned();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1010</td>
    <td class="codeLine">        return CI->isEquality() || CI->isUnsigned();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1011</td>
    <td class="codeLine">      llvm_unreachable("Cast failed unexpectedly");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1011</td>
    <td class="codeLine">      llvm_unreachable("Cast failed unexpectedly");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1012</td>
    <td class="codeLine">    case Instruction::Add:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1012</td>
    <td class="codeLine">    case Instruction::Add:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1013</td>
    <td class="codeLine">      return In->hasNoSignedWrap() && In->hasNoUnsignedWrap();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1013</td>
    <td class="codeLine">      return In->hasNoSignedWrap() && In->hasNoUnsignedWrap();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1014</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1014</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1015</td>
    <td class="codeLine">  return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1015</td>
    <td class="codeLine">  return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1016</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1016</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1017</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1017</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1018</td>
    <td class="codeLine">void PolynomialMultiplyRecognize::promoteTo(Instruction *In,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1018</td>
    <td class="codeLine">void PolynomialMultiplyRecognize::promoteTo(Instruction *In,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1019</td>
    <td class="codeLine">      IntegerType *DestTy, BasicBlock *LoopB) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1019</td>
    <td class="codeLine">      IntegerType *DestTy, BasicBlock *LoopB) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1020</td>
    <td class="codeLine">  Type *OrigTy = In->getType();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1020</td>
    <td class="codeLine">  Type *OrigTy = In->getType();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1021</td>
    <td class="codeLine">  assert(!OrigTy->isVoidTy() && "Invalid instruction to promote");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1021</td>
    <td class="codeLine">  assert(!OrigTy->isVoidTy() && "Invalid instruction to promote");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1022</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1022</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1023</td>
    <td class="codeLine">  // Leave boolean values alone.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1023</td>
    <td class="codeLine">  // Leave boolean values alone.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1024</td>
    <td class="codeLine">  if (!In->getType()->isIntegerTy(1))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1024</td>
    <td class="codeLine">  if (!In->getType()->isIntegerTy(1))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1025</td>
    <td class="codeLine">    In->mutateType(DestTy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1025</td>
    <td class="codeLine">    In->mutateType(DestTy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1026</td>
    <td class="codeLine">  unsigned DestBW = DestTy->getBitWidth();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1026</td>
    <td class="codeLine">  unsigned DestBW = DestTy->getBitWidth();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1027</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1027</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1028</td>
    <td class="codeLine">  // Handle PHIs.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1028</td>
    <td class="codeLine">  // Handle PHIs.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1029</td>
    <td class="codeLine">  if (PHINode *P = dyn_cast<PHINode>(In)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1029</td>
    <td class="codeLine">  if (PHINode *P = dyn_cast<PHINode>(In)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1030</td>
    <td class="codeLine">    unsigned N = P->getNumIncomingValues();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1030</td>
    <td class="codeLine">    unsigned N = P->getNumIncomingValues();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1031</td>
    <td class="codeLine">    for (unsigned i = 0; i != N; ++i) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1031</td>
    <td class="codeLine">    for (unsigned i = 0; i != N; ++i) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1032</td>
    <td class="codeLine">      BasicBlock *InB = P->getIncomingBlock(i);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1032</td>
    <td class="codeLine">      BasicBlock *InB = P->getIncomingBlock(i);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1033</td>
    <td class="codeLine">      if (InB == LoopB)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1033</td>
    <td class="codeLine">      if (InB == LoopB)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1034</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1034</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1035</td>
    <td class="codeLine">      Value *InV = P->getIncomingValue(i);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1035</td>
    <td class="codeLine">      Value *InV = P->getIncomingValue(i);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1036</td>
    <td class="codeLine">      IntegerType *Ty = cast<IntegerType>(InV->getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1036</td>
    <td class="codeLine">      IntegerType *Ty = cast<IntegerType>(InV->getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1037</td>
    <td class="codeLine">      // Do not promote values in PHI nodes of type i1.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1037</td>
    <td class="codeLine">      // Do not promote values in PHI nodes of type i1.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1038</td>
    <td class="codeLine">      if (Ty != P->getType()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1038</td>
    <td class="codeLine">      if (Ty != P->getType()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1039</td>
    <td class="codeLine">        // If the value type does not match the PHI type, the PHI type</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1039</td>
    <td class="codeLine">        // If the value type does not match the PHI type, the PHI type</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1040</td>
    <td class="codeLine">        // must have been promoted.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1040</td>
    <td class="codeLine">        // must have been promoted.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1041</td>
    <td class="codeLine">        assert(Ty->getBitWidth() < DestBW);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1041</td>
    <td class="codeLine">        assert(Ty->getBitWidth() < DestBW);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1042</td>
    <td class="codeLine">        InV = IRBuilder<>(InB->getTerminator()).CreateZExt(InV, DestTy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1042</td>
    <td class="codeLine">        InV = IRBuilder<>(InB->getTerminator()).CreateZExt(InV, DestTy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1043</td>
    <td class="codeLine">        P->setIncomingValue(i, InV);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1043</td>
    <td class="codeLine">        P->setIncomingValue(i, InV);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1044</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1044</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1045</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1045</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1046</td>
    <td class="codeLine">  } else if (ZExtInst *Z = dyn_cast<ZExtInst>(In)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1046</td>
    <td class="codeLine">  } else if (ZExtInst *Z = dyn_cast<ZExtInst>(In)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1047</td>
    <td class="codeLine">    Value *Op = Z->getOperand(0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1047</td>
    <td class="codeLine">    Value *Op = Z->getOperand(0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1048</td>
    <td class="codeLine">    if (Op->getType() == Z->getType())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1048</td>
    <td class="codeLine">    if (Op->getType() == Z->getType())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1049</td>
    <td class="codeLine">      Z->replaceAllUsesWith(Op);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1049</td>
    <td class="codeLine">      Z->replaceAllUsesWith(Op);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1050</td>
    <td class="codeLine">    Z->eraseFromParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1050</td>
    <td class="codeLine">    Z->eraseFromParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1051</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1051</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1052</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1052</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1053</td>
    <td class="codeLine">  if (TruncInst *T = dyn_cast<TruncInst>(In)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1053</td>
    <td class="codeLine">  if (TruncInst *T = dyn_cast<TruncInst>(In)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1054</td>
    <td class="codeLine">    IntegerType *TruncTy = cast<IntegerType>(OrigTy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1054</td>
    <td class="codeLine">    IntegerType *TruncTy = cast<IntegerType>(OrigTy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1055</td>
    <td class="codeLine">    Value *Mask = ConstantInt::get(DestTy, (1u << TruncTy->getBitWidth()) - 1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1055</td>
    <td class="codeLine">    Value *Mask = ConstantInt::get(DestTy, (1u << TruncTy->getBitWidth()) - 1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1056</td>
    <td class="codeLine">    Value *And = IRBuilder<>(In).CreateAnd(T->getOperand(0), Mask);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1056</td>
    <td class="codeLine">    Value *And = IRBuilder<>(In).CreateAnd(T->getOperand(0), Mask);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1057</td>
    <td class="codeLine">    T->replaceAllUsesWith(And);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1057</td>
    <td class="codeLine">    T->replaceAllUsesWith(And);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1058</td>
    <td class="codeLine">    T->eraseFromParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1058</td>
    <td class="codeLine">    T->eraseFromParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1059</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1059</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1060</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1060</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1061</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1061</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1062</td>
    <td class="codeLine">  // Promote immediates.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1062</td>
    <td class="codeLine">  // Promote immediates.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1063</td>
    <td class="codeLine">  for (unsigned i = 0, n = In->getNumOperands(); i != n; ++i) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1063</td>
    <td class="codeLine">  for (unsigned i = 0, n = In->getNumOperands(); i != n; ++i) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1064</td>
    <td class="codeLine">    if (ConstantInt *CI = dyn_cast<ConstantInt>(In->getOperand(i)))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1064</td>
    <td class="codeLine">    if (ConstantInt *CI = dyn_cast<ConstantInt>(In->getOperand(i)))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1065</td>
    <td class="codeLine">      if (CI->getType()->getBitWidth() < DestBW)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1065</td>
    <td class="codeLine">      if (CI->getType()->getBitWidth() < DestBW)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1066</td>
    <td class="codeLine">        In->setOperand(i, ConstantInt::get(DestTy, CI->getZExtValue()));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1066</td>
    <td class="codeLine">        In->setOperand(i, ConstantInt::get(DestTy, CI->getZExtValue()));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1067</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1067</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1068</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1068</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1069</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1069</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1070</td>
    <td class="codeLine">bool PolynomialMultiplyRecognize::promoteTypes(BasicBlock *LoopB,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1070</td>
    <td class="codeLine">bool PolynomialMultiplyRecognize::promoteTypes(BasicBlock *LoopB,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1071</td>
    <td class="codeLine">      BasicBlock *ExitB) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1071</td>
    <td class="codeLine">      BasicBlock *ExitB) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1072</td>
    <td class="codeLine">  assert(LoopB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1072</td>
    <td class="codeLine">  assert(LoopB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1073</td>
    <td class="codeLine">  // Skip loops where the exit block has more than one predecessor. The values</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1073</td>
    <td class="codeLine">  // Skip loops where the exit block has more than one predecessor. The values</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1074</td>
    <td class="codeLine">  // coming from the loop block will be promoted to another type, and so the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1074</td>
    <td class="codeLine">  // coming from the loop block will be promoted to another type, and so the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1075</td>
    <td class="codeLine">  // values coming into the exit block from other predecessors would also have</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1075</td>
    <td class="codeLine">  // values coming into the exit block from other predecessors would also have</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1076</td>
    <td class="codeLine">  // to be promoted.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1076</td>
    <td class="codeLine">  // to be promoted.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1077</td>
    <td class="codeLine">  if (!ExitB || (ExitB->getSinglePredecessor() != LoopB))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1077</td>
    <td class="codeLine">  if (!ExitB || (ExitB->getSinglePredecessor() != LoopB))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1078</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1078</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1079</td>
    <td class="codeLine">  IntegerType *DestTy = getPmpyType();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1079</td>
    <td class="codeLine">  IntegerType *DestTy = getPmpyType();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1080</td>
    <td class="codeLine">  // Check if the exit values have types that are no wider than the type</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1080</td>
    <td class="codeLine">  // Check if the exit values have types that are no wider than the type</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1081</td>
    <td class="codeLine">  // that we want to promote to.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1081</td>
    <td class="codeLine">  // that we want to promote to.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1082</td>
    <td class="codeLine">  unsigned DestBW = DestTy->getBitWidth();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1082</td>
    <td class="codeLine">  unsigned DestBW = DestTy->getBitWidth();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1083</td>
    <td class="codeLine">  for (PHINode &P : ExitB->phis()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1083</td>
    <td class="codeLine">  for (PHINode &P : ExitB->phis()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1084</td>
    <td class="codeLine">    if (P.getNumIncomingValues() != 1)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1084</td>
    <td class="codeLine">    if (P.getNumIncomingValues() != 1)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1085</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1085</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1086</td>
    <td class="codeLine">    assert(P.getIncomingBlock(0) == LoopB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1086</td>
    <td class="codeLine">    assert(P.getIncomingBlock(0) == LoopB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1087</td>
    <td class="codeLine">    IntegerType *T = dyn_cast<IntegerType>(P.getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1087</td>
    <td class="codeLine">    IntegerType *T = dyn_cast<IntegerType>(P.getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1088</td>
    <td class="codeLine">    if (!T || T->getBitWidth() > DestBW)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1088</td>
    <td class="codeLine">    if (!T || T->getBitWidth() > DestBW)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1089</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1089</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1090</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1090</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1091</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1091</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1092</td>
    <td class="codeLine">  // Check all instructions in the loop.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1092</td>
    <td class="codeLine">  // Check all instructions in the loop.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1093</td>
    <td class="codeLine">  for (Instruction &In : *LoopB)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1093</td>
    <td class="codeLine">  for (Instruction &In : *LoopB)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1094</td>
    <td class="codeLine">    if (!In.isTerminator() && !isPromotableTo(&In, DestTy))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1094</td>
    <td class="codeLine">    if (!In.isTerminator() && !isPromotableTo(&In, DestTy))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1095</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1095</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1096</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1096</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1097</td>
    <td class="codeLine">  // Perform the promotion.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1097</td>
    <td class="codeLine">  // Perform the promotion.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1098</td>
    <td class="codeLine">  std::vector<Instruction*> LoopIns;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1098</td>
    <td class="codeLine">  std::vector<Instruction*> LoopIns;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1099</td>
    <td class="codeLine">  std::transform(LoopB->begin(), LoopB->end(), std::back_inserter(LoopIns),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1099</td>
    <td class="codeLine">  std::transform(LoopB->begin(), LoopB->end(), std::back_inserter(LoopIns),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1100</td>
    <td class="codeLine">                 [](Instruction &In) { return &In; });</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1100</td>
    <td class="codeLine">                 [](Instruction &In) { return &In; });</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1101</td>
    <td class="codeLine">  for (Instruction *In : LoopIns)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1101</td>
    <td class="codeLine">  for (Instruction *In : LoopIns)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1102</td>
    <td class="codeLine">    if (!In->isTerminator())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1102</td>
    <td class="codeLine">    if (!In->isTerminator())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1103</td>
    <td class="codeLine">      promoteTo(In, DestTy, LoopB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1103</td>
    <td class="codeLine">      promoteTo(In, DestTy, LoopB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1104</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1104</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1105</td>
    <td class="codeLine">  // Fix up the PHI nodes in the exit block.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1105</td>
    <td class="codeLine">  // Fix up the PHI nodes in the exit block.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1106</td>
    <td class="codeLine">  Instruction *EndI = ExitB->getFirstNonPHI();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1106</td>
    <td class="codeLine">  Instruction *EndI = ExitB->getFirstNonPHI();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1107</td>
    <td class="codeLine">  BasicBlock::iterator End = EndI ? EndI->getIterator() : ExitB->end();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1107</td>
    <td class="codeLine">  BasicBlock::iterator End = EndI ? EndI->getIterator() : ExitB->end();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1108</td>
    <td class="codeLine">  for (auto I = ExitB->begin(); I != End; ++I) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1108</td>
    <td class="codeLine">  for (auto I = ExitB->begin(); I != End; ++I) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1109</td>
    <td class="codeLine">    PHINode *P = dyn_cast<PHINode>(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1109</td>
    <td class="codeLine">    PHINode *P = dyn_cast<PHINode>(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1110</td>
    <td class="codeLine">    if (!P)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1110</td>
    <td class="codeLine">    if (!P)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1111</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1111</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1112</td>
    <td class="codeLine">    Type *Ty0 = P->getIncomingValue(0)->getType();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1112</td>
    <td class="codeLine">    Type *Ty0 = P->getIncomingValue(0)->getType();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1113</td>
    <td class="codeLine">    Type *PTy = P->getType();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1113</td>
    <td class="codeLine">    Type *PTy = P->getType();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1114</td>
    <td class="codeLine">    if (PTy != Ty0) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1114</td>
    <td class="codeLine">    if (PTy != Ty0) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1115</td>
    <td class="codeLine">      assert(Ty0 == DestTy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1115</td>
    <td class="codeLine">      assert(Ty0 == DestTy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1116</td>
    <td class="codeLine">      // In order to create the trunc, P must have the promoted type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1116</td>
    <td class="codeLine">      // In order to create the trunc, P must have the promoted type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1117</td>
    <td class="codeLine">      P->mutateType(Ty0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1117</td>
    <td class="codeLine">      P->mutateType(Ty0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1118</td>
    <td class="codeLine">      Value *T = IRBuilder<>(ExitB, End).CreateTrunc(P, PTy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1118</td>
    <td class="codeLine">      Value *T = IRBuilder<>(ExitB, End).CreateTrunc(P, PTy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1119</td>
    <td class="codeLine">      // In order for the RAUW to work, the types of P and T must match.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1119</td>
    <td class="codeLine">      // In order for the RAUW to work, the types of P and T must match.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1120</td>
    <td class="codeLine">      P->mutateType(PTy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1120</td>
    <td class="codeLine">      P->mutateType(PTy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1121</td>
    <td class="codeLine">      P->replaceAllUsesWith(T);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1121</td>
    <td class="codeLine">      P->replaceAllUsesWith(T);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1122</td>
    <td class="codeLine">      // Final update of the P's type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1122</td>
    <td class="codeLine">      // Final update of the P's type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1123</td>
    <td class="codeLine">      P->mutateType(Ty0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1123</td>
    <td class="codeLine">      P->mutateType(Ty0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1124</td>
    <td class="codeLine">      cast<Instruction>(T)->setOperand(0, P);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1124</td>
    <td class="codeLine">      cast<Instruction>(T)->setOperand(0, P);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1125</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1125</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1126</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1126</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1127</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1127</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1128</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1128</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1129</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1129</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1130</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1130</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1131</td>
    <td class="codeLine">bool PolynomialMultiplyRecognize::findCycle(Value *Out, Value *In,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1131</td>
    <td class="codeLine">bool PolynomialMultiplyRecognize::findCycle(Value *Out, Value *In,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1132</td>
    <td class="codeLine">      ValueSeq &Cycle) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1132</td>
    <td class="codeLine">      ValueSeq &Cycle) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1133</td>
    <td class="codeLine">  // Out = ..., In, ...</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1133</td>
    <td class="codeLine">  // Out = ..., In, ...</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1134</td>
    <td class="codeLine">  if (Out == In)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1134</td>
    <td class="codeLine">  if (Out == In)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1135</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1135</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1136</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1136</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1137</td>
    <td class="codeLine">  auto *BB = cast<Instruction>(Out)->getParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1137</td>
    <td class="codeLine">  auto *BB = cast<Instruction>(Out)->getParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1138</td>
    <td class="codeLine">  bool HadPhi = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1138</td>
    <td class="codeLine">  bool HadPhi = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1139</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1139</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1140</td>
    <td class="codeLine">  for (auto *U : Out->users()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1140</td>
    <td class="codeLine">  for (auto *U : Out->users()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1141</td>
    <td class="codeLine">    auto *I = dyn_cast<Instruction>(&*U);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1141</td>
    <td class="codeLine">    auto *I = dyn_cast<Instruction>(&*U);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1142</td>
    <td class="codeLine">    if (I == nullptr || I->getParent() != BB)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1142</td>
    <td class="codeLine">    if (I == nullptr || I->getParent() != BB)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1143</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1143</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1144</td>
    <td class="codeLine">    // Make sure that there are no multi-iteration cycles, e.g.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1144</td>
    <td class="codeLine">    // Make sure that there are no multi-iteration cycles, e.g.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1145</td>
    <td class="codeLine">    //   p1 = phi(p2)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1145</td>
    <td class="codeLine">    //   p1 = phi(p2)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1146</td>
    <td class="codeLine">    //   p2 = phi(p1)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1146</td>
    <td class="codeLine">    //   p2 = phi(p1)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1147</td>
    <td class="codeLine">    // The cycle p1->p2->p1 would span two loop iterations.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1147</td>
    <td class="codeLine">    // The cycle p1->p2->p1 would span two loop iterations.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1148</td>
    <td class="codeLine">    // Check that there is only one phi in the cycle.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1148</td>
    <td class="codeLine">    // Check that there is only one phi in the cycle.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1149</td>
    <td class="codeLine">    bool IsPhi = isa<PHINode>(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1149</td>
    <td class="codeLine">    bool IsPhi = isa<PHINode>(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1150</td>
    <td class="codeLine">    if (IsPhi && HadPhi)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1150</td>
    <td class="codeLine">    if (IsPhi && HadPhi)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1151</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1151</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1152</td>
    <td class="codeLine">    HadPhi |= IsPhi;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1152</td>
    <td class="codeLine">    HadPhi |= IsPhi;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1153</td>
    <td class="codeLine">    if (!Cycle.insert(I))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1153</td>
    <td class="codeLine">    if (!Cycle.insert(I))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1154</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1154</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1155</td>
    <td class="codeLine">    if (findCycle(I, In, Cycle))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1155</td>
    <td class="codeLine">    if (findCycle(I, In, Cycle))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1156</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1156</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1157</td>
    <td class="codeLine">    Cycle.remove(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1157</td>
    <td class="codeLine">    Cycle.remove(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1158</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1158</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1159</td>
    <td class="codeLine">  return !Cycle.empty();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1159</td>
    <td class="codeLine">  return !Cycle.empty();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1160</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1160</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1161</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1161</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1162</td>
    <td class="codeLine">void PolynomialMultiplyRecognize::classifyCycle(Instruction *DivI,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1162</td>
    <td class="codeLine">void PolynomialMultiplyRecognize::classifyCycle(Instruction *DivI,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1163</td>
    <td class="codeLine">      ValueSeq &Cycle, ValueSeq &Early, ValueSeq &Late) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1163</td>
    <td class="codeLine">      ValueSeq &Cycle, ValueSeq &Early, ValueSeq &Late) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1164</td>
    <td class="codeLine">  // All the values in the cycle that are between the phi node and the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1164</td>
    <td class="codeLine">  // All the values in the cycle that are between the phi node and the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1165</td>
    <td class="codeLine">  // divider instruction will be classified as "early", all other values</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1165</td>
    <td class="codeLine">  // divider instruction will be classified as "early", all other values</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1166</td>
    <td class="codeLine">  // will be "late".</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1166</td>
    <td class="codeLine">  // will be "late".</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1167</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1167</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1168</td>
    <td class="codeLine">  bool IsE = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1168</td>
    <td class="codeLine">  bool IsE = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1169</td>
    <td class="codeLine">  unsigned I, N = Cycle.size();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1169</td>
    <td class="codeLine">  unsigned I, N = Cycle.size();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1170</td>
    <td class="codeLine">  for (I = 0; I < N; ++I) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1170</td>
    <td class="codeLine">  for (I = 0; I < N; ++I) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1171</td>
    <td class="codeLine">    Value *V = Cycle[I];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1171</td>
    <td class="codeLine">    Value *V = Cycle[I];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1172</td>
    <td class="codeLine">    if (DivI == V)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1172</td>
    <td class="codeLine">    if (DivI == V)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1173</td>
    <td class="codeLine">      IsE = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1173</td>
    <td class="codeLine">      IsE = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1174</td>
    <td class="codeLine">    else if (!isa<PHINode>(V))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1174</td>
    <td class="codeLine">    else if (!isa<PHINode>(V))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1175</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1175</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1176</td>
    <td class="codeLine">    // Stop if found either.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1176</td>
    <td class="codeLine">    // Stop if found either.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1177</td>
    <td class="codeLine">    break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1177</td>
    <td class="codeLine">    break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1178</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1178</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1179</td>
    <td class="codeLine">  // "I" is the index of either DivI or the phi node, whichever was first.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1179</td>
    <td class="codeLine">  // "I" is the index of either DivI or the phi node, whichever was first.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1180</td>
    <td class="codeLine">  // "E" is "false" or "true" respectively.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1180</td>
    <td class="codeLine">  // "E" is "false" or "true" respectively.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1181</td>
    <td class="codeLine">  ValueSeq &First = !IsE ? Early : Late;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1181</td>
    <td class="codeLine">  ValueSeq &First = !IsE ? Early : Late;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1182</td>
    <td class="codeLine">  for (unsigned J = 0; J < I; ++J)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1182</td>
    <td class="codeLine">  for (unsigned J = 0; J < I; ++J)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1183</td>
    <td class="codeLine">    First.insert(Cycle[J]);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1183</td>
    <td class="codeLine">    First.insert(Cycle[J]);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1184</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1184</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1185</td>
    <td class="codeLine">  ValueSeq &Second = IsE ? Early : Late;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1185</td>
    <td class="codeLine">  ValueSeq &Second = IsE ? Early : Late;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1186</td>
    <td class="codeLine">  Second.insert(Cycle[I]);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1186</td>
    <td class="codeLine">  Second.insert(Cycle[I]);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1187</td>
    <td class="codeLine">  for (++I; I < N; ++I) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1187</td>
    <td class="codeLine">  for (++I; I < N; ++I) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1188</td>
    <td class="codeLine">    Value *V = Cycle[I];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1188</td>
    <td class="codeLine">    Value *V = Cycle[I];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1189</td>
    <td class="codeLine">    if (DivI == V || isa<PHINode>(V))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1189</td>
    <td class="codeLine">    if (DivI == V || isa<PHINode>(V))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1190</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1190</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1191</td>
    <td class="codeLine">    Second.insert(V);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1191</td>
    <td class="codeLine">    Second.insert(V);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1192</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1192</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1193</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1193</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1194</td>
    <td class="codeLine">  for (; I < N; ++I)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1194</td>
    <td class="codeLine">  for (; I < N; ++I)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1195</td>
    <td class="codeLine">    First.insert(Cycle[I]);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1195</td>
    <td class="codeLine">    First.insert(Cycle[I]);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1196</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1196</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1197</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1197</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1198</td>
    <td class="codeLine">bool PolynomialMultiplyRecognize::classifyInst(Instruction *UseI,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1198</td>
    <td class="codeLine">bool PolynomialMultiplyRecognize::classifyInst(Instruction *UseI,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1199</td>
    <td class="codeLine">      ValueSeq &Early, ValueSeq &Late) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1199</td>
    <td class="codeLine">      ValueSeq &Early, ValueSeq &Late) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1200</td>
    <td class="codeLine">  // Select is an exception, since the condition value does not have to be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1200</td>
    <td class="codeLine">  // Select is an exception, since the condition value does not have to be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1201</td>
    <td class="codeLine">  // classified in the same way as the true/false values. The true/false</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1201</td>
    <td class="codeLine">  // classified in the same way as the true/false values. The true/false</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1202</td>
    <td class="codeLine">  // values do have to be both early or both late.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1202</td>
    <td class="codeLine">  // values do have to be both early or both late.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1203</td>
    <td class="codeLine">  if (UseI->getOpcode() == Instruction::Select) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1203</td>
    <td class="codeLine">  if (UseI->getOpcode() == Instruction::Select) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1204</td>
    <td class="codeLine">    Value *TV = UseI->getOperand(1), *FV = UseI->getOperand(2);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1204</td>
    <td class="codeLine">    Value *TV = UseI->getOperand(1), *FV = UseI->getOperand(2);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1205</td>
    <td class="codeLine">    if (Early.count(TV) || Early.count(FV)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1205</td>
    <td class="codeLine">    if (Early.count(TV) || Early.count(FV)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1206</td>
    <td class="codeLine">      if (Late.count(TV) || Late.count(FV))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1206</td>
    <td class="codeLine">      if (Late.count(TV) || Late.count(FV))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1207</td>
    <td class="codeLine">        return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1207</td>
    <td class="codeLine">        return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1208</td>
    <td class="codeLine">      Early.insert(UseI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1208</td>
    <td class="codeLine">      Early.insert(UseI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1209</td>
    <td class="codeLine">    } else if (Late.count(TV) || Late.count(FV)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1209</td>
    <td class="codeLine">    } else if (Late.count(TV) || Late.count(FV)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1210</td>
    <td class="codeLine">      if (Early.count(TV) || Early.count(FV))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1210</td>
    <td class="codeLine">      if (Early.count(TV) || Early.count(FV))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1211</td>
    <td class="codeLine">        return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1211</td>
    <td class="codeLine">        return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1212</td>
    <td class="codeLine">      Late.insert(UseI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1212</td>
    <td class="codeLine">      Late.insert(UseI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1213</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1213</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1214</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1214</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1215</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1215</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1216</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1216</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1217</td>
    <td class="codeLine">  // Not sure what would be the example of this, but the code below relies</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1217</td>
    <td class="codeLine">  // Not sure what would be the example of this, but the code below relies</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1218</td>
    <td class="codeLine">  // on having at least one operand.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1218</td>
    <td class="codeLine">  // on having at least one operand.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1219</td>
    <td class="codeLine">  if (UseI->getNumOperands() == 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1219</td>
    <td class="codeLine">  if (UseI->getNumOperands() == 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1220</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1220</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1221</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1221</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1222</td>
    <td class="codeLine">  bool AE = true, AL = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1222</td>
    <td class="codeLine">  bool AE = true, AL = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1223</td>
    <td class="codeLine">  for (auto &I : UseI->operands()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1223</td>
    <td class="codeLine">  for (auto &I : UseI->operands()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1224</td>
    <td class="codeLine">    if (Early.count(&*I))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1224</td>
    <td class="codeLine">    if (Early.count(&*I))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1225</td>
    <td class="codeLine">      AL = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1225</td>
    <td class="codeLine">      AL = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1226</td>
    <td class="codeLine">    else if (Late.count(&*I))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1226</td>
    <td class="codeLine">    else if (Late.count(&*I))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1227</td>
    <td class="codeLine">      AE = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1227</td>
    <td class="codeLine">      AE = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1228</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1228</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1229</td>
    <td class="codeLine">  // If the operands appear "all early" and "all late" at the same time,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1229</td>
    <td class="codeLine">  // If the operands appear "all early" and "all late" at the same time,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1230</td>
    <td class="codeLine">  // then it means that none of them are actually classified as either.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1230</td>
    <td class="codeLine">  // then it means that none of them are actually classified as either.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1231</td>
    <td class="codeLine">  // This is harmless.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1231</td>
    <td class="codeLine">  // This is harmless.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1232</td>
    <td class="codeLine">  if (AE && AL)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1232</td>
    <td class="codeLine">  if (AE && AL)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1233</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1233</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1234</td>
    <td class="codeLine">  // Conversely, if they are neither "all early" nor "all late", then</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1234</td>
    <td class="codeLine">  // Conversely, if they are neither "all early" nor "all late", then</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1235</td>
    <td class="codeLine">  // we have a mixture of early and late operands that is not a known</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1235</td>
    <td class="codeLine">  // we have a mixture of early and late operands that is not a known</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1236</td>
    <td class="codeLine">  // exception.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1236</td>
    <td class="codeLine">  // exception.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1237</td>
    <td class="codeLine">  if (!AE && !AL)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1237</td>
    <td class="codeLine">  if (!AE && !AL)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1238</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1238</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1239</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1239</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1240</td>
    <td class="codeLine">  // Check that we have covered the two special cases.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1240</td>
    <td class="codeLine">  // Check that we have covered the two special cases.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1241</td>
    <td class="codeLine">  assert(AE != AL);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1241</td>
    <td class="codeLine">  assert(AE != AL);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1242</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1242</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1243</td>
    <td class="codeLine">  if (AE)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1243</td>
    <td class="codeLine">  if (AE)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1244</td>
    <td class="codeLine">    Early.insert(UseI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1244</td>
    <td class="codeLine">    Early.insert(UseI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1245</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1245</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1246</td>
    <td class="codeLine">    Late.insert(UseI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1246</td>
    <td class="codeLine">    Late.insert(UseI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1247</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1247</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1248</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1248</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1249</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1249</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1250</td>
    <td class="codeLine">bool PolynomialMultiplyRecognize::commutesWithShift(Instruction *I) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1250</td>
    <td class="codeLine">bool PolynomialMultiplyRecognize::commutesWithShift(Instruction *I) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1251</td>
    <td class="codeLine">  switch (I->getOpcode()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1251</td>
    <td class="codeLine">  switch (I->getOpcode()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1252</td>
    <td class="codeLine">    case Instruction::And:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1252</td>
    <td class="codeLine">    case Instruction::And:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1253</td>
    <td class="codeLine">    case Instruction::Or:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1253</td>
    <td class="codeLine">    case Instruction::Or:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1254</td>
    <td class="codeLine">    case Instruction::Xor:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1254</td>
    <td class="codeLine">    case Instruction::Xor:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1255</td>
    <td class="codeLine">    case Instruction::LShr:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1255</td>
    <td class="codeLine">    case Instruction::LShr:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1256</td>
    <td class="codeLine">    case Instruction::Shl:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1256</td>
    <td class="codeLine">    case Instruction::Shl:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1257</td>
    <td class="codeLine">    case Instruction::Select:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1257</td>
    <td class="codeLine">    case Instruction::Select:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1258</td>
    <td class="codeLine">    case Instruction::ICmp:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1258</td>
    <td class="codeLine">    case Instruction::ICmp:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1259</td>
    <td class="codeLine">    case Instruction::PHI:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1259</td>
    <td class="codeLine">    case Instruction::PHI:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1260</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1260</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1261</td>
    <td class="codeLine">    default:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1261</td>
    <td class="codeLine">    default:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1262</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1262</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1263</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1263</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1264</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1264</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1265</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1265</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1266</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1266</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1267</td>
    <td class="codeLine">bool PolynomialMultiplyRecognize::highBitsAreZero(Value *V,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1267</td>
    <td class="codeLine">bool PolynomialMultiplyRecognize::highBitsAreZero(Value *V,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1268</td>
    <td class="codeLine">      unsigned IterCount) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1268</td>
    <td class="codeLine">      unsigned IterCount) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1269</td>
    <td class="codeLine">  auto *T = dyn_cast<IntegerType>(V->getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1269</td>
    <td class="codeLine">  auto *T = dyn_cast<IntegerType>(V->getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1270</td>
    <td class="codeLine">  if (!T)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1270</td>
    <td class="codeLine">  if (!T)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1271</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1271</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1272</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1272</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1273</td>
    <td class="codeLine">  KnownBits Known(T->getBitWidth());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1273</td>
    <td class="codeLine">  KnownBits Known(T->getBitWidth());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1274</td>
    <td class="codeLine">  computeKnownBits(V, Known, DL);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1274</td>
    <td class="codeLine">  computeKnownBits(V, Known, DL);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1275</td>
    <td class="codeLine">  return Known.countMinLeadingZeros() >= IterCount;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1275</td>
    <td class="codeLine">  return Known.countMinLeadingZeros() >= IterCount;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1276</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1276</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1277</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1277</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1278</td>
    <td class="codeLine">bool PolynomialMultiplyRecognize::keepsHighBitsZero(Value *V,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1278</td>
    <td class="codeLine">bool PolynomialMultiplyRecognize::keepsHighBitsZero(Value *V,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1279</td>
    <td class="codeLine">      unsigned IterCount) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1279</td>
    <td class="codeLine">      unsigned IterCount) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1280</td>
    <td class="codeLine">  // Assume that all inputs to the value have the high bits zero.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1280</td>
    <td class="codeLine">  // Assume that all inputs to the value have the high bits zero.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1281</td>
    <td class="codeLine">  // Check if the value itself preserves the zeros in the high bits.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1281</td>
    <td class="codeLine">  // Check if the value itself preserves the zeros in the high bits.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1282</td>
    <td class="codeLine">  if (auto *C = dyn_cast<ConstantInt>(V))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1282</td>
    <td class="codeLine">  if (auto *C = dyn_cast<ConstantInt>(V))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1283</td>
    <td class="codeLine">    return C->getValue().countl_zero() >= IterCount;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1283</td>
    <td class="codeLine">    return C->getValue().countl_zero() >= IterCount;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1284</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1284</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1285</td>
    <td class="codeLine">  if (auto *I = dyn_cast<Instruction>(V)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1285</td>
    <td class="codeLine">  if (auto *I = dyn_cast<Instruction>(V)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1286</td>
    <td class="codeLine">    switch (I->getOpcode()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1286</td>
    <td class="codeLine">    switch (I->getOpcode()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1287</td>
    <td class="codeLine">      case Instruction::And:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1287</td>
    <td class="codeLine">      case Instruction::And:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1288</td>
    <td class="codeLine">      case Instruction::Or:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1288</td>
    <td class="codeLine">      case Instruction::Or:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1289</td>
    <td class="codeLine">      case Instruction::Xor:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1289</td>
    <td class="codeLine">      case Instruction::Xor:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1290</td>
    <td class="codeLine">      case Instruction::LShr:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1290</td>
    <td class="codeLine">      case Instruction::LShr:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1291</td>
    <td class="codeLine">      case Instruction::Select:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1291</td>
    <td class="codeLine">      case Instruction::Select:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1292</td>
    <td class="codeLine">      case Instruction::ICmp:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1292</td>
    <td class="codeLine">      case Instruction::ICmp:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1293</td>
    <td class="codeLine">      case Instruction::PHI:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1293</td>
    <td class="codeLine">      case Instruction::PHI:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1294</td>
    <td class="codeLine">      case Instruction::ZExt:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1294</td>
    <td class="codeLine">      case Instruction::ZExt:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1295</td>
    <td class="codeLine">        return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1295</td>
    <td class="codeLine">        return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1296</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1296</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1297</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1297</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1298</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1298</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1299</td>
    <td class="codeLine">  return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1299</td>
    <td class="codeLine">  return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1300</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1300</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1301</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1301</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1302</td>
    <td class="codeLine">bool PolynomialMultiplyRecognize::isOperandShifted(Instruction *I, Value *Op) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1302</td>
    <td class="codeLine">bool PolynomialMultiplyRecognize::isOperandShifted(Instruction *I, Value *Op) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1303</td>
    <td class="codeLine">  unsigned Opc = I->getOpcode();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1303</td>
    <td class="codeLine">  unsigned Opc = I->getOpcode();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1304</td>
    <td class="codeLine">  if (Opc == Instruction::Shl || Opc == Instruction::LShr)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1304</td>
    <td class="codeLine">  if (Opc == Instruction::Shl || Opc == Instruction::LShr)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1305</td>
    <td class="codeLine">    return Op != I->getOperand(1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1305</td>
    <td class="codeLine">    return Op != I->getOperand(1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1306</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1306</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1307</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1307</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1308</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1308</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1309</td>
    <td class="codeLine">bool PolynomialMultiplyRecognize::convertShiftsToLeft(BasicBlock *LoopB,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1309</td>
    <td class="codeLine">bool PolynomialMultiplyRecognize::convertShiftsToLeft(BasicBlock *LoopB,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1310</td>
    <td class="codeLine">      BasicBlock *ExitB, unsigned IterCount) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1310</td>
    <td class="codeLine">      BasicBlock *ExitB, unsigned IterCount) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1311</td>
    <td class="codeLine">  Value *CIV = getCountIV(LoopB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1311</td>
    <td class="codeLine">  Value *CIV = getCountIV(LoopB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1312</td>
    <td class="codeLine">  if (CIV == nullptr)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1312</td>
    <td class="codeLine">  if (CIV == nullptr)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1313</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1313</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1314</td>
    <td class="codeLine">  auto *CIVTy = dyn_cast<IntegerType>(CIV->getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1314</td>
    <td class="codeLine">  auto *CIVTy = dyn_cast<IntegerType>(CIV->getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1315</td>
    <td class="codeLine">  if (CIVTy == nullptr)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1315</td>
    <td class="codeLine">  if (CIVTy == nullptr)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1316</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1316</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1317</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1317</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1318</td>
    <td class="codeLine">  ValueSeq RShifts;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1318</td>
    <td class="codeLine">  ValueSeq RShifts;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1319</td>
    <td class="codeLine">  ValueSeq Early, Late, Cycled;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1319</td>
    <td class="codeLine">  ValueSeq Early, Late, Cycled;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1320</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1320</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1321</td>
    <td class="codeLine">  // Find all value cycles that contain logical right shifts by 1.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1321</td>
    <td class="codeLine">  // Find all value cycles that contain logical right shifts by 1.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1322</td>
    <td class="codeLine">  for (Instruction &I : *LoopB) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1322</td>
    <td class="codeLine">  for (Instruction &I : *LoopB) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1323</td>
    <td class="codeLine">    using namespace PatternMatch;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1323</td>
    <td class="codeLine">    using namespace PatternMatch;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1324</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1324</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1325</td>
    <td class="codeLine">    Value *V = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1325</td>
    <td class="codeLine">    Value *V = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1326</td>
    <td class="codeLine">    if (!match(&I, m_LShr(m_Value(V), m_One())))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1326</td>
    <td class="codeLine">    if (!match(&I, m_LShr(m_Value(V), m_One())))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1327</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1327</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1328</td>
    <td class="codeLine">    ValueSeq C;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1328</td>
    <td class="codeLine">    ValueSeq C;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1329</td>
    <td class="codeLine">    if (!findCycle(&I, V, C))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1329</td>
    <td class="codeLine">    if (!findCycle(&I, V, C))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1330</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1330</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1331</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1331</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1332</td>
    <td class="codeLine">    // Found a cycle.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1332</td>
    <td class="codeLine">    // Found a cycle.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1333</td>
    <td class="codeLine">    C.insert(&I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1333</td>
    <td class="codeLine">    C.insert(&I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1334</td>
    <td class="codeLine">    classifyCycle(&I, C, Early, Late);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1334</td>
    <td class="codeLine">    classifyCycle(&I, C, Early, Late);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1335</td>
    <td class="codeLine">    Cycled.insert(C.begin(), C.end());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1335</td>
    <td class="codeLine">    Cycled.insert(C.begin(), C.end());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1336</td>
    <td class="codeLine">    RShifts.insert(&I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1336</td>
    <td class="codeLine">    RShifts.insert(&I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1337</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1337</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1338</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1338</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1339</td>
    <td class="codeLine">  // Find the set of all values affected by the shift cycles, i.e. all</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1339</td>
    <td class="codeLine">  // Find the set of all values affected by the shift cycles, i.e. all</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1340</td>
    <td class="codeLine">  // cycled values, and (recursively) all their users.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1340</td>
    <td class="codeLine">  // cycled values, and (recursively) all their users.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1341</td>
    <td class="codeLine">  ValueSeq Users(Cycled.begin(), Cycled.end());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1341</td>
    <td class="codeLine">  ValueSeq Users(Cycled.begin(), Cycled.end());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1342</td>
    <td class="codeLine">  for (unsigned i = 0; i < Users.size(); ++i) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1342</td>
    <td class="codeLine">  for (unsigned i = 0; i < Users.size(); ++i) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1343</td>
    <td class="codeLine">    Value *V = Users[i];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1343</td>
    <td class="codeLine">    Value *V = Users[i];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1344</td>
    <td class="codeLine">    if (!isa<IntegerType>(V->getType()))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1344</td>
    <td class="codeLine">    if (!isa<IntegerType>(V->getType()))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1345</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1345</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1346</td>
    <td class="codeLine">    auto *R = cast<Instruction>(V);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1346</td>
    <td class="codeLine">    auto *R = cast<Instruction>(V);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1347</td>
    <td class="codeLine">    // If the instruction does not commute with shifts, the loop cannot</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1347</td>
    <td class="codeLine">    // If the instruction does not commute with shifts, the loop cannot</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1348</td>
    <td class="codeLine">    // be unshifted.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1348</td>
    <td class="codeLine">    // be unshifted.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1349</td>
    <td class="codeLine">    if (!commutesWithShift(R))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1349</td>
    <td class="codeLine">    if (!commutesWithShift(R))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1350</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1350</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1351</td>
    <td class="codeLine">    for (User *U : R->users()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1351</td>
    <td class="codeLine">    for (User *U : R->users()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1352</td>
    <td class="codeLine">      auto *T = cast<Instruction>(U);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1352</td>
    <td class="codeLine">      auto *T = cast<Instruction>(U);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1353</td>
    <td class="codeLine">      // Skip users from outside of the loop. They will be handled later.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1353</td>
    <td class="codeLine">      // Skip users from outside of the loop. They will be handled later.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1354</td>
    <td class="codeLine">      // Also, skip the right-shifts and phi nodes, since they mix early</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1354</td>
    <td class="codeLine">      // Also, skip the right-shifts and phi nodes, since they mix early</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1355</td>
    <td class="codeLine">      // and late values.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1355</td>
    <td class="codeLine">      // and late values.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1356</td>
    <td class="codeLine">      if (T->getParent() != LoopB || RShifts.count(T) || isa<PHINode>(T))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1356</td>
    <td class="codeLine">      if (T->getParent() != LoopB || RShifts.count(T) || isa<PHINode>(T))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1357</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1357</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1358</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1358</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1359</td>
    <td class="codeLine">      Users.insert(T);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1359</td>
    <td class="codeLine">      Users.insert(T);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1360</td>
    <td class="codeLine">      if (!classifyInst(T, Early, Late))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1360</td>
    <td class="codeLine">      if (!classifyInst(T, Early, Late))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1361</td>
    <td class="codeLine">        return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1361</td>
    <td class="codeLine">        return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1362</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1362</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1363</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1363</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1364</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1364</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1365</td>
    <td class="codeLine">  if (Users.empty())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1365</td>
    <td class="codeLine">  if (Users.empty())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1366</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1366</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1367</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1367</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1368</td>
    <td class="codeLine">  // Verify that high bits remain zero.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1368</td>
    <td class="codeLine">  // Verify that high bits remain zero.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1369</td>
    <td class="codeLine">  ValueSeq Internal(Users.begin(), Users.end());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1369</td>
    <td class="codeLine">  ValueSeq Internal(Users.begin(), Users.end());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1370</td>
    <td class="codeLine">  ValueSeq Inputs;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1370</td>
    <td class="codeLine">  ValueSeq Inputs;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1371</td>
    <td class="codeLine">  for (unsigned i = 0; i < Internal.size(); ++i) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1371</td>
    <td class="codeLine">  for (unsigned i = 0; i < Internal.size(); ++i) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1372</td>
    <td class="codeLine">    auto *R = dyn_cast<Instruction>(Internal[i]);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1372</td>
    <td class="codeLine">    auto *R = dyn_cast<Instruction>(Internal[i]);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1373</td>
    <td class="codeLine">    if (!R)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1373</td>
    <td class="codeLine">    if (!R)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1374</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1374</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1375</td>
    <td class="codeLine">    for (Value *Op : R->operands()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1375</td>
    <td class="codeLine">    for (Value *Op : R->operands()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1376</td>
    <td class="codeLine">      auto *T = dyn_cast<Instruction>(Op);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1376</td>
    <td class="codeLine">      auto *T = dyn_cast<Instruction>(Op);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1377</td>
    <td class="codeLine">      if (T && T->getParent() != LoopB)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1377</td>
    <td class="codeLine">      if (T && T->getParent() != LoopB)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1378</td>
    <td class="codeLine">        Inputs.insert(Op);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1378</td>
    <td class="codeLine">        Inputs.insert(Op);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1379</td>
    <td class="codeLine">      else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1379</td>
    <td class="codeLine">      else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1380</td>
    <td class="codeLine">        Internal.insert(Op);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1380</td>
    <td class="codeLine">        Internal.insert(Op);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1381</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1381</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1382</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1382</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1383</td>
    <td class="codeLine">  for (Value *V : Inputs)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1383</td>
    <td class="codeLine">  for (Value *V : Inputs)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1384</td>
    <td class="codeLine">    if (!highBitsAreZero(V, IterCount))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1384</td>
    <td class="codeLine">    if (!highBitsAreZero(V, IterCount))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1385</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1385</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1386</td>
    <td class="codeLine">  for (Value *V : Internal)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1386</td>
    <td class="codeLine">  for (Value *V : Internal)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1387</td>
    <td class="codeLine">    if (!keepsHighBitsZero(V, IterCount))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1387</td>
    <td class="codeLine">    if (!keepsHighBitsZero(V, IterCount))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1388</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1388</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1389</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1389</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1390</td>
    <td class="codeLine">  // Finally, the work can be done. Unshift each user.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1390</td>
    <td class="codeLine">  // Finally, the work can be done. Unshift each user.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1391</td>
    <td class="codeLine">  IRBuilder<> IRB(LoopB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1391</td>
    <td class="codeLine">  IRBuilder<> IRB(LoopB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1392</td>
    <td class="codeLine">  std::map<Value*,Value*> ShiftMap;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1392</td>
    <td class="codeLine">  std::map<Value*,Value*> ShiftMap;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1393</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1393</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1394</td>
    <td class="codeLine">  using CastMapType = std::map<std::pair<Value *, Type *>, Value *>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1394</td>
    <td class="codeLine">  using CastMapType = std::map<std::pair<Value *, Type *>, Value *>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1395</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1395</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1396</td>
    <td class="codeLine">  CastMapType CastMap;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1396</td>
    <td class="codeLine">  CastMapType CastMap;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1397</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1397</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1398</td>
    <td class="codeLine">  auto upcast = [] (CastMapType &CM, IRBuilder<> &IRB, Value *V,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1398</td>
    <td class="codeLine">  auto upcast = [] (CastMapType &CM, IRBuilder<> &IRB, Value *V,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1399</td>
    <td class="codeLine">        IntegerType *Ty) -> Value* {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1399</td>
    <td class="codeLine">        IntegerType *Ty) -> Value* {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1400</td>
    <td class="codeLine">    auto H = CM.find(std::make_pair(V, Ty));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1400</td>
    <td class="codeLine">    auto H = CM.find(std::make_pair(V, Ty));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1401</td>
    <td class="codeLine">    if (H != CM.end())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1401</td>
    <td class="codeLine">    if (H != CM.end())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1402</td>
    <td class="codeLine">      return H->second;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1402</td>
    <td class="codeLine">      return H->second;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1403</td>
    <td class="codeLine">    Value *CV = IRB.CreateIntCast(V, Ty, false);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1403</td>
    <td class="codeLine">    Value *CV = IRB.CreateIntCast(V, Ty, false);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1404</td>
    <td class="codeLine">    CM.insert(std::make_pair(std::make_pair(V, Ty), CV));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1404</td>
    <td class="codeLine">    CM.insert(std::make_pair(std::make_pair(V, Ty), CV));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1405</td>
    <td class="codeLine">    return CV;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1405</td>
    <td class="codeLine">    return CV;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1406</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1406</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1407</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1407</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1408</td>
    <td class="codeLine">  for (auto I = LoopB->begin(), E = LoopB->end(); I != E; ++I) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1408</td>
    <td class="codeLine">  for (auto I = LoopB->begin(), E = LoopB->end(); I != E; ++I) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1409</td>
    <td class="codeLine">    using namespace PatternMatch;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1409</td>
    <td class="codeLine">    using namespace PatternMatch;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1410</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1410</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1411</td>
    <td class="codeLine">    if (isa<PHINode>(I) || !Users.count(&*I))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1411</td>
    <td class="codeLine">    if (isa<PHINode>(I) || !Users.count(&*I))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1412</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1412</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1413</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1413</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1414</td>
    <td class="codeLine">    // Match lshr x, 1.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1414</td>
    <td class="codeLine">    // Match lshr x, 1.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1415</td>
    <td class="codeLine">    Value *V = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1415</td>
    <td class="codeLine">    Value *V = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1416</td>
    <td class="codeLine">    if (match(&*I, m_LShr(m_Value(V), m_One()))) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1416</td>
    <td class="codeLine">    if (match(&*I, m_LShr(m_Value(V), m_One()))) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1417</td>
    <td class="codeLine">      replaceAllUsesOfWithIn(&*I, V, LoopB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1417</td>
    <td class="codeLine">      replaceAllUsesOfWithIn(&*I, V, LoopB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1418</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1418</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1419</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1419</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1420</td>
    <td class="codeLine">    // For each non-cycled operand, replace it with the corresponding</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1420</td>
    <td class="codeLine">    // For each non-cycled operand, replace it with the corresponding</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1421</td>
    <td class="codeLine">    // value shifted left.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1421</td>
    <td class="codeLine">    // value shifted left.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1422</td>
    <td class="codeLine">    for (auto &J : I->operands()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1422</td>
    <td class="codeLine">    for (auto &J : I->operands()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1423</td>
    <td class="codeLine">      Value *Op = J.get();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1423</td>
    <td class="codeLine">      Value *Op = J.get();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1424</td>
    <td class="codeLine">      if (!isOperandShifted(&*I, Op))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1424</td>
    <td class="codeLine">      if (!isOperandShifted(&*I, Op))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1425</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1425</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1426</td>
    <td class="codeLine">      if (Users.count(Op))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1426</td>
    <td class="codeLine">      if (Users.count(Op))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1427</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1427</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1428</td>
    <td class="codeLine">      // Skip shifting zeros.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1428</td>
    <td class="codeLine">      // Skip shifting zeros.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1429</td>
    <td class="codeLine">      if (isa<ConstantInt>(Op) && cast<ConstantInt>(Op)->isZero())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1429</td>
    <td class="codeLine">      if (isa<ConstantInt>(Op) && cast<ConstantInt>(Op)->isZero())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1430</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1430</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1431</td>
    <td class="codeLine">      // Check if we have already generated a shift for this value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1431</td>
    <td class="codeLine">      // Check if we have already generated a shift for this value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1432</td>
    <td class="codeLine">      auto F = ShiftMap.find(Op);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1432</td>
    <td class="codeLine">      auto F = ShiftMap.find(Op);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1433</td>
    <td class="codeLine">      Value *W = (F != ShiftMap.end()) ? F->second : nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1433</td>
    <td class="codeLine">      Value *W = (F != ShiftMap.end()) ? F->second : nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1434</td>
    <td class="codeLine">      if (W == nullptr) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1434</td>
    <td class="codeLine">      if (W == nullptr) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1435</td>
    <td class="codeLine">        IRB.SetInsertPoint(&*I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1435</td>
    <td class="codeLine">        IRB.SetInsertPoint(&*I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1436</td>
    <td class="codeLine">        // First, the shift amount will be CIV or CIV+1, depending on</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1436</td>
    <td class="codeLine">        // First, the shift amount will be CIV or CIV+1, depending on</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1437</td>
    <td class="codeLine">        // whether the value is early or late. Instead of creating CIV+1,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1437</td>
    <td class="codeLine">        // whether the value is early or late. Instead of creating CIV+1,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1438</td>
    <td class="codeLine">        // do a single shift of the value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1438</td>
    <td class="codeLine">        // do a single shift of the value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1439</td>
    <td class="codeLine">        Value *ShAmt = CIV, *ShVal = Op;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1439</td>
    <td class="codeLine">        Value *ShAmt = CIV, *ShVal = Op;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1440</td>
    <td class="codeLine">        auto *VTy = cast<IntegerType>(ShVal->getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1440</td>
    <td class="codeLine">        auto *VTy = cast<IntegerType>(ShVal->getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1441</td>
    <td class="codeLine">        auto *ATy = cast<IntegerType>(ShAmt->getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1441</td>
    <td class="codeLine">        auto *ATy = cast<IntegerType>(ShAmt->getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1442</td>
    <td class="codeLine">        if (Late.count(&*I))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1442</td>
    <td class="codeLine">        if (Late.count(&*I))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1443</td>
    <td class="codeLine">          ShVal = IRB.CreateShl(Op, ConstantInt::get(VTy, 1));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1443</td>
    <td class="codeLine">          ShVal = IRB.CreateShl(Op, ConstantInt::get(VTy, 1));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1444</td>
    <td class="codeLine">        // Second, the types of the shifted value and the shift amount</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1444</td>
    <td class="codeLine">        // Second, the types of the shifted value and the shift amount</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1445</td>
    <td class="codeLine">        // must match.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1445</td>
    <td class="codeLine">        // must match.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1446</td>
    <td class="codeLine">        if (VTy != ATy) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1446</td>
    <td class="codeLine">        if (VTy != ATy) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1447</td>
    <td class="codeLine">          if (VTy->getBitWidth() < ATy->getBitWidth())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1447</td>
    <td class="codeLine">          if (VTy->getBitWidth() < ATy->getBitWidth())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1448</td>
    <td class="codeLine">            ShVal = upcast(CastMap, IRB, ShVal, ATy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1448</td>
    <td class="codeLine">            ShVal = upcast(CastMap, IRB, ShVal, ATy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1449</td>
    <td class="codeLine">          else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1449</td>
    <td class="codeLine">          else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1450</td>
    <td class="codeLine">            ShAmt = upcast(CastMap, IRB, ShAmt, VTy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1450</td>
    <td class="codeLine">            ShAmt = upcast(CastMap, IRB, ShAmt, VTy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1451</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1451</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1452</td>
    <td class="codeLine">        // Ready to generate the shift and memoize it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1452</td>
    <td class="codeLine">        // Ready to generate the shift and memoize it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1453</td>
    <td class="codeLine">        W = IRB.CreateShl(ShVal, ShAmt);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1453</td>
    <td class="codeLine">        W = IRB.CreateShl(ShVal, ShAmt);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1454</td>
    <td class="codeLine">        ShiftMap.insert(std::make_pair(Op, W));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1454</td>
    <td class="codeLine">        ShiftMap.insert(std::make_pair(Op, W));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1455</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1455</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1456</td>
    <td class="codeLine">      I->replaceUsesOfWith(Op, W);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1456</td>
    <td class="codeLine">      I->replaceUsesOfWith(Op, W);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1457</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1457</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1458</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1458</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1459</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1459</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1460</td>
    <td class="codeLine">  // Update the users outside of the loop to account for having left</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1460</td>
    <td class="codeLine">  // Update the users outside of the loop to account for having left</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1461</td>
    <td class="codeLine">  // shifts. They would normally be shifted right in the loop, so shift</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1461</td>
    <td class="codeLine">  // shifts. They would normally be shifted right in the loop, so shift</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1462</td>
    <td class="codeLine">  // them right after the loop exit.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1462</td>
    <td class="codeLine">  // them right after the loop exit.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1463</td>
    <td class="codeLine">  // Take advantage of the loop-closed SSA form, which has all the post-</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1463</td>
    <td class="codeLine">  // Take advantage of the loop-closed SSA form, which has all the post-</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1464</td>
    <td class="codeLine">  // loop values in phi nodes.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1464</td>
    <td class="codeLine">  // loop values in phi nodes.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1465</td>
    <td class="codeLine">  IRB.SetInsertPoint(ExitB, ExitB->getFirstInsertionPt());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1465</td>
    <td class="codeLine">  IRB.SetInsertPoint(ExitB, ExitB->getFirstInsertionPt());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1466</td>
    <td class="codeLine">  for (auto P = ExitB->begin(), Q = ExitB->end(); P != Q; ++P) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1466</td>
    <td class="codeLine">  for (auto P = ExitB->begin(), Q = ExitB->end(); P != Q; ++P) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1467</td>
    <td class="codeLine">    if (!isa<PHINode>(P))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1467</td>
    <td class="codeLine">    if (!isa<PHINode>(P))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1468</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1468</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1469</td>
    <td class="codeLine">    auto *PN = cast<PHINode>(P);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1469</td>
    <td class="codeLine">    auto *PN = cast<PHINode>(P);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1470</td>
    <td class="codeLine">    Value *U = PN->getIncomingValueForBlock(LoopB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1470</td>
    <td class="codeLine">    Value *U = PN->getIncomingValueForBlock(LoopB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1471</td>
    <td class="codeLine">    if (!Users.count(U))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1471</td>
    <td class="codeLine">    if (!Users.count(U))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1472</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1472</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1473</td>
    <td class="codeLine">    Value *S = IRB.CreateLShr(PN, ConstantInt::get(PN->getType(), IterCount));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1473</td>
    <td class="codeLine">    Value *S = IRB.CreateLShr(PN, ConstantInt::get(PN->getType(), IterCount));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1474</td>
    <td class="codeLine">    PN->replaceAllUsesWith(S);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1474</td>
    <td class="codeLine">    PN->replaceAllUsesWith(S);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1475</td>
    <td class="codeLine">    // The above RAUW will create</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1475</td>
    <td class="codeLine">    // The above RAUW will create</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1476</td>
    <td class="codeLine">    //   S = lshr S, IterCount</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1476</td>
    <td class="codeLine">    //   S = lshr S, IterCount</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1477</td>
    <td class="codeLine">    // so we need to fix it back into</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1477</td>
    <td class="codeLine">    // so we need to fix it back into</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1478</td>
    <td class="codeLine">    //   S = lshr PN, IterCount</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1478</td>
    <td class="codeLine">    //   S = lshr PN, IterCount</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1479</td>
    <td class="codeLine">    cast<User>(S)->replaceUsesOfWith(S, PN);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1479</td>
    <td class="codeLine">    cast<User>(S)->replaceUsesOfWith(S, PN);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1480</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1480</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1481</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1481</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1482</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1482</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1483</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1483</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1484</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1484</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1485</td>
    <td class="codeLine">void PolynomialMultiplyRecognize::cleanupLoopBody(BasicBlock *LoopB) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1485</td>
    <td class="codeLine">void PolynomialMultiplyRecognize::cleanupLoopBody(BasicBlock *LoopB) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1486</td>
    <td class="codeLine">  for (auto &I : *LoopB)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1486</td>
    <td class="codeLine">  for (auto &I : *LoopB)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1487</td>
    <td class="codeLine">    if (Value *SV = simplifyInstruction(&I, {DL, &TLI, &DT}))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1487</td>
    <td class="codeLine">    if (Value *SV = simplifyInstruction(&I, {DL, &TLI, &DT}))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1488</td>
    <td class="codeLine">      I.replaceAllUsesWith(SV);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1488</td>
    <td class="codeLine">      I.replaceAllUsesWith(SV);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1489</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1489</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1490</td>
    <td class="codeLine">  for (Instruction &I : llvm::make_early_inc_range(*LoopB))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1490</td>
    <td class="codeLine">  for (Instruction &I : llvm::make_early_inc_range(*LoopB))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1491</td>
    <td class="codeLine">    RecursivelyDeleteTriviallyDeadInstructions(&I, &TLI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1491</td>
    <td class="codeLine">    RecursivelyDeleteTriviallyDeadInstructions(&I, &TLI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1492</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1492</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1493</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1493</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1494</td>
    <td class="codeLine">unsigned PolynomialMultiplyRecognize::getInverseMxN(unsigned QP) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1494</td>
    <td class="codeLine">unsigned PolynomialMultiplyRecognize::getInverseMxN(unsigned QP) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1495</td>
    <td class="codeLine">  // Arrays of coefficients of Q and the inverse, C.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1495</td>
    <td class="codeLine">  // Arrays of coefficients of Q and the inverse, C.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1496</td>
    <td class="codeLine">  // Q[i] = coefficient at x^i.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1496</td>
    <td class="codeLine">  // Q[i] = coefficient at x^i.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1497</td>
    <td class="codeLine">  std::array<char,32> Q, C;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1497</td>
    <td class="codeLine">  std::array<char,32> Q, C;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1498</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1498</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1499</td>
    <td class="codeLine">  for (unsigned i = 0; i < 32; ++i) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1499</td>
    <td class="codeLine">  for (unsigned i = 0; i < 32; ++i) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1500</td>
    <td class="codeLine">    Q[i] = QP & 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1500</td>
    <td class="codeLine">    Q[i] = QP & 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1501</td>
    <td class="codeLine">    QP >>= 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1501</td>
    <td class="codeLine">    QP >>= 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1502</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1502</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1503</td>
    <td class="codeLine">  assert(Q[0] == 1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1503</td>
    <td class="codeLine">  assert(Q[0] == 1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1504</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1504</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1505</td>
    <td class="codeLine">  // Find C, such that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1505</td>
    <td class="codeLine">  // Find C, such that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1506</td>
    <td class="codeLine">  // (Q[n]*x^n + ... + Q[1]*x + Q[0]) * (C[n]*x^n + ... + C[1]*x + C[0]) = 1</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1506</td>
    <td class="codeLine">  // (Q[n]*x^n + ... + Q[1]*x + Q[0]) * (C[n]*x^n + ... + C[1]*x + C[0]) = 1</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1507</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1507</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1508</td>
    <td class="codeLine">  // For it to have a solution, Q[0] must be 1. Since this is Z2[x], the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1508</td>
    <td class="codeLine">  // For it to have a solution, Q[0] must be 1. Since this is Z2[x], the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1509</td>
    <td class="codeLine">  // operations * and + are & and ^ respectively.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1509</td>
    <td class="codeLine">  // operations * and + are & and ^ respectively.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1510</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1510</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1511</td>
    <td class="codeLine">  // Find C[i] recursively, by comparing i-th coefficient in the product</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1511</td>
    <td class="codeLine">  // Find C[i] recursively, by comparing i-th coefficient in the product</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1512</td>
    <td class="codeLine">  // with 0 (or 1 for i=0).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1512</td>
    <td class="codeLine">  // with 0 (or 1 for i=0).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1513</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1513</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1514</td>
    <td class="codeLine">  // C[0] = 1, since C[0] = Q[0], and Q[0] = 1.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1514</td>
    <td class="codeLine">  // C[0] = 1, since C[0] = Q[0], and Q[0] = 1.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1515</td>
    <td class="codeLine">  C[0] = 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1515</td>
    <td class="codeLine">  C[0] = 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1516</td>
    <td class="codeLine">  for (unsigned i = 1; i < 32; ++i) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1516</td>
    <td class="codeLine">  for (unsigned i = 1; i < 32; ++i) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1517</td>
    <td class="codeLine">    // Solve for C[i] in:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1517</td>
    <td class="codeLine">    // Solve for C[i] in:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1518</td>
    <td class="codeLine">    //   C[0]Q[i] ^ C[1]Q[i-1] ^ ... ^ C[i-1]Q[1] ^ C[i]Q[0] = 0</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1518</td>
    <td class="codeLine">    //   C[0]Q[i] ^ C[1]Q[i-1] ^ ... ^ C[i-1]Q[1] ^ C[i]Q[0] = 0</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1519</td>
    <td class="codeLine">    // This is equivalent to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1519</td>
    <td class="codeLine">    // This is equivalent to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1520</td>
    <td class="codeLine">    //   C[0]Q[i] ^ C[1]Q[i-1] ^ ... ^ C[i-1]Q[1] ^ C[i] = 0</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1520</td>
    <td class="codeLine">    //   C[0]Q[i] ^ C[1]Q[i-1] ^ ... ^ C[i-1]Q[1] ^ C[i] = 0</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1521</td>
    <td class="codeLine">    // which is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1521</td>
    <td class="codeLine">    // which is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1522</td>
    <td class="codeLine">    //   C[0]Q[i] ^ C[1]Q[i-1] ^ ... ^ C[i-1]Q[1] = C[i]</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1522</td>
    <td class="codeLine">    //   C[0]Q[i] ^ C[1]Q[i-1] ^ ... ^ C[i-1]Q[1] = C[i]</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1523</td>
    <td class="codeLine">    unsigned T = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1523</td>
    <td class="codeLine">    unsigned T = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1524</td>
    <td class="codeLine">    for (unsigned j = 0; j < i; ++j)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1524</td>
    <td class="codeLine">    for (unsigned j = 0; j < i; ++j)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1525</td>
    <td class="codeLine">      T = T ^ (C[j] & Q[i-j]);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1525</td>
    <td class="codeLine">      T = T ^ (C[j] & Q[i-j]);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1526</td>
    <td class="codeLine">    C[i] = T;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1526</td>
    <td class="codeLine">    C[i] = T;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1527</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1527</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1528</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1528</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1529</td>
    <td class="codeLine">  unsigned QV = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1529</td>
    <td class="codeLine">  unsigned QV = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1530</td>
    <td class="codeLine">  for (unsigned i = 0; i < 32; ++i)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1530</td>
    <td class="codeLine">  for (unsigned i = 0; i < 32; ++i)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1531</td>
    <td class="codeLine">    if (C[i])</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1531</td>
    <td class="codeLine">    if (C[i])</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1532</td>
    <td class="codeLine">      QV |= (1 << i);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1532</td>
    <td class="codeLine">      QV |= (1 << i);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1533</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1533</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1534</td>
    <td class="codeLine">  return QV;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1534</td>
    <td class="codeLine">  return QV;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1535</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1535</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1536</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1536</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1537</td>
    <td class="codeLine">Value *PolynomialMultiplyRecognize::generate(BasicBlock::iterator At,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1537</td>
    <td class="codeLine">Value *PolynomialMultiplyRecognize::generate(BasicBlock::iterator At,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1538</td>
    <td class="codeLine">      ParsedValues &PV) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1538</td>
    <td class="codeLine">      ParsedValues &PV) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1539</td>
    <td class="codeLine">  IRBuilder<> B(&*At);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1539</td>
    <td class="codeLine">  IRBuilder<> B(&*At);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1540</td>
    <td class="codeLine">  Module *M = At->getParent()->getParent()->getParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1540</td>
    <td class="codeLine">  Module *M = At->getParent()->getParent()->getParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1541</td>
    <td class="codeLine">  Function *PMF = Intrinsic::getDeclaration(M, Intrinsic::hexagon_M4_pmpyw);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1541</td>
    <td class="codeLine">  Function *PMF = Intrinsic::getDeclaration(M, Intrinsic::hexagon_M4_pmpyw);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1542</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1542</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1543</td>
    <td class="codeLine">  Value *P = PV.P, *Q = PV.Q, *P0 = P;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1543</td>
    <td class="codeLine">  Value *P = PV.P, *Q = PV.Q, *P0 = P;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1544</td>
    <td class="codeLine">  unsigned IC = PV.IterCount;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1544</td>
    <td class="codeLine">  unsigned IC = PV.IterCount;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1545</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1545</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1546</td>
    <td class="codeLine">  if (PV.M != nullptr)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1546</td>
    <td class="codeLine">  if (PV.M != nullptr)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1547</td>
    <td class="codeLine">    P0 = P = B.CreateXor(P, PV.M);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1547</td>
    <td class="codeLine">    P0 = P = B.CreateXor(P, PV.M);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1548</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1548</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1549</td>
    <td class="codeLine">  // Create a bit mask to clear the high bits beyond IterCount.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1549</td>
    <td class="codeLine">  // Create a bit mask to clear the high bits beyond IterCount.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1550</td>
    <td class="codeLine">  auto *BMI = ConstantInt::get(P->getType(), APInt::getLowBitsSet(32, IC));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1550</td>
    <td class="codeLine">  auto *BMI = ConstantInt::get(P->getType(), APInt::getLowBitsSet(32, IC));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1551</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1551</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1552</td>
    <td class="codeLine">  if (PV.IterCount != 32)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1552</td>
    <td class="codeLine">  if (PV.IterCount != 32)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1553</td>
    <td class="codeLine">    P = B.CreateAnd(P, BMI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1553</td>
    <td class="codeLine">    P = B.CreateAnd(P, BMI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1554</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1554</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1555</td>
    <td class="codeLine">  if (PV.Inv) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1555</td>
    <td class="codeLine">  if (PV.Inv) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1556</td>
    <td class="codeLine">    auto *QI = dyn_cast<ConstantInt>(PV.Q);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1556</td>
    <td class="codeLine">    auto *QI = dyn_cast<ConstantInt>(PV.Q);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1557</td>
    <td class="codeLine">    assert(QI && QI->getBitWidth() <= 32);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1557</td>
    <td class="codeLine">    assert(QI && QI->getBitWidth() <= 32);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1558</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1558</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1559</td>
    <td class="codeLine">    // Again, clearing bits beyond IterCount.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1559</td>
    <td class="codeLine">    // Again, clearing bits beyond IterCount.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1560</td>
    <td class="codeLine">    unsigned M = (1 << PV.IterCount) - 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1560</td>
    <td class="codeLine">    unsigned M = (1 << PV.IterCount) - 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1561</td>
    <td class="codeLine">    unsigned Tmp = (QI->getZExtValue() | 1) & M;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1561</td>
    <td class="codeLine">    unsigned Tmp = (QI->getZExtValue() | 1) & M;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1562</td>
    <td class="codeLine">    unsigned QV = getInverseMxN(Tmp) & M;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1562</td>
    <td class="codeLine">    unsigned QV = getInverseMxN(Tmp) & M;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1563</td>
    <td class="codeLine">    auto *QVI = ConstantInt::get(QI->getType(), QV);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1563</td>
    <td class="codeLine">    auto *QVI = ConstantInt::get(QI->getType(), QV);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1564</td>
    <td class="codeLine">    P = B.CreateCall(PMF, {P, QVI});</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1564</td>
    <td class="codeLine">    P = B.CreateCall(PMF, {P, QVI});</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1565</td>
    <td class="codeLine">    P = B.CreateTrunc(P, QI->getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1565</td>
    <td class="codeLine">    P = B.CreateTrunc(P, QI->getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1566</td>
    <td class="codeLine">    if (IC != 32)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1566</td>
    <td class="codeLine">    if (IC != 32)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1567</td>
    <td class="codeLine">      P = B.CreateAnd(P, BMI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1567</td>
    <td class="codeLine">      P = B.CreateAnd(P, BMI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1568</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1568</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1569</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1569</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1570</td>
    <td class="codeLine">  Value *R = B.CreateCall(PMF, {P, Q});</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1570</td>
    <td class="codeLine">  Value *R = B.CreateCall(PMF, {P, Q});</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1571</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1571</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1572</td>
    <td class="codeLine">  if (PV.M != nullptr)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1572</td>
    <td class="codeLine">  if (PV.M != nullptr)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1573</td>
    <td class="codeLine">    R = B.CreateXor(R, B.CreateIntCast(P0, R->getType(), false));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1573</td>
    <td class="codeLine">    R = B.CreateXor(R, B.CreateIntCast(P0, R->getType(), false));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1574</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1574</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1575</td>
    <td class="codeLine">  return R;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1575</td>
    <td class="codeLine">  return R;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1576</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1576</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1577</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1577</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1578</td>
    <td class="codeLine">static bool hasZeroSignBit(const Value *V) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1578</td>
    <td class="codeLine">static bool hasZeroSignBit(const Value *V) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1579</td>
    <td class="codeLine">  if (const auto *CI = dyn_cast<const ConstantInt>(V))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1579</td>
    <td class="codeLine">  if (const auto *CI = dyn_cast<const ConstantInt>(V))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1580</td>
    <td class="codeLine">    return (CI->getType()->getSignBit() & CI->getSExtValue()) == 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1580</td>
    <td class="codeLine">    return (CI->getType()->getSignBit() & CI->getSExtValue()) == 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1581</td>
    <td class="codeLine">  const Instruction *I = dyn_cast<const Instruction>(V);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1581</td>
    <td class="codeLine">  const Instruction *I = dyn_cast<const Instruction>(V);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1582</td>
    <td class="codeLine">  if (!I)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1582</td>
    <td class="codeLine">  if (!I)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1583</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1583</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1584</td>
    <td class="codeLine">  switch (I->getOpcode()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1584</td>
    <td class="codeLine">  switch (I->getOpcode()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1585</td>
    <td class="codeLine">    case Instruction::LShr:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1585</td>
    <td class="codeLine">    case Instruction::LShr:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1586</td>
    <td class="codeLine">      if (const auto SI = dyn_cast<const ConstantInt>(I->getOperand(1)))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1586</td>
    <td class="codeLine">      if (const auto SI = dyn_cast<const ConstantInt>(I->getOperand(1)))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1587</td>
    <td class="codeLine">        return SI->getZExtValue() > 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1587</td>
    <td class="codeLine">        return SI->getZExtValue() > 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1588</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1588</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1589</td>
    <td class="codeLine">    case Instruction::Or:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1589</td>
    <td class="codeLine">    case Instruction::Or:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1590</td>
    <td class="codeLine">    case Instruction::Xor:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1590</td>
    <td class="codeLine">    case Instruction::Xor:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1591</td>
    <td class="codeLine">      return hasZeroSignBit(I->getOperand(0)) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1591</td>
    <td class="codeLine">      return hasZeroSignBit(I->getOperand(0)) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1592</td>
    <td class="codeLine">             hasZeroSignBit(I->getOperand(1));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1592</td>
    <td class="codeLine">             hasZeroSignBit(I->getOperand(1));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1593</td>
    <td class="codeLine">    case Instruction::And:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1593</td>
    <td class="codeLine">    case Instruction::And:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1594</td>
    <td class="codeLine">      return hasZeroSignBit(I->getOperand(0)) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1594</td>
    <td class="codeLine">      return hasZeroSignBit(I->getOperand(0)) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1595</td>
    <td class="codeLine">             hasZeroSignBit(I->getOperand(1));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1595</td>
    <td class="codeLine">             hasZeroSignBit(I->getOperand(1));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1596</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1596</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1597</td>
    <td class="codeLine">  return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1597</td>
    <td class="codeLine">  return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1598</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1598</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1599</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1599</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1600</td>
    <td class="codeLine">void PolynomialMultiplyRecognize::setupPreSimplifier(Simplifier &S) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1600</td>
    <td class="codeLine">void PolynomialMultiplyRecognize::setupPreSimplifier(Simplifier &S) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1601</td>
    <td class="codeLine">  S.addRule("sink-zext",</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1601</td>
    <td class="codeLine">  S.addRule("sink-zext",</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1602</td>
    <td class="codeLine">    // Sink zext past bitwise operations.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1602</td>
    <td class="codeLine">    // Sink zext past bitwise operations.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1603</td>
    <td class="codeLine">    [](Instruction *I, LLVMContext &Ctx) -> Value* {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1603</td>
    <td class="codeLine">    [](Instruction *I, LLVMContext &Ctx) -> Value* {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1604</td>
    <td class="codeLine">      if (I->getOpcode() != Instruction::ZExt)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1604</td>
    <td class="codeLine">      if (I->getOpcode() != Instruction::ZExt)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1605</td>
    <td class="codeLine">        return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1605</td>
    <td class="codeLine">        return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1606</td>
    <td class="codeLine">      Instruction *T = dyn_cast<Instruction>(I->getOperand(0));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1606</td>
    <td class="codeLine">      Instruction *T = dyn_cast<Instruction>(I->getOperand(0));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1607</td>
    <td class="codeLine">      if (!T)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1607</td>
    <td class="codeLine">      if (!T)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1608</td>
    <td class="codeLine">        return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1608</td>
    <td class="codeLine">        return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1609</td>
    <td class="codeLine">      switch (T->getOpcode()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1609</td>
    <td class="codeLine">      switch (T->getOpcode()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1610</td>
    <td class="codeLine">        case Instruction::And:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1610</td>
    <td class="codeLine">        case Instruction::And:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1611</td>
    <td class="codeLine">        case Instruction::Or:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1611</td>
    <td class="codeLine">        case Instruction::Or:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1612</td>
    <td class="codeLine">        case Instruction::Xor:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1612</td>
    <td class="codeLine">        case Instruction::Xor:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1613</td>
    <td class="codeLine">          break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1613</td>
    <td class="codeLine">          break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1614</td>
    <td class="codeLine">        default:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1614</td>
    <td class="codeLine">        default:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1615</td>
    <td class="codeLine">          return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1615</td>
    <td class="codeLine">          return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1616</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1616</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1617</td>
    <td class="codeLine">      IRBuilder<> B(Ctx);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1617</td>
    <td class="codeLine">      IRBuilder<> B(Ctx);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1618</td>
    <td class="codeLine">      return B.CreateBinOp(cast<BinaryOperator>(T)->getOpcode(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1618</td>
    <td class="codeLine">      return B.CreateBinOp(cast<BinaryOperator>(T)->getOpcode(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1619</td>
    <td class="codeLine">                           B.CreateZExt(T->getOperand(0), I->getType()),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1619</td>
    <td class="codeLine">                           B.CreateZExt(T->getOperand(0), I->getType()),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1620</td>
    <td class="codeLine">                           B.CreateZExt(T->getOperand(1), I->getType()));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1620</td>
    <td class="codeLine">                           B.CreateZExt(T->getOperand(1), I->getType()));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1621</td>
    <td class="codeLine">    });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1621</td>
    <td class="codeLine">    });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1622</td>
    <td class="codeLine">  S.addRule("xor/and -> and/xor",</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1622</td>
    <td class="codeLine">  S.addRule("xor/and -> and/xor",</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1623</td>
    <td class="codeLine">    // (xor (and x a) (and y a)) -> (and (xor x y) a)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1623</td>
    <td class="codeLine">    // (xor (and x a) (and y a)) -> (and (xor x y) a)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1624</td>
    <td class="codeLine">    [](Instruction *I, LLVMContext &Ctx) -> Value* {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1624</td>
    <td class="codeLine">    [](Instruction *I, LLVMContext &Ctx) -> Value* {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1625</td>
    <td class="codeLine">      if (I->getOpcode() != Instruction::Xor)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1625</td>
    <td class="codeLine">      if (I->getOpcode() != Instruction::Xor)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1626</td>
    <td class="codeLine">        return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1626</td>
    <td class="codeLine">        return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1627</td>
    <td class="codeLine">      Instruction *And0 = dyn_cast<Instruction>(I->getOperand(0));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1627</td>
    <td class="codeLine">      Instruction *And0 = dyn_cast<Instruction>(I->getOperand(0));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1628</td>
    <td class="codeLine">      Instruction *And1 = dyn_cast<Instruction>(I->getOperand(1));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1628</td>
    <td class="codeLine">      Instruction *And1 = dyn_cast<Instruction>(I->getOperand(1));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1629</td>
    <td class="codeLine">      if (!And0 || !And1)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1629</td>
    <td class="codeLine">      if (!And0 || !And1)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1630</td>
    <td class="codeLine">        return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1630</td>
    <td class="codeLine">        return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1631</td>
    <td class="codeLine">      if (And0->getOpcode() != Instruction::And ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1631</td>
    <td class="codeLine">      if (And0->getOpcode() != Instruction::And ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1632</td>
    <td class="codeLine">          And1->getOpcode() != Instruction::And)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1632</td>
    <td class="codeLine">          And1->getOpcode() != Instruction::And)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1633</td>
    <td class="codeLine">        return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1633</td>
    <td class="codeLine">        return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1634</td>
    <td class="codeLine">      if (And0->getOperand(1) != And1->getOperand(1))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1634</td>
    <td class="codeLine">      if (And0->getOperand(1) != And1->getOperand(1))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1635</td>
    <td class="codeLine">        return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1635</td>
    <td class="codeLine">        return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1636</td>
    <td class="codeLine">      IRBuilder<> B(Ctx);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1636</td>
    <td class="codeLine">      IRBuilder<> B(Ctx);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1637</td>
    <td class="codeLine">      return B.CreateAnd(B.CreateXor(And0->getOperand(0), And1->getOperand(0)),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1637</td>
    <td class="codeLine">      return B.CreateAnd(B.CreateXor(And0->getOperand(0), And1->getOperand(0)),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1638</td>
    <td class="codeLine">                         And0->getOperand(1));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1638</td>
    <td class="codeLine">                         And0->getOperand(1));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1639</td>
    <td class="codeLine">    });</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1639</td>
    <td class="codeLine">    });</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1640</td>
    <td class="codeLine">  S.addRule("sink binop into select",</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1640</td>
    <td class="codeLine">  S.addRule("sink binop into select",</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1641</td>
    <td class="codeLine">    // (Op (select c x y) z) -> (select c (Op x z) (Op y z))</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1641</td>
    <td class="codeLine">    // (Op (select c x y) z) -> (select c (Op x z) (Op y z))</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1642</td>
    <td class="codeLine">    // (Op x (select c y z)) -> (select c (Op x y) (Op x z))</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1642</td>
    <td class="codeLine">    // (Op x (select c y z)) -> (select c (Op x y) (Op x z))</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1643</td>
    <td class="codeLine">    [](Instruction *I, LLVMContext &Ctx) -> Value* {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1643</td>
    <td class="codeLine">    [](Instruction *I, LLVMContext &Ctx) -> Value* {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1644</td>
    <td class="codeLine">      BinaryOperator *BO = dyn_cast<BinaryOperator>(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1644</td>
    <td class="codeLine">      BinaryOperator *BO = dyn_cast<BinaryOperator>(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1645</td>
    <td class="codeLine">      if (!BO)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1645</td>
    <td class="codeLine">      if (!BO)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1646</td>
    <td class="codeLine">        return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1646</td>
    <td class="codeLine">        return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1647</td>
    <td class="codeLine">      Instruction::BinaryOps Op = BO->getOpcode();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1647</td>
    <td class="codeLine">      Instruction::BinaryOps Op = BO->getOpcode();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1648</td>
    <td class="codeLine">      if (SelectInst *Sel = dyn_cast<SelectInst>(BO->getOperand(0))) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1648</td>
    <td class="codeLine">      if (SelectInst *Sel = dyn_cast<SelectInst>(BO->getOperand(0))) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1649</td>
    <td class="codeLine">        IRBuilder<> B(Ctx);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1649</td>
    <td class="codeLine">        IRBuilder<> B(Ctx);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1650</td>
    <td class="codeLine">        Value *X = Sel->getTrueValue(), *Y = Sel->getFalseValue();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1650</td>
    <td class="codeLine">        Value *X = Sel->getTrueValue(), *Y = Sel->getFalseValue();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1651</td>
    <td class="codeLine">        Value *Z = BO->getOperand(1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1651</td>
    <td class="codeLine">        Value *Z = BO->getOperand(1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1652</td>
    <td class="codeLine">        return B.CreateSelect(Sel->getCondition(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1652</td>
    <td class="codeLine">        return B.CreateSelect(Sel->getCondition(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1653</td>
    <td class="codeLine">                              B.CreateBinOp(Op, X, Z),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1653</td>
    <td class="codeLine">                              B.CreateBinOp(Op, X, Z),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1654</td>
    <td class="codeLine">                              B.CreateBinOp(Op, Y, Z));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1654</td>
    <td class="codeLine">                              B.CreateBinOp(Op, Y, Z));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1655</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1655</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1656</td>
    <td class="codeLine">      if (SelectInst *Sel = dyn_cast<SelectInst>(BO->getOperand(1))) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1656</td>
    <td class="codeLine">      if (SelectInst *Sel = dyn_cast<SelectInst>(BO->getOperand(1))) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1657</td>
    <td class="codeLine">        IRBuilder<> B(Ctx);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1657</td>
    <td class="codeLine">        IRBuilder<> B(Ctx);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1658</td>
    <td class="codeLine">        Value *X = BO->getOperand(0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1658</td>
    <td class="codeLine">        Value *X = BO->getOperand(0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1659</td>
    <td class="codeLine">        Value *Y = Sel->getTrueValue(), *Z = Sel->getFalseValue();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1659</td>
    <td class="codeLine">        Value *Y = Sel->getTrueValue(), *Z = Sel->getFalseValue();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1660</td>
    <td class="codeLine">        return B.CreateSelect(Sel->getCondition(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1660</td>
    <td class="codeLine">        return B.CreateSelect(Sel->getCondition(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1661</td>
    <td class="codeLine">                              B.CreateBinOp(Op, X, Y),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1661</td>
    <td class="codeLine">                              B.CreateBinOp(Op, X, Y),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1662</td>
    <td class="codeLine">                              B.CreateBinOp(Op, X, Z));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1662</td>
    <td class="codeLine">                              B.CreateBinOp(Op, X, Z));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1663</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1663</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1664</td>
    <td class="codeLine">      return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1664</td>
    <td class="codeLine">      return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1665</td>
    <td class="codeLine">    });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1665</td>
    <td class="codeLine">    });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1666</td>
    <td class="codeLine">  S.addRule("fold select-select",</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1666</td>
    <td class="codeLine">  S.addRule("fold select-select",</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1667</td>
    <td class="codeLine">    // (select c (select c x y) z) -> (select c x z)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1667</td>
    <td class="codeLine">    // (select c (select c x y) z) -> (select c x z)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1668</td>
    <td class="codeLine">    // (select c x (select c y z)) -> (select c x z)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1668</td>
    <td class="codeLine">    // (select c x (select c y z)) -> (select c x z)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1669</td>
    <td class="codeLine">    [](Instruction *I, LLVMContext &Ctx) -> Value* {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1669</td>
    <td class="codeLine">    [](Instruction *I, LLVMContext &Ctx) -> Value* {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1670</td>
    <td class="codeLine">      SelectInst *Sel = dyn_cast<SelectInst>(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1670</td>
    <td class="codeLine">      SelectInst *Sel = dyn_cast<SelectInst>(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1671</td>
    <td class="codeLine">      if (!Sel)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1671</td>
    <td class="codeLine">      if (!Sel)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1672</td>
    <td class="codeLine">        return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1672</td>
    <td class="codeLine">        return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1673</td>
    <td class="codeLine">      IRBuilder<> B(Ctx);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1673</td>
    <td class="codeLine">      IRBuilder<> B(Ctx);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1674</td>
    <td class="codeLine">      Value *C = Sel->getCondition();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1674</td>
    <td class="codeLine">      Value *C = Sel->getCondition();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1675</td>
    <td class="codeLine">      if (SelectInst *Sel0 = dyn_cast<SelectInst>(Sel->getTrueValue())) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1675</td>
    <td class="codeLine">      if (SelectInst *Sel0 = dyn_cast<SelectInst>(Sel->getTrueValue())) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1676</td>
    <td class="codeLine">        if (Sel0->getCondition() == C)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1676</td>
    <td class="codeLine">        if (Sel0->getCondition() == C)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1677</td>
    <td class="codeLine">          return B.CreateSelect(C, Sel0->getTrueValue(), Sel->getFalseValue());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1677</td>
    <td class="codeLine">          return B.CreateSelect(C, Sel0->getTrueValue(), Sel->getFalseValue());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1678</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1678</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1679</td>
    <td class="codeLine">      if (SelectInst *Sel1 = dyn_cast<SelectInst>(Sel->getFalseValue())) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1679</td>
    <td class="codeLine">      if (SelectInst *Sel1 = dyn_cast<SelectInst>(Sel->getFalseValue())) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1680</td>
    <td class="codeLine">        if (Sel1->getCondition() == C)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1680</td>
    <td class="codeLine">        if (Sel1->getCondition() == C)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1681</td>
    <td class="codeLine">          return B.CreateSelect(C, Sel->getTrueValue(), Sel1->getFalseValue());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1681</td>
    <td class="codeLine">          return B.CreateSelect(C, Sel->getTrueValue(), Sel1->getFalseValue());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1682</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1682</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1683</td>
    <td class="codeLine">      return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1683</td>
    <td class="codeLine">      return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1684</td>
    <td class="codeLine">    });</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1684</td>
    <td class="codeLine">    });</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1685</td>
    <td class="codeLine">  S.addRule("or-signbit -> xor-signbit",</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1685</td>
    <td class="codeLine">  S.addRule("or-signbit -> xor-signbit",</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1686</td>
    <td class="codeLine">    // (or (lshr x 1) 0x800.0) -> (xor (lshr x 1) 0x800.0)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1686</td>
    <td class="codeLine">    // (or (lshr x 1) 0x800.0) -> (xor (lshr x 1) 0x800.0)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1687</td>
    <td class="codeLine">    [](Instruction *I, LLVMContext &Ctx) -> Value* {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1687</td>
    <td class="codeLine">    [](Instruction *I, LLVMContext &Ctx) -> Value* {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1688</td>
    <td class="codeLine">      if (I->getOpcode() != Instruction::Or)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1688</td>
    <td class="codeLine">      if (I->getOpcode() != Instruction::Or)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1689</td>
    <td class="codeLine">        return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1689</td>
    <td class="codeLine">        return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1690</td>
    <td class="codeLine">      ConstantInt *Msb = dyn_cast<ConstantInt>(I->getOperand(1));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1690</td>
    <td class="codeLine">      ConstantInt *Msb = dyn_cast<ConstantInt>(I->getOperand(1));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1691</td>
    <td class="codeLine">      if (!Msb || Msb->getZExtValue() != Msb->getType()->getSignBit())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1691</td>
    <td class="codeLine">      if (!Msb || Msb->getZExtValue() != Msb->getType()->getSignBit())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1692</td>
    <td class="codeLine">        return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1692</td>
    <td class="codeLine">        return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1693</td>
    <td class="codeLine">      if (!hasZeroSignBit(I->getOperand(0)))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1693</td>
    <td class="codeLine">      if (!hasZeroSignBit(I->getOperand(0)))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1694</td>
    <td class="codeLine">        return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1694</td>
    <td class="codeLine">        return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1695</td>
    <td class="codeLine">      return IRBuilder<>(Ctx).CreateXor(I->getOperand(0), Msb);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1695</td>
    <td class="codeLine">      return IRBuilder<>(Ctx).CreateXor(I->getOperand(0), Msb);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1696</td>
    <td class="codeLine">    });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1696</td>
    <td class="codeLine">    });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1697</td>
    <td class="codeLine">  S.addRule("sink lshr into binop",</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1697</td>
    <td class="codeLine">  S.addRule("sink lshr into binop",</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1698</td>
    <td class="codeLine">    // (lshr (BitOp x y) c) -> (BitOp (lshr x c) (lshr y c))</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1698</td>
    <td class="codeLine">    // (lshr (BitOp x y) c) -> (BitOp (lshr x c) (lshr y c))</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1699</td>
    <td class="codeLine">    [](Instruction *I, LLVMContext &Ctx) -> Value* {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1699</td>
    <td class="codeLine">    [](Instruction *I, LLVMContext &Ctx) -> Value* {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1700</td>
    <td class="codeLine">      if (I->getOpcode() != Instruction::LShr)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1700</td>
    <td class="codeLine">      if (I->getOpcode() != Instruction::LShr)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1701</td>
    <td class="codeLine">        return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1701</td>
    <td class="codeLine">        return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1702</td>
    <td class="codeLine">      BinaryOperator *BitOp = dyn_cast<BinaryOperator>(I->getOperand(0));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1702</td>
    <td class="codeLine">      BinaryOperator *BitOp = dyn_cast<BinaryOperator>(I->getOperand(0));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1703</td>
    <td class="codeLine">      if (!BitOp)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1703</td>
    <td class="codeLine">      if (!BitOp)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1704</td>
    <td class="codeLine">        return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1704</td>
    <td class="codeLine">        return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1705</td>
    <td class="codeLine">      switch (BitOp->getOpcode()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1705</td>
    <td class="codeLine">      switch (BitOp->getOpcode()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1706</td>
    <td class="codeLine">        case Instruction::And:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1706</td>
    <td class="codeLine">        case Instruction::And:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1707</td>
    <td class="codeLine">        case Instruction::Or:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1707</td>
    <td class="codeLine">        case Instruction::Or:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1708</td>
    <td class="codeLine">        case Instruction::Xor:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1708</td>
    <td class="codeLine">        case Instruction::Xor:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1709</td>
    <td class="codeLine">          break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1709</td>
    <td class="codeLine">          break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1710</td>
    <td class="codeLine">        default:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1710</td>
    <td class="codeLine">        default:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1711</td>
    <td class="codeLine">          return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1711</td>
    <td class="codeLine">          return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1712</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1712</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1713</td>
    <td class="codeLine">      IRBuilder<> B(Ctx);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1713</td>
    <td class="codeLine">      IRBuilder<> B(Ctx);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1714</td>
    <td class="codeLine">      Value *S = I->getOperand(1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1714</td>
    <td class="codeLine">      Value *S = I->getOperand(1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1715</td>
    <td class="codeLine">      return B.CreateBinOp(BitOp->getOpcode(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1715</td>
    <td class="codeLine">      return B.CreateBinOp(BitOp->getOpcode(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1716</td>
    <td class="codeLine">                B.CreateLShr(BitOp->getOperand(0), S),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1716</td>
    <td class="codeLine">                B.CreateLShr(BitOp->getOperand(0), S),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1717</td>
    <td class="codeLine">                B.CreateLShr(BitOp->getOperand(1), S));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1717</td>
    <td class="codeLine">                B.CreateLShr(BitOp->getOperand(1), S));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1718</td>
    <td class="codeLine">    });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1718</td>
    <td class="codeLine">    });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1719</td>
    <td class="codeLine">  S.addRule("expose bitop-const",</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1719</td>
    <td class="codeLine">  S.addRule("expose bitop-const",</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1720</td>
    <td class="codeLine">    // (BitOp1 (BitOp2 x a) b) -> (BitOp2 x (BitOp1 a b))</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1720</td>
    <td class="codeLine">    // (BitOp1 (BitOp2 x a) b) -> (BitOp2 x (BitOp1 a b))</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1721</td>
    <td class="codeLine">    [](Instruction *I, LLVMContext &Ctx) -> Value* {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1721</td>
    <td class="codeLine">    [](Instruction *I, LLVMContext &Ctx) -> Value* {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1722</td>
    <td class="codeLine">      auto IsBitOp = [](unsigned Op) -> bool {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1722</td>
    <td class="codeLine">      auto IsBitOp = [](unsigned Op) -> bool {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1723</td>
    <td class="codeLine">        switch (Op) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1723</td>
    <td class="codeLine">        switch (Op) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1724</td>
    <td class="codeLine">          case Instruction::And:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1724</td>
    <td class="codeLine">          case Instruction::And:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1725</td>
    <td class="codeLine">          case Instruction::Or:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1725</td>
    <td class="codeLine">          case Instruction::Or:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1726</td>
    <td class="codeLine">          case Instruction::Xor:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1726</td>
    <td class="codeLine">          case Instruction::Xor:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1727</td>
    <td class="codeLine">            return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1727</td>
    <td class="codeLine">            return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1728</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1728</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1729</td>
    <td class="codeLine">        return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1729</td>
    <td class="codeLine">        return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1730</td>
    <td class="codeLine">      };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1730</td>
    <td class="codeLine">      };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1731</td>
    <td class="codeLine">      BinaryOperator *BitOp1 = dyn_cast<BinaryOperator>(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1731</td>
    <td class="codeLine">      BinaryOperator *BitOp1 = dyn_cast<BinaryOperator>(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1732</td>
    <td class="codeLine">      if (!BitOp1 || !IsBitOp(BitOp1->getOpcode()))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1732</td>
    <td class="codeLine">      if (!BitOp1 || !IsBitOp(BitOp1->getOpcode()))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1733</td>
    <td class="codeLine">        return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1733</td>
    <td class="codeLine">        return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1734</td>
    <td class="codeLine">      BinaryOperator *BitOp2 = dyn_cast<BinaryOperator>(BitOp1->getOperand(0));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1734</td>
    <td class="codeLine">      BinaryOperator *BitOp2 = dyn_cast<BinaryOperator>(BitOp1->getOperand(0));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1735</td>
    <td class="codeLine">      if (!BitOp2 || !IsBitOp(BitOp2->getOpcode()))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1735</td>
    <td class="codeLine">      if (!BitOp2 || !IsBitOp(BitOp2->getOpcode()))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1736</td>
    <td class="codeLine">        return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1736</td>
    <td class="codeLine">        return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1737</td>
    <td class="codeLine">      ConstantInt *CA = dyn_cast<ConstantInt>(BitOp2->getOperand(1));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1737</td>
    <td class="codeLine">      ConstantInt *CA = dyn_cast<ConstantInt>(BitOp2->getOperand(1));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1738</td>
    <td class="codeLine">      ConstantInt *CB = dyn_cast<ConstantInt>(BitOp1->getOperand(1));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1738</td>
    <td class="codeLine">      ConstantInt *CB = dyn_cast<ConstantInt>(BitOp1->getOperand(1));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1739</td>
    <td class="codeLine">      if (!CA || !CB)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1739</td>
    <td class="codeLine">      if (!CA || !CB)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1740</td>
    <td class="codeLine">        return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1740</td>
    <td class="codeLine">        return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1741</td>
    <td class="codeLine">      IRBuilder<> B(Ctx);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1741</td>
    <td class="codeLine">      IRBuilder<> B(Ctx);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1742</td>
    <td class="codeLine">      Value *X = BitOp2->getOperand(0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1742</td>
    <td class="codeLine">      Value *X = BitOp2->getOperand(0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1743</td>
    <td class="codeLine">      return B.CreateBinOp(BitOp2->getOpcode(), X,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1743</td>
    <td class="codeLine">      return B.CreateBinOp(BitOp2->getOpcode(), X,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1744</td>
    <td class="codeLine">                B.CreateBinOp(BitOp1->getOpcode(), CA, CB));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1744</td>
    <td class="codeLine">                B.CreateBinOp(BitOp1->getOpcode(), CA, CB));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1745</td>
    <td class="codeLine">    });</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1745</td>
    <td class="codeLine">    });</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1746</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1746</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1747</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1747</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1748</td>
    <td class="codeLine">void PolynomialMultiplyRecognize::setupPostSimplifier(Simplifier &S) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1748</td>
    <td class="codeLine">void PolynomialMultiplyRecognize::setupPostSimplifier(Simplifier &S) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1749</td>
    <td class="codeLine">  S.addRule("(and (xor (and x a) y) b) -> (and (xor x y) b), if b == b&a",</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1749</td>
    <td class="codeLine">  S.addRule("(and (xor (and x a) y) b) -> (and (xor x y) b), if b == b&a",</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1750</td>
    <td class="codeLine">    [](Instruction *I, LLVMContext &Ctx) -> Value* {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1750</td>
    <td class="codeLine">    [](Instruction *I, LLVMContext &Ctx) -> Value* {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1751</td>
    <td class="codeLine">      if (I->getOpcode() != Instruction::And)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1751</td>
    <td class="codeLine">      if (I->getOpcode() != Instruction::And)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1752</td>
    <td class="codeLine">        return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1752</td>
    <td class="codeLine">        return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1753</td>
    <td class="codeLine">      Instruction *Xor = dyn_cast<Instruction>(I->getOperand(0));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1753</td>
    <td class="codeLine">      Instruction *Xor = dyn_cast<Instruction>(I->getOperand(0));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1754</td>
    <td class="codeLine">      ConstantInt *C0 = dyn_cast<ConstantInt>(I->getOperand(1));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1754</td>
    <td class="codeLine">      ConstantInt *C0 = dyn_cast<ConstantInt>(I->getOperand(1));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1755</td>
    <td class="codeLine">      if (!Xor || !C0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1755</td>
    <td class="codeLine">      if (!Xor || !C0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1756</td>
    <td class="codeLine">        return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1756</td>
    <td class="codeLine">        return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1757</td>
    <td class="codeLine">      if (Xor->getOpcode() != Instruction::Xor)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1757</td>
    <td class="codeLine">      if (Xor->getOpcode() != Instruction::Xor)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1758</td>
    <td class="codeLine">        return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1758</td>
    <td class="codeLine">        return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1759</td>
    <td class="codeLine">      Instruction *And0 = dyn_cast<Instruction>(Xor->getOperand(0));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1759</td>
    <td class="codeLine">      Instruction *And0 = dyn_cast<Instruction>(Xor->getOperand(0));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1760</td>
    <td class="codeLine">      Instruction *And1 = dyn_cast<Instruction>(Xor->getOperand(1));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1760</td>
    <td class="codeLine">      Instruction *And1 = dyn_cast<Instruction>(Xor->getOperand(1));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1761</td>
    <td class="codeLine">      // Pick the first non-null and.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1761</td>
    <td class="codeLine">      // Pick the first non-null and.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1762</td>
    <td class="codeLine">      if (!And0 || And0->getOpcode() != Instruction::And)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1762</td>
    <td class="codeLine">      if (!And0 || And0->getOpcode() != Instruction::And)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1763</td>
    <td class="codeLine">        std::swap(And0, And1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1763</td>
    <td class="codeLine">        std::swap(And0, And1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1764</td>
    <td class="codeLine">      ConstantInt *C1 = dyn_cast<ConstantInt>(And0->getOperand(1));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1764</td>
    <td class="codeLine">      ConstantInt *C1 = dyn_cast<ConstantInt>(And0->getOperand(1));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1765</td>
    <td class="codeLine">      if (!C1)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1765</td>
    <td class="codeLine">      if (!C1)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1766</td>
    <td class="codeLine">        return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1766</td>
    <td class="codeLine">        return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1767</td>
    <td class="codeLine">      uint32_t V0 = C0->getZExtValue();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1767</td>
    <td class="codeLine">      uint32_t V0 = C0->getZExtValue();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1768</td>
    <td class="codeLine">      uint32_t V1 = C1->getZExtValue();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1768</td>
    <td class="codeLine">      uint32_t V1 = C1->getZExtValue();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1769</td>
    <td class="codeLine">      if (V0 != (V0 & V1))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1769</td>
    <td class="codeLine">      if (V0 != (V0 & V1))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1770</td>
    <td class="codeLine">        return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1770</td>
    <td class="codeLine">        return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1771</td>
    <td class="codeLine">      IRBuilder<> B(Ctx);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1771</td>
    <td class="codeLine">      IRBuilder<> B(Ctx);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1772</td>
    <td class="codeLine">      return B.CreateAnd(B.CreateXor(And0->getOperand(0), And1), C0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1772</td>
    <td class="codeLine">      return B.CreateAnd(B.CreateXor(And0->getOperand(0), And1), C0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1773</td>
    <td class="codeLine">    });</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1773</td>
    <td class="codeLine">    });</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1774</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1774</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1775</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1775</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1776</td>
    <td class="codeLine">bool PolynomialMultiplyRecognize::recognize() {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1776</td>
    <td class="codeLine">bool PolynomialMultiplyRecognize::recognize() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1777</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "Starting PolynomialMultiplyRecognize on loop\n"</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1777</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "Starting PolynomialMultiplyRecognize on loop\n"</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1778</td>
    <td class="codeLine">                    << *CurLoop << '\n');</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1778</td>
    <td class="codeLine">                    << *CurLoop << '\n');</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1779</td>
    <td class="codeLine">  // Restrictions:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1779</td>
    <td class="codeLine">  // Restrictions:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1780</td>
    <td class="codeLine">  // - The loop must consist of a single block.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1780</td>
    <td class="codeLine">  // - The loop must consist of a single block.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1781</td>
    <td class="codeLine">  // - The iteration count must be known at compile-time.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1781</td>
    <td class="codeLine">  // - The iteration count must be known at compile-time.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1782</td>
    <td class="codeLine">  // - The loop must have an induction variable starting from 0, and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1782</td>
    <td class="codeLine">  // - The loop must have an induction variable starting from 0, and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1783</td>
    <td class="codeLine">  //   incremented in each iteration of the loop.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1783</td>
    <td class="codeLine">  //   incremented in each iteration of the loop.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1784</td>
    <td class="codeLine">  BasicBlock *LoopB = CurLoop->getHeader();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1784</td>
    <td class="codeLine">  BasicBlock *LoopB = CurLoop->getHeader();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1785</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "Loop header:\n" << *LoopB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1785</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "Loop header:\n" << *LoopB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1786</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1786</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1787</td>
    <td class="codeLine">  if (LoopB != CurLoop->getLoopLatch())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1787</td>
    <td class="codeLine">  if (LoopB != CurLoop->getLoopLatch())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1788</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1788</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1789</td>
    <td class="codeLine">  BasicBlock *ExitB = CurLoop->getExitBlock();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1789</td>
    <td class="codeLine">  BasicBlock *ExitB = CurLoop->getExitBlock();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1790</td>
    <td class="codeLine">  if (ExitB == nullptr)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1790</td>
    <td class="codeLine">  if (ExitB == nullptr)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1791</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1791</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1792</td>
    <td class="codeLine">  BasicBlock *EntryB = CurLoop->getLoopPreheader();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1792</td>
    <td class="codeLine">  BasicBlock *EntryB = CurLoop->getLoopPreheader();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1793</td>
    <td class="codeLine">  if (EntryB == nullptr)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1793</td>
    <td class="codeLine">  if (EntryB == nullptr)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1794</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1794</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1795</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1795</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1796</td>
    <td class="codeLine">  unsigned IterCount = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1796</td>
    <td class="codeLine">  unsigned IterCount = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1797</td>
    <td class="codeLine">  const SCEV *CT = SE.getBackedgeTakenCount(CurLoop);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1797</td>
    <td class="codeLine">  const SCEV *CT = SE.getBackedgeTakenCount(CurLoop);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1798</td>
    <td class="codeLine">  if (isa<SCEVCouldNotCompute>(CT))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1798</td>
    <td class="codeLine">  if (isa<SCEVCouldNotCompute>(CT))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1799</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1799</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1800</td>
    <td class="codeLine">  if (auto *CV = dyn_cast<SCEVConstant>(CT))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1800</td>
    <td class="codeLine">  if (auto *CV = dyn_cast<SCEVConstant>(CT))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1801</td>
    <td class="codeLine">    IterCount = CV->getValue()->getZExtValue() + 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1801</td>
    <td class="codeLine">    IterCount = CV->getValue()->getZExtValue() + 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1802</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1802</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1803</td>
    <td class="codeLine">  Value *CIV = getCountIV(LoopB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1803</td>
    <td class="codeLine">  Value *CIV = getCountIV(LoopB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1804</td>
    <td class="codeLine">  ParsedValues PV;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1804</td>
    <td class="codeLine">  ParsedValues PV;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1805</td>
    <td class="codeLine">  Simplifier PreSimp;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1805</td>
    <td class="codeLine">  Simplifier PreSimp;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1806</td>
    <td class="codeLine">  PV.IterCount = IterCount;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1806</td>
    <td class="codeLine">  PV.IterCount = IterCount;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1807</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "Loop IV: " << *CIV << "\nIterCount: " << IterCount</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1807</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "Loop IV: " << *CIV << "\nIterCount: " << IterCount</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1808</td>
    <td class="codeLine">                    << '\n');</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1808</td>
    <td class="codeLine">                    << '\n');</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1809</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1809</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1810</td>
    <td class="codeLine">  setupPreSimplifier(PreSimp);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1810</td>
    <td class="codeLine">  setupPreSimplifier(PreSimp);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1811</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1811</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1812</td>
    <td class="codeLine">  // Perform a preliminary scan of select instructions to see if any of them</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1812</td>
    <td class="codeLine">  // Perform a preliminary scan of select instructions to see if any of them</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1813</td>
    <td class="codeLine">  // looks like a generator of the polynomial multiply steps. Assume that a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1813</td>
    <td class="codeLine">  // looks like a generator of the polynomial multiply steps. Assume that a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1814</td>
    <td class="codeLine">  // loop can only contain a single transformable operation, so stop the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1814</td>
    <td class="codeLine">  // loop can only contain a single transformable operation, so stop the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1815</td>
    <td class="codeLine">  // traversal after the first reasonable candidate was found.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1815</td>
    <td class="codeLine">  // traversal after the first reasonable candidate was found.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1816</td>
    <td class="codeLine">  // XXX: Currently this approach can modify the loop before being 100% sure</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1816</td>
    <td class="codeLine">  // XXX: Currently this approach can modify the loop before being 100% sure</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1817</td>
    <td class="codeLine">  // that the transformation can be carried out.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1817</td>
    <td class="codeLine">  // that the transformation can be carried out.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1818</td>
    <td class="codeLine">  bool FoundPreScan = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1818</td>
    <td class="codeLine">  bool FoundPreScan = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1819</td>
    <td class="codeLine">  auto FeedsPHI = [LoopB](const Value *V) -> bool {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1819</td>
    <td class="codeLine">  auto FeedsPHI = [LoopB](const Value *V) -> bool {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1820</td>
    <td class="codeLine">    for (const Value *U : V->users()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1820</td>
    <td class="codeLine">    for (const Value *U : V->users()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1821</td>
    <td class="codeLine">      if (const auto *P = dyn_cast<const PHINode>(U))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1821</td>
    <td class="codeLine">      if (const auto *P = dyn_cast<const PHINode>(U))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1822</td>
    <td class="codeLine">        if (P->getParent() == LoopB)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1822</td>
    <td class="codeLine">        if (P->getParent() == LoopB)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1823</td>
    <td class="codeLine">          return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1823</td>
    <td class="codeLine">          return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1824</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1824</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1825</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1825</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1826</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1826</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1827</td>
    <td class="codeLine">  for (Instruction &In : *LoopB) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1827</td>
    <td class="codeLine">  for (Instruction &In : *LoopB) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1828</td>
    <td class="codeLine">    SelectInst *SI = dyn_cast<SelectInst>(&In);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1828</td>
    <td class="codeLine">    SelectInst *SI = dyn_cast<SelectInst>(&In);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1829</td>
    <td class="codeLine">    if (!SI || !FeedsPHI(SI))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1829</td>
    <td class="codeLine">    if (!SI || !FeedsPHI(SI))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1830</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1830</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1831</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1831</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1832</td>
    <td class="codeLine">    Simplifier::Context C(SI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1832</td>
    <td class="codeLine">    Simplifier::Context C(SI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1833</td>
    <td class="codeLine">    Value *T = PreSimp.simplify(C);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1833</td>
    <td class="codeLine">    Value *T = PreSimp.simplify(C);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1834</td>
    <td class="codeLine">    SelectInst *SelI = (T && isa<SelectInst>(T)) ? cast<SelectInst>(T) : SI;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1834</td>
    <td class="codeLine">    SelectInst *SelI = (T && isa<SelectInst>(T)) ? cast<SelectInst>(T) : SI;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1835</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "scanSelect(pre-scan): " << PE(C, SelI) << '\n');</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1835</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "scanSelect(pre-scan): " << PE(C, SelI) << '\n');</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1836</td>
    <td class="codeLine">    if (scanSelect(SelI, LoopB, EntryB, CIV, PV, true)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1836</td>
    <td class="codeLine">    if (scanSelect(SelI, LoopB, EntryB, CIV, PV, true)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1837</td>
    <td class="codeLine">      FoundPreScan = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1837</td>
    <td class="codeLine">      FoundPreScan = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1838</td>
    <td class="codeLine">      if (SelI != SI) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1838</td>
    <td class="codeLine">      if (SelI != SI) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1839</td>
    <td class="codeLine">        Value *NewSel = C.materialize(LoopB, SI->getIterator());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1839</td>
    <td class="codeLine">        Value *NewSel = C.materialize(LoopB, SI->getIterator());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1840</td>
    <td class="codeLine">        SI->replaceAllUsesWith(NewSel);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1840</td>
    <td class="codeLine">        SI->replaceAllUsesWith(NewSel);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1841</td>
    <td class="codeLine">        RecursivelyDeleteTriviallyDeadInstructions(SI, &TLI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1841</td>
    <td class="codeLine">        RecursivelyDeleteTriviallyDeadInstructions(SI, &TLI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1842</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1842</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1843</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1843</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1844</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1844</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1845</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1845</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1846</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1846</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1847</td>
    <td class="codeLine">  if (!FoundPreScan) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1847</td>
    <td class="codeLine">  if (!FoundPreScan) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1848</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "Have not found candidates for pmpy\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1848</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "Have not found candidates for pmpy\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1849</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1849</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1850</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1850</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1851</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1851</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1852</td>
    <td class="codeLine">  if (!PV.Left) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1852</td>
    <td class="codeLine">  if (!PV.Left) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1853</td>
    <td class="codeLine">    // The right shift version actually only returns the higher bits of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1853</td>
    <td class="codeLine">    // The right shift version actually only returns the higher bits of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1854</td>
    <td class="codeLine">    // the result (each iteration discards the LSB). If we want to convert it</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1854</td>
    <td class="codeLine">    // the result (each iteration discards the LSB). If we want to convert it</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1855</td>
    <td class="codeLine">    // to a left-shifting loop, the working data type must be at least as</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1855</td>
    <td class="codeLine">    // to a left-shifting loop, the working data type must be at least as</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1856</td>
    <td class="codeLine">    // wide as the target's pmpy instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1856</td>
    <td class="codeLine">    // wide as the target's pmpy instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1857</td>
    <td class="codeLine">    if (!promoteTypes(LoopB, ExitB))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1857</td>
    <td class="codeLine">    if (!promoteTypes(LoopB, ExitB))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1858</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1858</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1859</td>
    <td class="codeLine">    // Run post-promotion simplifications.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1859</td>
    <td class="codeLine">    // Run post-promotion simplifications.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1860</td>
    <td class="codeLine">    Simplifier PostSimp;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1860</td>
    <td class="codeLine">    Simplifier PostSimp;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1861</td>
    <td class="codeLine">    setupPostSimplifier(PostSimp);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1861</td>
    <td class="codeLine">    setupPostSimplifier(PostSimp);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1862</td>
    <td class="codeLine">    for (Instruction &In : *LoopB) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1862</td>
    <td class="codeLine">    for (Instruction &In : *LoopB) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1863</td>
    <td class="codeLine">      SelectInst *SI = dyn_cast<SelectInst>(&In);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1863</td>
    <td class="codeLine">      SelectInst *SI = dyn_cast<SelectInst>(&In);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1864</td>
    <td class="codeLine">      if (!SI || !FeedsPHI(SI))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1864</td>
    <td class="codeLine">      if (!SI || !FeedsPHI(SI))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1865</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1865</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1866</td>
    <td class="codeLine">      Simplifier::Context C(SI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1866</td>
    <td class="codeLine">      Simplifier::Context C(SI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1867</td>
    <td class="codeLine">      Value *T = PostSimp.simplify(C);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1867</td>
    <td class="codeLine">      Value *T = PostSimp.simplify(C);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1868</td>
    <td class="codeLine">      SelectInst *SelI = dyn_cast_or_null<SelectInst>(T);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1868</td>
    <td class="codeLine">      SelectInst *SelI = dyn_cast_or_null<SelectInst>(T);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1869</td>
    <td class="codeLine">      if (SelI != SI) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1869</td>
    <td class="codeLine">      if (SelI != SI) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1870</td>
    <td class="codeLine">        Value *NewSel = C.materialize(LoopB, SI->getIterator());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1870</td>
    <td class="codeLine">        Value *NewSel = C.materialize(LoopB, SI->getIterator());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1871</td>
    <td class="codeLine">        SI->replaceAllUsesWith(NewSel);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1871</td>
    <td class="codeLine">        SI->replaceAllUsesWith(NewSel);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1872</td>
    <td class="codeLine">        RecursivelyDeleteTriviallyDeadInstructions(SI, &TLI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1872</td>
    <td class="codeLine">        RecursivelyDeleteTriviallyDeadInstructions(SI, &TLI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1873</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1873</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1874</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1874</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1875</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1875</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1876</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1876</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1877</td>
    <td class="codeLine">    if (!convertShiftsToLeft(LoopB, ExitB, IterCount))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1877</td>
    <td class="codeLine">    if (!convertShiftsToLeft(LoopB, ExitB, IterCount))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1878</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1878</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1879</td>
    <td class="codeLine">    cleanupLoopBody(LoopB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1879</td>
    <td class="codeLine">    cleanupLoopBody(LoopB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1880</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1880</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1881</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1881</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1882</td>
    <td class="codeLine">  // Scan the loop again, find the generating select instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1882</td>
    <td class="codeLine">  // Scan the loop again, find the generating select instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1883</td>
    <td class="codeLine">  bool FoundScan = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1883</td>
    <td class="codeLine">  bool FoundScan = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1884</td>
    <td class="codeLine">  for (Instruction &In : *LoopB) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1884</td>
    <td class="codeLine">  for (Instruction &In : *LoopB) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1885</td>
    <td class="codeLine">    SelectInst *SelI = dyn_cast<SelectInst>(&In);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1885</td>
    <td class="codeLine">    SelectInst *SelI = dyn_cast<SelectInst>(&In);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1886</td>
    <td class="codeLine">    if (!SelI)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1886</td>
    <td class="codeLine">    if (!SelI)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1887</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1887</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1888</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "scanSelect: " << *SelI << '\n');</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1888</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "scanSelect: " << *SelI << '\n');</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1889</td>
    <td class="codeLine">    FoundScan = scanSelect(SelI, LoopB, EntryB, CIV, PV, false);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1889</td>
    <td class="codeLine">    FoundScan = scanSelect(SelI, LoopB, EntryB, CIV, PV, false);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1890</td>
    <td class="codeLine">    if (FoundScan)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1890</td>
    <td class="codeLine">    if (FoundScan)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1891</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1891</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1892</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1892</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1893</td>
    <td class="codeLine">  assert(FoundScan);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1893</td>
    <td class="codeLine">  assert(FoundScan);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1894</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1894</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1895</td>
    <td class="codeLine">  LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1895</td>
    <td class="codeLine">  LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1896</td>
    <td class="codeLine">    StringRef PP = (PV.M ? "(P+M)" : "P");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1896</td>
    <td class="codeLine">    StringRef PP = (PV.M ? "(P+M)" : "P");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1897</td>
    <td class="codeLine">    if (!PV.Inv)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1897</td>
    <td class="codeLine">    if (!PV.Inv)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1898</td>
    <td class="codeLine">      dbgs() << "Found pmpy idiom: R = " << PP << ".Q\n";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1898</td>
    <td class="codeLine">      dbgs() << "Found pmpy idiom: R = " << PP << ".Q\n";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1899</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1899</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1900</td>
    <td class="codeLine">      dbgs() << "Found inverse pmpy idiom: R = (" << PP << "/Q).Q) + "</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1900</td>
    <td class="codeLine">      dbgs() << "Found inverse pmpy idiom: R = (" << PP << "/Q).Q) + "</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1901</td>
    <td class="codeLine">             << PP << "\n";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1901</td>
    <td class="codeLine">             << PP << "\n";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1902</td>
    <td class="codeLine">    dbgs() << "  Res:" << *PV.Res << "\n  P:" << *PV.P << "\n";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1902</td>
    <td class="codeLine">    dbgs() << "  Res:" << *PV.Res << "\n  P:" << *PV.P << "\n";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1903</td>
    <td class="codeLine">    if (PV.M)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1903</td>
    <td class="codeLine">    if (PV.M)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1904</td>
    <td class="codeLine">      dbgs() << "  M:" << *PV.M << "\n";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1904</td>
    <td class="codeLine">      dbgs() << "  M:" << *PV.M << "\n";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1905</td>
    <td class="codeLine">    dbgs() << "  Q:" << *PV.Q << "\n";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1905</td>
    <td class="codeLine">    dbgs() << "  Q:" << *PV.Q << "\n";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1906</td>
    <td class="codeLine">    dbgs() << "  Iteration count:" << PV.IterCount << "\n";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1906</td>
    <td class="codeLine">    dbgs() << "  Iteration count:" << PV.IterCount << "\n";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1907</td>
    <td class="codeLine">  });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1907</td>
    <td class="codeLine">  });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1908</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1908</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1909</td>
    <td class="codeLine">  BasicBlock::iterator At(EntryB->getTerminator());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1909</td>
    <td class="codeLine">  BasicBlock::iterator At(EntryB->getTerminator());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1910</td>
    <td class="codeLine">  Value *PM = generate(At, PV);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1910</td>
    <td class="codeLine">  Value *PM = generate(At, PV);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1911</td>
    <td class="codeLine">  if (PM == nullptr)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1911</td>
    <td class="codeLine">  if (PM == nullptr)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1912</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1912</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1913</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1913</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1914</td>
    <td class="codeLine">  if (PM->getType() != PV.Res->getType())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1914</td>
    <td class="codeLine">  if (PM->getType() != PV.Res->getType())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1915</td>
    <td class="codeLine">    PM = IRBuilder<>(&*At).CreateIntCast(PM, PV.Res->getType(), false);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1915</td>
    <td class="codeLine">    PM = IRBuilder<>(&*At).CreateIntCast(PM, PV.Res->getType(), false);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1916</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1916</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1917</td>
    <td class="codeLine">  PV.Res->replaceAllUsesWith(PM);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1917</td>
    <td class="codeLine">  PV.Res->replaceAllUsesWith(PM);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1918</td>
    <td class="codeLine">  PV.Res->eraseFromParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1918</td>
    <td class="codeLine">  PV.Res->eraseFromParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1919</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1919</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1920</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1920</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1921</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1921</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1922</td>
    <td class="codeLine">int HexagonLoopIdiomRecognize::getSCEVStride(const SCEVAddRecExpr *S) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1922</td>
    <td class="codeLine">int HexagonLoopIdiomRecognize::getSCEVStride(const SCEVAddRecExpr *S) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1923</td>
    <td class="codeLine">  if (const SCEVConstant *SC = dyn_cast<SCEVConstant>(S->getOperand(1)))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1923</td>
    <td class="codeLine">  if (const SCEVConstant *SC = dyn_cast<SCEVConstant>(S->getOperand(1)))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1924</td>
    <td class="codeLine">    return SC->getAPInt().getSExtValue();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1924</td>
    <td class="codeLine">    return SC->getAPInt().getSExtValue();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1925</td>
    <td class="codeLine">  return 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1925</td>
    <td class="codeLine">  return 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1926</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1926</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1927</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1927</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1928</td>
    <td class="codeLine">bool HexagonLoopIdiomRecognize::isLegalStore(Loop *CurLoop, StoreInst *SI) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1928</td>
    <td class="codeLine">bool HexagonLoopIdiomRecognize::isLegalStore(Loop *CurLoop, StoreInst *SI) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1929</td>
    <td class="codeLine">  // Allow volatile stores if HexagonVolatileMemcpy is enabled.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1929</td>
    <td class="codeLine">  // Allow volatile stores if HexagonVolatileMemcpy is enabled.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1930</td>
    <td class="codeLine">  if (!(SI->isVolatile() && HexagonVolatileMemcpy) && !SI->isSimple())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1930</td>
    <td class="codeLine">  if (!(SI->isVolatile() && HexagonVolatileMemcpy) && !SI->isSimple())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1931</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1931</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1932</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1932</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1933</td>
    <td class="codeLine">  Value *StoredVal = SI->getValueOperand();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1933</td>
    <td class="codeLine">  Value *StoredVal = SI->getValueOperand();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1934</td>
    <td class="codeLine">  Value *StorePtr = SI->getPointerOperand();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1934</td>
    <td class="codeLine">  Value *StorePtr = SI->getPointerOperand();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1935</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1935</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1936</td>
    <td class="codeLine">  // Reject stores that are so large that they overflow an unsigned.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1936</td>
    <td class="codeLine">  // Reject stores that are so large that they overflow an unsigned.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1937</td>
    <td class="codeLine">  uint64_t SizeInBits = DL->getTypeSizeInBits(StoredVal->getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1937</td>
    <td class="codeLine">  uint64_t SizeInBits = DL->getTypeSizeInBits(StoredVal->getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1938</td>
    <td class="codeLine">  if ((SizeInBits & 7) || (SizeInBits >> 32) != 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1938</td>
    <td class="codeLine">  if ((SizeInBits & 7) || (SizeInBits >> 32) != 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1939</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1939</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1940</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1940</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1941</td>
    <td class="codeLine">  // See if the pointer expression is an AddRec like {base,+,1} on the current</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1941</td>
    <td class="codeLine">  // See if the pointer expression is an AddRec like {base,+,1} on the current</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1942</td>
    <td class="codeLine">  // loop, which indicates a strided store.  If we have something else, it's a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1942</td>
    <td class="codeLine">  // loop, which indicates a strided store.  If we have something else, it's a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1943</td>
    <td class="codeLine">  // random store we can't handle.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1943</td>
    <td class="codeLine">  // random store we can't handle.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1944</td>
    <td class="codeLine">  auto *StoreEv = dyn_cast<SCEVAddRecExpr>(SE->getSCEV(StorePtr));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1944</td>
    <td class="codeLine">  auto *StoreEv = dyn_cast<SCEVAddRecExpr>(SE->getSCEV(StorePtr));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1945</td>
    <td class="codeLine">  if (!StoreEv || StoreEv->getLoop() != CurLoop || !StoreEv->isAffine())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1945</td>
    <td class="codeLine">  if (!StoreEv || StoreEv->getLoop() != CurLoop || !StoreEv->isAffine())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1946</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1946</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1947</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1947</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1948</td>
    <td class="codeLine">  // Check to see if the stride matches the size of the store.  If so, then we</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1948</td>
    <td class="codeLine">  // Check to see if the stride matches the size of the store.  If so, then we</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1949</td>
    <td class="codeLine">  // know that every byte is touched in the loop.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1949</td>
    <td class="codeLine">  // know that every byte is touched in the loop.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1950</td>
    <td class="codeLine">  int Stride = getSCEVStride(StoreEv);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1950</td>
    <td class="codeLine">  int Stride = getSCEVStride(StoreEv);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1951</td>
    <td class="codeLine">  if (Stride == 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1951</td>
    <td class="codeLine">  if (Stride == 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1952</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1952</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1953</td>
    <td class="codeLine">  unsigned StoreSize = DL->getTypeStoreSize(SI->getValueOperand()->getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1953</td>
    <td class="codeLine">  unsigned StoreSize = DL->getTypeStoreSize(SI->getValueOperand()->getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1954</td>
    <td class="codeLine">  if (StoreSize != unsigned(std::abs(Stride)))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1954</td>
    <td class="codeLine">  if (StoreSize != unsigned(std::abs(Stride)))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1955</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1955</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1956</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1956</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1957</td>
    <td class="codeLine">  // The store must be feeding a non-volatile load.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1957</td>
    <td class="codeLine">  // The store must be feeding a non-volatile load.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1958</td>
    <td class="codeLine">  LoadInst *LI = dyn_cast<LoadInst>(SI->getValueOperand());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1958</td>
    <td class="codeLine">  LoadInst *LI = dyn_cast<LoadInst>(SI->getValueOperand());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1959</td>
    <td class="codeLine">  if (!LI || !LI->isSimple())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1959</td>
    <td class="codeLine">  if (!LI || !LI->isSimple())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1960</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1960</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1961</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1961</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1962</td>
    <td class="codeLine">  // See if the pointer expression is an AddRec like {base,+,1} on the current</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1962</td>
    <td class="codeLine">  // See if the pointer expression is an AddRec like {base,+,1} on the current</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1963</td>
    <td class="codeLine">  // loop, which indicates a strided load.  If we have something else, it's a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1963</td>
    <td class="codeLine">  // loop, which indicates a strided load.  If we have something else, it's a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1964</td>
    <td class="codeLine">  // random load we can't handle.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1964</td>
    <td class="codeLine">  // random load we can't handle.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1965</td>
    <td class="codeLine">  Value *LoadPtr = LI->getPointerOperand();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1965</td>
    <td class="codeLine">  Value *LoadPtr = LI->getPointerOperand();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1966</td>
    <td class="codeLine">  auto *LoadEv = dyn_cast<SCEVAddRecExpr>(SE->getSCEV(LoadPtr));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1966</td>
    <td class="codeLine">  auto *LoadEv = dyn_cast<SCEVAddRecExpr>(SE->getSCEV(LoadPtr));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1967</td>
    <td class="codeLine">  if (!LoadEv || LoadEv->getLoop() != CurLoop || !LoadEv->isAffine())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1967</td>
    <td class="codeLine">  if (!LoadEv || LoadEv->getLoop() != CurLoop || !LoadEv->isAffine())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1968</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1968</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1969</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1969</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1970</td>
    <td class="codeLine">  // The store and load must share the same stride.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1970</td>
    <td class="codeLine">  // The store and load must share the same stride.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1971</td>
    <td class="codeLine">  if (StoreEv->getOperand(1) != LoadEv->getOperand(1))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1971</td>
    <td class="codeLine">  if (StoreEv->getOperand(1) != LoadEv->getOperand(1))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1972</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1972</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1973</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1973</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1974</td>
    <td class="codeLine">  // Success.  This store can be converted into a memcpy.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1974</td>
    <td class="codeLine">  // Success.  This store can be converted into a memcpy.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1975</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1975</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1976</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1976</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1977</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1977</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1978</td>
    <td class="codeLine">/// mayLoopAccessLocation - Return true if the specified loop might access the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1978</td>
    <td class="codeLine">/// mayLoopAccessLocation - Return true if the specified loop might access the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1979</td>
    <td class="codeLine">/// specified pointer location, which is a loop-strided access.  The 'Access'</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1979</td>
    <td class="codeLine">/// specified pointer location, which is a loop-strided access.  The 'Access'</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1980</td>
    <td class="codeLine">/// argument specifies what the verboten forms of access are (read or write).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1980</td>
    <td class="codeLine">/// argument specifies what the verboten forms of access are (read or write).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1981</td>
    <td class="codeLine">static bool</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1981</td>
    <td class="codeLine">static bool</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1982</td>
    <td class="codeLine">mayLoopAccessLocation(Value *Ptr, ModRefInfo Access, Loop *L,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1982</td>
    <td class="codeLine">mayLoopAccessLocation(Value *Ptr, ModRefInfo Access, Loop *L,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1983</td>
    <td class="codeLine">                      const SCEV *BECount, unsigned StoreSize,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1983</td>
    <td class="codeLine">                      const SCEV *BECount, unsigned StoreSize,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1984</td>
    <td class="codeLine">                      AliasAnalysis &AA,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1984</td>
    <td class="codeLine">                      AliasAnalysis &AA,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1985</td>
    <td class="codeLine">                      SmallPtrSetImpl<Instruction *> &Ignored) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1985</td>
    <td class="codeLine">                      SmallPtrSetImpl<Instruction *> &Ignored) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1986</td>
    <td class="codeLine">  // Get the location that may be stored across the loop.  Since the access</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1986</td>
    <td class="codeLine">  // Get the location that may be stored across the loop.  Since the access</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1987</td>
    <td class="codeLine">  // is strided positively through memory, we say that the modified location</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1987</td>
    <td class="codeLine">  // is strided positively through memory, we say that the modified location</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1988</td>
    <td class="codeLine">  // starts at the pointer and has infinite size.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1988</td>
    <td class="codeLine">  // starts at the pointer and has infinite size.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1989</td>
    <td class="codeLine">  LocationSize AccessSize = LocationSize::afterPointer();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1989</td>
    <td class="codeLine">  LocationSize AccessSize = LocationSize::afterPointer();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1990</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1990</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1991</td>
    <td class="codeLine">  // If the loop iterates a fixed number of times, we can refine the access</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1991</td>
    <td class="codeLine">  // If the loop iterates a fixed number of times, we can refine the access</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1992</td>
    <td class="codeLine">  // size to be exactly the size of the memset, which is (BECount+1)*StoreSize</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1992</td>
    <td class="codeLine">  // size to be exactly the size of the memset, which is (BECount+1)*StoreSize</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1993</td>
    <td class="codeLine">  if (const SCEVConstant *BECst = dyn_cast<SCEVConstant>(BECount))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1993</td>
    <td class="codeLine">  if (const SCEVConstant *BECst = dyn_cast<SCEVConstant>(BECount))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1994</td>
    <td class="codeLine">    AccessSize = LocationSize::precise((BECst->getValue()->getZExtValue() + 1) *</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1994</td>
    <td class="codeLine">    AccessSize = LocationSize::precise((BECst->getValue()->getZExtValue() + 1) *</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1995</td>
    <td class="codeLine">                                       StoreSize);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1995</td>
    <td class="codeLine">                                       StoreSize);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1996</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1996</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1997</td>
    <td class="codeLine">  // TODO: For this to be really effective, we have to dive into the pointer</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1997</td>
    <td class="codeLine">  // TODO: For this to be really effective, we have to dive into the pointer</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1998</td>
    <td class="codeLine">  // operand in the store.  Store to &A[i] of 100 will always return may alias</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1998</td>
    <td class="codeLine">  // operand in the store.  Store to &A[i] of 100 will always return may alias</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1999</td>
    <td class="codeLine">  // with store of &A[100], we need to StoreLoc to be "A" with size of 100,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1999</td>
    <td class="codeLine">  // with store of &A[100], we need to StoreLoc to be "A" with size of 100,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2000</td>
    <td class="codeLine">  // which will then no-alias a store to &A[100].</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2000</td>
    <td class="codeLine">  // which will then no-alias a store to &A[100].</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2001</td>
    <td class="codeLine">  MemoryLocation StoreLoc(Ptr, AccessSize);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2001</td>
    <td class="codeLine">  MemoryLocation StoreLoc(Ptr, AccessSize);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2002</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2002</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2003</td>
    <td class="codeLine">  for (auto *B : L->blocks())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2003</td>
    <td class="codeLine">  for (auto *B : L->blocks())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2004</td>
    <td class="codeLine">    for (auto &I : *B)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2004</td>
    <td class="codeLine">    for (auto &I : *B)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2005</td>
    <td class="codeLine">      if (Ignored.count(&I) == 0 &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2005</td>
    <td class="codeLine">      if (Ignored.count(&I) == 0 &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2006</td>
    <td class="codeLine">          isModOrRefSet(AA.getModRefInfo(&I, StoreLoc) & Access))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2006</td>
    <td class="codeLine">          isModOrRefSet(AA.getModRefInfo(&I, StoreLoc) & Access))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2007</td>
    <td class="codeLine">        return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2007</td>
    <td class="codeLine">        return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2008</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2008</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2009</td>
    <td class="codeLine">  return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2009</td>
    <td class="codeLine">  return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2010</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2010</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2011</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2011</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2012</td>
    <td class="codeLine">void HexagonLoopIdiomRecognize::collectStores(Loop *CurLoop, BasicBlock *BB,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2012</td>
    <td class="codeLine">void HexagonLoopIdiomRecognize::collectStores(Loop *CurLoop, BasicBlock *BB,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2013</td>
    <td class="codeLine">      SmallVectorImpl<StoreInst*> &Stores) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2013</td>
    <td class="codeLine">      SmallVectorImpl<StoreInst*> &Stores) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2014</td>
    <td class="codeLine">  Stores.clear();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2014</td>
    <td class="codeLine">  Stores.clear();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2015</td>
    <td class="codeLine">  for (Instruction &I : *BB)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2015</td>
    <td class="codeLine">  for (Instruction &I : *BB)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2016</td>
    <td class="codeLine">    if (StoreInst *SI = dyn_cast<StoreInst>(&I))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2016</td>
    <td class="codeLine">    if (StoreInst *SI = dyn_cast<StoreInst>(&I))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2017</td>
    <td class="codeLine">      if (isLegalStore(CurLoop, SI))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2017</td>
    <td class="codeLine">      if (isLegalStore(CurLoop, SI))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2018</td>
    <td class="codeLine">        Stores.push_back(SI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2018</td>
    <td class="codeLine">        Stores.push_back(SI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2019</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2019</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2020</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2020</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2021</td>
    <td class="codeLine">bool HexagonLoopIdiomRecognize::processCopyingStore(Loop *CurLoop,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2021</td>
    <td class="codeLine">bool HexagonLoopIdiomRecognize::processCopyingStore(Loop *CurLoop,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2022</td>
    <td class="codeLine">      StoreInst *SI, const SCEV *BECount) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2022</td>
    <td class="codeLine">      StoreInst *SI, const SCEV *BECount) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2023</td>
    <td class="codeLine">  assert((SI->isSimple() || (SI->isVolatile() && HexagonVolatileMemcpy)) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2023</td>
    <td class="codeLine">  assert((SI->isSimple() || (SI->isVolatile() && HexagonVolatileMemcpy)) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2024</td>
    <td class="codeLine">         "Expected only non-volatile stores, or Hexagon-specific memcpy"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2024</td>
    <td class="codeLine">         "Expected only non-volatile stores, or Hexagon-specific memcpy"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2025</td>
    <td class="codeLine">         "to volatile destination.");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2025</td>
    <td class="codeLine">         "to volatile destination.");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2026</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2026</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2027</td>
    <td class="codeLine">  Value *StorePtr = SI->getPointerOperand();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2027</td>
    <td class="codeLine">  Value *StorePtr = SI->getPointerOperand();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2028</td>
    <td class="codeLine">  auto *StoreEv = cast<SCEVAddRecExpr>(SE->getSCEV(StorePtr));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2028</td>
    <td class="codeLine">  auto *StoreEv = cast<SCEVAddRecExpr>(SE->getSCEV(StorePtr));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2029</td>
    <td class="codeLine">  unsigned Stride = getSCEVStride(StoreEv);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2029</td>
    <td class="codeLine">  unsigned Stride = getSCEVStride(StoreEv);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2030</td>
    <td class="codeLine">  unsigned StoreSize = DL->getTypeStoreSize(SI->getValueOperand()->getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2030</td>
    <td class="codeLine">  unsigned StoreSize = DL->getTypeStoreSize(SI->getValueOperand()->getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2031</td>
    <td class="codeLine">  if (Stride != StoreSize)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2031</td>
    <td class="codeLine">  if (Stride != StoreSize)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2032</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2032</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2033</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2033</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2034</td>
    <td class="codeLine">  // See if the pointer expression is an AddRec like {base,+,1} on the current</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2034</td>
    <td class="codeLine">  // See if the pointer expression is an AddRec like {base,+,1} on the current</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2035</td>
    <td class="codeLine">  // loop, which indicates a strided load.  If we have something else, it's a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2035</td>
    <td class="codeLine">  // loop, which indicates a strided load.  If we have something else, it's a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2036</td>
    <td class="codeLine">  // random load we can't handle.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2036</td>
    <td class="codeLine">  // random load we can't handle.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2037</td>
    <td class="codeLine">  auto *LI = cast<LoadInst>(SI->getValueOperand());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2037</td>
    <td class="codeLine">  auto *LI = cast<LoadInst>(SI->getValueOperand());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2038</td>
    <td class="codeLine">  auto *LoadEv = cast<SCEVAddRecExpr>(SE->getSCEV(LI->getPointerOperand()));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2038</td>
    <td class="codeLine">  auto *LoadEv = cast<SCEVAddRecExpr>(SE->getSCEV(LI->getPointerOperand()));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2039</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2039</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2040</td>
    <td class="codeLine">  // The trip count of the loop and the base pointer of the addrec SCEV is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2040</td>
    <td class="codeLine">  // The trip count of the loop and the base pointer of the addrec SCEV is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2041</td>
    <td class="codeLine">  // guaranteed to be loop invariant, which means that it should dominate the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2041</td>
    <td class="codeLine">  // guaranteed to be loop invariant, which means that it should dominate the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2042</td>
    <td class="codeLine">  // header.  This allows us to insert code for it in the preheader.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2042</td>
    <td class="codeLine">  // header.  This allows us to insert code for it in the preheader.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2043</td>
    <td class="codeLine">  BasicBlock *Preheader = CurLoop->getLoopPreheader();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2043</td>
    <td class="codeLine">  BasicBlock *Preheader = CurLoop->getLoopPreheader();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2044</td>
    <td class="codeLine">  Instruction *ExpPt = Preheader->getTerminator();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2044</td>
    <td class="codeLine">  Instruction *ExpPt = Preheader->getTerminator();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2045</td>
    <td class="codeLine">  IRBuilder<> Builder(ExpPt);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2045</td>
    <td class="codeLine">  IRBuilder<> Builder(ExpPt);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2046</td>
    <td class="codeLine">  SCEVExpander Expander(*SE, *DL, "hexagon-loop-idiom");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2046</td>
    <td class="codeLine">  SCEVExpander Expander(*SE, *DL, "hexagon-loop-idiom");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2047</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2047</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2048</td>
    <td class="codeLine">  Type *IntPtrTy = Builder.getIntPtrTy(*DL, SI->getPointerAddressSpace());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2048</td>
    <td class="codeLine">  Type *IntPtrTy = Builder.getIntPtrTy(*DL, SI->getPointerAddressSpace());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2049</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2049</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2050</td>
    <td class="codeLine">  // Okay, we have a strided store "p[i]" of a loaded value.  We can turn</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2050</td>
    <td class="codeLine">  // Okay, we have a strided store "p[i]" of a loaded value.  We can turn</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2051</td>
    <td class="codeLine">  // this into a memcpy/memmove in the loop preheader now if we want.  However,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2051</td>
    <td class="codeLine">  // this into a memcpy/memmove in the loop preheader now if we want.  However,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2052</td>
    <td class="codeLine">  // this would be unsafe to do if there is anything else in the loop that may</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2052</td>
    <td class="codeLine">  // this would be unsafe to do if there is anything else in the loop that may</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2053</td>
    <td class="codeLine">  // read or write the memory region we're storing to.  For memcpy, this</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2053</td>
    <td class="codeLine">  // read or write the memory region we're storing to.  For memcpy, this</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2054</td>
    <td class="codeLine">  // includes the load that feeds the stores.  Check for an alias by generating</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2054</td>
    <td class="codeLine">  // includes the load that feeds the stores.  Check for an alias by generating</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2055</td>
    <td class="codeLine">  // the base address and checking everything.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2055</td>
    <td class="codeLine">  // the base address and checking everything.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2056</td>
    <td class="codeLine">  Value *StoreBasePtr = Expander.expandCodeFor(StoreEv->getStart(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2056</td>
    <td class="codeLine">  Value *StoreBasePtr = Expander.expandCodeFor(StoreEv->getStart(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2057</td>
    <td class="codeLine">      Builder.getInt8PtrTy(SI->getPointerAddressSpace()), ExpPt);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2057</td>
    <td class="codeLine">      Builder.getInt8PtrTy(SI->getPointerAddressSpace()), ExpPt);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2058</td>
    <td class="codeLine">  Value *LoadBasePtr = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2058</td>
    <td class="codeLine">  Value *LoadBasePtr = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2059</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2059</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2060</td>
    <td class="codeLine">  bool Overlap = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2060</td>
    <td class="codeLine">  bool Overlap = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2061</td>
    <td class="codeLine">  bool DestVolatile = SI->isVolatile();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2061</td>
    <td class="codeLine">  bool DestVolatile = SI->isVolatile();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2062</td>
    <td class="codeLine">  Type *BECountTy = BECount->getType();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2062</td>
    <td class="codeLine">  Type *BECountTy = BECount->getType();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2063</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2063</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2064</td>
    <td class="codeLine">  if (DestVolatile) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2064</td>
    <td class="codeLine">  if (DestVolatile) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2065</td>
    <td class="codeLine">    // The trip count must fit in i32, since it is the type of the "num_words"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2065</td>
    <td class="codeLine">    // The trip count must fit in i32, since it is the type of the "num_words"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2066</td>
    <td class="codeLine">    // argument to hexagon_memcpy_forward_vp4cp4n2.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2066</td>
    <td class="codeLine">    // argument to hexagon_memcpy_forward_vp4cp4n2.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2067</td>
    <td class="codeLine">    if (StoreSize != 4 || DL->getTypeSizeInBits(BECountTy) > 32) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2067</td>
    <td class="codeLine">    if (StoreSize != 4 || DL->getTypeSizeInBits(BECountTy) > 32) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2068</td>
    <td class="codeLine">CleanupAndExit:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2068</td>
    <td class="codeLine">CleanupAndExit:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2069</td>
    <td class="codeLine">      // If we generated new code for the base pointer, clean up.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2069</td>
    <td class="codeLine">      // If we generated new code for the base pointer, clean up.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2070</td>
    <td class="codeLine">      Expander.clear();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2070</td>
    <td class="codeLine">      Expander.clear();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2071</td>
    <td class="codeLine">      if (StoreBasePtr && (LoadBasePtr != StoreBasePtr)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2071</td>
    <td class="codeLine">      if (StoreBasePtr && (LoadBasePtr != StoreBasePtr)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2072</td>
    <td class="codeLine">        RecursivelyDeleteTriviallyDeadInstructions(StoreBasePtr, TLI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2072</td>
    <td class="codeLine">        RecursivelyDeleteTriviallyDeadInstructions(StoreBasePtr, TLI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2073</td>
    <td class="codeLine">        StoreBasePtr = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2073</td>
    <td class="codeLine">        StoreBasePtr = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2074</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2074</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2075</td>
    <td class="codeLine">      if (LoadBasePtr) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2075</td>
    <td class="codeLine">      if (LoadBasePtr) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2076</td>
    <td class="codeLine">        RecursivelyDeleteTriviallyDeadInstructions(LoadBasePtr, TLI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2076</td>
    <td class="codeLine">        RecursivelyDeleteTriviallyDeadInstructions(LoadBasePtr, TLI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2077</td>
    <td class="codeLine">        LoadBasePtr = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2077</td>
    <td class="codeLine">        LoadBasePtr = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2078</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2078</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2079</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2079</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2080</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2080</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2081</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2081</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2082</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2082</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2083</td>
    <td class="codeLine">  SmallPtrSet<Instruction*, 2> Ignore1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2083</td>
    <td class="codeLine">  SmallPtrSet<Instruction*, 2> Ignore1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2084</td>
    <td class="codeLine">  Ignore1.insert(SI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2084</td>
    <td class="codeLine">  Ignore1.insert(SI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2085</td>
    <td class="codeLine">  if (mayLoopAccessLocation(StoreBasePtr, ModRefInfo::ModRef, CurLoop, BECount,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2085</td>
    <td class="codeLine">  if (mayLoopAccessLocation(StoreBasePtr, ModRefInfo::ModRef, CurLoop, BECount,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2086</td>
    <td class="codeLine">                            StoreSize, *AA, Ignore1)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2086</td>
    <td class="codeLine">                            StoreSize, *AA, Ignore1)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2087</td>
    <td class="codeLine">    // Check if the load is the offending instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2087</td>
    <td class="codeLine">    // Check if the load is the offending instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2088</td>
    <td class="codeLine">    Ignore1.insert(LI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2088</td>
    <td class="codeLine">    Ignore1.insert(LI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2089</td>
    <td class="codeLine">    if (mayLoopAccessLocation(StoreBasePtr, ModRefInfo::ModRef, CurLoop,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2089</td>
    <td class="codeLine">    if (mayLoopAccessLocation(StoreBasePtr, ModRefInfo::ModRef, CurLoop,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2090</td>
    <td class="codeLine">                              BECount, StoreSize, *AA, Ignore1)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2090</td>
    <td class="codeLine">                              BECount, StoreSize, *AA, Ignore1)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2091</td>
    <td class="codeLine">      // Still bad. Nothing we can do.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2091</td>
    <td class="codeLine">      // Still bad. Nothing we can do.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2092</td>
    <td class="codeLine">      goto CleanupAndExit;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2092</td>
    <td class="codeLine">      goto CleanupAndExit;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2093</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2093</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2094</td>
    <td class="codeLine">    // It worked with the load ignored.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2094</td>
    <td class="codeLine">    // It worked with the load ignored.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2095</td>
    <td class="codeLine">    Overlap = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2095</td>
    <td class="codeLine">    Overlap = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2096</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2096</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2097</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2097</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2098</td>
    <td class="codeLine">  if (!Overlap) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2098</td>
    <td class="codeLine">  if (!Overlap) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2099</td>
    <td class="codeLine">    if (DisableMemcpyIdiom || !HasMemcpy)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2099</td>
    <td class="codeLine">    if (DisableMemcpyIdiom || !HasMemcpy)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2100</td>
    <td class="codeLine">      goto CleanupAndExit;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2100</td>
    <td class="codeLine">      goto CleanupAndExit;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2101</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2101</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2102</td>
    <td class="codeLine">    // Don't generate memmove if this function will be inlined. This is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2102</td>
    <td class="codeLine">    // Don't generate memmove if this function will be inlined. This is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2103</td>
    <td class="codeLine">    // because the caller will undergo this transformation after inlining.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2103</td>
    <td class="codeLine">    // because the caller will undergo this transformation after inlining.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2104</td>
    <td class="codeLine">    Function *Func = CurLoop->getHeader()->getParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2104</td>
    <td class="codeLine">    Function *Func = CurLoop->getHeader()->getParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2105</td>
    <td class="codeLine">    if (Func->hasFnAttribute(Attribute::AlwaysInline))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2105</td>
    <td class="codeLine">    if (Func->hasFnAttribute(Attribute::AlwaysInline))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2106</td>
    <td class="codeLine">      goto CleanupAndExit;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2106</td>
    <td class="codeLine">      goto CleanupAndExit;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2107</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2107</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2108</td>
    <td class="codeLine">    // In case of a memmove, the call to memmove will be executed instead</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2108</td>
    <td class="codeLine">    // In case of a memmove, the call to memmove will be executed instead</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2109</td>
    <td class="codeLine">    // of the loop, so we need to make sure that there is nothing else in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2109</td>
    <td class="codeLine">    // of the loop, so we need to make sure that there is nothing else in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2110</td>
    <td class="codeLine">    // the loop than the load, store and instructions that these two depend</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2110</td>
    <td class="codeLine">    // the loop than the load, store and instructions that these two depend</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2111</td>
    <td class="codeLine">    // on.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2111</td>
    <td class="codeLine">    // on.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2112</td>
    <td class="codeLine">    SmallVector<Instruction*,2> Insts;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2112</td>
    <td class="codeLine">    SmallVector<Instruction*,2> Insts;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2113</td>
    <td class="codeLine">    Insts.push_back(SI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2113</td>
    <td class="codeLine">    Insts.push_back(SI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2114</td>
    <td class="codeLine">    Insts.push_back(LI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2114</td>
    <td class="codeLine">    Insts.push_back(LI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2115</td>
    <td class="codeLine">    if (!coverLoop(CurLoop, Insts))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2115</td>
    <td class="codeLine">    if (!coverLoop(CurLoop, Insts))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2116</td>
    <td class="codeLine">      goto CleanupAndExit;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2116</td>
    <td class="codeLine">      goto CleanupAndExit;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2117</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2117</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2118</td>
    <td class="codeLine">    if (DisableMemmoveIdiom || !HasMemmove)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2118</td>
    <td class="codeLine">    if (DisableMemmoveIdiom || !HasMemmove)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2119</td>
    <td class="codeLine">      goto CleanupAndExit;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2119</td>
    <td class="codeLine">      goto CleanupAndExit;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2120</td>
    <td class="codeLine">    bool IsNested = CurLoop->getParentLoop() != nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2120</td>
    <td class="codeLine">    bool IsNested = CurLoop->getParentLoop() != nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2121</td>
    <td class="codeLine">    if (IsNested && OnlyNonNestedMemmove)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2121</td>
    <td class="codeLine">    if (IsNested && OnlyNonNestedMemmove)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2122</td>
    <td class="codeLine">      goto CleanupAndExit;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2122</td>
    <td class="codeLine">      goto CleanupAndExit;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2123</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2123</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2124</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2124</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2125</td>
    <td class="codeLine">  // For a memcpy, we have to make sure that the input array is not being</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2125</td>
    <td class="codeLine">  // For a memcpy, we have to make sure that the input array is not being</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2126</td>
    <td class="codeLine">  // mutated by the loop.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2126</td>
    <td class="codeLine">  // mutated by the loop.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2127</td>
    <td class="codeLine">  LoadBasePtr = Expander.expandCodeFor(LoadEv->getStart(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2127</td>
    <td class="codeLine">  LoadBasePtr = Expander.expandCodeFor(LoadEv->getStart(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2128</td>
    <td class="codeLine">      Builder.getInt8PtrTy(LI->getPointerAddressSpace()), ExpPt);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2128</td>
    <td class="codeLine">      Builder.getInt8PtrTy(LI->getPointerAddressSpace()), ExpPt);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2129</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2129</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2130</td>
    <td class="codeLine">  SmallPtrSet<Instruction*, 2> Ignore2;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2130</td>
    <td class="codeLine">  SmallPtrSet<Instruction*, 2> Ignore2;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2131</td>
    <td class="codeLine">  Ignore2.insert(SI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2131</td>
    <td class="codeLine">  Ignore2.insert(SI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2132</td>
    <td class="codeLine">  if (mayLoopAccessLocation(LoadBasePtr, ModRefInfo::Mod, CurLoop, BECount,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2132</td>
    <td class="codeLine">  if (mayLoopAccessLocation(LoadBasePtr, ModRefInfo::Mod, CurLoop, BECount,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2133</td>
    <td class="codeLine">                            StoreSize, *AA, Ignore2))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2133</td>
    <td class="codeLine">                            StoreSize, *AA, Ignore2))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2134</td>
    <td class="codeLine">    goto CleanupAndExit;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2134</td>
    <td class="codeLine">    goto CleanupAndExit;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2135</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2135</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2136</td>
    <td class="codeLine">  // Check the stride.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2136</td>
    <td class="codeLine">  // Check the stride.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2137</td>
    <td class="codeLine">  bool StridePos = getSCEVStride(LoadEv) >= 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2137</td>
    <td class="codeLine">  bool StridePos = getSCEVStride(LoadEv) >= 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2138</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2138</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2139</td>
    <td class="codeLine">  // Currently, the volatile memcpy only emulates traversing memory forward.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2139</td>
    <td class="codeLine">  // Currently, the volatile memcpy only emulates traversing memory forward.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2140</td>
    <td class="codeLine">  if (!StridePos && DestVolatile)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2140</td>
    <td class="codeLine">  if (!StridePos && DestVolatile)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2141</td>
    <td class="codeLine">    goto CleanupAndExit;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2141</td>
    <td class="codeLine">    goto CleanupAndExit;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2142</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2142</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2143</td>
    <td class="codeLine">  bool RuntimeCheck = (Overlap || DestVolatile);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2143</td>
    <td class="codeLine">  bool RuntimeCheck = (Overlap || DestVolatile);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2144</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2144</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2145</td>
    <td class="codeLine">  BasicBlock *ExitB;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2145</td>
    <td class="codeLine">  BasicBlock *ExitB;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2146</td>
    <td class="codeLine">  if (RuntimeCheck) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2146</td>
    <td class="codeLine">  if (RuntimeCheck) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2147</td>
    <td class="codeLine">    // The runtime check needs a single exit block.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2147</td>
    <td class="codeLine">    // The runtime check needs a single exit block.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2148</td>
    <td class="codeLine">    SmallVector<BasicBlock*, 8> ExitBlocks;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2148</td>
    <td class="codeLine">    SmallVector<BasicBlock*, 8> ExitBlocks;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2149</td>
    <td class="codeLine">    CurLoop->getUniqueExitBlocks(ExitBlocks);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2149</td>
    <td class="codeLine">    CurLoop->getUniqueExitBlocks(ExitBlocks);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2150</td>
    <td class="codeLine">    if (ExitBlocks.size() != 1)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2150</td>
    <td class="codeLine">    if (ExitBlocks.size() != 1)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2151</td>
    <td class="codeLine">      goto CleanupAndExit;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2151</td>
    <td class="codeLine">      goto CleanupAndExit;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2152</td>
    <td class="codeLine">    ExitB = ExitBlocks[0];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2152</td>
    <td class="codeLine">    ExitB = ExitBlocks[0];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2153</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2153</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2154</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2154</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2155</td>
    <td class="codeLine">  // The # stored bytes is (BECount+1)*Size.  Expand the trip count out to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2155</td>
    <td class="codeLine">  // The # stored bytes is (BECount+1)*Size.  Expand the trip count out to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2156</td>
    <td class="codeLine">  // pointer size if it isn't already.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2156</td>
    <td class="codeLine">  // pointer size if it isn't already.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2157</td>
    <td class="codeLine">  LLVMContext &Ctx = SI->getContext();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2157</td>
    <td class="codeLine">  LLVMContext &Ctx = SI->getContext();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2158</td>
    <td class="codeLine">  BECount = SE->getTruncateOrZeroExtend(BECount, IntPtrTy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2158</td>
    <td class="codeLine">  BECount = SE->getTruncateOrZeroExtend(BECount, IntPtrTy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2159</td>
    <td class="codeLine">  DebugLoc DLoc = SI->getDebugLoc();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2159</td>
    <td class="codeLine">  DebugLoc DLoc = SI->getDebugLoc();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2160</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2160</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2161</td>
    <td class="codeLine">  const SCEV *NumBytesS =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2161</td>
    <td class="codeLine">  const SCEV *NumBytesS =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2162</td>
    <td class="codeLine">      SE->getAddExpr(BECount, SE->getOne(IntPtrTy), SCEV::FlagNUW);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2162</td>
    <td class="codeLine">      SE->getAddExpr(BECount, SE->getOne(IntPtrTy), SCEV::FlagNUW);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2163</td>
    <td class="codeLine">  if (StoreSize != 1)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2163</td>
    <td class="codeLine">  if (StoreSize != 1)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2164</td>
    <td class="codeLine">    NumBytesS = SE->getMulExpr(NumBytesS, SE->getConstant(IntPtrTy, StoreSize),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2164</td>
    <td class="codeLine">    NumBytesS = SE->getMulExpr(NumBytesS, SE->getConstant(IntPtrTy, StoreSize),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2165</td>
    <td class="codeLine">                               SCEV::FlagNUW);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2165</td>
    <td class="codeLine">                               SCEV::FlagNUW);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2166</td>
    <td class="codeLine">  Value *NumBytes = Expander.expandCodeFor(NumBytesS, IntPtrTy, ExpPt);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2166</td>
    <td class="codeLine">  Value *NumBytes = Expander.expandCodeFor(NumBytesS, IntPtrTy, ExpPt);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2167</td>
    <td class="codeLine">  if (Instruction *In = dyn_cast<Instruction>(NumBytes))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2167</td>
    <td class="codeLine">  if (Instruction *In = dyn_cast<Instruction>(NumBytes))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2168</td>
    <td class="codeLine">    if (Value *Simp = simplifyInstruction(In, {*DL, TLI, DT}))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2168</td>
    <td class="codeLine">    if (Value *Simp = simplifyInstruction(In, {*DL, TLI, DT}))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2169</td>
    <td class="codeLine">      NumBytes = Simp;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2169</td>
    <td class="codeLine">      NumBytes = Simp;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2170</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2170</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2171</td>
    <td class="codeLine">  CallInst *NewCall;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2171</td>
    <td class="codeLine">  CallInst *NewCall;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2172</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2172</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2173</td>
    <td class="codeLine">  if (RuntimeCheck) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2173</td>
    <td class="codeLine">  if (RuntimeCheck) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2174</td>
    <td class="codeLine">    unsigned Threshold = RuntimeMemSizeThreshold;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2174</td>
    <td class="codeLine">    unsigned Threshold = RuntimeMemSizeThreshold;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2175</td>
    <td class="codeLine">    if (ConstantInt *CI = dyn_cast<ConstantInt>(NumBytes)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2175</td>
    <td class="codeLine">    if (ConstantInt *CI = dyn_cast<ConstantInt>(NumBytes)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2176</td>
    <td class="codeLine">      uint64_t C = CI->getZExtValue();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2176</td>
    <td class="codeLine">      uint64_t C = CI->getZExtValue();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2177</td>
    <td class="codeLine">      if (Threshold != 0 && C < Threshold)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2177</td>
    <td class="codeLine">      if (Threshold != 0 && C < Threshold)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2178</td>
    <td class="codeLine">        goto CleanupAndExit;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2178</td>
    <td class="codeLine">        goto CleanupAndExit;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2179</td>
    <td class="codeLine">      if (C < CompileTimeMemSizeThreshold)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2179</td>
    <td class="codeLine">      if (C < CompileTimeMemSizeThreshold)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2180</td>
    <td class="codeLine">        goto CleanupAndExit;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2180</td>
    <td class="codeLine">        goto CleanupAndExit;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2181</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2181</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2182</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2182</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2183</td>
    <td class="codeLine">    BasicBlock *Header = CurLoop->getHeader();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2183</td>
    <td class="codeLine">    BasicBlock *Header = CurLoop->getHeader();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2184</td>
    <td class="codeLine">    Function *Func = Header->getParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2184</td>
    <td class="codeLine">    Function *Func = Header->getParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2185</td>
    <td class="codeLine">    Loop *ParentL = LF->getLoopFor(Preheader);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2185</td>
    <td class="codeLine">    Loop *ParentL = LF->getLoopFor(Preheader);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2186</td>
    <td class="codeLine">    StringRef HeaderName = Header->getName();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2186</td>
    <td class="codeLine">    StringRef HeaderName = Header->getName();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2187</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2187</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2188</td>
    <td class="codeLine">    // Create a new (empty) preheader, and update the PHI nodes in the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2188</td>
    <td class="codeLine">    // Create a new (empty) preheader, and update the PHI nodes in the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2189</td>
    <td class="codeLine">    // header to use the new preheader.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2189</td>
    <td class="codeLine">    // header to use the new preheader.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2190</td>
    <td class="codeLine">    BasicBlock *NewPreheader = BasicBlock::Create(Ctx, HeaderName+".rtli.ph",</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2190</td>
    <td class="codeLine">    BasicBlock *NewPreheader = BasicBlock::Create(Ctx, HeaderName+".rtli.ph",</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2191</td>
    <td class="codeLine">                                                  Func, Header);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2191</td>
    <td class="codeLine">                                                  Func, Header);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2192</td>
    <td class="codeLine">    if (ParentL)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2192</td>
    <td class="codeLine">    if (ParentL)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2193</td>
    <td class="codeLine">      ParentL->addBasicBlockToLoop(NewPreheader, *LF);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2193</td>
    <td class="codeLine">      ParentL->addBasicBlockToLoop(NewPreheader, *LF);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2194</td>
    <td class="codeLine">    IRBuilder<>(NewPreheader).CreateBr(Header);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2194</td>
    <td class="codeLine">    IRBuilder<>(NewPreheader).CreateBr(Header);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2195</td>
    <td class="codeLine">    for (auto &In : *Header) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2195</td>
    <td class="codeLine">    for (auto &In : *Header) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2196</td>
    <td class="codeLine">      PHINode *PN = dyn_cast<PHINode>(&In);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2196</td>
    <td class="codeLine">      PHINode *PN = dyn_cast<PHINode>(&In);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2197</td>
    <td class="codeLine">      if (!PN)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2197</td>
    <td class="codeLine">      if (!PN)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2198</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2198</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2199</td>
    <td class="codeLine">      int bx = PN->getBasicBlockIndex(Preheader);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2199</td>
    <td class="codeLine">      int bx = PN->getBasicBlockIndex(Preheader);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2200</td>
    <td class="codeLine">      if (bx >= 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2200</td>
    <td class="codeLine">      if (bx >= 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2201</td>
    <td class="codeLine">        PN->setIncomingBlock(bx, NewPreheader);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2201</td>
    <td class="codeLine">        PN->setIncomingBlock(bx, NewPreheader);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2202</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2202</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2203</td>
    <td class="codeLine">    DT->addNewBlock(NewPreheader, Preheader);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2203</td>
    <td class="codeLine">    DT->addNewBlock(NewPreheader, Preheader);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2204</td>
    <td class="codeLine">    DT->changeImmediateDominator(Header, NewPreheader);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2204</td>
    <td class="codeLine">    DT->changeImmediateDominator(Header, NewPreheader);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2205</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2205</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2206</td>
    <td class="codeLine">    // Check for safe conditions to execute memmove.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2206</td>
    <td class="codeLine">    // Check for safe conditions to execute memmove.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2207</td>
    <td class="codeLine">    // If stride is positive, copying things from higher to lower addresses</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2207</td>
    <td class="codeLine">    // If stride is positive, copying things from higher to lower addresses</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2208</td>
    <td class="codeLine">    // is equivalent to memmove.  For negative stride, it's the other way</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2208</td>
    <td class="codeLine">    // is equivalent to memmove.  For negative stride, it's the other way</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2209</td>
    <td class="codeLine">    // around.  Copying forward in memory with positive stride may not be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2209</td>
    <td class="codeLine">    // around.  Copying forward in memory with positive stride may not be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2210</td>
    <td class="codeLine">    // same as memmove since we may be copying values that we just stored</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2210</td>
    <td class="codeLine">    // same as memmove since we may be copying values that we just stored</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2211</td>
    <td class="codeLine">    // in some previous iteration.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2211</td>
    <td class="codeLine">    // in some previous iteration.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2212</td>
    <td class="codeLine">    Value *LA = Builder.CreatePtrToInt(LoadBasePtr, IntPtrTy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2212</td>
    <td class="codeLine">    Value *LA = Builder.CreatePtrToInt(LoadBasePtr, IntPtrTy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2213</td>
    <td class="codeLine">    Value *SA = Builder.CreatePtrToInt(StoreBasePtr, IntPtrTy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2213</td>
    <td class="codeLine">    Value *SA = Builder.CreatePtrToInt(StoreBasePtr, IntPtrTy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2214</td>
    <td class="codeLine">    Value *LowA = StridePos ? SA : LA;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2214</td>
    <td class="codeLine">    Value *LowA = StridePos ? SA : LA;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2215</td>
    <td class="codeLine">    Value *HighA = StridePos ? LA : SA;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2215</td>
    <td class="codeLine">    Value *HighA = StridePos ? LA : SA;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2216</td>
    <td class="codeLine">    Value *CmpA = Builder.CreateICmpULT(LowA, HighA);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2216</td>
    <td class="codeLine">    Value *CmpA = Builder.CreateICmpULT(LowA, HighA);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2217</td>
    <td class="codeLine">    Value *Cond = CmpA;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2217</td>
    <td class="codeLine">    Value *Cond = CmpA;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2218</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2218</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2219</td>
    <td class="codeLine">    // Check for distance between pointers. Since the case LowA < HighA</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2219</td>
    <td class="codeLine">    // Check for distance between pointers. Since the case LowA < HighA</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2220</td>
    <td class="codeLine">    // is checked for above, assume LowA >= HighA.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2220</td>
    <td class="codeLine">    // is checked for above, assume LowA >= HighA.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2221</td>
    <td class="codeLine">    Value *Dist = Builder.CreateSub(LowA, HighA);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2221</td>
    <td class="codeLine">    Value *Dist = Builder.CreateSub(LowA, HighA);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2222</td>
    <td class="codeLine">    Value *CmpD = Builder.CreateICmpSLE(NumBytes, Dist);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2222</td>
    <td class="codeLine">    Value *CmpD = Builder.CreateICmpSLE(NumBytes, Dist);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2223</td>
    <td class="codeLine">    Value *CmpEither = Builder.CreateOr(Cond, CmpD);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2223</td>
    <td class="codeLine">    Value *CmpEither = Builder.CreateOr(Cond, CmpD);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2224</td>
    <td class="codeLine">    Cond = CmpEither;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2224</td>
    <td class="codeLine">    Cond = CmpEither;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2225</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2225</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2226</td>
    <td class="codeLine">    if (Threshold != 0) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2226</td>
    <td class="codeLine">    if (Threshold != 0) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2227</td>
    <td class="codeLine">      Type *Ty = NumBytes->getType();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2227</td>
    <td class="codeLine">      Type *Ty = NumBytes->getType();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2228</td>
    <td class="codeLine">      Value *Thr = ConstantInt::get(Ty, Threshold);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2228</td>
    <td class="codeLine">      Value *Thr = ConstantInt::get(Ty, Threshold);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2229</td>
    <td class="codeLine">      Value *CmpB = Builder.CreateICmpULT(Thr, NumBytes);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2229</td>
    <td class="codeLine">      Value *CmpB = Builder.CreateICmpULT(Thr, NumBytes);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2230</td>
    <td class="codeLine">      Value *CmpBoth = Builder.CreateAnd(Cond, CmpB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2230</td>
    <td class="codeLine">      Value *CmpBoth = Builder.CreateAnd(Cond, CmpB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2231</td>
    <td class="codeLine">      Cond = CmpBoth;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2231</td>
    <td class="codeLine">      Cond = CmpBoth;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2232</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2232</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2233</td>
    <td class="codeLine">    BasicBlock *MemmoveB = BasicBlock::Create(Ctx, Header->getName()+".rtli",</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2233</td>
    <td class="codeLine">    BasicBlock *MemmoveB = BasicBlock::Create(Ctx, Header->getName()+".rtli",</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2234</td>
    <td class="codeLine">                                              Func, NewPreheader);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2234</td>
    <td class="codeLine">                                              Func, NewPreheader);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2235</td>
    <td class="codeLine">    if (ParentL)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2235</td>
    <td class="codeLine">    if (ParentL)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2236</td>
    <td class="codeLine">      ParentL->addBasicBlockToLoop(MemmoveB, *LF);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2236</td>
    <td class="codeLine">      ParentL->addBasicBlockToLoop(MemmoveB, *LF);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2237</td>
    <td class="codeLine">    Instruction *OldT = Preheader->getTerminator();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2237</td>
    <td class="codeLine">    Instruction *OldT = Preheader->getTerminator();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2238</td>
    <td class="codeLine">    Builder.CreateCondBr(Cond, MemmoveB, NewPreheader);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2238</td>
    <td class="codeLine">    Builder.CreateCondBr(Cond, MemmoveB, NewPreheader);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2239</td>
    <td class="codeLine">    OldT->eraseFromParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2239</td>
    <td class="codeLine">    OldT->eraseFromParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2240</td>
    <td class="codeLine">    Preheader->setName(Preheader->getName()+".old");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2240</td>
    <td class="codeLine">    Preheader->setName(Preheader->getName()+".old");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2241</td>
    <td class="codeLine">    DT->addNewBlock(MemmoveB, Preheader);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2241</td>
    <td class="codeLine">    DT->addNewBlock(MemmoveB, Preheader);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2242</td>
    <td class="codeLine">    // Find the new immediate dominator of the exit block.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2242</td>
    <td class="codeLine">    // Find the new immediate dominator of the exit block.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2243</td>
    <td class="codeLine">    BasicBlock *ExitD = Preheader;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2243</td>
    <td class="codeLine">    BasicBlock *ExitD = Preheader;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2244</td>
    <td class="codeLine">    for (BasicBlock *PB : predecessors(ExitB)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2244</td>
    <td class="codeLine">    for (BasicBlock *PB : predecessors(ExitB)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2245</td>
    <td class="codeLine">      ExitD = DT->findNearestCommonDominator(ExitD, PB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2245</td>
    <td class="codeLine">      ExitD = DT->findNearestCommonDominator(ExitD, PB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2246</td>
    <td class="codeLine">      if (!ExitD)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2246</td>
    <td class="codeLine">      if (!ExitD)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2247</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2247</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2248</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2248</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2249</td>
    <td class="codeLine">    // If the prior immediate dominator of ExitB was dominated by the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2249</td>
    <td class="codeLine">    // If the prior immediate dominator of ExitB was dominated by the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2250</td>
    <td class="codeLine">    // old preheader, then the old preheader becomes the new immediate</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2250</td>
    <td class="codeLine">    // old preheader, then the old preheader becomes the new immediate</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2251</td>
    <td class="codeLine">    // dominator.  Otherwise don't change anything (because the newly</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2251</td>
    <td class="codeLine">    // dominator.  Otherwise don't change anything (because the newly</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2252</td>
    <td class="codeLine">    // added blocks are dominated by the old preheader).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2252</td>
    <td class="codeLine">    // added blocks are dominated by the old preheader).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2253</td>
    <td class="codeLine">    if (ExitD && DT->dominates(Preheader, ExitD)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2253</td>
    <td class="codeLine">    if (ExitD && DT->dominates(Preheader, ExitD)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2254</td>
    <td class="codeLine">      DomTreeNode *BN = DT->getNode(ExitB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2254</td>
    <td class="codeLine">      DomTreeNode *BN = DT->getNode(ExitB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2255</td>
    <td class="codeLine">      DomTreeNode *DN = DT->getNode(ExitD);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2255</td>
    <td class="codeLine">      DomTreeNode *DN = DT->getNode(ExitD);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2256</td>
    <td class="codeLine">      BN->setIDom(DN);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2256</td>
    <td class="codeLine">      BN->setIDom(DN);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2257</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2257</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2258</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2258</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2259</td>
    <td class="codeLine">    // Add a call to memmove to the conditional block.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2259</td>
    <td class="codeLine">    // Add a call to memmove to the conditional block.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2260</td>
    <td class="codeLine">    IRBuilder<> CondBuilder(MemmoveB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2260</td>
    <td class="codeLine">    IRBuilder<> CondBuilder(MemmoveB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2261</td>
    <td class="codeLine">    CondBuilder.CreateBr(ExitB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2261</td>
    <td class="codeLine">    CondBuilder.CreateBr(ExitB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2262</td>
    <td class="codeLine">    CondBuilder.SetInsertPoint(MemmoveB->getTerminator());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2262</td>
    <td class="codeLine">    CondBuilder.SetInsertPoint(MemmoveB->getTerminator());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2263</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2263</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2264</td>
    <td class="codeLine">    if (DestVolatile) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2264</td>
    <td class="codeLine">    if (DestVolatile) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2265</td>
    <td class="codeLine">      Type *Int32Ty = Type::getInt32Ty(Ctx);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2265</td>
    <td class="codeLine">      Type *Int32Ty = Type::getInt32Ty(Ctx);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2266</td>
    <td class="codeLine">      Type *Int32PtrTy = Type::getInt32PtrTy(Ctx);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2266</td>
    <td class="codeLine">      Type *Int32PtrTy = Type::getInt32PtrTy(Ctx);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2267</td>
    <td class="codeLine">      Type *VoidTy = Type::getVoidTy(Ctx);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2267</td>
    <td class="codeLine">      Type *VoidTy = Type::getVoidTy(Ctx);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2268</td>
    <td class="codeLine">      Module *M = Func->getParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2268</td>
    <td class="codeLine">      Module *M = Func->getParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2269</td>
    <td class="codeLine">      FunctionCallee Fn = M->getOrInsertFunction(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2269</td>
    <td class="codeLine">      FunctionCallee Fn = M->getOrInsertFunction(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2270</td>
    <td class="codeLine">          HexagonVolatileMemcpyName, VoidTy, Int32PtrTy, Int32PtrTy, Int32Ty);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2270</td>
    <td class="codeLine">          HexagonVolatileMemcpyName, VoidTy, Int32PtrTy, Int32PtrTy, Int32Ty);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2271</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2271</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2272</td>
    <td class="codeLine">      const SCEV *OneS = SE->getConstant(Int32Ty, 1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2272</td>
    <td class="codeLine">      const SCEV *OneS = SE->getConstant(Int32Ty, 1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2273</td>
    <td class="codeLine">      const SCEV *BECount32 = SE->getTruncateOrZeroExtend(BECount, Int32Ty);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2273</td>
    <td class="codeLine">      const SCEV *BECount32 = SE->getTruncateOrZeroExtend(BECount, Int32Ty);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2274</td>
    <td class="codeLine">      const SCEV *NumWordsS = SE->getAddExpr(BECount32, OneS, SCEV::FlagNUW);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2274</td>
    <td class="codeLine">      const SCEV *NumWordsS = SE->getAddExpr(BECount32, OneS, SCEV::FlagNUW);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2275</td>
    <td class="codeLine">      Value *NumWords = Expander.expandCodeFor(NumWordsS, Int32Ty,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2275</td>
    <td class="codeLine">      Value *NumWords = Expander.expandCodeFor(NumWordsS, Int32Ty,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2276</td>
    <td class="codeLine">                                               MemmoveB->getTerminator());</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2276</td>
    <td class="codeLine">                                               MemmoveB->getTerminator());</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2277</td>
    <td class="codeLine">      if (Instruction *In = dyn_cast<Instruction>(NumWords))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2277</td>
    <td class="codeLine">      if (Instruction *In = dyn_cast<Instruction>(NumWords))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2278</td>
    <td class="codeLine">        if (Value *Simp = simplifyInstruction(In, {*DL, TLI, DT}))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2278</td>
    <td class="codeLine">        if (Value *Simp = simplifyInstruction(In, {*DL, TLI, DT}))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2279</td>
    <td class="codeLine">          NumWords = Simp;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2279</td>
    <td class="codeLine">          NumWords = Simp;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2280</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2280</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2281</td>
    <td class="codeLine">      Value *Op0 = (StoreBasePtr->getType() == Int32PtrTy)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2281</td>
    <td class="codeLine">      Value *Op0 = (StoreBasePtr->getType() == Int32PtrTy)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2282</td>
    <td class="codeLine">                      ? StoreBasePtr</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2282</td>
    <td class="codeLine">                      ? StoreBasePtr</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2283</td>
    <td class="codeLine">                      : CondBuilder.CreateBitCast(StoreBasePtr, Int32PtrTy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2283</td>
    <td class="codeLine">                      : CondBuilder.CreateBitCast(StoreBasePtr, Int32PtrTy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2284</td>
    <td class="codeLine">      Value *Op1 = (LoadBasePtr->getType() == Int32PtrTy)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2284</td>
    <td class="codeLine">      Value *Op1 = (LoadBasePtr->getType() == Int32PtrTy)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2285</td>
    <td class="codeLine">                      ? LoadBasePtr</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2285</td>
    <td class="codeLine">                      ? LoadBasePtr</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2286</td>
    <td class="codeLine">                      : CondBuilder.CreateBitCast(LoadBasePtr, Int32PtrTy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2286</td>
    <td class="codeLine">                      : CondBuilder.CreateBitCast(LoadBasePtr, Int32PtrTy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2287</td>
    <td class="codeLine">      NewCall = CondBuilder.CreateCall(Fn, {Op0, Op1, NumWords});</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2287</td>
    <td class="codeLine">      NewCall = CondBuilder.CreateCall(Fn, {Op0, Op1, NumWords});</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2288</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2288</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2289</td>
    <td class="codeLine">      NewCall = CondBuilder.CreateMemMove(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2289</td>
    <td class="codeLine">      NewCall = CondBuilder.CreateMemMove(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2290</td>
    <td class="codeLine">          StoreBasePtr, SI->getAlign(), LoadBasePtr, LI->getAlign(), NumBytes);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2290</td>
    <td class="codeLine">          StoreBasePtr, SI->getAlign(), LoadBasePtr, LI->getAlign(), NumBytes);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2291</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2291</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2292</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2292</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2293</td>
    <td class="codeLine">    NewCall = Builder.CreateMemCpy(StoreBasePtr, SI->getAlign(), LoadBasePtr,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2293</td>
    <td class="codeLine">    NewCall = Builder.CreateMemCpy(StoreBasePtr, SI->getAlign(), LoadBasePtr,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2294</td>
    <td class="codeLine">                                   LI->getAlign(), NumBytes);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2294</td>
    <td class="codeLine">                                   LI->getAlign(), NumBytes);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2295</td>
    <td class="codeLine">    // Okay, the memcpy has been formed.  Zap the original store and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2295</td>
    <td class="codeLine">    // Okay, the memcpy has been formed.  Zap the original store and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2296</td>
    <td class="codeLine">    // anything that feeds into it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2296</td>
    <td class="codeLine">    // anything that feeds into it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2297</td>
    <td class="codeLine">    RecursivelyDeleteTriviallyDeadInstructions(SI, TLI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2297</td>
    <td class="codeLine">    RecursivelyDeleteTriviallyDeadInstructions(SI, TLI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2298</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2298</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2299</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2299</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2300</td>
    <td class="codeLine">  NewCall->setDebugLoc(DLoc);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2300</td>
    <td class="codeLine">  NewCall->setDebugLoc(DLoc);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2301</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2301</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2302</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "  Formed " << (Overlap ? "memmove: " : "memcpy: ")</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2302</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "  Formed " << (Overlap ? "memmove: " : "memcpy: ")</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2303</td>
    <td class="codeLine">                    << *NewCall << "\n"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2303</td>
    <td class="codeLine">                    << *NewCall << "\n"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2304</td>
    <td class="codeLine">                    << "    from load ptr=" << *LoadEv << " at: " << *LI << "\n"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2304</td>
    <td class="codeLine">                    << "    from load ptr=" << *LoadEv << " at: " << *LI << "\n"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2305</td>
    <td class="codeLine">                    << "    from store ptr=" << *StoreEv << " at: " << *SI</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2305</td>
    <td class="codeLine">                    << "    from store ptr=" << *StoreEv << " at: " << *SI</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2306</td>
    <td class="codeLine">                    << "\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2306</td>
    <td class="codeLine">                    << "\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2307</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2307</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2308</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2308</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2309</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2309</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2310</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2310</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2311</td>
    <td class="codeLine">// Check if the instructions in Insts, together with their dependencies</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2311</td>
    <td class="codeLine">// Check if the instructions in Insts, together with their dependencies</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2312</td>
    <td class="codeLine">// cover the loop in the sense that the loop could be safely eliminated once</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2312</td>
    <td class="codeLine">// cover the loop in the sense that the loop could be safely eliminated once</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2313</td>
    <td class="codeLine">// the instructions in Insts are removed.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2313</td>
    <td class="codeLine">// the instructions in Insts are removed.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2314</td>
    <td class="codeLine">bool HexagonLoopIdiomRecognize::coverLoop(Loop *L,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2314</td>
    <td class="codeLine">bool HexagonLoopIdiomRecognize::coverLoop(Loop *L,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2315</td>
    <td class="codeLine">      SmallVectorImpl<Instruction*> &Insts) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2315</td>
    <td class="codeLine">      SmallVectorImpl<Instruction*> &Insts) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2316</td>
    <td class="codeLine">  SmallSet<BasicBlock*,8> LoopBlocks;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2316</td>
    <td class="codeLine">  SmallSet<BasicBlock*,8> LoopBlocks;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2317</td>
    <td class="codeLine">  for (auto *B : L->blocks())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2317</td>
    <td class="codeLine">  for (auto *B : L->blocks())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2318</td>
    <td class="codeLine">    LoopBlocks.insert(B);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2318</td>
    <td class="codeLine">    LoopBlocks.insert(B);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2319</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2319</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2320</td>
    <td class="codeLine">  SetVector<Instruction*> Worklist(Insts.begin(), Insts.end());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2320</td>
    <td class="codeLine">  SetVector<Instruction*> Worklist(Insts.begin(), Insts.end());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2321</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2321</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2322</td>
    <td class="codeLine">  // Collect all instructions from the loop that the instructions in Insts</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2322</td>
    <td class="codeLine">  // Collect all instructions from the loop that the instructions in Insts</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2323</td>
    <td class="codeLine">  // depend on (plus their dependencies, etc.).  These instructions will</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2323</td>
    <td class="codeLine">  // depend on (plus their dependencies, etc.).  These instructions will</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2324</td>
    <td class="codeLine">  // constitute the expression trees that feed those in Insts, but the trees</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2324</td>
    <td class="codeLine">  // constitute the expression trees that feed those in Insts, but the trees</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2325</td>
    <td class="codeLine">  // will be limited only to instructions contained in the loop.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2325</td>
    <td class="codeLine">  // will be limited only to instructions contained in the loop.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2326</td>
    <td class="codeLine">  for (unsigned i = 0; i < Worklist.size(); ++i) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2326</td>
    <td class="codeLine">  for (unsigned i = 0; i < Worklist.size(); ++i) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2327</td>
    <td class="codeLine">    Instruction *In = Worklist[i];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2327</td>
    <td class="codeLine">    Instruction *In = Worklist[i];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2328</td>
    <td class="codeLine">    for (auto I = In->op_begin(), E = In->op_end(); I != E; ++I) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2328</td>
    <td class="codeLine">    for (auto I = In->op_begin(), E = In->op_end(); I != E; ++I) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2329</td>
    <td class="codeLine">      Instruction *OpI = dyn_cast<Instruction>(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2329</td>
    <td class="codeLine">      Instruction *OpI = dyn_cast<Instruction>(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2330</td>
    <td class="codeLine">      if (!OpI)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2330</td>
    <td class="codeLine">      if (!OpI)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2331</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2331</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2332</td>
    <td class="codeLine">      BasicBlock *PB = OpI->getParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2332</td>
    <td class="codeLine">      BasicBlock *PB = OpI->getParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2333</td>
    <td class="codeLine">      if (!LoopBlocks.count(PB))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2333</td>
    <td class="codeLine">      if (!LoopBlocks.count(PB))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2334</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2334</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2335</td>
    <td class="codeLine">      Worklist.insert(OpI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2335</td>
    <td class="codeLine">      Worklist.insert(OpI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2336</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2336</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2337</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2337</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2338</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2338</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2339</td>
    <td class="codeLine">  // Scan all instructions in the loop, if any of them have a user outside</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2339</td>
    <td class="codeLine">  // Scan all instructions in the loop, if any of them have a user outside</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2340</td>
    <td class="codeLine">  // of the loop, or outside of the expressions collected above, then either</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2340</td>
    <td class="codeLine">  // of the loop, or outside of the expressions collected above, then either</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2341</td>
    <td class="codeLine">  // the loop has a side-effect visible outside of it, or there are</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2341</td>
    <td class="codeLine">  // the loop has a side-effect visible outside of it, or there are</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2342</td>
    <td class="codeLine">  // instructions in it that are not involved in the original set Insts.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2342</td>
    <td class="codeLine">  // instructions in it that are not involved in the original set Insts.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2343</td>
    <td class="codeLine">  for (auto *B : L->blocks()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2343</td>
    <td class="codeLine">  for (auto *B : L->blocks()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2344</td>
    <td class="codeLine">    for (auto &In : *B) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2344</td>
    <td class="codeLine">    for (auto &In : *B) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2345</td>
    <td class="codeLine">      if (isa<BranchInst>(In) || isa<DbgInfoIntrinsic>(In))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2345</td>
    <td class="codeLine">      if (isa<BranchInst>(In) || isa<DbgInfoIntrinsic>(In))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2346</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2346</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2347</td>
    <td class="codeLine">      if (!Worklist.count(&In) && In.mayHaveSideEffects())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2347</td>
    <td class="codeLine">      if (!Worklist.count(&In) && In.mayHaveSideEffects())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2348</td>
    <td class="codeLine">        return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2348</td>
    <td class="codeLine">        return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2349</td>
    <td class="codeLine">      for (auto *K : In.users()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2349</td>
    <td class="codeLine">      for (auto *K : In.users()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2350</td>
    <td class="codeLine">        Instruction *UseI = dyn_cast<Instruction>(K);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2350</td>
    <td class="codeLine">        Instruction *UseI = dyn_cast<Instruction>(K);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2351</td>
    <td class="codeLine">        if (!UseI)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2351</td>
    <td class="codeLine">        if (!UseI)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2352</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2352</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2353</td>
    <td class="codeLine">        BasicBlock *UseB = UseI->getParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2353</td>
    <td class="codeLine">        BasicBlock *UseB = UseI->getParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2354</td>
    <td class="codeLine">        if (LF->getLoopFor(UseB) != L)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2354</td>
    <td class="codeLine">        if (LF->getLoopFor(UseB) != L)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2355</td>
    <td class="codeLine">          return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2355</td>
    <td class="codeLine">          return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2356</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2356</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2357</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2357</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2358</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2358</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2359</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2359</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2360</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2360</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2361</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2361</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2362</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2362</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2363</td>
    <td class="codeLine">/// runOnLoopBlock - Process the specified block, which lives in a counted loop</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2363</td>
    <td class="codeLine">/// runOnLoopBlock - Process the specified block, which lives in a counted loop</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2364</td>
    <td class="codeLine">/// with the specified backedge count.  This block is known to be in the current</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2364</td>
    <td class="codeLine">/// with the specified backedge count.  This block is known to be in the current</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2365</td>
    <td class="codeLine">/// loop and not in any subloops.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2365</td>
    <td class="codeLine">/// loop and not in any subloops.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2366</td>
    <td class="codeLine">bool HexagonLoopIdiomRecognize::runOnLoopBlock(Loop *CurLoop, BasicBlock *BB,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2366</td>
    <td class="codeLine">bool HexagonLoopIdiomRecognize::runOnLoopBlock(Loop *CurLoop, BasicBlock *BB,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2367</td>
    <td class="codeLine">      const SCEV *BECount, SmallVectorImpl<BasicBlock*> &ExitBlocks) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2367</td>
    <td class="codeLine">      const SCEV *BECount, SmallVectorImpl<BasicBlock*> &ExitBlocks) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2368</td>
    <td class="codeLine">  // We can only promote stores in this block if they are unconditionally</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2368</td>
    <td class="codeLine">  // We can only promote stores in this block if they are unconditionally</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2369</td>
    <td class="codeLine">  // executed in the loop.  For a block to be unconditionally executed, it has</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2369</td>
    <td class="codeLine">  // executed in the loop.  For a block to be unconditionally executed, it has</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2370</td>
    <td class="codeLine">  // to dominate all the exit blocks of the loop.  Verify this now.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2370</td>
    <td class="codeLine">  // to dominate all the exit blocks of the loop.  Verify this now.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2371</td>
    <td class="codeLine">  auto DominatedByBB = [this,BB] (BasicBlock *EB) -> bool {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2371</td>
    <td class="codeLine">  auto DominatedByBB = [this,BB] (BasicBlock *EB) -> bool {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2372</td>
    <td class="codeLine">    return DT->dominates(BB, EB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2372</td>
    <td class="codeLine">    return DT->dominates(BB, EB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2373</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2373</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2374</td>
    <td class="codeLine">  if (!all_of(ExitBlocks, DominatedByBB))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2374</td>
    <td class="codeLine">  if (!all_of(ExitBlocks, DominatedByBB))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2375</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2375</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2376</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2376</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2377</td>
    <td class="codeLine">  bool MadeChange = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2377</td>
    <td class="codeLine">  bool MadeChange = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2378</td>
    <td class="codeLine">  // Look for store instructions, which may be optimized to memset/memcpy.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2378</td>
    <td class="codeLine">  // Look for store instructions, which may be optimized to memset/memcpy.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2379</td>
    <td class="codeLine">  SmallVector<StoreInst*,8> Stores;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2379</td>
    <td class="codeLine">  SmallVector<StoreInst*,8> Stores;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2380</td>
    <td class="codeLine">  collectStores(CurLoop, BB, Stores);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2380</td>
    <td class="codeLine">  collectStores(CurLoop, BB, Stores);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2381</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2381</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2382</td>
    <td class="codeLine">  // Optimize the store into a memcpy, if it feeds an similarly strided load.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2382</td>
    <td class="codeLine">  // Optimize the store into a memcpy, if it feeds an similarly strided load.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2383</td>
    <td class="codeLine">  for (auto &SI : Stores)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2383</td>
    <td class="codeLine">  for (auto &SI : Stores)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2384</td>
    <td class="codeLine">    MadeChange |= processCopyingStore(CurLoop, SI, BECount);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2384</td>
    <td class="codeLine">    MadeChange |= processCopyingStore(CurLoop, SI, BECount);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2385</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2385</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2386</td>
    <td class="codeLine">  return MadeChange;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2386</td>
    <td class="codeLine">  return MadeChange;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2387</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2387</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2388</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2388</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2389</td>
    <td class="codeLine">bool HexagonLoopIdiomRecognize::runOnCountableLoop(Loop *L) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2389</td>
    <td class="codeLine">bool HexagonLoopIdiomRecognize::runOnCountableLoop(Loop *L) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2390</td>
    <td class="codeLine">  PolynomialMultiplyRecognize PMR(L, *DL, *DT, *TLI, *SE);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2390</td>
    <td class="codeLine">  PolynomialMultiplyRecognize PMR(L, *DL, *DT, *TLI, *SE);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2391</td>
    <td class="codeLine">  if (PMR.recognize())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2391</td>
    <td class="codeLine">  if (PMR.recognize())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2392</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2392</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2393</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2393</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2394</td>
    <td class="codeLine">  if (!HasMemcpy && !HasMemmove)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2394</td>
    <td class="codeLine">  if (!HasMemcpy && !HasMemmove)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2395</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2395</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2396</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2396</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2397</td>
    <td class="codeLine">  const SCEV *BECount = SE->getBackedgeTakenCount(L);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2397</td>
    <td class="codeLine">  const SCEV *BECount = SE->getBackedgeTakenCount(L);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2398</td>
    <td class="codeLine">  assert(!isa<SCEVCouldNotCompute>(BECount) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2398</td>
    <td class="codeLine">  assert(!isa<SCEVCouldNotCompute>(BECount) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2399</td>
    <td class="codeLine">         "runOnCountableLoop() called on a loop without a predictable"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2399</td>
    <td class="codeLine">         "runOnCountableLoop() called on a loop without a predictable"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2400</td>
    <td class="codeLine">         "backedge-taken count");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2400</td>
    <td class="codeLine">         "backedge-taken count");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2401</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2401</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2402</td>
    <td class="codeLine">  SmallVector<BasicBlock *, 8> ExitBlocks;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2402</td>
    <td class="codeLine">  SmallVector<BasicBlock *, 8> ExitBlocks;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2403</td>
    <td class="codeLine">  L->getUniqueExitBlocks(ExitBlocks);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2403</td>
    <td class="codeLine">  L->getUniqueExitBlocks(ExitBlocks);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2404</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2404</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2405</td>
    <td class="codeLine">  bool Changed = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2405</td>
    <td class="codeLine">  bool Changed = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2406</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2406</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2407</td>
    <td class="codeLine">  // Scan all the blocks in the loop that are not in subloops.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2407</td>
    <td class="codeLine">  // Scan all the blocks in the loop that are not in subloops.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2408</td>
    <td class="codeLine">  for (auto *BB : L->getBlocks()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2408</td>
    <td class="codeLine">  for (auto *BB : L->getBlocks()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2409</td>
    <td class="codeLine">    // Ignore blocks in subloops.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2409</td>
    <td class="codeLine">    // Ignore blocks in subloops.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2410</td>
    <td class="codeLine">    if (LF->getLoopFor(BB) != L)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2410</td>
    <td class="codeLine">    if (LF->getLoopFor(BB) != L)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2411</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2411</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2412</td>
    <td class="codeLine">    Changed |= runOnLoopBlock(L, BB, BECount, ExitBlocks);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2412</td>
    <td class="codeLine">    Changed |= runOnLoopBlock(L, BB, BECount, ExitBlocks);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2413</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2413</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2414</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2414</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2415</td>
    <td class="codeLine">  return Changed;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2415</td>
    <td class="codeLine">  return Changed;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2416</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2416</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2417</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2417</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2418</td>
    <td class="codeLine">bool HexagonLoopIdiomRecognize::run(Loop *L) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2418</td>
    <td class="codeLine">bool HexagonLoopIdiomRecognize::run(Loop *L) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2419</td>
    <td class="codeLine">  const Module &M = *L->getHeader()->getParent()->getParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2419</td>
    <td class="codeLine">  const Module &M = *L->getHeader()->getParent()->getParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2420</td>
    <td class="codeLine">  if (Triple(M.getTargetTriple()).getArch() != Triple::hexagon)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2420</td>
    <td class="codeLine">  if (Triple(M.getTargetTriple()).getArch() != Triple::hexagon)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2421</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2421</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2422</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2422</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2423</td>
    <td class="codeLine">  // If the loop could not be converted to canonical form, it must have an</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2423</td>
    <td class="codeLine">  // If the loop could not be converted to canonical form, it must have an</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2424</td>
    <td class="codeLine">  // indirectbr in it, just give up.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2424</td>
    <td class="codeLine">  // indirectbr in it, just give up.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2425</td>
    <td class="codeLine">  if (!L->getLoopPreheader())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2425</td>
    <td class="codeLine">  if (!L->getLoopPreheader())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2426</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2426</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2427</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2427</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2428</td>
    <td class="codeLine">  // Disable loop idiom recognition if the function's name is a common idiom.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2428</td>
    <td class="codeLine">  // Disable loop idiom recognition if the function's name is a common idiom.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2429</td>
    <td class="codeLine">  StringRef Name = L->getHeader()->getParent()->getName();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2429</td>
    <td class="codeLine">  StringRef Name = L->getHeader()->getParent()->getName();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2430</td>
    <td class="codeLine">  if (Name == "memset" || Name == "memcpy" || Name == "memmove")</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2430</td>
    <td class="codeLine">  if (Name == "memset" || Name == "memcpy" || Name == "memmove")</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2431</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2431</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2432</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2432</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2433</td>
    <td class="codeLine">  DL = &L->getHeader()->getModule()->getDataLayout();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2433</td>
    <td class="codeLine">  DL = &L->getHeader()->getModule()->getDataLayout();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2434</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2434</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2435</td>
    <td class="codeLine">  HasMemcpy = TLI->has(LibFunc_memcpy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2435</td>
    <td class="codeLine">  HasMemcpy = TLI->has(LibFunc_memcpy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2436</td>
    <td class="codeLine">  HasMemmove = TLI->has(LibFunc_memmove);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2436</td>
    <td class="codeLine">  HasMemmove = TLI->has(LibFunc_memmove);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2437</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2437</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2438</td>
    <td class="codeLine">  if (SE->hasLoopInvariantBackedgeTakenCount(L))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2438</td>
    <td class="codeLine">  if (SE->hasLoopInvariantBackedgeTakenCount(L))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2439</td>
    <td class="codeLine">    return runOnCountableLoop(L);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2439</td>
    <td class="codeLine">    return runOnCountableLoop(L);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2440</td>
    <td class="codeLine">  return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2440</td>
    <td class="codeLine">  return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2441</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2441</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2442</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2442</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2443</td>
    <td class="codeLine">bool HexagonLoopIdiomRecognizeLegacyPass::runOnLoop(Loop *L,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2443</td>
    <td class="codeLine">bool HexagonLoopIdiomRecognizeLegacyPass::runOnLoop(Loop *L,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2444</td>
    <td class="codeLine">                                                    LPPassManager &LPM) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2444</td>
    <td class="codeLine">                                                    LPPassManager &LPM) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2445</td>
    <td class="codeLine">  if (skipLoop(L))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2445</td>
    <td class="codeLine">  if (skipLoop(L))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2446</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2446</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2447</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2447</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2448</td>
    <td class="codeLine">  auto *AA = &getAnalysis<AAResultsWrapperPass>().getAAResults();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2448</td>
    <td class="codeLine">  auto *AA = &getAnalysis<AAResultsWrapperPass>().getAAResults();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2449</td>
    <td class="codeLine">  auto *DT = &getAnalysis<DominatorTreeWrapperPass>().getDomTree();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2449</td>
    <td class="codeLine">  auto *DT = &getAnalysis<DominatorTreeWrapperPass>().getDomTree();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2450</td>
    <td class="codeLine">  auto *LF = &getAnalysis<LoopInfoWrapperPass>().getLoopInfo();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2450</td>
    <td class="codeLine">  auto *LF = &getAnalysis<LoopInfoWrapperPass>().getLoopInfo();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2451</td>
    <td class="codeLine">  auto *TLI = &getAnalysis<TargetLibraryInfoWrapperPass>().getTLI(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2451</td>
    <td class="codeLine">  auto *TLI = &getAnalysis<TargetLibraryInfoWrapperPass>().getTLI(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2452</td>
    <td class="codeLine">      *L->getHeader()->getParent());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2452</td>
    <td class="codeLine">      *L->getHeader()->getParent());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2453</td>
    <td class="codeLine">  auto *SE = &getAnalysis<ScalarEvolutionWrapperPass>().getSE();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2453</td>
    <td class="codeLine">  auto *SE = &getAnalysis<ScalarEvolutionWrapperPass>().getSE();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2454</td>
    <td class="codeLine">  return HexagonLoopIdiomRecognize(AA, DT, LF, TLI, SE).run(L);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2454</td>
    <td class="codeLine">  return HexagonLoopIdiomRecognize(AA, DT, LF, TLI, SE).run(L);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2455</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2455</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2456</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2456</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2457</td>
    <td class="codeLine">Pass *llvm::createHexagonLoopIdiomPass() {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2457</td>
    <td class="codeLine">Pass *llvm::createHexagonLoopIdiomPass() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2458</td>
    <td class="codeLine">  return new HexagonLoopIdiomRecognizeLegacyPass();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2458</td>
    <td class="codeLine">  return new HexagonLoopIdiomRecognizeLegacyPass();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2459</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2459</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2460</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2460</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2461</td>
    <td class="codeLine">PreservedAnalyses</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2461</td>
    <td class="codeLine">PreservedAnalyses</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2462</td>
    <td class="codeLine">HexagonLoopIdiomRecognitionPass::run(Loop &L, LoopAnalysisManager &AM,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2462</td>
    <td class="codeLine">HexagonLoopIdiomRecognitionPass::run(Loop &L, LoopAnalysisManager &AM,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2463</td>
    <td class="codeLine">                                     LoopStandardAnalysisResults &AR,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2463</td>
    <td class="codeLine">                                     LoopStandardAnalysisResults &AR,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2464</td>
    <td class="codeLine">                                     LPMUpdater &U) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2464</td>
    <td class="codeLine">                                     LPMUpdater &U) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2465</td>
    <td class="codeLine">  return HexagonLoopIdiomRecognize(&AR.AA, &AR.DT, &AR.LI, &AR.TLI, &AR.SE)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2465</td>
    <td class="codeLine">  return HexagonLoopIdiomRecognize(&AR.AA, &AR.DT, &AR.LI, &AR.TLI, &AR.SE)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2466</td>
    <td class="codeLine">                 .run(&L)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2466</td>
    <td class="codeLine">                 .run(&L)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2467</td>
    <td class="codeLine">             ? getLoopPassPreservedAnalyses()</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2467</td>
    <td class="codeLine">             ? getLoopPassPreservedAnalyses()</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2468</td>
    <td class="codeLine">             : PreservedAnalyses::all();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2468</td>
    <td class="codeLine">             : PreservedAnalyses::all();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2469</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2469</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2470</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2470</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
</table>
    </div>
    <button id="myBtn" onclick="topFunction()" title="Go to top" type="button">Top</button>
    <script src="../Javascript/drop_down.js"></script>
    <script src="../Javascript/top_button.js"></script>
  </body>
</html>